{"version":3,"file":"retrying-transport.js","sourceRoot":"","sources":["../../src/retrying-transport.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AAKH,MAAM,YAAY,GAAG,CAAC,CAAC;AACvB,MAAM,eAAe,GAAG,IAAI,CAAC;AAC7B,MAAM,WAAW,GAAG,IAAI,CAAC;AACzB,MAAM,kBAAkB,GAAG,GAAG,CAAC;AAC/B,MAAM,MAAM,GAAG,GAAG,CAAC;AAEnB;;GAEG;AACH,SAAS,SAAS;IAChB,OAAO,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC;AAC/C,CAAC;AAED,MAAM,iBAAiB;IACD;IAApB,YAAoB,UAA8B;QAA9B,eAAU,GAAV,UAAU,CAAoB;IAAG,CAAC;IAE9C,KAAK,CACX,IAAgB,EAChB,aAAqB,EACrB,QAAgB;QAEhB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,UAAU,CAAC,GAAG,EAAE;gBACd,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YAClE,CAAC,EAAE,QAAQ,CAAC,CAAC;QACf,CAAC,CAAC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,IAAI,CAAC,IAAgB,EAAE,aAAqB;QAChD,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,aAAa,CAAC;QAC5C,IAAI,MAAM,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;QAC7D,IAAI,QAAQ,GAAG,YAAY,CAAC;QAC5B,IAAI,WAAW,GAAG,eAAe,CAAC;QAElC,OAAO,MAAM,CAAC,MAAM,KAAK,WAAW,IAAI,QAAQ,GAAG,CAAC,EAAE;YACpD,QAAQ,EAAE,CAAC;YAEX,mEAAmE;YACnE,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CACtB,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,GAAG,SAAS,EAAE,EAChD,CAAC,CACF,CAAC;YACF,WAAW,GAAG,WAAW,GAAG,kBAAkB,CAAC;YAC/C,MAAM,aAAa,GAAG,MAAM,CAAC,aAAa,IAAI,OAAO,CAAC;YAEtD,gEAAgE;YAChE,MAAM,sBAAsB,GAAG,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACrD,IAAI,aAAa,GAAG,sBAAsB,EAAE;gBAC1C,OAAO,MAAM,CAAC;aACf;YAED,MAAM,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,sBAAsB,EAAE,aAAa,CAAC,CAAC;SACxE;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,QAAQ;QACN,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;IACpC,CAAC;CACF;AAED;;GAEG;AACH,SAAgB,uBAAuB,CAAC,OAGvC;IACC,OAAO,IAAI,iBAAiB,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;AAClD,CAAC;AALD,0DAKC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IExporterTransport } from './exporter-transport';\nimport { ExportResponse } from './export-response';\n\nconst MAX_ATTEMPTS = 5;\nconst INITIAL_BACKOFF = 1000;\nconst MAX_BACKOFF = 5000;\nconst BACKOFF_MULTIPLIER = 1.5;\nconst JITTER = 0.2;\n\n/**\n * Get a pseudo-random jitter that falls in the range of [-JITTER, +JITTER]\n */\nfunction getJitter() {\n  return Math.random() * (2 * JITTER) - JITTER;\n}\n\nclass RetryingTransport implements IExporterTransport {\n  constructor(private _transport: IExporterTransport) {}\n\n  private retry(\n    data: Uint8Array,\n    timeoutMillis: number,\n    inMillis: number\n  ): Promise<ExportResponse> {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        this._transport.send(data, timeoutMillis).then(resolve, reject);\n      }, inMillis);\n    });\n  }\n\n  async send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    const deadline = Date.now() + timeoutMillis;\n    let result = await this._transport.send(data, timeoutMillis);\n    let attempts = MAX_ATTEMPTS;\n    let nextBackoff = INITIAL_BACKOFF;\n\n    while (result.status === 'retryable' && attempts > 0) {\n      attempts--;\n\n      // use maximum of computed backoff and 0 to avoid negative timeouts\n      const backoff = Math.max(\n        Math.min(nextBackoff, MAX_BACKOFF) + getJitter(),\n        0\n      );\n      nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;\n      const retryInMillis = result.retryInMillis ?? backoff;\n\n      // return when expected retry time is after the export deadline.\n      const remainingTimeoutMillis = deadline - Date.now();\n      if (retryInMillis > remainingTimeoutMillis) {\n        return result;\n      }\n\n      result = await this.retry(data, remainingTimeoutMillis, retryInMillis);\n    }\n\n    return result;\n  }\n\n  shutdown() {\n    return this._transport.shutdown();\n  }\n}\n\n/**\n * Creates an Exporter Transport that retries on 'retryable' response.\n */\nexport function createRetryingTransport(options: {\n  // Underlying transport to wrap.\n  transport: IExporterTransport;\n}): IExporterTransport {\n  return new RetryingTransport(options.transport);\n}\n"]}