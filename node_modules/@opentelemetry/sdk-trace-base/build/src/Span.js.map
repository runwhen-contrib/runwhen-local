{"version":3,"file":"Span.js","sourceRoot":"","sources":["../../src/Span.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  diag,\n  Exception,\n  HrTime,\n  Link,\n  Span as APISpan,\n  Attributes,\n  AttributeValue,\n  SpanContext,\n  SpanKind,\n  SpanStatus,\n  SpanStatusCode,\n  TimeInput,\n} from '@opentelemetry/api';\nimport {\n  addHrTimes,\n  millisToHrTime,\n  getTimeOrigin,\n  hrTime,\n  hrTimeDuration,\n  InstrumentationScope,\n  isAttributeValue,\n  isTimeInput,\n  isTimeInputHrTime,\n  otperformance,\n  sanitizeAttributes,\n} from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport {\n  SEMATTRS_EXCEPTION_MESSAGE,\n  SEMATTRS_EXCEPTION_STACKTRACE,\n  SEMATTRS_EXCEPTION_TYPE,\n} from '@opentelemetry/semantic-conventions';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { ExceptionEventName } from './enums';\nimport { SpanProcessor } from './SpanProcessor';\nimport { TimedEvent } from './TimedEvent';\nimport { SpanLimits } from './types';\n\n/**\n * This type provides the properties of @link{ReadableSpan} at the same time\n * of the Span API\n */\nexport type Span = APISpan & ReadableSpan;\n\ninterface SpanOptions {\n  resource: Resource;\n  scope: InstrumentationScope;\n  context: Context;\n  spanContext: SpanContext;\n  name: string;\n  kind: SpanKind;\n  parentSpanContext?: SpanContext;\n  links?: Link[];\n  startTime?: TimeInput;\n  attributes?: Attributes;\n  spanLimits: SpanLimits;\n  spanProcessor: SpanProcessor;\n}\n\n/**\n * This class represents a span.\n */\nexport class SpanImpl implements Span {\n  // Below properties are included to implement ReadableSpan for export\n  // purposes but are not intended to be written-to directly.\n  private readonly _spanContext: SpanContext;\n  readonly kind: SpanKind;\n  readonly parentSpanContext?: SpanContext;\n  readonly attributes: Attributes = {};\n  readonly links: Link[] = [];\n  readonly events: TimedEvent[] = [];\n  readonly startTime: HrTime;\n  readonly resource: Resource;\n  readonly instrumentationScope: InstrumentationScope;\n\n  private _droppedAttributesCount = 0;\n  private _droppedEventsCount: number = 0;\n  private _droppedLinksCount: number = 0;\n\n  name: string;\n  status: SpanStatus = {\n    code: SpanStatusCode.UNSET,\n  };\n  endTime: HrTime = [0, 0];\n  private _ended = false;\n  private _duration: HrTime = [-1, -1];\n  private readonly _spanProcessor: SpanProcessor;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _attributeValueLengthLimit: number;\n\n  private readonly _performanceStartTime: number;\n  private readonly _performanceOffset: number;\n  private readonly _startTimeProvided: boolean;\n\n  /**\n   * Constructs a new SpanImpl instance.\n   */\n  constructor(opts: SpanOptions) {\n    const now = Date.now();\n\n    this._spanContext = opts.spanContext;\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset =\n      now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = opts.startTime != null;\n    this._spanLimits = opts.spanLimits;\n    this._attributeValueLengthLimit =\n      this._spanLimits.attributeValueLengthLimit || 0;\n    this._spanProcessor = opts.spanProcessor;\n\n    this.name = opts.name;\n    this.parentSpanContext = opts.parentSpanContext;\n    this.kind = opts.kind;\n    this.links = opts.links || [];\n    this.startTime = this._getTime(opts.startTime ?? now);\n    this.resource = opts.resource;\n    this.instrumentationScope = opts.scope;\n\n    if (opts.attributes != null) {\n      this.setAttributes(opts.attributes);\n    }\n\n    this._spanProcessor.onStart(this, opts.context);\n  }\n\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  setAttribute(key: string, value?: AttributeValue): this;\n  setAttribute(key: string, value: unknown): this {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n\n    const { attributeCountLimit } = this._spanLimits;\n\n    if (\n      attributeCountLimit !== undefined &&\n      Object.keys(this.attributes).length >= attributeCountLimit &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  }\n\n  setAttributes(attributes: Attributes): this {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: Attributes | TimeInput,\n    timeStamp?: TimeInput\n  ): this {\n    if (this._isSpanEnded()) return this;\n\n    const { eventCountLimit } = this._spanLimits;\n\n    if (eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n\n    if (\n      eventCountLimit !== undefined &&\n      this.events.length >= eventCountLimit\n    ) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n\n    const attributes = sanitizeAttributes(attributesOrStartTime);\n\n    this.events.push({\n      name,\n      attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0,\n    });\n    return this;\n  }\n\n  addLink(link: Link): this {\n    this.links.push(link);\n    return this;\n  }\n\n  addLinks(links: Link[]): this {\n    this.links.push(...links);\n    return this;\n  }\n\n  setStatus(status: SpanStatus): this {\n    if (this._isSpanEnded()) return this;\n    this.status = { ...status };\n\n    // When using try-catch, the caught \"error\" is of type `any`. When then assigning `any` to `status.message`,\n    // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()\n    // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or\n    // undefined to avoid an incorrect type causing issues downstream.\n    if (this.status.message != null && typeof status.message !== 'string') {\n      diag.warn(\n        `Dropping invalid status.message of type '${typeof status.message}', expected 'string'`\n      );\n      delete this.status.message;\n    }\n\n    return this;\n  }\n\n  updateName(name: string): this {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  }\n\n  end(endTime?: TimeInput): void {\n    if (this._isSpanEnded()) {\n      diag.error(\n        `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`\n      );\n      return;\n    }\n    this._ended = true;\n\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n\n    if (this._duration[0] < 0) {\n      diag.warn(\n        'Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.',\n        this.startTime,\n        this.endTime\n      );\n      this.endTime = this.startTime.slice() as HrTime;\n      this._duration = [0, 0];\n    }\n\n    if (this._droppedEventsCount > 0) {\n      diag.warn(\n        `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`\n      );\n    }\n\n    this._spanProcessor.onEnd(this);\n  }\n\n  private _getTime(inp?: TimeInput): HrTime {\n    if (typeof inp === 'number' && inp <= otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n\n    const msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  }\n\n  isRecording(): boolean {\n    return this._ended === false;\n  }\n\n  recordException(exception: Exception, time?: TimeInput): void {\n    const attributes: Attributes = {};\n    if (typeof exception === 'string') {\n      attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SEMATTRS_EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n\n    // these are minimum requirements from spec\n    if (\n      attributes[SEMATTRS_EXCEPTION_TYPE] ||\n      attributes[SEMATTRS_EXCEPTION_MESSAGE]\n    ) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(`Failed to record an exception ${exception}`);\n    }\n  }\n\n  get duration(): HrTime {\n    return this._duration;\n  }\n\n  get ended(): boolean {\n    return this._ended;\n  }\n\n  get droppedAttributesCount(): number {\n    return this._droppedAttributesCount;\n  }\n\n  get droppedEventsCount(): number {\n    return this._droppedEventsCount;\n  }\n\n  get droppedLinksCount(): number {\n    return this._droppedLinksCount;\n  }\n\n  private _isSpanEnded(): boolean {\n    if (this._ended) {\n      const error = new Error(\n        `Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`\n      );\n\n      diag.warn(\n        `Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,\n        error\n      );\n    }\n    return this._ended;\n  }\n\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  }\n\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with truncated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  private _truncateToSize(value: AttributeValue): AttributeValue {\n    const limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val =>\n        typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val\n      );\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n}\n"]}