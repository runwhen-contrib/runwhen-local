{"version":3,"file":"Aggregation.js","sourceRoot":"","sources":["../../../src/view/Aggregation.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  Aggregator,\n  SumAggregator,\n  DropAggregator,\n  LastValueAggregator,\n  HistogramAggregator,\n  ExponentialHistogramAggregator,\n} from '../aggregator';\nimport { Accumulation } from '../aggregator/types';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { Maybe } from '../utils';\nimport { InstrumentType } from '../export/MetricData';\n\n/**\n * Configures how measurements are combined into metrics for views.\n *\n * Aggregation provides a set of built-in aggregations via static methods.\n */\nexport interface Aggregation {\n  createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>>;\n}\n\n/**\n * The default drop aggregation.\n */\nexport class DropAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new DropAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return DropAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default sum aggregation.\n */\nexport class SumAggregation implements Aggregation {\n  private static MONOTONIC_INSTANCE = new SumAggregator(true);\n  private static NON_MONOTONIC_INSTANCE = new SumAggregator(false);\n  createAggregator(instrument: InstrumentDescriptor) {\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.HISTOGRAM: {\n        return SumAggregation.MONOTONIC_INSTANCE;\n      }\n      default: {\n        return SumAggregation.NON_MONOTONIC_INSTANCE;\n      }\n    }\n  }\n}\n\n/**\n * The default last value aggregation.\n */\nexport class LastValueAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new LastValueAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return LastValueAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default histogram aggregation.\n\n */\nexport class HistogramAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new HistogramAggregator(\n    [0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 10000],\n    true\n  );\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return HistogramAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The explicit bucket histogram aggregation.\n */\nexport class ExplicitBucketHistogramAggregation implements Aggregation {\n  private _boundaries: number[];\n\n  /**\n   * @param boundaries the bucket boundaries of the histogram aggregation\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    boundaries: number[],\n    private readonly _recordMinMax = true\n  ) {\n    if (boundaries == null) {\n      throw new Error(\n        'ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array'\n      );\n    }\n    // Copy the boundaries array for modification.\n    boundaries = boundaries.concat();\n    // We need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    boundaries = boundaries.sort((a, b) => a - b);\n    // Remove all Infinity from the boundaries.\n    const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);\n    let infinityIndex: number | undefined = boundaries.indexOf(Infinity);\n    if (infinityIndex === -1) {\n      infinityIndex = undefined;\n    }\n    this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);\n  }\n\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new HistogramAggregator(this._boundaries, this._recordMinMax);\n  }\n}\n\nexport class ExponentialHistogramAggregation implements Aggregation {\n  constructor(\n    private readonly _maxSize: number = 160,\n    private readonly _recordMinMax = true\n  ) {}\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new ExponentialHistogramAggregator(\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n}\n\n/**\n * The default aggregation.\n */\nexport class DefaultAggregation implements Aggregation {\n  private _resolve(instrument: InstrumentDescriptor): Aggregation {\n    // cast to unknown to disable complaints on the (unreachable) fallback.\n    switch (instrument.type as unknown) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.UP_DOWN_COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {\n        return SUM_AGGREGATION;\n      }\n      case InstrumentType.GAUGE:\n      case InstrumentType.OBSERVABLE_GAUGE: {\n        return LAST_VALUE_AGGREGATION;\n      }\n      case InstrumentType.HISTOGRAM: {\n        if (instrument.advice.explicitBucketBoundaries) {\n          return new ExplicitBucketHistogramAggregation(\n            instrument.advice.explicitBucketBoundaries\n          );\n        }\n        return HISTOGRAM_AGGREGATION;\n      }\n    }\n    api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);\n    return DROP_AGGREGATION;\n  }\n\n  createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>> {\n    return this._resolve(instrument).createAggregator(instrument);\n  }\n}\n\nexport const DROP_AGGREGATION = new DropAggregation();\nexport const SUM_AGGREGATION = new SumAggregation();\nexport const LAST_VALUE_AGGREGATION = new LastValueAggregation();\nexport const HISTOGRAM_AGGREGATION = new HistogramAggregation();\nexport const EXPONENTIAL_HISTOGRAM_AGGREGATION =\n  new ExponentialHistogramAggregation();\nexport const DEFAULT_AGGREGATION = new DefaultAggregation();\n"]}