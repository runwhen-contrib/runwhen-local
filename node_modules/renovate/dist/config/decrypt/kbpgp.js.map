{"version":3,"file":"kbpgp.js","sourceRoot":"","sources":["../../../lib/config/decrypt/kbpgp.ts"],"names":[],"mappings":";;AAIA,0CA0DC;;AA9DD,kEAA4C;AAC5C,yCAAsC;AACtC,4CAAyC;AAElC,KAAK,UAAU,eAAe,CACnC,UAAkB,EAClB,YAAoB;IAEpB,IAAI,YAAY,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC;QAC9B,sDAAsD;QACtD,OAAO,IAAI,CAAC;IACd,CAAC;IACD,IAAI,CAAC;QACH,MAAM,EAAE,GAAG,MAAM,IAAI,OAAO,CAAmB,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACjE,KAAK,CAAC,UAAU,CAAC,uBAAuB,CACtC;gBACE,OAAO,EAAE,UAAU,CAAC,OAAO,CAAC,IAAA,aAAK,EAAC,WAAW,CAAC,EAAE,IAAI,CAAC;aACtD,EACD,CAAC,GAAU,EAAE,EAAE,EAAE,EAAE;gBACjB,IAAI,GAAG,EAAE,CAAC;oBACR,MAAM,CAAC,GAAG,CAAC,CAAC;gBACd,CAAC;qBAAM,CAAC;oBACN,OAAO,CAAC,EAAE,CAAC,CAAC;gBACd,CAAC;YACH,CAAC,CACF,CAAC;QACJ,CAAC,CAAC,CAAC;QAEH,MAAM,IAAI,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QACzC,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;QAEzB,MAAM,UAAU,GAAG,iCAAiC,CAAC;QACrD,MAAM,QAAQ,GAAG,6BAA6B,CAAC;QAC/C,IAAI,cAAc,GAAG,YAAY,CAAC,IAAI,EAAE,CAAC;QACzC,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC;YAC3C,cAAc,GAAG,GAAG,UAAU,GAAG,cAAc,EAAE,CAAC;QACpD,CAAC;QACD,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;YACvC,cAAc,GAAG,GAAG,cAAc,GAAG,QAAQ,EAAE,CAAC;QAClD,CAAC;QAED,MAAM,IAAI,GAAG,MAAM,IAAI,OAAO,CAAgB,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAChE,KAAK,CAAC,KAAK,CACT;gBACE,QAAQ,EAAE,IAAI;gBACd,OAAO,EAAE,cAAc;aACxB,EACD,CAAC,GAAU,EAAE,QAAa,EAAE,EAAE;gBAC5B,IAAI,GAAG,EAAE,CAAC;oBACR,MAAM,CAAC,GAAG,CAAC,CAAC;gBACd,CAAC;qBAAM,CAAC;oBACN,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;gBAClC,CAAC;YACH,CAAC,CACF,CAAC;QACJ,CAAC,CAAC,CAAC;QACH,eAAM,CAAC,KAAK,CAAC,8BAA8B,CAAC,CAAC;QAC7C,OAAO,IAAc,CAAC;IACxB,CAAC;IAAC,OAAO,GAAG,EAAE,CAAC;QACb,eAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,EAAE,+BAA+B,CAAC,CAAC;QACvD,OAAO,IAAI,CAAC;IACd,CAAC;AACH,CAAC","sourcesContent":["import * as kbpgp from '@renovatebot/kbpgp';\nimport { logger } from '../../logger';\nimport { regEx } from '../../util/regex';\n\nexport async function tryDecryptKbPgp(\n  privateKey: string,\n  encryptedStr: string,\n): Promise<string | null> {\n  if (encryptedStr.length < 500) {\n    // optimization during transition of public key -> pgp\n    return null;\n  }\n  try {\n    const pk = await new Promise<kbpgp.KeyManager>((resolve, reject) => {\n      kbpgp.KeyManager.import_from_armored_pgp(\n        {\n          armored: privateKey.replace(regEx(/\\n[ \\t]+/g), '\\n'),\n        },\n        (err: Error, pk) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(pk);\n          }\n        },\n      );\n    });\n\n    const ring = new kbpgp.keyring.KeyRing();\n    ring.add_key_manager(pk);\n\n    const startBlock = '-----BEGIN PGP MESSAGE-----\\n\\n';\n    const endBlock = '\\n-----END PGP MESSAGE-----';\n    let armoredMessage = encryptedStr.trim();\n    if (!armoredMessage.startsWith(startBlock)) {\n      armoredMessage = `${startBlock}${armoredMessage}`;\n    }\n    if (!armoredMessage.endsWith(endBlock)) {\n      armoredMessage = `${armoredMessage}${endBlock}`;\n    }\n\n    const data = await new Promise<kbpgp.Literal>((resolve, reject) => {\n      kbpgp.unbox(\n        {\n          keyfetch: ring,\n          armored: armoredMessage,\n        },\n        (err: Error, literals: any) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(literals[0].toString());\n          }\n        },\n      );\n    });\n    logger.debug('Decrypted config using kppgp');\n    return data as string;\n  } catch (err) {\n    logger.debug({ err }, 'Could not decrypt using kppgp');\n    return null;\n  }\n}\n"]}