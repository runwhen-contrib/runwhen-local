{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../lib/modules/datasource/hackage/index.ts"],"names":[],"mappings":";;;AAyCA,4CAgBC;;AAzDD,kEAAkC;AAClC,2CAAiD;AACjD,4EAAsD;AACtD,8CAA2C;AAE3C,qCAAkD;AAElD,MAAa,iBAAkB,SAAQ,uBAAU;IAC/C,MAAM,CAAU,EAAE,GAAG,SAAS,CAAC;IAE/B;QACE,KAAK,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;IAC9B,CAAC;IAEiB,iBAAiB,GAAG,aAAa,CAAC,EAAE,CAAC;IACrC,qBAAqB,GAAG,KAAK,CAAC;IAC9B,mBAAmB,GAAG,CAAC,8BAA8B,CAAC,CAAC;IAEzE,KAAK,CAAC,WAAW,CAAC,MAAyB;QACzC,MAAM,EAAE,WAAW,EAAE,WAAW,EAAE,GAAG,MAAM,CAAC;QAC5C,IAAI,CAAC,YAAE,CAAC,cAAc,CAAC,WAAW,CAAC,EAAE,CAAC;YACpC,OAAO,IAAI,CAAC;QACd,CAAC;QACD,MAAM,mBAAmB,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC;QAC5D,MAAM,GAAG,GAAG,IAAA,kBAAY,EACtB,WAAW,EACX,SAAS,EACT,GAAG,mBAAmB,OAAO,CAC9B,CAAC;QACF,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,+BAAsB,CAAC,CAAC;QACjE,MAAM,QAAQ,GAAG,EAAE,CAAC;QACpB,KAAK,MAAM,CAAC,OAAO,EAAE,aAAa,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;YAChE,MAAM,YAAY,GAAG,aAAa,KAAK,YAAY,CAAC;YACpD,QAAQ,CAAC,IAAI,CACX,gBAAgB,CAAC,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,YAAY,CAAC,CAClE,CAAC;QACJ,CAAC;QACD,OAAO,EAAE,QAAQ,EAAE,CAAC;IACtB,CAAC;;AA/BH,8CAgCC;AAED,SAAgB,gBAAgB,CAC9B,OAAe,EACf,WAAmB,EACnB,WAAmB,EACnB,YAAqB;IAErB,OAAO;QACL,OAAO;QACP,YAAY,EAAE,IAAA,kBAAY,EACxB,WAAW,EACX,SAAS,EACT,GAAG,WAAW,IAAI,OAAO,EAAE,EAC3B,WAAW,CACZ;QACD,YAAY;KACb,CAAC;AACJ,CAAC","sourcesContent":["import is from '@sindresorhus/is';\nimport { joinUrlParts } from '../../../util/url';\nimport * as pvpVersioning from '../../versioning/pvp';\nimport { Datasource } from '../datasource';\nimport type { GetReleasesConfig, Release, ReleaseResult } from '../types';\nimport { HackagePackageMetadata } from './schema';\n\nexport class HackageDatasource extends Datasource {\n  static readonly id = 'hackage';\n\n  constructor() {\n    super(HackageDatasource.id);\n  }\n\n  override readonly defaultVersioning = pvpVersioning.id;\n  override readonly customRegistrySupport = false;\n  override readonly defaultRegistryUrls = ['https://hackage.haskell.org/'];\n\n  async getReleases(config: GetReleasesConfig): Promise<ReleaseResult | null> {\n    const { registryUrl, packageName } = config;\n    if (!is.nonEmptyString(registryUrl)) {\n      return null;\n    }\n    const massagedPackageName = encodeURIComponent(packageName);\n    const url = joinUrlParts(\n      registryUrl,\n      'package',\n      `${massagedPackageName}.json`,\n    );\n    const res = await this.http.getJson(url, HackagePackageMetadata);\n    const releases = [];\n    for (const [version, versionStatus] of Object.entries(res.body)) {\n      const isDeprecated = versionStatus === 'deprecated';\n      releases.push(\n        versionToRelease(version, packageName, registryUrl, isDeprecated),\n      );\n    }\n    return { releases };\n  }\n}\n\nexport function versionToRelease(\n  version: string,\n  packageName: string,\n  registryUrl: string,\n  isDeprecated: boolean,\n): Release {\n  return {\n    version,\n    changelogUrl: joinUrlParts(\n      registryUrl,\n      'package',\n      `${packageName}-${version}`,\n      'changelog',\n    ),\n    isDeprecated,\n  };\n}\n"]}