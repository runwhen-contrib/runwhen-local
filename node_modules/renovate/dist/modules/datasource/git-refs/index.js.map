{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../lib/modules/datasource/git-refs/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from '../../../logger';\nimport { cache } from '../../../util/cache/package/decorator';\nimport { regEx } from '../../../util/regex';\nimport type { DigestConfig, GetReleasesConfig, ReleaseResult } from '../types';\nimport { GitDatasource } from './base';\nimport type { RawRefs } from './types';\n\n// git will prompt for known hosts or passwords, unless we activate BatchMode\nprocess.env.GIT_SSH_COMMAND = 'ssh -o BatchMode=yes';\n\nexport class GitRefsDatasource extends GitDatasource {\n  static override readonly id = 'git-refs';\n\n  constructor() {\n    super(GitRefsDatasource.id);\n  }\n\n  override readonly customRegistrySupport = false;\n\n  override readonly sourceUrlSupport = 'package';\n  override readonly sourceUrlNote =\n    'The source URL is determined by using the `packageName` and `registryUrl`.';\n\n  @cache({\n    namespace: `datasource-${GitRefsDatasource.id}`,\n    key: ({ packageName }: GetReleasesConfig) => packageName,\n  })\n  override async getReleases({\n    packageName,\n  }: GetReleasesConfig): Promise<ReleaseResult | null> {\n    let rawRefs: RawRefs[] | null = null;\n\n    try {\n      rawRefs = await this.getRawRefs({ packageName });\n    } catch (err) /* istanbul ignore next */ {\n      logger.debug({ err }, 'Error getting git-refs');\n    }\n\n    if (!rawRefs) {\n      return null;\n    }\n\n    const refs = rawRefs\n      .filter((ref) => ref.type === 'tags' || ref.type === 'heads')\n      .map((ref) => ref.value);\n\n    const uniqueRefs = [...new Set(refs)];\n\n    const sourceUrl = packageName\n      .replace(regEx(/\\.git$/), '')\n      .replace(regEx(/\\/$/), '');\n\n    const result: ReleaseResult = {\n      sourceUrl,\n      releases: uniqueRefs.map((ref) => ({\n        version: ref,\n        gitRef: ref,\n        newDigest: rawRefs.find((rawRef) => rawRef.value === ref)?.hash,\n      })),\n    };\n\n    return result;\n  }\n\n  override async getDigest(\n    { packageName }: DigestConfig,\n    newValue?: string,\n  ): Promise<string | null> {\n    const rawRefs: RawRefs[] | null = await this.getRawRefs({ packageName });\n\n    /* v8 ignore next 3 -- TODO: add test */\n    if (!rawRefs) {\n      return null;\n    }\n\n    let ref: RawRefs | undefined;\n    if (newValue) {\n      ref = rawRefs.find(\n        (rawRef) =>\n          ['heads', 'tags'].includes(rawRef.type) && rawRef.value === newValue,\n      );\n    } else {\n      ref = rawRefs.find(\n        (rawRef) => rawRef.type === '' && rawRef.value === 'HEAD',\n      );\n    }\n    if (ref) {\n      return ref.hash;\n    }\n    return null;\n  }\n}\n"]}