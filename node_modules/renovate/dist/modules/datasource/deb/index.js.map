{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../lib/modules/datasource/deb/index.ts"],"names":[],"mappings":"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","sourcesContent":["import readline from 'readline';\nimport { nanoid } from 'nanoid';\nimport upath from 'upath';\nimport { logger } from '../../../logger';\nimport { cache } from '../../../util/cache/package/decorator';\nimport * as fs from '../../../util/fs';\nimport { toSha256 } from '../../../util/hash';\nimport type { HttpOptions } from '../../../util/http/types';\nimport { joinUrlParts } from '../../../util/url';\nimport { Datasource } from '../datasource';\nimport type { GetReleasesConfig, ReleaseResult } from '../types';\nimport { computeFileChecksum, parseChecksumsFromInRelease } from './checksum';\nimport { cacheSubDir, packageKeys, requiredPackageKeys } from './common';\nimport { extract, getFileCreationTime } from './file';\nimport { formatReleaseResult, releaseMetaInformationMatches } from './release';\nimport type { PackageDescription } from './types';\nimport { constructComponentUrls, getBaseSuiteUrl } from './url';\n\nexport class DebDatasource extends Datasource {\n  static readonly id = 'deb';\n\n  constructor() {\n    super(DebDatasource.id);\n  }\n\n  /**\n   * Users are able to specify custom Debian repositories as long as they follow\n   * the Debian package repository format as specified here\n   * @see{https://wiki.debian.org/DebianRepository/Format}\n   */\n  override readonly customRegistrySupport = true;\n\n  /**\n   * Users can specify multiple upstream repositories and the datasource will aggregate the release\n   * @example\n   * When specifying multiple dependencies both internal and external dependencies from internal/external artifactory\n   */\n  override readonly registryStrategy = 'merge';\n\n  /**\n   * The original apt source list file format is\n   * deb uri distribution [component1] [component2] [...]\n   * @see{https://wiki.debian.org/DebianRepository/Format}\n   *\n   * However, for Renovate, we require the registry URLs to be\n   * valid URLs which is why the parameters are encoded in the URL.\n   *\n   * The following query parameters are required:\n   * - components: comma separated list of components\n   * - suite: stable, oldstable or other alias for a release, either this or release must be given like buster\n   * - binaryArch: e.g. amd64 resolves to http://deb.debian.org/debian/dists/stable/non-free/binary-amd64/\n   */\n  override readonly defaultRegistryUrls = [\n    'https://deb.debian.org/debian?suite=stable&components=main,contrib,non-free&binaryArch=amd64',\n  ];\n\n  override readonly defaultVersioning = 'deb';\n\n  /**\n   * Downloads and extracts a package file from a component URL.\n   *\n   * @param componentUrl - The URL of the component.\n   * @returns The path to the extracted file and the last modification timestamp.\n   * @throws Will throw an error if no valid compression method is found.\n   */\n  private async downloadAndExtractPackage(\n    componentUrl: string,\n  ): Promise<{ extractedFile: string; lastTimestamp: Date }> {\n    const packageUrlHash = toSha256(componentUrl);\n    const fullCacheDir = await fs.ensureCacheDir(cacheSubDir);\n    const extractedFile = upath.join(fullCacheDir, `${packageUrlHash}.txt`);\n    let lastTimestamp = await getFileCreationTime(extractedFile);\n\n    const compression = 'gz';\n    const compressedFile = upath.join(\n      fullCacheDir,\n      `${nanoid()}_${packageUrlHash}.${compression}`,\n    );\n\n    const wasUpdated = await this.downloadPackageFile(\n      componentUrl,\n      compression,\n      compressedFile,\n      lastTimestamp,\n    );\n\n    if (wasUpdated || !lastTimestamp) {\n      try {\n        await extract(compressedFile, compression, extractedFile);\n        lastTimestamp = await getFileCreationTime(extractedFile);\n      } catch (error) {\n        logger.warn(\n          {\n            compressedFile,\n            componentUrl,\n            compression,\n            error: error.message,\n          },\n          'Failed to extract package file from compressed file',\n        );\n      } finally {\n        await fs.rmCache(compressedFile);\n      }\n    }\n\n    if (!lastTimestamp) {\n      //extracting went wrong\n      throw new Error('Missing metadata in extracted package index file!');\n    }\n\n    return { extractedFile, lastTimestamp };\n  }\n\n  /**\n   * Downloads a package file if it has been modified since the last download timestamp.\n   *\n   * @param basePackageUrl - The base URL of the package.\n   * @param compression - The compression method used (e.g., 'gz').\n   * @param compressedFile - The path where the compressed file will be saved.\n   * @param lastDownloadTimestamp - The timestamp of the last download.\n   * @returns True if the file was downloaded, otherwise false.\n   */\n  private async downloadPackageFile(\n    basePackageUrl: string,\n    compression: string,\n    compressedFile: string,\n    lastDownloadTimestamp?: Date,\n  ): Promise<boolean> {\n    const baseSuiteUrl = getBaseSuiteUrl(basePackageUrl);\n    const packageUrl = joinUrlParts(basePackageUrl, `Packages.${compression}`);\n    let needsToDownload = true;\n\n    if (lastDownloadTimestamp) {\n      needsToDownload = await this.checkIfModified(\n        packageUrl,\n        lastDownloadTimestamp,\n      );\n    }\n\n    if (!needsToDownload) {\n      logger.debug(`No need to download ${packageUrl}, file is up to date.`);\n      return false;\n    }\n    const readStream = this.http.stream(packageUrl);\n    const writeStream = fs.createCacheWriteStream(compressedFile);\n    await fs.pipeline(readStream, writeStream);\n    logger.debug(\n      { url: packageUrl, targetFile: compressedFile },\n      'Downloading Debian package file',\n    );\n\n    let inReleaseContent = '';\n\n    try {\n      inReleaseContent = await this.fetchInReleaseFile(baseSuiteUrl);\n    } catch (error) {\n      // This is expected to fail for Artifactory if GPG verification is not enabled\n      logger.debug(\n        { url: baseSuiteUrl, err: error },\n        'Could not fetch InRelease file',\n      );\n    }\n\n    if (inReleaseContent) {\n      const actualChecksum = await computeFileChecksum(compressedFile);\n      const expectedChecksum = parseChecksumsFromInRelease(\n        inReleaseContent,\n        // path to the Package.gz file\n        packageUrl.replace(`${baseSuiteUrl}/`, ''),\n      );\n      if (actualChecksum !== expectedChecksum) {\n        await fs.rmCache(compressedFile);\n        throw new Error('SHA256 checksum validation failed');\n      }\n    }\n\n    return needsToDownload;\n  }\n\n  /**\n   * Fetches the content of the InRelease file from the given base suite URL.\n   *\n   * @param baseReleaseUrl - The base URL of the suite (e.g., 'https://deb.debian.org/debian/dists/bullseye').\n   * @returns resolves to the content of the InRelease file.\n   * @throws An error if the InRelease file could not be downloaded.\n   */\n  private async fetchInReleaseFile(baseReleaseUrl: string): Promise<string> {\n    const inReleaseUrl = joinUrlParts(baseReleaseUrl, 'InRelease');\n    const response = await this.http.getText(inReleaseUrl);\n    return response.body;\n  }\n\n  /**\n   * Checks if a packageUrl content has been modified since the specified timestamp.\n   *\n   * @param packageUrl - The URL to check.\n   * @param lastDownloadTimestamp - The timestamp of the last download.\n   * @returns True if the content has been modified, otherwise false.\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\n   */\n  private async checkIfModified(\n    packageUrl: string,\n    lastDownloadTimestamp: Date,\n  ): Promise<boolean> {\n    const options: HttpOptions = {\n      headers: {\n        'If-Modified-Since': lastDownloadTimestamp.toUTCString(),\n      },\n    };\n\n    try {\n      const response = await this.http.head(packageUrl, options);\n      return response.statusCode !== 304;\n    } catch (error) {\n      logger.warn(\n        { packageUrl, lastDownloadTimestamp, errorMessage: error.message },\n        'Could not determine if package file is modified since last download',\n      );\n      return true; // Assume it needs to be downloaded if check fails\n    }\n  }\n\n  /**\n   * Parses the extracted package index file.\n   *\n   * @param extractedFile - The path to the extracted package file.\n   * @param lastTimestamp - The timestamp of the last modification.\n   * @returns a list of packages with minimal Metadata.\n   */\n  @cache({\n    namespace: `datasource-${DebDatasource.id}`,\n    key: (extractedFile: string, lastTimestamp: Date) =>\n      `${extractedFile}:${lastTimestamp.getTime()}`,\n    ttlMinutes: 24 * 60,\n  })\n  async parseExtractedPackageIndex(\n    extractedFile: string,\n    _lastTimestamp: Date,\n  ): Promise<Record<string, PackageDescription[]>> {\n    // read line by line to avoid high memory consumption as the extracted Packages\n    // files can be multiple MBs in size\n    const rl = readline.createInterface({\n      input: fs.createCacheReadStream(extractedFile),\n      terminal: false,\n    });\n\n    let currentPackage: PackageDescription = {};\n    // A Package Index can contain multiple Versions of the package on private Artifactory (e.g. Jfrog)\n    const allPackages: Record<string, PackageDescription[]> = {};\n\n    for await (const line of rl) {\n      if (line === '') {\n        // All information of the package are available, add to the list of packages\n        if (requiredPackageKeys.every((key) => key in currentPackage)) {\n          if (!allPackages[currentPackage.Package!]) {\n            allPackages[currentPackage.Package!] = [];\n          }\n          allPackages[currentPackage.Package!].push(currentPackage);\n          currentPackage = {};\n        }\n      } else {\n        for (const key of packageKeys) {\n          if (line.startsWith(`${key}:`)) {\n            currentPackage[key] = line.substring(key.length + 1).trim();\n            break;\n          }\n        }\n      }\n    }\n\n    // Check the last package after file reading is complete\n    if (requiredPackageKeys.every((key) => key in currentPackage)) {\n      if (!allPackages[currentPackage.Package!]) {\n        allPackages[currentPackage.Package!] = [];\n      }\n      allPackages[currentPackage.Package!].push(currentPackage);\n    }\n\n    return allPackages;\n  }\n\n  @cache({\n    namespace: `datasource-${DebDatasource.id}`,\n    key: (componentUrl: string) => componentUrl,\n  })\n  async getPackageIndex(\n    componentUrl: string,\n  ): Promise<Record<string, PackageDescription[]>> {\n    const { extractedFile, lastTimestamp } =\n      await this.downloadAndExtractPackage(componentUrl);\n    return await this.parseExtractedPackageIndex(extractedFile, lastTimestamp);\n  }\n\n  /**\n   * Fetches the release information for a given package from the registry URL.\n   *\n   * @param config - Configuration for fetching releases.\n   * @returns The release result if the package is found, otherwise null.\n   */\n  @cache({\n    namespace: `datasource-${DebDatasource.id}`,\n    key: ({ registryUrl, packageName }: GetReleasesConfig) =>\n      `${registryUrl}:${packageName}`,\n  })\n  async getReleases({\n    registryUrl,\n    packageName,\n  }: GetReleasesConfig): Promise<ReleaseResult | null> {\n    /* v8 ignore next 3 -- should never happen */\n    if (!registryUrl) {\n      return null;\n    }\n\n    const componentUrls = constructComponentUrls(registryUrl);\n    let aggregatedRelease: ReleaseResult | null = null;\n\n    for (const componentUrl of componentUrls) {\n      try {\n        const packageIndex = await this.getPackageIndex(componentUrl);\n        const parsedPackages = packageIndex[packageName];\n\n        if (parsedPackages) {\n          const newRelease = formatReleaseResult(parsedPackages);\n          if (aggregatedRelease === null) {\n            aggregatedRelease = newRelease;\n          } else {\n            if (!releaseMetaInformationMatches(aggregatedRelease, newRelease)) {\n              logger.warn(\n                { packageName },\n                'Package occurred in more than one repository with different meta information. Aggregating releases anyway.',\n              );\n            }\n            aggregatedRelease.releases.push(...newRelease.releases);\n          }\n        }\n      } catch (error) {\n        logger.debug(\n          { componentUrl, error },\n          'Skipping component due to an error',\n        );\n      }\n    }\n\n    return aggregatedRelease;\n  }\n}\n"]}