{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../lib/modules/datasource/repology/index.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { HOST_DISABLED } from '../../../constants/error-messages';\nimport { logger } from '../../../logger';\nimport { ExternalHostError } from '../../../types/errors/external-host-error';\nimport { cache } from '../../../util/cache/package/decorator';\nimport { getQueryString, joinUrlParts } from '../../../util/url';\nimport { Datasource } from '../datasource';\nimport type { GetReleasesConfig, ReleaseResult } from '../types';\nimport type { RepologyPackage, RepologyPackageType } from './types';\n\nconst packageTypes: RepologyPackageType[] = ['binname', 'srcname'];\n\nfunction findPackageInResponse(\n  response: RepologyPackage[],\n  repoName: string,\n  pkgName: string,\n  types: RepologyPackageType[],\n): RepologyPackage[] | null {\n  const repoPackages = response.filter((pkg) => pkg.repo === repoName);\n\n  if (repoPackages.length === 0) {\n    // no packages associated with repoName\n    return null;\n  }\n\n  if (repoPackages.length === 1) {\n    // repo contains exactly one package, so we can return them safely\n    return repoPackages;\n  }\n\n  // In some cases Repology bundles multiple packages into a single project, which might result in ambiguous results.\n  // We need to do additional filtering by matching allowed package types passed as params with package description.\n  // Remaining packages are the one we are looking for\n  const packagesWithType = repoPackages.filter((pkg) => {\n    for (const pkgType of types) {\n      if (pkg[pkgType] && pkg[pkgType] === pkgName) {\n        return true;\n      }\n    }\n    return false;\n  });\n\n  return packagesWithType.length > 0 ? packagesWithType : null;\n}\n\nexport class RepologyDatasource extends Datasource {\n  static readonly id = 'repology';\n\n  override readonly defaultRegistryUrls = ['https://repology.org/'];\n\n  override readonly registryStrategy = 'hunt';\n\n  constructor() {\n    super(RepologyDatasource.id);\n  }\n\n  private async queryPackages(url: string): Promise<RepologyPackage[]> {\n    try {\n      const res = await this.http.getJsonUnchecked<RepologyPackage[]>(url);\n      return res.body;\n    } catch (err) {\n      if (err.statusCode === 404) {\n        // Return an array here because the api does not return proper http codes\n        // and instead of an 404 error an empty array with code 200 is returned\n        // When querying the resolver 404 is thrown if package could not be resolved\n        // and 403 if the repo is not supported\n        // 403 is handled later because in this case we are trying the API\n        return [];\n      }\n\n      throw err;\n    }\n  }\n\n  private async queryPackagesViaResolver(\n    registryUrl: string,\n    repoName: string,\n    packageName: string,\n    packageType: RepologyPackageType,\n  ): Promise<RepologyPackage[]> {\n    const query = getQueryString({\n      repo: repoName,\n      name_type: packageType,\n      target_page: 'api_v1_project',\n      noautoresolve: 'on',\n      name: packageName,\n    });\n\n    // Retrieve list of packages by looking up Repology project\n    const packages = await this.queryPackages(\n      joinUrlParts(registryUrl, `tools/project-by?${query}`),\n    );\n\n    return packages;\n  }\n\n  private async queryPackagesViaAPI(\n    registryUrl: string,\n    packageName: string,\n  ): Promise<RepologyPackage[]> {\n    // Directly query the package via the API. This will only work if `packageName` has the\n    // same name as the repology project\n    const packages = await this.queryPackages(\n      joinUrlParts(registryUrl, `api/v1/project`, packageName),\n    );\n\n    return packages;\n  }\n\n  @cache({\n    ttlMinutes: 60,\n    namespace: `datasource-${RepologyDatasource.id}`,\n    key: (registryUrl: string, repoName: string, pkgName: string) =>\n      joinUrlParts(registryUrl, repoName, pkgName),\n  })\n  async queryPackage(\n    registryUrl: string,\n    repoName: string,\n    pkgName: string,\n  ): Promise<RepologyPackage[] | undefined> {\n    let response: RepologyPackage[];\n    // Try getting the packages from tools/project-by first for type binname and\n    // afterwards for srcname. This needs to be done first, because some packages\n    // resolve to repology projects which have a different name than the package\n    // e.g. `pulseaudio-utils` resolves to project `pulseaudio`, BUT there is also\n    // a project called `pulseaudio-utils` but it does not contain the package we\n    // are looking for.\n    try {\n      for (const pkgType of packageTypes) {\n        response = await this.queryPackagesViaResolver(\n          registryUrl,\n          repoName,\n          pkgName,\n          pkgType,\n        );\n\n        if (response) {\n          const pkg = findPackageInResponse(response, repoName, pkgName, [\n            pkgType,\n          ]);\n          if (is.nonEmptyArray(pkg)) {\n            // exit immediately if package found\n            return pkg;\n          }\n        }\n      }\n    } catch (err) {\n      if (err.statusCode === 403) {\n        logger.debug(\n          { repoName, pkgName },\n          'Repology does not support tools/project-by lookups for repository. Will try direct API access now',\n        );\n\n        // If the repository is not supported in tools/project-by we try directly accessing the\n        // API. This will support all repositories but requires that the project name is equal to the\n        // package name. This won't be always the case but for a good portion we might be able to resolve\n        // the package this way.\n        response = await this.queryPackagesViaAPI(registryUrl, pkgName);\n        const pkg = findPackageInResponse(\n          response,\n          repoName,\n          pkgName,\n          packageTypes,\n        );\n        if (is.nonEmptyArray(pkg)) {\n          // exit immediately if package found\n          return pkg;\n        }\n      } else if (err.statusCode === 300) {\n        logger.warn(\n          { repoName, pkgName },\n          'Ambiguous redirection from package name to project name in Repology. Skipping this package',\n        );\n        return undefined;\n      }\n\n      throw err;\n    }\n\n    logger.debug(\n      { repoName, pkgName },\n      'Repository or package not found on Repology',\n    );\n\n    return undefined;\n  }\n\n  async getReleases({\n    packageName,\n    registryUrl,\n  }: GetReleasesConfig): Promise<ReleaseResult | null> {\n    /* v8 ignore next 3 -- should never happen */\n    if (!registryUrl) {\n      return null;\n    }\n    // Ensure lookup name contains both repository and package\n    const [repoName, pkgName] = packageName.split('/', 2);\n    if (!repoName || !pkgName) {\n      throw new ExternalHostError(\n        new Error(\n          'Repology lookup name must contain repository and package separated by slash (<repo>/<pkg>)',\n        ),\n      );\n    }\n\n    logger.trace(`repology.getReleases(${repoName}, ${pkgName})`);\n    try {\n      // Try to retrieve (cached) package information from Repology\n      const pkg = await this.queryPackage(registryUrl, repoName, pkgName);\n      if (!pkg) {\n        return null;\n      }\n\n      // Always prefer origversion if available, otherwise default to version\n      // This is required as source packages usually have no origversion\n      const releases = pkg.map((item) => ({\n        version: item.origversion ?? item.version,\n      }));\n      return { releases };\n    } catch (err) {\n      if (err.message === HOST_DISABLED) {\n        logger.trace({ packageName, err }, 'Host disabled');\n      } else {\n        logger.warn(\n          { packageName, err },\n          'Repology lookup failed with unexpected error',\n        );\n      }\n\n      throw new ExternalHostError(err);\n    }\n  }\n}\n"]}