{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../../../lib/modules/manager/deps-edn/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport moo from 'moo';\nimport { logger } from '../../../logger';\nimport type {\n  EdnMetadata,\n  ParsedEdnArray,\n  ParsedEdnMetadata,\n  ParsedEdnRecord,\n  ParsedEdnResult,\n  ParserState,\n  TokenTypes,\n} from './types';\n\nconst lexerStates = {\n  main: {\n    comma: { match: ',' },\n    lineComment: { match: /;.*?$/ },\n    leftParen: { match: '(' },\n    rightParen: { match: ')' },\n    leftSquare: { match: '[' },\n    rightSquare: { match: ']' },\n    leftFigure: { match: '{' },\n    rightFigure: { match: '}' },\n    longDoubleQuoted: {\n      match: '\"\"\"',\n      push: 'longDoubleQuoted',\n    },\n    doubleQuoted: {\n      match: '\"',\n      push: 'doubleQuoted',\n    },\n    // https://clojure.org/reference/reader#_reader_forms\n    keyword: {\n      match:\n        /:(?:[a-zA-Z*+!_'?<>=.-][a-zA-Z0-9*+!_'?<>=.-]*)(?:\\/(?:[a-zA-Z*+!_'?<>=.-][a-zA-Z0-9*+!_'?<>=.-]*))?/,\n      value: (x: string) => x.slice(1),\n    },\n    symbol: {\n      match:\n        /(?:[a-zA-Z*+!_'?<>=.-][a-zA-Z0-9*+!_'?<>=.-]*)(?:\\/(?:[a-zA-Z*+!_'?<>=.-][a-zA-Z0-9*+!_'?<>=.-]*))?/,\n    },\n    double: {\n      match:\n        /(?:[0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?|(?:[0-9]+[eE][+-]?[0-9]+)/,\n    },\n    rational: { match: /[0-9]+\\/[0-9]+/ },\n    integer: { match: /(?:0x[0-9a-fA-F]+|[0-9]+r[0-9a-zA-Z]+|[0-9]+)/ },\n    unknown: moo.fallback,\n  },\n  longDoubleQuoted: {\n    stringFinish: { match: '\"\"\"', pop: 1 },\n    stringContent: moo.fallback,\n  },\n  doubleQuoted: {\n    stringFinish: { match: '\"', pop: 1 },\n    stringContent: moo.fallback,\n  },\n};\n\ntype TokenType = TokenTypes<typeof lexerStates>;\n\nconst lexer = moo.states(lexerStates);\n\nexport function parseDepsEdnFile(content: string): ParsedEdnResult | null {\n  lexer.reset(content);\n  const tokens = [...lexer];\n  lexer.reset();\n\n  const stack: ParserState[] = [];\n  let state: ParserState = { type: 'root', data: null };\n\n  const metadata: ParsedEdnMetadata = new WeakMap<\n    ParsedEdnRecord | ParsedEdnArray,\n    EdnMetadata\n  >();\n\n  const popState = (): boolean => {\n    const savedState = stack.pop();\n    if (!savedState) {\n      return false;\n    }\n\n    if (savedState.type === 'root') {\n      savedState.data = state.data;\n      state = savedState;\n      return false;\n    }\n\n    if (savedState.type === 'record') {\n      if (savedState.skipKey) {\n        savedState.currentKey = null;\n        savedState.skipKey = false;\n      } else if (savedState.currentKey) {\n        savedState.data[savedState.currentKey] = state.data;\n        savedState.currentKey = null;\n      } else {\n        savedState.skipKey = true;\n      }\n    }\n\n    if (savedState.type === 'array') {\n      savedState.data.push(state.data);\n    }\n\n    state = savedState;\n    return true;\n  };\n\n  for (const token of tokens) {\n    const tokenType = token.type as TokenType;\n    const stateType = state.type;\n\n    // istanbul ignore else: token type comprehension\n    if (\n      tokenType === 'lineComment' ||\n      tokenType === 'unknown' ||\n      tokenType === 'doubleQuoted' ||\n      tokenType === 'longDoubleQuoted' ||\n      tokenType === 'stringFinish' ||\n      tokenType === 'comma'\n    ) {\n      continue;\n    } else if (\n      tokenType === 'rightParen' ||\n      tokenType === 'rightSquare' ||\n      tokenType === 'rightFigure'\n    ) {\n      if (state.type === 'record' || state.type === 'array') {\n        const { startIndex } = state;\n        const endIndex = token.offset + token.value.length;\n        const replaceString = content.slice(startIndex, endIndex);\n        metadata.set(state.data, { replaceString });\n      }\n\n      if (!popState()) {\n        break;\n      }\n    } else if (tokenType === 'leftParen' || tokenType === 'leftSquare') {\n      stack.push(state);\n      state = {\n        type: 'array',\n        startIndex: token.offset,\n        data: [],\n      };\n    } else if (tokenType === 'leftFigure') {\n      stack.push(state);\n      state = {\n        type: 'record',\n        startIndex: token.offset,\n        data: {},\n        skipKey: false,\n        currentKey: null,\n      };\n    } else if (\n      tokenType === 'symbol' ||\n      tokenType === 'keyword' ||\n      tokenType === 'stringContent' ||\n      tokenType === 'double' ||\n      tokenType === 'rational' ||\n      tokenType === 'integer'\n    ) {\n      if (stateType === 'record') {\n        if (state.skipKey) {\n          state.currentKey = null;\n          state.skipKey = false;\n        } else if (state.currentKey) {\n          state.data[state.currentKey] = token.value;\n          state.currentKey = null;\n        } else {\n          state.currentKey = token.value;\n        }\n      } else if (stateType === 'array') {\n        state.data.push(token.value);\n      } else if (stateType === 'root') {\n        state.data = token.value;\n      }\n    } else {\n      const unknownType: never = tokenType;\n      logger.debug({ unknownType }, `Unknown token type for \"deps.edn\"`);\n    }\n  }\n\n  while (stack.length) {\n    popState();\n  }\n\n  if (is.plainObject(state.data)) {\n    return { data: state.data, metadata };\n  }\n\n  return null;\n}\n"]}