{"version":3,"file":"extract.js","sourceRoot":"","sources":["../../../../lib/modules/manager/haskell-cabal/extract.ts"],"names":[],"mappings":"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","sourcesContent":["import { regEx } from '../../../util/regex';\n\nconst buildDependsRegex = regEx(\n  /(?<buildDependsFieldName>build-depends[ \\t]*:)/i,\n);\nconst commentRegex = regEx(/^[ \\t]*--/);\nfunction isNonASCII(str: string): boolean {\n  for (let i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) > 127) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function countPackageNameLength(input: string): number | null {\n  if (input.length < 1 || isNonASCII(input)) {\n    return null;\n  }\n  if (!regEx(/^[A-Za-z0-9]/).test(input[0])) {\n    // Must start with letter or number\n    return null;\n  }\n  let idx = 1;\n  while (idx < input.length) {\n    if (regEx(/[A-Za-z0-9-]/).test(input[idx])) {\n      idx++;\n    } else {\n      break;\n    }\n  }\n  if (!regEx(/[A-Za-z]/).test(input.slice(0, idx))) {\n    // Must contain a letter\n    return null;\n  }\n  if (idx - 1 < input.length && input[idx - 1] === '-') {\n    // Can't end in a hyphen\n    return null;\n  }\n  return idx;\n}\n\nexport interface CabalDependency {\n  packageName: string;\n  currentValue: string;\n  replaceString: string;\n}\n\n/**\n * Find extents of field contents\n *\n * @param {number} indent -\n *    Indention level maintained within the block.\n *    Any indention lower than this means it's outside the field.\n *    Lines with this level or more are included in the field.\n * @returns {number}\n *    Index just after the end of the block.\n *    Note that it may be after the end of the string.\n */\nexport function findExtents(indent: number, content: string): number {\n  let blockIdx = 0;\n  let mode: 'finding-newline' | 'finding-indention' = 'finding-newline';\n  for (;;) {\n    if (mode === 'finding-newline') {\n      while (content[blockIdx++] !== '\\n') {\n        if (blockIdx >= content.length) {\n          break;\n        }\n      }\n      if (blockIdx >= content.length) {\n        return content.length;\n      }\n      mode = 'finding-indention';\n    } else {\n      let thisIndent = 0;\n      for (;;) {\n        if ([' ', '\\t'].includes(content[blockIdx])) {\n          thisIndent += 1;\n          blockIdx++;\n          if (blockIdx >= content.length) {\n            return content.length;\n          }\n          continue;\n        }\n        mode = 'finding-newline';\n        blockIdx++;\n        break;\n      }\n      if (thisIndent < indent) {\n        if (content.slice(blockIdx - 1, blockIdx + 1) === '--') {\n          // not enough indention, but the line is a comment, so include it\n          mode = 'finding-newline';\n          continue;\n        }\n        // go back to before the newline\n        for (;;) {\n          if (content[blockIdx--] === '\\n') {\n            break;\n          }\n        }\n        return blockIdx + 1;\n      }\n      mode = 'finding-newline';\n    }\n  }\n}\n\n/**\n * Find indention level of build-depends\n *\n * @param {number} match -\n *   Search starts at this index, and proceeds backwards.\n * @returns {number}\n *   Number of indention levels found before 'match'.\n */\nexport function countPrecedingIndentation(\n  content: string,\n  match: number,\n): number {\n  let whitespaceIdx = match - 1;\n  let indent = 0;\n  while (whitespaceIdx >= 0 && [' ', '\\t'].includes(content[whitespaceIdx])) {\n    indent += 1;\n    whitespaceIdx--;\n  }\n  return indent;\n}\n\n/**\n * Find one 'build-depends' field name usage and its field value\n *\n * @returns {{buildDependsContent: string, lengthProcessed: number}}\n *   buildDependsContent:\n *     the contents of the field, excluding the field name and the colon,\n *     and any comments within\n *\n *   lengthProcessed:\n *     points to after the end of the field. Note that the field does _not_\n *     necessarily start at `content.length - lengthProcessed`.\n *\n *   Returns null if no 'build-depends' field is found.\n */\nexport function findDepends(\n  content: string,\n): { buildDependsContent: string; lengthProcessed: number } | null {\n  const matchObj = buildDependsRegex.exec(content);\n  if (!matchObj?.groups) {\n    return null;\n  }\n  const indent = countPrecedingIndentation(content, matchObj.index);\n  const ourIdx: number =\n    matchObj.index + matchObj.groups.buildDependsFieldName.length;\n  const extentLength: number = findExtents(indent + 1, content.slice(ourIdx));\n  const extent = content.slice(ourIdx, ourIdx + extentLength);\n  const lines = [];\n  // Windows-style line breaks are fine because\n  // carriage returns are before the line feed.\n  for (const maybeCommentLine of extent.split('\\n')) {\n    if (!commentRegex.test(maybeCommentLine)) {\n      lines.push(maybeCommentLine);\n    }\n  }\n  return {\n    buildDependsContent: lines.join('\\n'),\n    lengthProcessed: ourIdx + extentLength,\n  };\n}\n\n/**\n * Split a cabal single dependency into its constituent parts.\n * The first part is the package name, an optional second part contains\n * the version constraint.\n *\n * For example 'base == 3.2' would be split into 'base' and ' == 3.2'.\n *\n * @returns {{name: string, range: string}}\n *   Null if the trimmed string doesn't begin with a package name.\n */\nexport function splitSingleDependency(\n  input: string,\n): { name: string; range: string } | null {\n  const match = countPackageNameLength(input);\n  if (match === null) {\n    return null;\n  }\n  const name: string = input.slice(0, match);\n  const range = input.slice(match).trim();\n  return { name, range };\n}\n\nexport function extractNamesAndRanges(content: string): CabalDependency[] {\n  const list = content.split(',');\n  const deps = [];\n  for (const untrimmedReplaceString of list) {\n    const replaceString = untrimmedReplaceString.trim();\n    const maybeNameRange = splitSingleDependency(replaceString);\n    if (maybeNameRange !== null) {\n      deps.push({\n        currentValue: maybeNameRange.range,\n        packageName: maybeNameRange.name,\n        replaceString,\n      });\n    }\n  }\n  return deps;\n}\n"]}