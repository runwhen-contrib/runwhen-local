{"version":3,"file":"rules.js","sourceRoot":"","sources":["../../../../../lib/modules/manager/bazel-module/parser/rules.ts"],"names":[],"mappings":";;;AAAA,2DAAgD;AAChD,kDAA+C;AAC/C,qCAAoC;AAGpC,gFAAgF;AAChF,wDAAwD;AACxD,EAAE;AACF,wDAAwD;AACxD,+BAA+B;AAC/B,EAAE;AACF,oEAAoE;AACpE,gEAAgE;AAChE,+DAA+D;AAE/D,MAAM,cAAc,GAAG;IACrB,kBAAkB;IAClB,WAAW;IACX,cAAc;IACd,qBAAqB;IACrB,yBAAyB;IACzB,gBAAgB;CACjB,CAAC;AACF,MAAM,mBAAmB,GAAG,IAAA,aAAK,EAAC,IAAI,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAEtD,QAAA,KAAK,GAAG,0BAAC;KACnB,GAAG,CAAM,mBAAmB,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;KACzE,IAAI,CACH,0BAAC,CAAC,IAAI,CAAC;IACL,IAAI,EAAE,cAAc;IACpB,QAAQ,EAAE,CAAC;IACX,MAAM,EAAE,iBAAQ;IAChB,WAAW,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,OAAO,EAAE;CACpC,CAAC,CACH,CAAC","sourcesContent":["import { query as q } from 'good-enough-parser';\nimport { regEx } from '../../../../util/regex';\nimport { kvParams } from './common';\nimport type { Ctx } from './context';\n\n// For the purpose of parsing bazel module files in Renovate, we consider a rule\n// to be any \"direct function application\". For example:\n//\n//     bazel_dep(name = \"platforms\", version = \"0.0.11\")\n//     ^^^^^^^^^ --> the \"rule\"\n//\n// In bazel, rules have typically a more narrow definition. However:\n// - They are syntactically indistinguishable from, say, macros.\n// - In informal speech, \"rule\" is often used as umbrella term.\n\nconst supportedRules = [\n  'archive_override',\n  'bazel_dep',\n  'git_override',\n  'local_path_override',\n  'single_version_override',\n  'git_repository',\n];\nconst supportedRulesRegex = regEx(`^${supportedRules.join('|')}$`);\n\nexport const rules = q\n  .sym<Ctx>(supportedRulesRegex, (ctx, token) => ctx.startRule(token.value))\n  .join(\n    q.tree({\n      type: 'wrapped-tree',\n      maxDepth: 1,\n      search: kvParams,\n      postHandler: (ctx) => ctx.endRule(),\n    }),\n  );\n"]}