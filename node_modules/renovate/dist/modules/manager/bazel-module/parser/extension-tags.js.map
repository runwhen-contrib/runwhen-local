{"version":3,"file":"extension-tags.js","sourceRoot":"","sources":["../../../../../lib/modules/manager/bazel-module/parser/extension-tags.ts"],"names":[],"mappings":";;;AAAA,2DAAgD;AAChD,kDAA+C;AAC/C,qCAAoC;AAGpC,mCAAmE;AACnE,+BAA6D;AAE7D,kFAAkF;AAClF,eAAe;AACf,EAAE;AACF,mEAAmE;AACnE,mEAAmE;AACnE,EAAE;AACF,6BAA6B;AAC7B,qCAAqC;AACrC,EAAE;AACF,gFAAgF;AAChF,+EAA+E;AAC/E,kEAAkE;AAElE,MAAM,uBAAuB,GAAG,IAAA,aAAK,EACnC,KAAK,wBAAkB,IAAI,4BAAoB,MAAM,CACtD,CAAC;AAEF,MAAM,sBAAsB,GAAG,CAAC,GAAG,0BAAkB,EAAE,GAAG,sBAAgB,CAAC,CAAC;AAE5E,MAAM,2BAA2B,GAAG,IAAA,aAAK,EACvC,KAAK,sBAAsB,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAC1C,CAAC;AAEW,QAAA,aAAa,GAAG,0BAAC;KAC3B,GAAG,CAAM,uBAAuB,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE;IAChD,MAAM,YAAY,GAAG,KAAK,CAAC,KAAK,CAAC;IACjC,MAAM,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC,uBAAuB,CAAE,CAAC;IAC3D,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3B,OAAO,GAAG,CAAC,mBAAmB,CAAC,SAAS,EAAE,YAAY,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;AACxE,CAAC,CAAC;KACD,EAAE,CAAC,GAAG,CAAC;KACP,GAAG,CAAC,2BAA2B,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE;IAC/C,OAAO,GAAG,CAAC,iBAAiB,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAC5C,CAAC,CAAC;KACD,IAAI,CACH,0BAAC,CAAC,IAAI,CAAC;IACL,IAAI,EAAE,cAAc;IACpB,QAAQ,EAAE,CAAC;IACX,MAAM,EAAE,iBAAQ;IAChB,WAAW,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;QACzB,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc,EAAE,CAAC;YACjC,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;YAC1B,MAAM,SAAS,GAAG,QAAQ,CAAC,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC;YAC1D,OAAO,GAAG,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;QACxC,CAAC;QAED,uBAAuB;QACvB,MAAM,IAAI,KAAK,CAAC,mCAAmC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;IAClE,CAAC;CACF,CAAC,CACH,CAAC","sourcesContent":["import { query as q } from 'good-enough-parser';\nimport { regEx } from '../../../../util/regex';\nimport { kvParams } from './common';\nimport type { Ctx } from './context';\n\nimport { mavenExtensionPrefix, mavenExtensionTags } from './maven';\nimport { ociExtensionPrefix, ociExtensionTags } from './oci';\n\n// In bazel modules an extension tag is (roughly) a \"member function application\".\n// For example:\n//\n//     oci = use_extension(\"@rules_oci//oci:extensions.bzl\", \"oci\")\n//     ^^^ --> the extension definition (not parsed by this module)\n//\n//     oci.pull(<parameters>)\n//         ^^^^ --> the extension tag\n//\n// The name of the extension (`oci` in the example above) technically arbitrary.\n// However, in practice, there are conventions. We use this to simplify parsing\n// by assuming the extension names start with well-known prefixes.\n\nconst supportedExtensionRegex = regEx(\n  `^(${ociExtensionPrefix}|${mavenExtensionPrefix}).*$`,\n);\n\nconst supportedExtensionTags = [...mavenExtensionTags, ...ociExtensionTags];\n\nconst supportedExtensionTagsRegex = regEx(\n  `^(${supportedExtensionTags.join('|')})$`,\n);\n\nexport const extensionTags = q\n  .sym<Ctx>(supportedExtensionRegex, (ctx, token) => {\n    const rawExtension = token.value;\n    const match = rawExtension.match(supportedExtensionRegex)!;\n    const extension = match[1];\n    return ctx.prepareExtensionTag(extension, rawExtension, token.offset);\n  })\n  .op('.')\n  .sym(supportedExtensionTagsRegex, (ctx, token) => {\n    return ctx.startExtensionTag(token.value);\n  })\n  .join(\n    q.tree({\n      type: 'wrapped-tree',\n      maxDepth: 1,\n      search: kvParams,\n      postHandler: (ctx, tree) => {\n        if (tree.type === 'wrapped-tree') {\n          const { endsWith } = tree;\n          const endOffset = endsWith.offset + endsWith.value.length;\n          return ctx.endExtensionTag(endOffset);\n        }\n\n        // istanbul ignore next\n        throw new Error(`Unexpected tree in postHandler: ${tree.type}`);\n      },\n    }),\n  );\n"]}