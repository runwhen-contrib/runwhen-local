"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDependency = updateDependency;
// TODO: types (#22198)
const logger_1 = require("../../../logger");
const regex_1 = require("../../../util/regex");
function getNameWithNoVersion(name) {
    // remove version suffixes like /v1 or /v2
    let nameNoVersion = name.replace((0, regex_1.regEx)(/\/v\d+$/), '');
    // gopkg.in is a special case where the major version is added with a dot rather than a slash
    if (nameNoVersion.startsWith('gopkg.in')) {
        nameNoVersion = nameNoVersion.replace((0, regex_1.regEx)(/\.v\d+$/), '');
    }
    return nameNoVersion;
}
function updateDependency({ fileContent, upgrade, }) {
    try {
        logger_1.logger.debug(`gomod.updateDependency: ${upgrade.newValue}`);
        const { depType, updateType } = upgrade;
        const currentName = upgrade.depName;
        if (updateType === 'replacement') {
            logger_1.logger.warn('gomod manager does not support replacement updates yet');
            return null;
        }
        /* v8 ignore next 3 -- should never happen */
        if (!currentName || !upgrade.managerData) {
            return null;
        }
        const currentNameNoVersion = getNameWithNoVersion(currentName);
        const lines = fileContent.split(regex_1.newlineRegex);
        /* v8 ignore next 4 -- hard to test */
        if (lines.length <= upgrade.managerData.lineNumber) {
            logger_1.logger.warn('go.mod current line no longer exists after update');
            return null;
        }
        const lineToChange = lines[upgrade.managerData.lineNumber];
        logger_1.logger.trace({ upgrade, lineToChange }, 'go.mod current line');
        if (!lineToChange.includes(currentNameNoVersion) &&
            !lineToChange.includes('rethinkdb/rethinkdb-go.v5')) {
            logger_1.logger.debug({ lineToChange, depName: currentName }, "go.mod current line doesn't contain dependency");
            return null;
        }
        let updateLineExp;
        if (depType === 'golang' || depType === 'toolchain') {
            updateLineExp = (0, regex_1.regEx)(/(?<depPart>(?:toolchain )?go)(?<divider>\s*)([^\s]+|[\w]+)/);
        }
        if (depType === 'replace') {
            if (upgrade.managerData.multiLine) {
                updateLineExp = (0, regex_1.regEx)(/^(?<depPart>\s+[^\s]+[\s]+[=][>]+\s+)(?<divider>[^\s]+\s+)[^\s]+/);
            }
            else {
                updateLineExp = (0, regex_1.regEx)(/^(?<depPart>replace\s+[^\s]+[\s]+[=][>]+\s+)(?<divider>[^\s]+\s+)[^\s]+/);
            }
        }
        else if (depType === 'require' || depType === 'indirect') {
            if (upgrade.managerData.multiLine) {
                updateLineExp = (0, regex_1.regEx)(/^(?<depPart>\s+[^\s]+)(?<divider>\s+)[^\s]+/);
            }
            else {
                updateLineExp = (0, regex_1.regEx)(/^(?<depPart>require\s+[^\s]+)(?<divider>\s+)[^\s]+/);
            }
        }
        if (updateLineExp && !updateLineExp.test(lineToChange)) {
            logger_1.logger.debug('No line found to update');
            return null;
        }
        let newLine;
        if (upgrade.updateType === 'digest') {
            const newDigestRightSized = upgrade.newDigest.substring(0, upgrade.currentDigest.length);
            if (lineToChange.includes(newDigestRightSized)) {
                return fileContent;
            }
            logger_1.logger.debug({ depName: currentName, lineToChange, newDigestRightSized }, 'gomod: need to update digest');
            newLine = lineToChange.replace(
            // TODO: can be undefined? (#22198)
            updateLineExp, `$<depPart>$<divider>${newDigestRightSized}`);
        }
        else {
            newLine = lineToChange.replace(
            // TODO: can be undefined? (#22198)
            updateLineExp, `$<depPart>$<divider>${upgrade.newValue}`);
        }
        if (upgrade.updateType === 'major') {
            logger_1.logger.debug(`gomod: major update for ${currentName}`);
            if (currentName.startsWith('gopkg.in/')) {
                const oldV = currentName.split('.').pop();
                newLine = newLine.replace(`.${oldV}`, `.v${upgrade.newMajor}`);
                // Package renames - I couldn't think of a better place to do this
                newLine = newLine.replace('gorethink/gorethink.v5', 'rethinkdb/rethinkdb-go.v5');
            }
            else if (upgrade.newMajor > 1 &&
                !newLine.includes(`/v${upgrade.newMajor}`) &&
                !upgrade.newValue.endsWith('+incompatible')) {
                if (currentName === currentNameNoVersion) {
                    // If package currently has no version, pin to latest one.
                    newLine = newLine.replace(currentName, `${currentName}/v${upgrade.newMajor}`);
                }
                else {
                    // Replace version
                    const [oldV] = upgrade.currentValue.split('.');
                    newLine = newLine.replace((0, regex_1.regEx)(`/${oldV}(\\s+)`, undefined, false), `/v${upgrade.newMajor}$1`);
                }
            }
        }
        if (lineToChange.endsWith('+incompatible') &&
            !upgrade.newValue?.endsWith('+incompatible')) {
            let toAdd = '+incompatible';
            if (upgrade.updateType === 'major' && upgrade.newMajor >= 2) {
                toAdd = '';
            }
            newLine += toAdd;
        }
        if (newLine === lineToChange) {
            logger_1.logger.debug('No changes necessary');
            return fileContent;
        }
        if (depType === 'indirect') {
            newLine = newLine.replace((0, regex_1.regEx)(/\s*(?:\/\/\s*indirect(?:\s*;)?\s*)*$/), ' // indirect');
        }
        lines[upgrade.managerData.lineNumber] = newLine;
        return lines.join('\n');
    }
    catch (err) {
        logger_1.logger.debug({ err }, 'Error setting new go.mod version');
        return null;
    }
}
//# sourceMappingURL=update.js.map