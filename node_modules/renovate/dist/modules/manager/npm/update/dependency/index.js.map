{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../../lib/modules/manager/npm/update/dependency/index.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { dequal } from 'dequal';\nimport { logger } from '../../../../../logger';\nimport { escapeRegExp, regEx } from '../../../../../util/regex';\nimport { matchAt, replaceAt } from '../../../../../util/string';\nimport type { UpdateDependencyConfig, Upgrade } from '../../../types';\nimport type {\n  DependenciesMeta,\n  NpmPackage,\n  OverrideDependency,\n  RecursiveOverride,\n} from '../../extract/types';\nimport type { NpmDepType, NpmManagerData } from '../../types';\nimport { getNewGitValue, getNewNpmAliasValue } from './common';\nimport { updatePnpmCatalogDependency } from './pnpm';\n\nfunction renameObjKey(\n  oldObj: DependenciesMeta,\n  oldKey: string,\n  newKey: string,\n): DependenciesMeta {\n  const keys = Object.keys(oldObj);\n  return keys.reduce((acc, key) => {\n    if (key === oldKey) {\n      acc[newKey] = oldObj[oldKey];\n    } else {\n      acc[key] = oldObj[key];\n    }\n    return acc;\n  }, {} as DependenciesMeta);\n}\n\nfunction replaceAsString(\n  parsedContents: NpmPackage,\n  fileContent: string,\n  depType:\n    | NpmDepType\n    | 'dependenciesMeta'\n    | 'packageManager'\n    | 'pnpm.overrides',\n  depName: string,\n  oldValue: string,\n  newValue: string,\n  parents?: string[],\n): string {\n  if (depType === 'packageManager') {\n    parsedContents[depType] = newValue;\n  } else if (depType === 'pnpm.overrides') {\n    parsedContents.pnpm!.overrides![depName] = newValue;\n  } else if (depName === oldValue) {\n    // The old value is the name of the dependency itself\n    delete Object.assign(parsedContents[depType]!, {\n      [newValue]: parsedContents[depType]![oldValue],\n    })[oldValue];\n  } else if (depType === 'dependenciesMeta') {\n    if (oldValue !== newValue) {\n      parsedContents.dependenciesMeta = renameObjKey(\n        // TODO #22198\n        parsedContents.dependenciesMeta!,\n        oldValue,\n        newValue,\n      );\n    }\n  } else if (parents && depType === 'overrides') {\n    // there is an object as a value in overrides block\n    const { depObjectReference, overrideDepName } = overrideDepPosition(\n      parsedContents[depType]!,\n      parents,\n      depName,\n    );\n    if (depObjectReference) {\n      depObjectReference[overrideDepName] = newValue;\n    }\n  } else {\n    // The old value is the version of the dependency\n    parsedContents[depType]![depName] = newValue;\n  }\n  // Look for the old version number\n  const searchString = `\"${oldValue}\"`;\n  let newString = `\"${newValue}\"`;\n\n  const escapedDepName = escapeRegExp(depName);\n  const patchRe = regEx(`^(patch:${escapedDepName}@(npm:)?).*#`);\n  const match = patchRe.exec(oldValue);\n  if (match && depType === 'resolutions') {\n    const patch = oldValue.replace(match[0], `${match[1]}${newValue}#`);\n    parsedContents[depType]![depName] = patch;\n    newString = `\"${patch}\"`;\n  }\n\n  // Skip ahead to depType section\n  let searchIndex = fileContent.indexOf(`\"${depType}\"`) + depType.length;\n  logger.trace(`Starting search at index ${searchIndex}`);\n  // Iterate through the rest of the file\n  for (; searchIndex < fileContent.length; searchIndex += 1) {\n    // First check if we have a hit for the old version\n    if (matchAt(fileContent, searchIndex, searchString)) {\n      logger.trace(`Found match at index ${searchIndex}`);\n      // Now test if the result matches\n      const testContent = replaceAt(\n        fileContent,\n        searchIndex,\n        searchString,\n        newString,\n      );\n      // Compare the parsed JSON structure of old and new\n      if (dequal(parsedContents, JSON.parse(testContent))) {\n        return testContent;\n      }\n    }\n  }\n  // istanbul ignore next\n  throw new Error();\n}\n\nexport function updateDependency({\n  fileContent,\n  upgrade,\n}: UpdateDependencyConfig): string | null {\n  if (upgrade.depType?.startsWith('pnpm.catalog')) {\n    return updatePnpmCatalogDependency({ fileContent, upgrade });\n  }\n\n  const { depType, managerData } = upgrade;\n  const depName: string = managerData?.key ?? upgrade.depName;\n  let { newValue } = upgrade;\n\n  newValue = getNewGitValue(upgrade) ?? newValue;\n  newValue = getNewNpmAliasValue(newValue, upgrade) ?? newValue;\n\n  logger.debug(`npm.updateDependency(): ${depType}.${depName} = ${newValue}`);\n  try {\n    const parsedContents: NpmPackage = JSON.parse(fileContent);\n    let overrideDepParents: string[] | undefined = undefined;\n    // Save the old version\n    let oldVersion: string | undefined;\n    if (depType === 'packageManager') {\n      oldVersion = parsedContents[depType];\n      newValue = `${depName}@${newValue}`;\n    } else if (isOverrideObject(upgrade)) {\n      overrideDepParents = managerData?.parents;\n      if (overrideDepParents) {\n        // old version when there is an object as a value in overrides block\n        const { depObjectReference, overrideDepName } = overrideDepPosition(\n          parsedContents.overrides!,\n          overrideDepParents,\n          depName,\n        );\n        if (depObjectReference) {\n          oldVersion = depObjectReference[overrideDepName]!;\n        }\n      }\n    } else if (depType === 'pnpm.overrides') {\n      oldVersion = parsedContents.pnpm?.overrides?.[depName];\n    } else {\n      oldVersion = parsedContents[depType as NpmDepType]![depName] as string;\n    }\n    if (oldVersion === newValue) {\n      logger.trace('Version is already updated');\n      return fileContent;\n    }\n\n    // TODO #22198\n    let newFileContent: string;\n    if (upgrade.newName && upgrade.replacementApproach === 'alias') {\n      newFileContent = replaceAsString(\n        parsedContents,\n        fileContent,\n        depType as NpmDepType,\n        depName,\n        oldVersion!,\n        `npm:${upgrade.newName}@${newValue}`,\n        overrideDepParents,\n      );\n    } else {\n      newFileContent = replaceAsString(\n        parsedContents,\n        fileContent,\n        depType as NpmDepType,\n        depName,\n        oldVersion!,\n        newValue!,\n        overrideDepParents,\n      );\n      if (upgrade.newName) {\n        newFileContent = replaceAsString(\n          parsedContents,\n          newFileContent,\n          depType as NpmDepType,\n          depName,\n          depName,\n          upgrade.newName,\n          overrideDepParents,\n        );\n      }\n    }\n    // istanbul ignore if\n    if (!newFileContent) {\n      logger.debug(\n        { fileContent, parsedContents, depType, depName, newValue },\n        'Warning: updateDependency error',\n      );\n      return fileContent;\n    }\n    if (parsedContents?.resolutions) {\n      let depKey: string | undefined;\n      if (parsedContents.resolutions[depName]) {\n        depKey = depName;\n      } else if (parsedContents.resolutions[`**/${depName}`]) {\n        depKey = `**/${depName}`;\n      }\n      if (depKey) {\n        // istanbul ignore if\n        if (parsedContents.resolutions[depKey] !== oldVersion) {\n          logger.debug(\n            {\n              depName,\n              depKey,\n              oldVersion,\n              resolutionsVersion: parsedContents.resolutions[depKey],\n            },\n            'Upgraded dependency exists in yarn resolutions but is different version',\n          );\n        }\n        newFileContent = replaceAsString(\n          parsedContents,\n          newFileContent,\n          'resolutions',\n          depKey,\n          // TODO #22198\n          parsedContents.resolutions[depKey]!,\n          // TODO #22198\n          newValue!,\n        );\n        if (upgrade.newName) {\n          if (depKey === `**/${depName}`) {\n            // handles the case where a replacement is in a resolution\n            upgrade.newName = `**/${upgrade.newName}`;\n          }\n          newFileContent = replaceAsString(\n            parsedContents,\n            newFileContent,\n            'resolutions',\n            depKey,\n            depKey,\n            upgrade.newName,\n          );\n        }\n      }\n    }\n    if (parsedContents?.dependenciesMeta) {\n      for (const [depKey] of Object.entries(parsedContents.dependenciesMeta)) {\n        if (depKey.startsWith(depName + '@')) {\n          newFileContent = replaceAsString(\n            parsedContents,\n            newFileContent,\n            'dependenciesMeta',\n            depName,\n            depKey,\n            // TODO: types (#22198)\n            `${depName}@${newValue}`,\n          );\n        }\n      }\n    }\n    return newFileContent;\n  } catch (err) {\n    logger.debug({ err }, 'updateDependency error');\n    return null;\n  }\n}\n\nfunction overrideDepPosition(\n  overrideBlock: OverrideDependency,\n  parents: string[],\n  depName: string,\n): {\n  depObjectReference: Record<string, string>;\n  overrideDepName: string;\n} {\n  // get override dep position when its nested in an object\n  const lastParent = parents[parents.length - 1];\n  let overrideDep: OverrideDependency = overrideBlock;\n  for (const parent of parents) {\n    if (overrideDep) {\n      overrideDep = overrideDep[parent] as Record<string, RecursiveOverride>;\n    }\n  }\n  const overrideDepName = depName === lastParent ? '.' : depName;\n  const depObjectReference = overrideDep as Record<string, string>;\n  return { depObjectReference, overrideDepName };\n}\n\nfunction isOverrideObject(upgrade: Upgrade<NpmManagerData>): boolean {\n  return (\n    is.array(upgrade.managerData?.parents, is.nonEmptyStringAndNotWhitespace) &&\n    upgrade.depType === 'overrides'\n  );\n}\n"]}