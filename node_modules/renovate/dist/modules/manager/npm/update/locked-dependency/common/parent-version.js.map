{"version":3,"file":"parent-version.js","sourceRoot":"","sources":["../../../../../../../lib/modules/manager/npm/update/locked-dependency/common/parent-version.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from '../../../../../../logger';\nimport type {\n  GetPkgReleasesConfig,\n  ReleaseResult,\n} from '../../../../../datasource';\nimport { getPkgReleases } from '../../../../../datasource';\nimport { api as semver } from '../../../../../versioning/npm';\n\nconst pkgCache = new Map<string, Promise<ReleaseResult | null>>();\n\nfunction getPkgReleasesCached(\n  packageName: string,\n): Promise<ReleaseResult | null> {\n  let cachedResult = pkgCache.get(packageName);\n  if (!cachedResult) {\n    const lookupConfig: GetPkgReleasesConfig = {\n      datasource: 'npm',\n      packageName,\n    };\n    cachedResult = getPkgReleases(lookupConfig);\n    pkgCache.set(packageName, cachedResult);\n  }\n  return cachedResult;\n}\n\n/**\n * Finds the first stable version of parentName after parentStartingVersion which either:\n * - depends on targetDepName@targetVersion or a range which it satisfies, OR\n * - removes the dependency targetDepName altogether, OR\n * - depends on any version of targetDepName higher than targetVersion\n */\nexport async function findFirstParentVersion(\n  parentName: string,\n  parentStartingVersion: string,\n  targetDepName: string,\n  targetVersion: string,\n): Promise<string | null> {\n  // istanbul ignore if\n  if (!semver.isVersion(parentStartingVersion)) {\n    logger.debug('parentStartingVersion is not a version - cannot remediate');\n    return null;\n  }\n  logger.debug(\n    `Finding first version of ${parentName} starting with ${parentStartingVersion} which supports >= ${targetDepName}@${targetVersion}`,\n  );\n  try {\n    const targetDep = await getPkgReleasesCached(targetDepName);\n    // istanbul ignore if\n    if (!targetDep) {\n      logger.info(\n        { targetDepName },\n        'Could not look up target dependency for remediation',\n      );\n      return null;\n    }\n    const targetVersions = targetDep.releases\n      .map((release) => release.version)\n      .filter(\n        (version) =>\n          semver.isVersion(version) &&\n          semver.isStable(version) &&\n          (version === targetVersion ||\n            semver.isGreaterThan(version, targetVersion)),\n      );\n    const parentDep = await getPkgReleasesCached(parentName);\n    // istanbul ignore if\n    if (!parentDep) {\n      logger.info(\n        { parentName },\n        'Could not look up parent dependency for remediation',\n      );\n      return null;\n    }\n    const parentVersions = parentDep.releases\n      .map((release) => release.version)\n      .filter(\n        (version) =>\n          semver.isVersion(version) &&\n          semver.isStable(version) &&\n          (version === parentStartingVersion ||\n            semver.isGreaterThan(version, parentStartingVersion)),\n      )\n      .sort((v1, v2) => semver.sortVersions(v1, v2));\n    // iterate through parentVersions in sorted order\n    for (const parentVersion of parentVersions) {\n      const constraint = parentDep.releases.find(\n        (release) => release.version === parentVersion,\n      )?.dependencies?.[targetDepName];\n      if (!constraint) {\n        logger.debug(\n          `${targetDepName} has been removed from ${parentName}@${parentVersion}`,\n        );\n        return parentVersion;\n      }\n      if (semver.matches(targetVersion, constraint)) {\n        // could be version or range\n        logger.debug(\n          `${targetDepName} needs ${parentName}@${parentVersion} which uses constraint \"${constraint}\" in order to update to ${targetVersion}`,\n        );\n        return parentVersion;\n      }\n      if (semver.isVersion(constraint)) {\n        if (semver.isGreaterThan(constraint, targetVersion)) {\n          // it's not the version we were after - the parent skipped to a higher version\n          logger.debug(\n            `${targetDepName} needs ${parentName}@${parentVersion} which uses version \"${constraint}\" in order to update to greater than ${targetVersion}`,\n          );\n          return parentVersion;\n        }\n      } else if (\n        // check the range against all versions\n        targetVersions.some((version) => semver.matches(version, constraint))\n      ) {\n        // the constraint didn't match the version we wanted, but it matches one of the versions higher\n        logger.debug(\n          `${targetDepName} needs ${parentName}@${parentVersion} which uses constraint \"${constraint}\" in order to update to greater than ${targetVersion}`,\n        );\n        return parentVersion;\n      }\n    }\n  } catch (err) /* istanbul ignore next */ {\n    logger.warn(\n      { parentName, parentStartingVersion, targetDepName, targetVersion, err },\n      'findFirstParentVersion error',\n    );\n    return null;\n  }\n  logger.debug(`Could not find a matching version`);\n  return null;\n}\n"]}