{"version":3,"file":"pnpm.js","sourceRoot":"","sources":["../../../../../lib/modules/manager/npm/extract/pnpm.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { findPackages } from 'find-packages';\nimport upath from 'upath';\nimport type { z } from 'zod';\nimport { GlobalConfig } from '../../../../config/global';\nimport { logger } from '../../../../logger';\nimport {\n  findLocalSiblingOrParent,\n  getSiblingFileName,\n  localPathExists,\n  readLocalFile,\n} from '../../../../util/fs';\nimport { parseSingleYaml } from '../../../../util/yaml';\nimport type {\n  PackageDependency,\n  PackageFile,\n  PackageFileContent,\n} from '../../types';\nimport type { PnpmDependencySchema, PnpmLockFile } from '../post-update/types';\nimport type { PnpmCatalogsSchema } from '../schema';\nimport { PnpmWorkspaceFileSchema } from '../schema';\nimport type { NpmManagerData } from '../types';\nimport { extractDependency, parseDepName } from './common/dependency';\nimport type { LockFile, PnpmCatalog, PnpmWorkspaceFile } from './types';\n\nfunction isPnpmLockfile(obj: any): obj is PnpmLockFile {\n  return is.plainObject(obj) && 'lockfileVersion' in obj;\n}\n\nexport async function extractPnpmFilters(\n  fileName: string,\n): Promise<string[] | undefined> {\n  try {\n    // TODO: use schema (#9610,#22198)\n    const contents = parseSingleYaml<PnpmWorkspaceFile>(\n      (await readLocalFile(fileName, 'utf8'))!,\n    );\n    if (\n      !Array.isArray(contents.packages) ||\n      !contents.packages.every((item) => is.string(item))\n    ) {\n      logger.trace(\n        { fileName },\n        'Failed to find required \"packages\" array in pnpm-workspace.yaml',\n      );\n      return undefined;\n    }\n    return contents.packages;\n  } catch (err) {\n    logger.trace({ fileName, err }, 'Failed to parse pnpm-workspace.yaml');\n    return undefined;\n  }\n}\n\nexport async function findPnpmWorkspace(\n  packageFile: string,\n): Promise<{ lockFilePath: string; workspaceYamlPath: string } | null> {\n  // search for pnpm-workspace.yaml\n  const workspaceYamlPath = await findLocalSiblingOrParent(\n    packageFile,\n    'pnpm-workspace.yaml',\n  );\n  if (!workspaceYamlPath) {\n    logger.trace(\n      { packageFile },\n      'Failed to locate pnpm-workspace.yaml in a parent directory.',\n    );\n    return null;\n  }\n\n  // search for pnpm-lock.yaml next to pnpm-workspace.yaml\n  const pnpmLockfilePath = getSiblingFileName(\n    workspaceYamlPath,\n    'pnpm-lock.yaml',\n  );\n  if (!(await localPathExists(pnpmLockfilePath))) {\n    logger.trace(\n      { workspaceYamlPath, packageFile },\n      'Failed to find a pnpm-lock.yaml sibling for the workspace.',\n    );\n    return null;\n  }\n\n  return {\n    lockFilePath: pnpmLockfilePath,\n    workspaceYamlPath,\n  };\n}\n\nexport async function detectPnpmWorkspaces(\n  packageFiles: Partial<PackageFile<NpmManagerData>>[],\n): Promise<void> {\n  logger.debug(`Detecting pnpm Workspaces`);\n  const packagePathCache = new Map<string, string[] | null>();\n\n  for (const p of packageFiles) {\n    const { packageFile, managerData } = p;\n    const pnpmShrinkwrap = managerData?.pnpmShrinkwrap;\n\n    // check if pnpmShrinkwrap-file has already been provided\n    if (pnpmShrinkwrap) {\n      logger.trace(\n        { packageFile, pnpmShrinkwrap },\n        'Found an existing pnpm shrinkwrap file; skipping pnpm monorepo check.',\n      );\n      continue;\n    }\n\n    // search for corresponding pnpm workspace\n    // TODO #22198\n    const pnpmWorkspace = await findPnpmWorkspace(packageFile!);\n    if (pnpmWorkspace === null) {\n      continue;\n    }\n    const { workspaceYamlPath, lockFilePath } = pnpmWorkspace;\n\n    // check if package matches workspace filter\n    if (!packagePathCache.has(workspaceYamlPath)) {\n      const filters = await extractPnpmFilters(workspaceYamlPath);\n      const localDir = GlobalConfig.get('localDir');\n      const packages = await findPackages(\n        upath.dirname(upath.join(localDir, workspaceYamlPath)),\n        {\n          patterns: filters,\n          // Match the ignores used in @pnpm/find-workspace-packages\n          ignore: ['**/node_modules/**', '**/bower_components/**'],\n        },\n      );\n      const packagePaths = packages.map((pkg) =>\n        upath.join(pkg.dir, 'package.json'),\n      );\n      packagePathCache.set(workspaceYamlPath, packagePaths);\n    }\n    const packagePaths = packagePathCache.get(workspaceYamlPath);\n\n    const isPackageInWorkspace = packagePaths?.some((p) =>\n      p.endsWith(packageFile!),\n    );\n\n    if (isPackageInWorkspace) {\n      p.managerData ??= {};\n      p.managerData.pnpmShrinkwrap = lockFilePath;\n    } else {\n      logger.trace(\n        { packageFile, workspaceYamlPath },\n        `Didn't find the package in the pnpm workspace`,\n      );\n    }\n  }\n}\n\nexport async function getPnpmLock(filePath: string): Promise<LockFile> {\n  try {\n    const pnpmLockRaw = await readLocalFile(filePath, 'utf8');\n    if (!pnpmLockRaw) {\n      throw new Error('Unable to read pnpm-lock.yaml');\n    }\n\n    const lockParsed = parseSingleYaml(pnpmLockRaw);\n    if (!isPnpmLockfile(lockParsed)) {\n      throw new Error('Invalid or empty lockfile');\n    }\n    logger.trace({ lockParsed }, 'pnpm lockfile parsed');\n\n    // field lockfileVersion is type string in lockfileVersion = 6 and type number in < 6\n    const lockfileVersion: number = is.number(lockParsed.lockfileVersion)\n      ? lockParsed.lockfileVersion\n      : parseFloat(lockParsed.lockfileVersion);\n\n    const lockedVersions = getLockedVersions(lockParsed);\n    const lockedCatalogVersions = getLockedCatalogVersions(lockParsed);\n\n    return {\n      lockedVersionsWithPath: lockedVersions,\n      lockedVersionsWithCatalog: lockedCatalogVersions,\n      lockfileVersion,\n    };\n  } catch (err) {\n    logger.debug({ filePath, err }, 'Warning: Exception parsing pnpm lockfile');\n    return { lockedVersions: {} };\n  }\n}\n\nfunction getLockedCatalogVersions(\n  lockParsed: PnpmLockFile,\n): Record<string, Record<string, string>> {\n  const lockedVersions: Record<string, Record<string, string>> = {};\n\n  if (is.nonEmptyObject(lockParsed.catalogs)) {\n    for (const [catalog, dependencies] of Object.entries(lockParsed.catalogs)) {\n      const versions: Record<string, string> = {};\n\n      for (const [dep, versionCarrier] of Object.entries(dependencies)) {\n        versions[dep] = versionCarrier.version;\n      }\n\n      lockedVersions[catalog] = versions;\n    }\n  }\n\n  return lockedVersions;\n}\n\nfunction getLockedVersions(\n  lockParsed: PnpmLockFile,\n): Record<string, Record<string, Record<string, string>>> {\n  const lockedVersions: Record<\n    string,\n    Record<string, Record<string, string>>\n  > = {};\n\n  // monorepo\n  if (is.nonEmptyObject(lockParsed.importers)) {\n    for (const [importer, imports] of Object.entries(lockParsed.importers)) {\n      lockedVersions[importer] = getLockedDependencyVersions(imports);\n    }\n  }\n  // normal repo\n  else {\n    lockedVersions['.'] = getLockedDependencyVersions(lockParsed);\n  }\n\n  return lockedVersions;\n}\n\nfunction getLockedDependencyVersions(\n  obj: PnpmLockFile | Record<string, PnpmDependencySchema>,\n): Record<string, Record<string, string>> {\n  const dependencyTypes = [\n    'dependencies',\n    'devDependencies',\n    'optionalDependencies',\n  ] as const;\n\n  const res: Record<string, Record<string, string>> = {};\n  for (const depType of dependencyTypes) {\n    res[depType] = {};\n    for (const [pkgName, versionCarrier] of Object.entries(\n      obj[depType] ?? {},\n    )) {\n      let version: string;\n      if (is.object(versionCarrier)) {\n        version = versionCarrier.version;\n      } else {\n        version = versionCarrier;\n      }\n\n      const pkgVersion = version.split('(')[0].trim();\n      res[depType][pkgName] = pkgVersion;\n    }\n  }\n\n  return res;\n}\n\nexport function tryParsePnpmWorkspaceYaml(content: string):\n  | {\n      success: true;\n      data: PnpmWorkspaceFile;\n    }\n  | { success: false; data?: never } {\n  try {\n    const data = parseSingleYaml(content, {\n      customSchema: PnpmWorkspaceFileSchema,\n    });\n    return { success: true, data };\n  } catch {\n    return { success: false };\n  }\n}\n\ntype PnpmCatalogs = z.TypeOf<typeof PnpmCatalogsSchema>;\n\nexport async function extractPnpmWorkspaceFile(\n  catalogs: PnpmCatalogs,\n  packageFile: string,\n): Promise<PackageFileContent<NpmManagerData> | null> {\n  logger.trace(`pnpm.extractPnpmWorkspaceFile(${packageFile})`);\n\n  const pnpmCatalogs = pnpmCatalogsToArray(catalogs);\n\n  const deps = extractPnpmCatalogDeps(pnpmCatalogs);\n\n  let pnpmShrinkwrap;\n  const filePath = getSiblingFileName(packageFile, 'pnpm-lock.yaml');\n\n  if (await readLocalFile(filePath, 'utf8')) {\n    pnpmShrinkwrap = filePath;\n  }\n\n  return {\n    deps,\n    managerData: {\n      pnpmShrinkwrap,\n    },\n  };\n}\n\n/**\n * In order to facilitate matching on specific catalogs, we structure the\n * depType as `pnpm.catalog.default`, `pnpm.catalog.react17`, and so on.\n */\nfunction getCatalogDepType(name: string): string {\n  const CATALOG_DEPENDENCY = 'pnpm.catalog';\n  return `${CATALOG_DEPENDENCY}.${name}`;\n}\n\nfunction extractPnpmCatalogDeps(\n  catalogs: PnpmCatalog[],\n): PackageDependency<NpmManagerData>[] {\n  const deps: PackageDependency<NpmManagerData>[] = [];\n\n  for (const catalog of catalogs) {\n    for (const [key, val] of Object.entries(catalog.dependencies)) {\n      const depType = getCatalogDepType(catalog.name);\n      const depName = parseDepName(depType, key);\n      const dep: PackageDependency<NpmManagerData> = {\n        depType,\n        depName,\n        ...extractDependency(depType, depName, val!),\n        prettyDepType: depType,\n      };\n      deps.push(dep);\n    }\n  }\n\n  return deps;\n}\n\nfunction pnpmCatalogsToArray({\n  catalog: defaultCatalogDeps,\n  catalogs: namedCatalogs,\n}: PnpmCatalogs): PnpmCatalog[] {\n  const result: PnpmCatalog[] = [];\n\n  if (defaultCatalogDeps !== undefined) {\n    result.push({ name: 'default', dependencies: defaultCatalogDeps });\n  }\n\n  if (!namedCatalogs) {\n    return result;\n  }\n\n  for (const [name, dependencies] of Object.entries(namedCatalogs)) {\n    result.push({\n      name,\n      dependencies,\n    });\n  }\n\n  return result;\n}\n"]}