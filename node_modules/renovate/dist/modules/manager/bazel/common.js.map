{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../../lib/modules/manager/bazel/common.ts"],"names":[],"mappings":";;AAIA,4CA0BC;AAED,kDAWC;AAED,oDAaC;AAED,gCAWC;;AAvED,kEAAkC;AAClC,qCAAiC;AAGjC,SAAgB,gBAAgB,CAC9B,KAAa,EACb,IAAkB;IAElB,MAAM,MAAM,GAAG,IAAA,cAAK,EAAC,KAAK,CAAC,CAAC;IAC5B,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,CAAC,SAAS,EAAE,GAAG,QAAQ,CAAC,GAAG,IAAI,CAAC;IACtC,IAAI,QAAQ,GAAyB,MAAM,CAAC,SAAS,CAAC,CAAC;IACvD,KAAK,MAAM,GAAG,IAAI,QAAQ,EAAE,CAAC;QAC3B,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,MAAM;QACR,CAAC;QAED,IAAI,QAAQ,CAAC,IAAI,KAAK,OAAO,IAAI,YAAE,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC;YAChD,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QACpC,CAAC;QAED,IAAI,QAAQ,CAAC,IAAI,KAAK,QAAQ,IAAI,YAAE,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC;YACjD,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QACpC,CAAC;IACH,CAAC;IAED,OAAO,QAAQ,IAAI,IAAI,CAAC;AAC1B,CAAC;AAED,SAAgB,mBAAmB,CACjC,KAAa,EACb,QAAkB,EAClB,OAAwB;IAExB,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC;IACnC,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;IACpC,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;IACjD,OAAO,YAAE,CAAC,MAAM,CAAC,OAAO,CAAC;QACvB,CAAC,CAAC,GAAG,IAAI,GAAG,OAAO,GAAG,KAAK,EAAE;QAC7B,CAAC,CAAC,GAAG,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,KAAK,EAAE,CAAC;AACzC,CAAC;AAED,SAAgB,oBAAoB,CAClC,KAAa,EACb,SAAqB,EACrB,OAAwB;IAExB,MAAM,eAAe,GAAG,SAAS,CAAC,IAAI,CACpC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CACxC,CAAC;IACF,IAAI,MAAM,GAAG,KAAK,CAAC;IACnB,KAAK,MAAM,QAAQ,IAAI,eAAe,EAAE,CAAC;QACvC,MAAM,GAAG,mBAAmB,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC1D,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAgB,UAAU,CACxB,KAAa,EACb,IAAkB,EAClB,OAAwB;IAExB,MAAM,QAAQ,GAAG,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IAC/C,IAAI,CAAC,QAAQ,EAAE,CAAC;QACd,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO,mBAAmB,CAAC,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AACvD,CAAC","sourcesContent":["import is from '@sindresorhus/is';\nimport { parse } from './parser';\nimport type { Fragment, FragmentPath, FragmentUpdater } from './types';\n\nexport function findCodeFragment(\n  input: string,\n  path: FragmentPath,\n): Fragment | null {\n  const parsed = parse(input);\n  if (!parsed) {\n    return null;\n  }\n\n  const [ruleIndex, ...restPath] = path;\n  let fragment: Fragment | undefined = parsed[ruleIndex];\n  for (const key of restPath) {\n    if (!fragment) {\n      break;\n    }\n\n    if (fragment.type === 'array' && is.number(key)) {\n      fragment = fragment.children[key];\n    }\n\n    if (fragment.type === 'record' && is.string(key)) {\n      fragment = fragment.children[key];\n    }\n  }\n\n  return fragment ?? null;\n}\n\nexport function patchCodeAtFragment(\n  input: string,\n  fragment: Fragment,\n  updater: FragmentUpdater,\n): string {\n  const { value, offset } = fragment;\n  const left = input.slice(0, offset);\n  const right = input.slice(offset + value.length);\n  return is.string(updater)\n    ? `${left}${updater}${right}`\n    : `${left}${updater(value)}${right}`;\n}\n\nexport function patchCodeAtFragments(\n  input: string,\n  fragments: Fragment[],\n  updater: FragmentUpdater,\n): string {\n  const sortedFragments = fragments.sort(\n    ({ offset: a }, { offset: b }) => b - a,\n  );\n  let result = input;\n  for (const fragment of sortedFragments) {\n    result = patchCodeAtFragment(result, fragment, updater);\n  }\n  return result;\n}\n\nexport function updateCode(\n  input: string,\n  path: FragmentPath,\n  updater: FragmentUpdater,\n): string {\n  const fragment = findCodeFragment(input, path);\n  if (!fragment) {\n    return input;\n  }\n\n  return patchCodeAtFragment(input, fragment, updater);\n}\n"]}