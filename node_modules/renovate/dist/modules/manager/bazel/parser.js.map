{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../../../lib/modules/manager/bazel/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import type { lexer, parser } from 'good-enough-parser';\nimport { lang, query as q } from 'good-enough-parser';\nimport { logger } from '../../../logger';\nimport * as memCache from '../../../util/cache/memory';\nimport { hash } from '../../../util/hash';\nimport { supportedRulesRegex } from './rules';\nimport type { NestedFragment, RecordFragment } from './types';\n\ninterface Ctx {\n  readonly source: string;\n  results: RecordFragment[];\n  stack: NestedFragment[];\n  recordKey?: string;\n  subRecordKey?: string;\n  argIndex?: number;\n}\n\nfunction emptyCtx(source: string): Ctx {\n  return {\n    source,\n    results: [],\n    stack: [],\n  };\n}\n\nfunction currentFragment(ctx: Ctx): NestedFragment {\n  const deepestFragment = ctx.stack[ctx.stack.length - 1];\n  return deepestFragment;\n}\n\nfunction extractTreeValue(\n  source: string,\n  tree: parser.Tree,\n  offset: number,\n): string {\n  if (tree.type === 'wrapped-tree') {\n    const { endsWith } = tree;\n    const to = endsWith.offset + endsWith.value.length;\n    return source.slice(offset, to);\n  }\n\n  // istanbul ignore next\n  return '';\n}\n\n/**\n * Matches key-value pairs:\n * - `tag = \"1.2.3\"`\n * - `name = \"foobar\"`\n * - `deps = [\"foo\", \"bar\"]`\n * - `\n *     artifacts = [\n         maven.artifact(\n           group = \"com.example1\",\n           artifact = \"foobar\",\n           version = \"1.2.3\",\n         )\n       ]\n     `\n **/\nconst kwParams = q\n  .sym<Ctx>((ctx, { value: recordKey }) => {\n    return { ...ctx, recordKey };\n  })\n  .op('=')\n  .alt(\n    // string\n    q.str((ctx, { offset, value }) => {\n      const frag = currentFragment(ctx);\n      if (frag.type === 'record' && ctx.recordKey) {\n        const key = ctx.recordKey;\n        frag.children[key] = { type: 'string', value, offset };\n      }\n      return ctx;\n    }),\n    // array of strings or calls\n    q.tree({\n      type: 'wrapped-tree',\n      maxDepth: 1,\n      startsWith: '[',\n      endsWith: ']',\n      preHandler: (ctx, tree) => {\n        const parentRecord = currentFragment(ctx) as RecordFragment;\n        if (\n          parentRecord.type === 'record' &&\n          ctx.recordKey &&\n          tree.type === 'wrapped-tree'\n        ) {\n          const key = ctx.recordKey;\n          parentRecord.children[key] = {\n            type: 'array',\n            value: '',\n            offset: tree.startsWith.offset,\n            children: [],\n          };\n        }\n        return ctx;\n      },\n      search: q.alt(\n        q.str<Ctx>((ctx, { value, offset }) => {\n          const parentRecord = currentFragment(ctx);\n          if (parentRecord.type === 'record' && ctx.recordKey) {\n            const key = ctx.recordKey;\n            const array = parentRecord.children[key];\n            if (array.type === 'array') {\n              array.children.push({ type: 'string', value, offset });\n            }\n          }\n          return ctx;\n        }),\n        q\n          .sym<Ctx>()\n          .handler(recordStartHandler)\n          .handler((ctx, { value, offset }) => {\n            const ruleFragment = currentFragment(ctx);\n            if (ruleFragment.type === 'record') {\n              ruleFragment.children._function = {\n                type: 'string',\n                value,\n                offset,\n              };\n            }\n            return ctx;\n          })\n          .many(\n            q.op<Ctx>('.').sym((ctx, { value }) => {\n              const ruleFragment = currentFragment(ctx);\n              if (\n                ruleFragment.type === 'record' &&\n                ruleFragment.children._function\n              ) {\n                ruleFragment.children._function.value += `.${value}`;\n              }\n              return ctx;\n            }),\n            0,\n            3,\n          )\n          .tree({\n            type: 'wrapped-tree',\n            maxDepth: 1,\n            startsWith: '(',\n            endsWith: ')',\n            search: q\n              .opt(\n                q\n                  .sym<Ctx>((ctx, { value: subRecordKey }) => ({\n                    ...ctx,\n                    subRecordKey,\n                  }))\n                  .op('='),\n              )\n              .str((ctx, { value: subRecordValue, offset }) => {\n                const argIndex = ctx.argIndex ?? 0;\n\n                const subRecordKey = ctx.subRecordKey! ?? argIndex.toString();\n                const ruleFragment = currentFragment(ctx);\n                if (ruleFragment.type === 'record') {\n                  ruleFragment.children[subRecordKey] = {\n                    type: 'string',\n                    value: subRecordValue,\n                    offset,\n                  };\n                }\n                delete ctx.subRecordKey;\n                ctx.argIndex = argIndex + 1;\n                return ctx;\n              }),\n            postHandler: (ctx, tree) => {\n              delete ctx.argIndex;\n\n              const callFrag = currentFragment(ctx);\n              ctx.stack.pop();\n              if (callFrag.type === 'record' && tree.type === 'wrapped-tree') {\n                callFrag.value = extractTreeValue(\n                  ctx.source,\n                  tree,\n                  callFrag.offset,\n                );\n\n                const parentRecord = currentFragment(ctx);\n                if (parentRecord.type === 'record' && ctx.recordKey) {\n                  const key = ctx.recordKey;\n                  const array = parentRecord.children[key];\n                  if (array.type === 'array') {\n                    array.children.push(callFrag);\n                  }\n                }\n              }\n              return ctx;\n            },\n          }),\n      ),\n      postHandler: (ctx, tree) => {\n        const parentRecord = currentFragment(ctx);\n        if (\n          parentRecord.type === 'record' &&\n          ctx.recordKey &&\n          tree.type === 'wrapped-tree'\n        ) {\n          const key = ctx.recordKey;\n          const array = parentRecord.children[key];\n          if (array.type === 'array') {\n            array.value = extractTreeValue(ctx.source, tree, array.offset);\n          }\n        }\n        return ctx;\n      },\n    }),\n  )\n  .handler((ctx) => {\n    delete ctx.recordKey;\n    return ctx;\n  });\n\n/**\n * Matches rule signature:\n *   `git_repository(......)`\n *                  ^^^^^^^^\n *\n * @param search something to match inside parens\n */\nfunction ruleCall(\n  search: q.QueryBuilder<Ctx, parser.Node>,\n): q.QueryBuilder<Ctx, parser.Node> {\n  return q.tree({\n    type: 'wrapped-tree',\n    maxDepth: 1,\n    search,\n    postHandler: (ctx, tree) => {\n      const frag = currentFragment(ctx);\n      if (frag.type === 'record' && tree.type === 'wrapped-tree') {\n        frag.value = extractTreeValue(ctx.source, tree, frag.offset);\n        ctx.stack.pop();\n        ctx.results.push(frag);\n      }\n\n      return ctx;\n    },\n  });\n}\n\nfunction recordStartHandler(ctx: Ctx, { offset }: lexer.Token): Ctx {\n  ctx.stack.push({\n    type: 'record',\n    value: '',\n    offset,\n    children: {},\n  });\n  return ctx;\n}\n\nfunction ruleNameHandler(ctx: Ctx, { value, offset }: lexer.Token): Ctx {\n  const ruleFragment = currentFragment(ctx);\n  if (ruleFragment.type === 'record') {\n    ruleFragment.children.rule = { type: 'string', value, offset };\n  }\n\n  return ctx;\n}\n\n/**\n * Matches regular rules:\n * - `git_repository(...)`\n * - `_go_repository(...)`\n */\nconst regularRule = q\n  .sym<Ctx>(supportedRulesRegex, (ctx, token) =>\n    ruleNameHandler(recordStartHandler(ctx, token), token),\n  )\n  .join(ruleCall(kwParams));\n\n/**\n * Matches \"maybe\"-form rules:\n * - `maybe(git_repository, ...)`\n * - `maybe(_go_repository, ...)`\n */\nconst maybeRule = q\n  .sym<Ctx>('maybe', recordStartHandler)\n  .join(\n    ruleCall(\n      q.alt(\n        q.begin<Ctx>().sym(supportedRulesRegex, ruleNameHandler).op(','),\n        kwParams,\n      ),\n    ),\n  );\n\nconst rule = q.alt<Ctx>(maybeRule, regularRule);\n\nconst query = q.tree<Ctx>({\n  type: 'root-tree',\n  maxDepth: 16,\n  search: rule,\n});\n\nfunction getCacheKey(input: string): string {\n  const hashedInput = hash(input);\n  return `bazel-parser-${hashedInput}`;\n}\n\nconst starlark = lang.createLang('starlark');\n\nexport function parse(\n  input: string,\n  packageFile?: string,\n): RecordFragment[] | null {\n  const cacheKey = getCacheKey(input);\n\n  const cachedResult = memCache.get<RecordFragment[] | null>(cacheKey);\n  // istanbul ignore if\n  if (cachedResult === null || cachedResult) {\n    return cachedResult;\n  }\n\n  let result: RecordFragment[] | null = null;\n  try {\n    const parsedResult = starlark.query(input, query, emptyCtx(input));\n    if (parsedResult) {\n      result = parsedResult.results;\n    }\n  } catch (err) /* istanbul ignore next */ {\n    logger.debug({ err, packageFile }, 'Bazel parsing error');\n  }\n\n  memCache.set(cacheKey, result);\n  return result;\n}\n"]}