{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../lib/modules/manager/bazel/types.ts"],"names":[],"mappings":"","sourcesContent":["export interface BazelManagerData {\n  idx: number;\n}\n\nexport type TargetAttribute = string | string[];\n\nexport interface Target extends Record<string, TargetAttribute> {\n  rule: string;\n  name: string;\n}\n\ninterface FragmentBase {\n  value: string;\n  offset: number;\n}\n\nexport interface ArrayFragment extends FragmentBase {\n  type: 'array';\n  children: Fragment[];\n}\n\nexport interface RecordFragment extends FragmentBase {\n  type: 'record';\n  children: Record<string, Fragment>;\n}\n\nexport interface StringFragment extends FragmentBase {\n  type: 'string';\n}\n\nexport type NestedFragment = ArrayFragment | RecordFragment;\nexport type Fragment = NestedFragment | StringFragment;\n\n/**\n * Parsed bazel files are represented as nested arrays and objects,\n * which is enough for Renovate purposes.\n */\nexport type FragmentData =\n  | string\n  | FragmentData[]\n  | { [k: string]: FragmentData };\n\n/**\n * To access a fragment, we provide its path in the tree.\n *\n * The first element is the index of the rule in the file,\n * which had been chosen over the rule name because it helps\n * to deal with duplicate rule names in `if-else` branches.\n */\nexport type FragmentPath =\n  | [number]\n  | [number, string]\n  | [number, string, number]\n  | [number, string, number, string];\n\nexport type FragmentUpdater = string | ((_: string) => string);\n"]}