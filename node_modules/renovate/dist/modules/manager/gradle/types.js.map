{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../lib/modules/manager/gradle/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { lexer } from 'good-enough-parser';\nimport type { PackageDependency } from '../types';\n\nexport interface GradleManagerData {\n  fileReplacePosition?: number;\n  packageFile?: string;\n}\n\nexport interface VariableData extends GradleManagerData {\n  key: string;\n  value: string;\n}\n\nexport type PackageVariables = Record<string, VariableData>;\nexport type VariableRegistry = Record<string, PackageVariables>;\n\nexport interface ParseGradleResult {\n  deps: PackageDependency<GradleManagerData>[];\n  urls: PackageRegistry[];\n  vars: PackageVariables;\n  javaLanguageVersion?: string;\n}\n\nexport interface GradleCatalog {\n  versions?: Record<string, GradleVersionPointerTarget>;\n  libraries?: Record<\n    string,\n    GradleCatalogModuleDescriptor | GradleCatalogArtifactDescriptor | string\n  >;\n  plugins?: Record<string, GradleCatalogPluginDescriptor | string>;\n}\n\nexport interface GradleCatalogModuleDescriptor {\n  module: string;\n  version?: GradleVersionCatalogVersion;\n}\n\nexport interface GradleCatalogArtifactDescriptor {\n  name: string;\n  group: string;\n  version?: GradleVersionCatalogVersion;\n}\n\nexport interface GradleCatalogPluginDescriptor {\n  id: string;\n  version: GradleVersionCatalogVersion;\n}\n\nexport interface VersionPointer {\n  ref: string;\n}\n\n/**\n * Rich version declarations in Gradle version catalogs\n *\n * @see https://docs.gradle.org/current/userguide/rich_versions.html\n * @see https://docs.gradle.org/current/userguide/platforms.html#sub::toml-dependencies-format\n */\nexport interface RichVersion {\n  require?: string;\n  strictly?: string;\n  prefer?: string;\n  reject?: string[];\n  rejectAll?: boolean;\n}\n\n// references cannot themselves be references\nexport type GradleVersionPointerTarget = string | RichVersion;\nexport type GradleVersionCatalogVersion = string | VersionPointer | RichVersion;\n\nexport type ContentDescriptorMatcher = 'simple' | 'regex' | 'subgroup';\n\nexport interface ContentDescriptorSpec {\n  mode: 'include' | 'exclude';\n  matcher: ContentDescriptorMatcher;\n  groupId: string;\n  artifactId?: string;\n  version?: string;\n}\n\nexport interface PackageRegistry {\n  registryUrl: string;\n  registryType: 'regular' | 'exclusive';\n  scope: 'dep' | 'plugin';\n  content?: ContentDescriptorSpec[];\n}\n\nexport interface Ctx {\n  readonly packageFile: string;\n  readonly fileContents: Record<string, string | null>;\n  recursionDepth: number;\n\n  globalVars: PackageVariables;\n  deps: PackageDependency<GradleManagerData>[];\n  registryUrls: PackageRegistry[];\n  javaLanguageVersion?: string;\n\n  varTokens: lexer.Token[];\n  tmpKotlinImportStore: lexer.Token[][];\n  tmpNestingDepth: lexer.Token[];\n  tmpRegistryContent: ContentDescriptorSpec[];\n  tmpTokenStore: Record<string, lexer.Token[]>;\n  tokenMap: Record<string, lexer.Token[]>;\n}\n\nexport type NonEmptyArray<T> = T[] & { 0: T };\n"]}