{"version":3,"file":"generic-docker-image-ref.js","sourceRoot":"","sources":["../../../../../../lib/modules/manager/terraform/extractors/resources/generic-docker-image-ref.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { getDep } from '../../../dockerfile/extract';\nimport type { ExtractConfig, PackageDependency } from '../../../types';\nimport { DependencyExtractor } from '../../base';\nimport type { TerraformDefinitionFile } from '../../hcl/types';\nimport type { ProviderLock } from '../../lockfile/types';\nimport { generic_image_resource } from './utils';\n\nexport class GenericDockerImageRefExtractor extends DependencyExtractor {\n  getCheckList(): string[] {\n    return generic_image_resource.map((value) => `\"${value.type}\"`);\n  }\n\n  extract(\n    hclMap: TerraformDefinitionFile,\n    _locks: ProviderLock[],\n    config: ExtractConfig,\n  ): PackageDependency[] {\n    const resourceTypMap = hclMap.resource;\n    if (is.nullOrUndefined(resourceTypMap)) {\n      return [];\n    }\n\n    const dependencies = [];\n\n    for (const image_resource_def of generic_image_resource) {\n      const { type, path } = image_resource_def;\n      const resourceInstancesMap = resourceTypMap[type];\n      // is there a resource with current looked at type ( `image_resource_def` )\n      if (!is.nonEmptyObject(resourceInstancesMap)) {\n        continue;\n      }\n\n      // loop over instances of a resource type\n      for (const instance of Object.values(resourceInstancesMap).flat()) {\n        dependencies.push(\n          ...this.walkPath({ depType: type }, instance, path, config),\n        );\n      }\n    }\n    return dependencies;\n  }\n\n  /**\n   * Recursively follow the path to find elements on the path.\n   * If a path element is '*' the parentElement will be interpreted as a list\n   * and each element will be followed\n   * @param abstractDep dependency which will used as basis for adding attributes\n   * @param parentElement element from which the next element will be extracted\n   * @param leftPath path elements left to walk down\n   */\n  private walkPath(\n    abstractDep: PackageDependency,\n    parentElement: unknown,\n    leftPath: string[],\n    config: ExtractConfig,\n  ): PackageDependency[] {\n    const dependencies: PackageDependency[] = [];\n    // if there are no path elements left, we have reached the end of the path\n    if (leftPath.length === 0) {\n      // istanbul ignore if\n      if (!is.nonEmptyString(parentElement)) {\n        return [\n          {\n            ...abstractDep,\n            skipReason: 'invalid-dependency-specification',\n          },\n        ];\n      }\n      const test = getDep(parentElement, true, config.registryAliases);\n      const dep: PackageDependency = {\n        ...abstractDep,\n        ...test,\n      };\n      return [dep];\n    }\n\n    // is this a list iterator\n    const pathElement = leftPath[0];\n\n    // get sub element\n    const element = is.nonEmptyObject(parentElement)\n      ? parentElement[pathElement]\n      : null;\n    if (is.nullOrUndefined(element)) {\n      return leftPath.length === 1 // if this is the last element assume a false defined dependency\n        ? [\n            {\n              ...abstractDep,\n              skipReason: 'invalid-dependency-specification',\n            },\n          ]\n        : [];\n    }\n    if (is.array(element)) {\n      for (const arrayElement of element) {\n        dependencies.push(\n          ...this.walkPath(\n            abstractDep,\n            arrayElement,\n            leftPath.slice(1),\n            config,\n          ),\n        );\n      }\n      return dependencies;\n    }\n    return this.walkPath(abstractDep, element, leftPath.slice(1), config);\n  }\n}\n"]}