{"version":3,"file":"api-cache.js","sourceRoot":"","sources":["../../../../lib/modules/platform/github/api-cache.ts"],"names":[],"mappings":";;;AAAA,mCAAgC;AAChC,iCAAiC;AAGjC,MAAa,QAAQ;IACC;IAApB,YAAoB,KAAsB;QAAtB,UAAK,GAAL,KAAK,CAAiB;IAAG,CAAC;IAE9C,QAAQ;QACN,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAC9C,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO,CAAC,MAAc;QACpB,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC;IAC1C,CAAC;IAED;;;;;OAKG;IACH,UAAU,CAAC,IAAO;QAChB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;IACvC,CAAC;IAED;;;;;;;;;OASG;IACH,SAAS,CAAC,IAAS;QACjB,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;QAC7B,IAAI,EAAE,YAAY,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;QAElC,IAAI,YAAY,GAAG,IAAI,CAAC;QAExB,KAAK,MAAM,OAAO,IAAI,IAAI,EAAE,CAAC;YAC3B,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;YAC9B,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;YAE9B,MAAM,WAAW,GAAG,gBAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YACzD,MAAM,WAAW,GAAG,OAAO,EAAE,UAAU;gBACrC,CAAC,CAAC,gBAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC;gBACtC,CAAC,CAAC,IAAI,CAAC;YAET,IAAI,CAAC,IAAA,eAAM,EAAC,OAAO,EAAE,OAAO,CAAC,EAAE,CAAC;gBAC9B,KAAK,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC;YAC1B,CAAC;YAED,YAAY,GAAG,WAAW,CAAC,CAAC,CAAC,WAAW,GAAG,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC;YAE9D,MAAM,YAAY,GAAG,YAAY,CAAC,CAAC,CAAC,gBAAQ,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;YAC1E,IAAI,CAAC,YAAY,IAAI,WAAW,GAAG,YAAY,EAAE,CAAC;gBAChD,YAAY,GAAG,OAAO,CAAC,UAAU,CAAC;YACpC,CAAC;QACH,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,YAAY,GAAG,YAAY,CAAC;QAEvC,OAAO,YAAY,CAAC;IACtB,CAAC;CACF;AA/DD,4BA+DC","sourcesContent":["import { dequal } from 'dequal';\nimport { DateTime } from 'luxon';\nimport type { ApiPageCache, ApiPageItem } from './types';\n\nexport class ApiCache<T extends ApiPageItem> {\n  constructor(private cache: ApiPageCache<T>) {}\n\n  getItems(): T[] {\n    const items = Object.values(this.cache.items);\n    return items;\n  }\n\n  getItem(number: number): T | null {\n    return this.cache.items[number] ?? null;\n  }\n\n  /**\n   * It intentionally doesn't alter `lastModified` cache field.\n   *\n   * The point is to allow cache modifications during run, but\n   * force fetching and refreshing of modified items next run.\n   */\n  updateItem(item: T): void {\n    this.cache.items[item.number] = item;\n  }\n\n  /**\n   * Copies items from `page` to `cache`.\n   * Updates internal cache timestamp.\n   *\n   * @param cache Cache object\n   * @param page List of cacheable items, sorted by `updated_at` field\n   * starting from the most recently updated.\n   * @returns `true` when the next page is likely to contain fresh items,\n   * otherwise `false`.\n   */\n  reconcile(page: T[]): boolean {\n    const { items } = this.cache;\n    let { lastModified } = this.cache;\n\n    let needNextPage = true;\n\n    for (const newItem of page) {\n      const number = newItem.number;\n      const oldItem = items[number];\n\n      const itemNewTime = DateTime.fromISO(newItem.updated_at);\n      const itemOldTime = oldItem?.updated_at\n        ? DateTime.fromISO(oldItem.updated_at)\n        : null;\n\n      if (!dequal(oldItem, newItem)) {\n        items[number] = newItem;\n      }\n\n      needNextPage = itemOldTime ? itemOldTime < itemNewTime : true;\n\n      const cacheOldTime = lastModified ? DateTime.fromISO(lastModified) : null;\n      if (!cacheOldTime || itemNewTime > cacheOldTime) {\n        lastModified = newItem.updated_at;\n      }\n    }\n\n    this.cache.lastModified = lastModified;\n\n    return needNextPage;\n  }\n}\n"]}