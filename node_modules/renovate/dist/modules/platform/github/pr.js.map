{"version":3,"file":"pr.js","sourceRoot":"","sources":["../../../../lib/modules/platform/github/pr.ts"],"names":[],"mappings":";;AAiDA,gCAsEC;AAED,sCAGC;;AA5HD,kEAAkC;AAClC,4CAAyC;AACzC,mFAA8E;AAC9E,+DAA0D;AAC1D,4GAA4F;AAE5F,2CAAoD;AACpD,2CAAuC;AACvC,qCAAwC;AAGxC,SAAS,aAAa;IACpB,MAAM,SAAS,GAAG,IAAA,qBAAQ,GAAE,CAAC;IAC7B,SAAS,CAAC,QAAQ,KAAK,EAAE,CAAC;IAC1B,SAAS,CAAC,QAAQ,CAAC,MAAM,KAAK,EAAE,CAAC;IACjC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,iBAAiB,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC;IAC9D,MAAM,UAAU,GAAG,IAAI,oBAAQ,CAC7B,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,iBAAuC,CAClE,CAAC;IACF,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;AACI,KAAK,UAAU,UAAU,CAC9B,IAAgB,EAChB,IAAY,EACZ,QAAuB;IAEvB,MAAM,UAAU,GAAG,aAAa,EAAE,CAAC;IACnC,MAAM,SAAS,GAAG,YAAE,CAAC,UAAU,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC;IAEvD,IAAI,CAAC;QACH,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,IAAI,gBAAgB,GAAG,KAAK,CAAC;QAC7B,IAAI,iBAAiB,GAAG,IAAI,CAAC;QAC7B,IAAI,gBAAgB,GAAG,IAAI,CAAC;QAE5B,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,OAAO,iBAAiB,IAAI,gBAAgB,EAAE,CAAC;YAC7C,MAAM,IAAI,GAAsB,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC;YACrE,IAAI,OAAO,KAAK,CAAC,EAAE,CAAC;gBAClB,IAAI,CAAC,aAAa,GAAG,kDAAiB,CAAC;gBACvC,IAAI,SAAS,EAAE,CAAC;oBACd,yBAAyB;oBACzB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;gBACvB,CAAC;YACH,CAAC;YAED,MAAM,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;YACrC,MAAM,OAAO,GAAG,SAAS,IAAI,mBAAmB,OAAO,+CAA+C,OAAO,EAAE,CAAC;YAEhH,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAa,OAAO,EAAE,IAAI,CAAC,CAAC;YACnE,gBAAgB,GAAG,IAAI,CAAC;YACxB,aAAa,IAAI,CAAC,CAAC;YAEnB,MAAM,EACJ,OAAO,EAAE,EAAE,IAAI,EAAE,UAAU,EAAE,GAC9B,GAAG,GAAG,CAAC;YAER,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,GAAG,CAAC;YAEzB,IAAI,QAAQ,EAAE,CAAC;gBACb,IAAI,GAAG,IAAI,CAAC,MAAM,CAChB,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,QAAQ,CAC5D,CAAC;YACJ,CAAC;YAED,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,qBAAY,CAAC,CAAC;YAErC,gBAAgB,GAAG,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YAC/C,iBAAiB,GAAG,CAAC,CAAC,IAAA,qBAAe,EAAC,UAAU,CAAC,EAAE,IAAI,CAAC;YAExD,IAAI,OAAO,KAAK,CAAC,EAAE,CAAC;gBAClB,iBAAiB,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;YACvC,CAAC;YAED,OAAO,IAAI,CAAC,CAAC;QACf,CAAC;QAED,eAAM,CAAC,KAAK,CACV;YACE,UAAU,EAAE,UAAU,CAAC,QAAQ,EAAE,CAAC,MAAM;YACxC,aAAa;YACb,gBAAgB;SACjB,EACD,mBAAmB,CACpB,CAAC;IACJ,CAAC;IAAC,OAAO,GAAG,EAAE,qBAAqB,CAAC,CAAC;QACnC,eAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,EAAE,eAAe,CAAC,CAAC;QACvC,MAAM,IAAI,uCAAiB,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;IAC7C,CAAC,CAAC,oBAAoB;IAEtB,OAAO,UAAU,CAAC,QAAQ,EAAE,CAAC;AAC/B,CAAC;AAED,SAAgB,aAAa,CAAC,EAAQ;IACpC,MAAM,KAAK,GAAG,aAAa,EAAE,CAAC;IAC9B,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;AACvB,CAAC","sourcesContent":["import is from '@sindresorhus/is';\nimport { logger } from '../../../logger';\nimport { ExternalHostError } from '../../../types/errors/external-host-error';\nimport { getCache } from '../../../util/cache/repository';\nimport { repoCacheProvider } from '../../../util/http/cache/repository-http-cache-provider';\nimport type { GithubHttp, GithubHttpOptions } from '../../../util/http/github';\nimport { parseLinkHeader } from '../../../util/url';\nimport { ApiCache } from './api-cache';\nimport { coerceRestPr } from './common';\nimport type { ApiPageCache, GhPr, GhRestPr } from './types';\n\nfunction getPrApiCache(): ApiCache<GhPr> {\n  const repoCache = getCache();\n  repoCache.platform ??= {};\n  repoCache.platform.github ??= {};\n  repoCache.platform.github.pullRequestsCache ??= { items: {} };\n  const prApiCache = new ApiCache<GhPr>(\n    repoCache.platform.github.pullRequestsCache as ApiPageCache<GhPr>,\n  );\n  return prApiCache;\n}\n\n/**\n *  Fetch and return Pull Requests from GitHub repository:\n *\n *   1. Synchronize long-term cache.\n *\n *   2. Store items in raw format, i.e. exactly what\n *      has been returned by GitHub REST API.\n *\n *   3. Convert items to the Renovate format and return.\n *\n * In order synchronize ApiCache properly, we handle 3 cases:\n *\n *   a. We never fetched PR list for this repo before.\n *      If cached PR list is empty, we assume it's the case.\n *\n *      In this case, we're falling back to quick fetch via\n *      `paginate=true` option (see `util/http/github.ts`).\n *\n *   b. Some of PRs had changed since last run.\n *\n *      In this case, we sequentially fetch page by page\n *      until `ApiCache.coerce` function indicates that\n *      no more fresh items can be found in the next page.\n *\n *      We expect to fetch just one page per run in average,\n *      since it's rare to have more than 100 updated PRs.\n */\nexport async function getPrCache(\n  http: GithubHttp,\n  repo: string,\n  username: string | null,\n): Promise<Record<number, GhPr>> {\n  const prApiCache = getPrApiCache();\n  const isInitial = is.emptyArray(prApiCache.getItems());\n\n  try {\n    let requestsTotal = 0;\n    let apiQuotaAffected = false;\n    let needNextPageFetch = true;\n    let needNextPageSync = true;\n\n    let pageIdx = 1;\n    while (needNextPageFetch && needNextPageSync) {\n      const opts: GithubHttpOptions = { paginate: false, memCache: false };\n      if (pageIdx === 1) {\n        opts.cacheProvider = repoCacheProvider;\n        if (isInitial) {\n          // Speed up initial fetch\n          opts.paginate = true;\n        }\n      }\n\n      const perPage = isInitial ? 100 : 20;\n      const urlPath = `repos/${repo}/pulls?per_page=${perPage}&state=all&sort=updated&direction=desc&page=${pageIdx}`;\n\n      const res = await http.getJsonUnchecked<GhRestPr[]>(urlPath, opts);\n      apiQuotaAffected = true;\n      requestsTotal += 1;\n\n      const {\n        headers: { link: linkHeader },\n      } = res;\n\n      let { body: page } = res;\n\n      if (username) {\n        page = page.filter(\n          (ghPr) => ghPr?.user?.login && ghPr.user.login === username,\n        );\n      }\n\n      const items = page.map(coerceRestPr);\n\n      needNextPageSync = prApiCache.reconcile(items);\n      needNextPageFetch = !!parseLinkHeader(linkHeader)?.next;\n\n      if (pageIdx === 1) {\n        needNextPageFetch &&= !opts.paginate;\n      }\n\n      pageIdx += 1;\n    }\n\n    logger.debug(\n      {\n        pullsTotal: prApiCache.getItems().length,\n        requestsTotal,\n        apiQuotaAffected,\n      },\n      `getPrList success`,\n    );\n  } catch (err) /* v8 ignore start */ {\n    logger.debug({ err }, 'getPrList err');\n    throw new ExternalHostError(err, 'github');\n  } /* v8 ignore stop */\n\n  return prApiCache.getItems();\n}\n\nexport function updatePrCache(pr: GhPr): void {\n  const cache = getPrApiCache();\n  cache.updateItem(pr);\n}\n"]}