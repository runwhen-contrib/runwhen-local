{"version":3,"file":"branch.js","sourceRoot":"","sources":["../../../../lib/modules/platform/github/branch.ts"],"names":[],"mappings":";;AAqBA,gDAWC;AAhCD,6BAAwB;AACxB,+CAA4C;AAC5C,qCAAqC;AAErC,MAAM,WAAW,GAAG,OAAC;KAClB,MAAM,CAAC,EAAE,GAAG,EAAE,OAAC,CAAC,MAAM,EAAE,EAAE,CAAC;KAC3B,SAAS,CAAC,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,IAAA,aAAK,EAAC,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC;KAChE,KAAK,EAAE,CAAC;AAEX,KAAK,UAAU,gBAAgB,CAC7B,IAAY,EACZ,UAAkB;IAElB,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,MAAM,kBAAS,CAAC,OAAO,CAChD,UAAU,IAAI,4BAA4B,UAAU,EAAE,EACtD,EAAE,QAAQ,EAAE,KAAK,EAAE,EACnB,WAAW,CACZ,CAAC;IACF,OAAO,QAAQ,CAAC;AAClB,CAAC;AAEM,KAAK,UAAU,kBAAkB,CACtC,IAAY,EACZ,UAAkB;IAElB,MAAM,QAAQ,GAAG,MAAM,gBAAgB,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;IAC1D,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC;QACnE,MAAM,OAAO,GAAG,8BAA8B,UAAU,wCAAwC,CAAC;QACjG,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;IAC3B,CAAC;IAED,OAAO,QAAQ,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;AACvC,CAAC","sourcesContent":["import { z } from 'zod';\nimport { regEx } from '../../../util/regex';\nimport { githubApi } from './common';\n\nconst MatchingRef = z\n  .object({ ref: z.string() })\n  .transform(({ ref }) => ref.replace(regEx(/^refs\\/heads\\//), ''))\n  .array();\n\nasync function matchingBranches(\n  repo: string,\n  branchName: string,\n): Promise<string[]> {\n  const { body: branches } = await githubApi.getJson(\n    `/repos/${repo}/git/matching-refs/heads/${branchName}`,\n    { memCache: false },\n    MatchingRef,\n  );\n  return branches;\n}\n\nexport async function remoteBranchExists(\n  repo: string,\n  branchName: string,\n): Promise<boolean> {\n  const branches = await matchingBranches(repo, branchName);\n  if (branches.some((branch) => branch.startsWith(`${branchName}/`))) {\n    const message = `Trying to create a branch '${branchName}' while it's the part of nested branch`;\n    throw new Error(message);\n  }\n\n  return branches.includes(branchName);\n}\n"]}