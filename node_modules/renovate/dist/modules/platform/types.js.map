{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../lib/modules/platform/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { MergeStrategy } from '../../config/types';\nimport type { BranchStatus, HostRule, VulnerabilityAlert } from '../../types';\nimport type { CommitFilesConfig, LongCommitSha } from '../../util/git/types';\n\ntype VulnerabilityKey = string;\ntype VulnerabilityRangeKey = string;\ntype VulnerabilityPatch = string;\nexport type AggregatedVulnerabilities = Record<\n  VulnerabilityKey,\n  Record<VulnerabilityRangeKey, VulnerabilityPatch | null>\n>;\n\nexport interface PlatformParams {\n  endpoint?: string;\n  token?: string;\n  username?: string;\n  password?: string;\n  gitAuthor?: string;\n}\n\nexport interface PlatformResult {\n  endpoint: string;\n  renovateUsername?: string;\n  token?: string;\n  gitAuthor?: string;\n  /*\n   * return these only if _additional_ rules/hosts are required\n   */\n  hostRules?: HostRule[];\n}\n\nexport interface RepoResult {\n  defaultBranch: string;\n  isFork: boolean;\n  repoFingerprint: string;\n}\n\nexport type GitUrlOption = 'default' | 'ssh' | 'endpoint';\n\nexport interface RepoParams {\n  repository: string;\n  endpoint?: string;\n  gitUrl?: GitUrlOption;\n  forkCreation?: boolean;\n  forkOrg?: string;\n  forkToken?: string;\n  forkProcessing?: 'enabled' | 'disabled';\n  renovateUsername?: string;\n  cloneSubmodules?: boolean;\n  cloneSubmodulesFilter?: string[];\n  ignorePrAuthor?: boolean;\n  bbUseDevelopmentBranch?: boolean;\n  includeMirrors?: boolean;\n}\n\nexport interface PrDebugData {\n  createdInVer: string;\n  updatedInVer: string;\n  targetBranch: string;\n  labels?: string[];\n}\n\nexport interface PrBodyStruct {\n  hash: string;\n  rawConfigHash?: string;\n  rebaseRequested?: boolean;\n  debugData?: PrDebugData;\n}\n\n/**\n *\n */\nexport interface Pr {\n  bodyStruct?: PrBodyStruct;\n  sourceBranch: string;\n  cannotMergeReason?: string; // for reflecting platform policies which may prevent merging\n  createdAt?: string;\n  closedAt?: string;\n  hasAssignees?: boolean;\n  labels?: string[];\n  number: number;\n  reviewers?: string[];\n  sha?: LongCommitSha;\n  sourceRepo?: string;\n  state: string;\n  targetBranch?: string;\n  title: string;\n  isDraft?: boolean;\n}\n\n/**\n * TODO: Proper typing\n */\nexport interface Issue {\n  body?: string;\n  number?: number;\n  state?: string;\n  title?: string;\n}\nexport interface PlatformPrOptions {\n  autoApprove?: boolean;\n  automergeStrategy?: MergeStrategy;\n  azureWorkItemId?: number;\n  bbUseDefaultReviewers?: boolean;\n  bbAutoResolvePrTasks?: boolean;\n  gitLabIgnoreApprovals?: boolean;\n  usePlatformAutomerge?: boolean;\n  forkModeDisallowMaintainerEdits?: boolean;\n}\n\nexport interface CreatePRConfig {\n  sourceBranch: string;\n  targetBranch: string;\n  prTitle: string;\n  prBody: string;\n  labels?: string[] | null;\n  platformPrOptions?: PlatformPrOptions;\n  draftPR?: boolean;\n  milestone?: number;\n}\nexport interface UpdatePrConfig {\n  number: number;\n  platformPrOptions?: PlatformPrOptions;\n  prTitle: string;\n  prBody?: string;\n  state?: 'open' | 'closed';\n  targetBranch?: string;\n\n  /**\n   * This field allows for label management and is designed to\n   * accommodate the different label update methods on various platforms.\n   *\n   * - For Gitea, labels are updated by replacing the entire labels array.\n   * - In the case of GitHub and GitLab, specific endpoints exist\n   *   for adding and removing labels.\n   */\n  labels?: string[] | null;\n\n  /**\n   * Specifies an array of labels to be added.\n   * @see {@link labels}\n   */\n  addLabels?: string[] | null;\n\n  /**\n   * Specifies an array of labels to be removed.\n   * @see {@link labels}\n   */\n  removeLabels?: string[] | null;\n}\nexport interface ReattemptPlatformAutomergeConfig {\n  number: number;\n  platformPrOptions?: PlatformPrOptions;\n}\nexport interface EnsureIssueConfig {\n  title: string;\n  reuseTitle?: string;\n  body: string;\n  labels?: string[];\n  once?: boolean;\n  shouldReOpen?: boolean;\n  confidential?: boolean;\n}\nexport interface BranchStatusConfig {\n  branchName: string;\n  context: string;\n  description: string;\n  state: BranchStatus;\n  url?: string;\n}\nexport interface FindPRConfig {\n  branchName: string;\n  prTitle?: string | null;\n  state?: 'open' | 'closed' | '!open' | 'all';\n  refreshCache?: boolean;\n  targetBranch?: string | null;\n  includeOtherAuthors?: boolean;\n}\nexport interface MergePRConfig {\n  branchName?: string;\n  id: number;\n  strategy?: MergeStrategy;\n}\nexport interface EnsureCommentConfig {\n  number: number;\n  topic: string | null;\n  content: string;\n}\n\nexport interface EnsureCommentRemovalConfigByTopic {\n  type: 'by-topic';\n  number: number;\n  topic: string;\n}\nexport interface EnsureCommentRemovalConfigByContent {\n  type: 'by-content';\n  number: number;\n  content: string;\n}\nexport type EnsureCommentRemovalConfig =\n  | EnsureCommentRemovalConfigByTopic\n  | EnsureCommentRemovalConfigByContent;\n\nexport type EnsureIssueResult = 'updated' | 'created';\n\nexport type RepoSortMethod =\n  | 'alpha'\n  | 'created'\n  | 'updated'\n  | 'size'\n  | 'id'\n  | null;\n\nexport type SortMethod = 'asc' | 'desc' | null;\nexport interface AutodiscoverConfig {\n  topics?: string[];\n  sort?: RepoSortMethod;\n  order?: SortMethod;\n  includeMirrors?: boolean;\n  namespaces?: string[];\n  projects?: string[];\n}\n\nexport interface Platform {\n  findIssue(title: string): Promise<Issue | null>;\n  getIssueList(): Promise<Issue[]>;\n  getIssue?(number: number, memCache?: boolean): Promise<Issue | null>;\n  getVulnerabilityAlerts?(): Promise<VulnerabilityAlert[]>;\n  getRawFile(\n    fileName: string,\n    repoName?: string,\n    branchOrTag?: string,\n  ): Promise<string | null>;\n  getJsonFile(\n    fileName: string,\n    repoName?: string,\n    branchOrTag?: string,\n  ): Promise<any>;\n  initRepo(config: RepoParams): Promise<RepoResult>;\n  getPrList(): Promise<Pr[]>;\n  ensureIssueClosing(title: string): Promise<void>;\n  ensureIssue(\n    issueConfig: EnsureIssueConfig,\n  ): Promise<EnsureIssueResult | null>;\n  massageMarkdown(prBody: string): string;\n  updatePr(prConfig: UpdatePrConfig): Promise<void>;\n  mergePr(config: MergePRConfig): Promise<boolean>;\n  addReviewers(number: number, reviewers: string[]): Promise<void>;\n  addAssignees(number: number, assignees: string[]): Promise<void>;\n  createPr(prConfig: CreatePRConfig): Promise<Pr | null>;\n  getRepos(config?: AutodiscoverConfig): Promise<string[]>;\n  getBranchForceRebase?(branchName: string): Promise<boolean>;\n  deleteLabel(number: number, label: string): Promise<void>;\n  addLabel?(number: number, label: string): Promise<void>;\n  setBranchStatus(branchStatusConfig: BranchStatusConfig): Promise<void>;\n  getBranchStatusCheck(\n    branchName: string,\n    // TODO: can be undefined or null ? #22198\n    context: string | null | undefined,\n  ): Promise<BranchStatus | null>;\n  ensureCommentRemoval(\n    ensureCommentRemoval:\n      | EnsureCommentRemovalConfigByTopic\n      | EnsureCommentRemovalConfigByContent,\n  ): Promise<void>;\n  ensureComment(ensureComment: EnsureCommentConfig): Promise<boolean>;\n  getPr(number: number): Promise<Pr | null>;\n  findPr(findPRConfig: FindPRConfig): Promise<Pr | null>;\n  refreshPr?(number: number): Promise<void>;\n  reattemptPlatformAutomerge?(\n    prConfig: ReattemptPlatformAutomergeConfig,\n  ): Promise<void>;\n  getBranchStatus(\n    branchName: string,\n    internalChecksAsSuccess: boolean,\n  ): Promise<BranchStatus>;\n  getBranchPr(branchName: string, targetBranch?: string): Promise<Pr | null>;\n  tryReuseAutoclosedPr?(pr: Pr): Promise<Pr | null>;\n  initPlatform(config: PlatformParams): Promise<PlatformResult>;\n  filterUnavailableUsers?(users: string[]): Promise<string[]>;\n  commitFiles?(config: CommitFilesConfig): Promise<LongCommitSha | null>;\n  expandGroupMembers?(reviewersOrAssignees: string[]): Promise<string[]>;\n\n  maxBodyLength(): number;\n  labelCharLimit?(): number;\n}\n\nexport interface PlatformScm {\n  isBranchBehindBase(branchName: string, baseBranch: string): Promise<boolean>;\n  isBranchModified(branchName: string, baseBranch: string): Promise<boolean>;\n  isBranchConflicted(baseBranch: string, branch: string): Promise<boolean>;\n  branchExists(branchName: string): Promise<boolean>;\n  getBranchCommit(branchName: string): Promise<LongCommitSha | null>;\n  deleteBranch(branchName: string): Promise<void>;\n  commitAndPush(commitConfig: CommitFilesConfig): Promise<LongCommitSha | null>;\n  getFileList(): Promise<string[]>;\n  checkoutBranch(branchName: string): Promise<LongCommitSha>;\n  mergeToLocal(branchName: string): Promise<void>;\n  mergeAndPush(branchName: string): Promise<void>;\n}\n"]}