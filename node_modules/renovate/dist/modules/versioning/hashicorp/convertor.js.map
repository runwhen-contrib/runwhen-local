{"version":3,"file":"convertor.js","sourceRoot":"","sources":["../../../../lib/modules/versioning/hashicorp/convertor.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from '../../../logger';\nimport { regEx } from '../../../util/regex';\n\n// Taken from https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string. Licensed under CC BY 3.0\n// Removed the ^ and $.\n// Made minor and patch versions optional by surrounding them in parentheses followed by a question mark.\nconst semverRegex =\n  /(0|[1-9]\\d*)(\\.(0|[1-9]\\d*))?(\\.(0|[1-9]\\d*))?(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?/;\n\n/**\n * This can convert most hashicorp ranges to valid npm syntax\n * The `!=` syntax is currently unsupported as there is no direct\n * equivalent in npm and isn't widely used\n * The version part of the constraint is parsed as a semver but with the minor and patch versions being optional.\n * The prerelease syntax is less well-defined for hashicorp and will\n * cause issues if it is not semvar compatible as no attempts to convert it\n * are made\n */\nexport function hashicorp2npm(input: string): string {\n  if (!input) {\n    return input;\n  }\n  return input\n    .split(',')\n    .map((single) => {\n      const r = single.match(\n        regEx(\n          `^\\\\s*(?<operator>(|=|!=|>|<|>=|<=|~>))\\\\s*v?(?<version>${semverRegex.source})\\\\s*$`,\n        ),\n      );\n      if (!r) {\n        logger.warn(\n          { constraint: input, element: single },\n          'Invalid hashicorp constraint',\n        );\n        throw new Error('Invalid hashicorp constraint');\n      }\n      if (r.groups!.operator === '!=') {\n        logger.warn(\n          { constraint: input, element: single },\n          'Unsupported hashicorp constraint',\n        );\n        throw new Error('Unsupported hashicorp constraint');\n      }\n      return {\n        operator: r.groups!.operator,\n        version: r.groups!.version,\n      };\n    })\n    .map(({ operator, version }) => {\n      switch (operator) {\n        case '=':\n          return version;\n        case '~>':\n          if (version.match(regEx(/^\\d+$/))) {\n            return `>=${version}`;\n          }\n          if (version.match(regEx(/^\\d+\\.\\d+$/))) {\n            return `^${version}`;\n          }\n          return `~${version}`;\n        default:\n          return `${operator}${version}`;\n      }\n    })\n    .join(' ');\n}\n\n/**\n * This can convert a limited set of npm range syntax to hashicorp,\n * it supports all the syntax that hashicorp2npm can output\n * It cannot handle `*`, `1.x.x`, range with `-`, `||`\n */\nexport function npm2hashicorp(input: string): string {\n  if (!input) {\n    return input;\n  }\n  return input\n    .split(' ')\n    .map((single) => {\n      const r = single.match(\n        regEx(\n          `^(?<operator>(|>|<|>=|<=|~|\\\\^))v?(?<version>${semverRegex.source})$`,\n        ),\n      );\n      if (!r) {\n        throw new Error('invalid npm constraint');\n      }\n      return {\n        operator: r.groups!.operator,\n        version: r.groups!.version,\n      };\n    })\n    .map(({ operator, version }) => {\n      switch (operator) {\n        case '^': {\n          if (version.match(regEx(/^\\d+$/))) {\n            return `~> ${version}.0`;\n          }\n          const withZero = version.match(regEx(/^(\\d+\\.\\d+)\\.0$/));\n          if (withZero) {\n            return `~> ${withZero[1]}`;\n          }\n          const nonZero = version.match(regEx(/^(\\d+\\.\\d+)\\.\\d+$/));\n          if (nonZero) {\n            // not including`>= ${version}`, which makes this less accurate\n            // but makes the results cleaner\n            return `~> ${nonZero[1]}`;\n          }\n          return `~> ${version}`;\n        }\n        case '~':\n          if (version.match(regEx(/^\\d+$/))) {\n            return `~> ${version}.0`;\n          }\n          if (version.match(regEx(/^\\d+\\.\\d+$/))) {\n            return `~> ${version}.0`;\n          }\n          return `~> ${version}`;\n        case '':\n          return `${version}`;\n        default:\n          return `${operator} ${version}`;\n      }\n    })\n    .join(', ');\n}\n"]}