{"version":3,"file":"bump.js","sourceRoot":"","sources":["../../../../../lib/modules/versioning/ruby/strategies/bump.ts"],"names":[],"mappings":";;AAAA,0DAAuD;AACvD,0CAA4D;AAE5D,oCAAwD;AACxD,wCAA+C;AAC/C,uCAAwC;AAExC,kBAAe,CAAC,EAAE,KAAK,EAAE,EAAE,EAAiC,EAAU,EAAE;IACtE,MAAM,KAAK,GAAG,IAAA,mBAAW,EAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAS,EAAE;QACnD,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;QACxC,QAAQ,QAAQ,EAAE,CAAC;YACjB,iFAAiF;YACjF,KAAK,aAAE;gBACL,OAAO,IAAA,iBAAG,EAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,IAAA,qBAAW,EAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;YACrD,KAAK,cAAG;gBACN,OAAO,IAAA,gBAAE,EAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,IAAA,qBAAW,EAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;YACpD,eAAe;YACf,KAAK,eAAI,CAAC,CAAC,CAAC;gBACV,6CAA6C;gBAC7C,MAAM,OAAO,GAAG,IAAA,eAAK,EAAC,EAAE,EAAE,GAAG,CAAC,CAAC;gBAC/B,IAAI,IAAA,oBAAU,EAAC,OAAO,CAAC,KAAK,IAAA,oBAAU,EAAC,EAAE,CAAC,EAAE,CAAC;oBAC3C,qEAAqE;oBACrE,OAAO,EAAE,GAAG,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,CAAC;gBAC7D,CAAC;qBAAM,CAAC;oBACN,+BAA+B;oBAC/B,OAAO;wBACL,GAAG,IAAI;wBACP,OAAO,EAAE,OAAO;wBAChB,SAAS,EAAE,EAAE,QAAQ,EAAE,cAAG,EAAE,SAAS,EAAE,GAAG,EAAE,OAAO,EAAE,EAAE,EAAE;qBAC1D,CAAC;gBACJ,CAAC;YACH,CAAC;YACD,KAAK,oBAAS;gBACZ,IAAI,IAAA,gBAAE,EAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC;oBAChB,8CAA8C;oBAC9C,OAAO,EAAE,GAAG,IAAI,EAAE,QAAQ,EAAE,cAAG,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC;gBACjD,CAAC;gBACD,OAAO,IAAI,CAAC;YACd;gBACE,2EAA2E;gBAC3E,OAAO,IAAA,qBAAW,EAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QACjC,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,IAAA,uBAAe,EAAC,KAAK,CAAC,CAAC;AAChC,CAAC,CAAC","sourcesContent":["import { gt, gte, lt } from '@renovatebot/ruby-semver';\nimport { GTE, LT, LTE, NOT_EQUAL, PGTE } from '../operator';\nimport type { Range } from '../range';\nimport { parseRanges, stringifyRanges } from '../range';\nimport { adapt, trimZeroes } from '../version';\nimport { replacePart } from './replace';\n\nexport default ({ range, to }: { range: string; to: string }): string => {\n  const parts = parseRanges(range).map((part): Range => {\n    const { operator, version: ver } = part;\n    switch (operator) {\n      // Update upper bound (`<` and `<=`) ranges only if the new version violates them\n      case LT:\n        return gte(to, ver) ? replacePart(part, to) : part;\n      case LTE:\n        return gt(to, ver) ? replacePart(part, to) : part;\n      // `~>` ranges.\n      case PGTE: {\n        // Try to add / remove extra `>=` constraint.\n        const trimmed = adapt(to, ver);\n        if (trimZeroes(trimmed) === trimZeroes(to)) {\n          // E.g. `'~> 5.2', '>= 5.2.0'`. In this case the latter is redundant.\n          return { ...part, version: trimmed, companion: undefined };\n        } else {\n          // E.g. `'~> 5.2', '>= 5.2.1'`.\n          return {\n            ...part,\n            version: trimmed,\n            companion: { operator: GTE, delimiter: ' ', version: to },\n          };\n        }\n      }\n      case NOT_EQUAL:\n        if (lt(ver, to)) {\n          // The version to exclude is now out of range.\n          return { ...part, operator: GTE, version: to };\n        }\n        return part;\n      default:\n        // For `=` and lower bound ranges, always keep it stick to the new version.\n        return replacePart(part, to);\n    }\n  });\n\n  return stringifyRanges(parts);\n};\n"]}