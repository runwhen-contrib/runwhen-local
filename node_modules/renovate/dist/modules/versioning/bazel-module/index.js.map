{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../lib/modules/versioning/bazel-module/index.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NewValueConfig, VersioningApi } from '../types';\nimport { BzlmodVersion } from './bzlmod-version';\n\nexport const id = 'bazel-module';\nexport const displayName = 'Bazel Module';\nexport const urls = ['https://bazel.build/external/module'];\nexport const supportsRanges = false;\n\nfunction getBzlmodVersion(version: string): BzlmodVersion {\n  return new BzlmodVersion(version);\n}\n\nfunction getMajor(version: string): null | number {\n  return getBzlmodVersion(version).release.major;\n}\n\nfunction getMinor(version: string): null | number {\n  return getBzlmodVersion(version).release.minor;\n}\n\nfunction getPatch(version: string): null | number {\n  return getBzlmodVersion(version).release.patch;\n}\n\n/**\n * Check whether `version` and `other` are logically equivalent, even if\n * they're not the exact same string.\n *\n * For example, with Semver the build metadata should be ignored when comparing.\n */\nfunction equals(version: string, other: string): boolean {\n  const abv = new BzlmodVersion(version);\n  const bbv = new BzlmodVersion(other);\n  return abv.equals(bbv);\n}\n\n/**\n * Check whether `version` is \"greater\" than the `other` version.\n */\nfunction isGreaterThan(version: string, other: string): boolean {\n  const abv = new BzlmodVersion(version);\n  const bbv = new BzlmodVersion(other);\n  return abv.isGreaterThan(bbv);\n}\n\n/**\n * Check whether the `version` is \"less\" than all the versions possible in\n * the `range`.\n */\nfunction isLessThanRange(version: string, range: string): boolean {\n  const abv = new BzlmodVersion(version);\n  const bbv = new BzlmodVersion(range);\n  return abv.isLessThan(bbv);\n}\n\n/**\n * Select the highest version from `versions` that is within the given\n * `range` constraint, or return `null` if there is no matching version.\n */\nfunction getSatisfyingVersion(\n  versions: string[],\n  range: string,\n): string | null {\n  const target = new BzlmodVersion(range);\n  const result = versions.find((ver) => {\n    const bv = new BzlmodVersion(ver);\n    return target.equals(bv);\n  });\n  return result ? range : null;\n}\n\n/**\n * Select the lowest version from `versions` that is within the given\n * `range` constraint, or return `null` if there is no matching version.\n */\nfunction minSatisfyingVersion(\n  versions: string[],\n  range: string,\n): string | null {\n  return getSatisfyingVersion(versions, range);\n}\n\n/**\n * Calculate a new version constraint based on the current constraint, the\n * `rangeStrategy` option, and the current and new version.\n */\nfunction getNewValue({\n  currentValue,\n  currentVersion,\n  newVersion,\n}: NewValueConfig): string {\n  if (currentVersion === `v${currentValue}`) {\n    return newVersion.replace(/^v/, '');\n  }\n  return newVersion;\n}\n\n/**\n * Compare two versions. Return `0` if `v1 == v2`, or `1` if `v1` is\n * greater, or `-1` if `v2` is greater.\n */\nfunction sortVersions(version: string, other: string): number {\n  const abv = new BzlmodVersion(version);\n  const bbv = new BzlmodVersion(other);\n  return BzlmodVersion.defaultCompare(abv, bbv);\n}\n\n/**\n * Check whether the `version` satisfies the `range` constraint.\n */\nfunction matches(version: string, range: string): boolean {\n  return equals(version, range);\n}\n\n/**\n * Check whether the `version` is compatible with the `current` value\n * constraint.\n */\nfunction isCompatible(version: string, current?: string): boolean {\n  return isValid(version);\n}\n\n/**\n * Check whether the `version` constraint is not a range, i.e. it only allows a\n * single specific version.\n */\nfunction isSingleVersion(version: string): boolean {\n  return isValid(version);\n}\n\n/**\n * Check whether the `version` is considered to be \"stable\".\n *\n * Example: in SemVer the version must not have a pre-release marker.\n */\nfunction isStable(version: string): boolean {\n  const abv = new BzlmodVersion(version);\n  return !abv.isPrerelease;\n}\n\n/**\n * Check whether the `input` is a valid version or a valid version range constraint.\n */\nfunction isValid(input: string): boolean {\n  try {\n    new BzlmodVersion(input);\n  } catch {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Check whether the `input` is a valid version string.\n */\nfunction isVersion(input: string | undefined | null): boolean {\n  if (input === undefined || input === null) {\n    return false;\n  }\n  return isValid(input);\n}\n\nexport const api: VersioningApi = {\n  equals,\n  getMajor,\n  getMinor,\n  getPatch,\n  isCompatible,\n  isGreaterThan,\n  isLessThanRange,\n  isSingleVersion,\n  isStable,\n  isValid,\n  isVersion,\n  matches,\n  getSatisfyingVersion,\n  minSatisfyingVersion,\n  getNewValue,\n  sortVersions,\n};\nexport default api;\n"]}