{"version":3,"file":"result.js","sourceRoot":"","sources":["../../lib/util/result.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  SafeParseReturnType,\n  input as ZodInput,\n  output as ZodOutput,\n  ZodType,\n} from 'zod';\nimport { NEVER, ZodError, ZodIssueCode } from 'zod';\nimport { logger } from '../logger';\n\ntype Val = NonNullable<unknown>;\ntype Nullable<T extends Val> = T | null | undefined;\n\ninterface Ok<T extends Val> {\n  readonly ok: true;\n  readonly val: T;\n  readonly err?: never;\n}\n\ninterface Err<E extends Val> {\n  readonly ok: false;\n  readonly err: E;\n  readonly val?: never;\n\n  /**\n   * Internal flag to indicate that the error was thrown during `.transform()`\n   * and will be re-thrown on `.unwrap()`.\n   */\n  readonly _uncaught?: true;\n}\n\ntype Res<T extends Val, E extends Val> = Ok<T> | Err<E>;\n\nfunction isZodResult<Input, Output extends Val>(\n  input: unknown,\n): input is SafeParseReturnType<Input, Output> {\n  if (\n    typeof input !== 'object' ||\n    input === null ||\n    Object.keys(input).length !== 2 ||\n    !('success' in input) ||\n    typeof input.success !== 'boolean'\n  ) {\n    return false;\n  }\n\n  if (input.success) {\n    return (\n      'data' in input &&\n      typeof input.data !== 'undefined' &&\n      input.data !== null\n    );\n  } else {\n    return 'error' in input && input.error instanceof ZodError;\n  }\n}\n\nfunction fromZodResult<ZodInput, ZodOutput extends Val>(\n  input: SafeParseReturnType<ZodInput, ZodOutput>,\n): Result<ZodOutput, ZodError<ZodInput>> {\n  return input.success ? Result.ok(input.data) : Result.err(input.error);\n}\n\n/**\n * All non-nullable values that also are not Promises nor Zod results.\n * It's useful for restricting Zod results to not return `null` or `undefined`.\n */\ntype RawValue<T extends Val> = Exclude<\n  T,\n  SafeParseReturnType<unknown, T> | Promise<unknown>\n>;\n\nfunction fromNullable<\n  T extends Val,\n  ErrForNull extends Val,\n  ErrForUndefined extends Val,\n>(\n  input: Nullable<T>,\n  errForNull: ErrForNull,\n  errForUndefined: ErrForUndefined,\n): Result<T, ErrForNull | ErrForUndefined> {\n  if (input === null) {\n    return Result.err(errForNull);\n  }\n\n  if (input === undefined) {\n    return Result.err(errForUndefined);\n  }\n\n  return Result.ok(input);\n}\n\n/**\n * Class for representing a result that can fail.\n *\n * The mental model:\n * - `.wrap()` and `.wrapNullable()` are sinks\n * - `.transform()` are pipes which can be chained\n * - `.unwrap()` is the point of consumption\n */\nexport class Result<T extends Val, E extends Val = Error> {\n  private constructor(private readonly res: Res<T, E>) {}\n\n  static ok<T extends Val>(val: T): Result<T, never> {\n    return new Result({ ok: true, val });\n  }\n\n  static err<E extends Val>(err: E): Result<never, E> {\n    return new Result({ ok: false, err });\n  }\n\n  static _uncaught<E extends Val>(err: E): Result<never, E> {\n    return new Result({ ok: false, err, _uncaught: true });\n  }\n\n  /**\n   * Wrap a callback or promise in a Result in such a way that any thrown errors\n   * are caught and wrapped with `Result.err()` (and hence never re-thrown).\n   *\n   * In case of a promise, the `AsyncResult` is returned.\n   * Use `.unwrap()` to get the `Promise<Result<T, E>>` from `AsyncResult`.\n   *\n   *   ```ts\n   *\n   *   // SYNC\n   *   const parse = (json: string) => Result.wrap(() => JSON.parse(json));\n   *\n   *   const { val, err } = parse('{\"foo\": \"bar\"}').unwrap();\n   *   expect(val).toEqual({ foo: 'bar' });\n   *   expect(err).toBeUndefined();\n   *\n   *   const { val, err } = parse('!!!').unwrap();\n   *   expect(val).toBeUndefined();\n   *   expect(err).toBeInstanceOf(SyntaxError);\n   *\n   *   // ASYNC\n   *   const request = (url: string) => Result.wrap(http.get(url));\n   *\n   *   const { val, err } = await request('https://example.com').unwrap();\n   *   expect(val).toBeString();\n   *   expect(err).toBeUndefined();\n   *\n   *   ```\n   */\n  static wrap<T extends Val, Input = unknown>(\n    zodResult: SafeParseReturnType<Input, T>,\n  ): Result<T, ZodError<Input>>;\n  static wrap<T extends Val, E extends Val = Error>(\n    callback: () => RawValue<T>,\n  ): Result<T, E>;\n  static wrap<T extends Val, E extends Val = Error>(\n    callback: () => Promise<RawValue<T>>,\n  ): AsyncResult<T, E>;\n  static wrap<T extends Val, E extends Val = Error, EE extends Val = never>(\n    promise: Promise<Result<T, EE>>,\n  ): AsyncResult<T, E | EE>;\n  static wrap<T extends Val, E extends Val = Error>(\n    promise: Promise<RawValue<T>>,\n  ): AsyncResult<T, E>;\n  static wrap<\n    T extends Val,\n    E extends Val = Error,\n    EE extends Val = never,\n    Input = unknown,\n  >(\n    input:\n      | SafeParseReturnType<Input, T>\n      | (() => RawValue<T>)\n      | (() => Promise<RawValue<T>>)\n      | Promise<Result<T, EE>>\n      | Promise<RawValue<T>>,\n  ): Result<T, ZodError<Input>> | Result<T, E | EE> | AsyncResult<T, E | EE> {\n    if (isZodResult<Input, T>(input)) {\n      return fromZodResult(input);\n    }\n\n    if (input instanceof Promise) {\n      return AsyncResult.wrap(input as never);\n    }\n\n    try {\n      const result = input();\n\n      if (result instanceof Promise) {\n        return AsyncResult.wrap(result);\n      }\n\n      return Result.ok(result);\n    } catch (error) {\n      return Result.err(error);\n    }\n  }\n\n  /**\n   * Similar to `Result.wrap()`, but helps to undo the billion dollar mistake by\n   * replacing `null` or `undefined` with an error of provided type.\n   *\n   * Errors thrown inside the callback or promise are caught and wrapped with `Result.err()`,\n   * hence never re-thrown.\n   *\n   * Since functions and promises returning nullable can't be wrapped with `Result.wrap()`\n   * because `val` is constrained by being `NonNullable`, `null` and `undefined`\n   * must be converted to some sort of `err` value.\n   *\n   * This method does exactly this, i.g. it is the feature-rich shorthand for:\n   *\n   *   ```ts\n   *   const { val, err } = Result.wrap(() => {\n   *     const result = callback();\n   *     return result === null || result === undefined\n   *       ? Result.err('oops')\n   *       : Result.ok(result);\n   *   }).unwrap();\n   *   ```\n   *\n   * In case of a promise, the `AsyncResult` is returned.\n   *\n   *   ```ts\n   *\n   *   // SYNC\n   *   const getHostname = (url: string) =>\n   *     Result.wrapNullable(\n   *       () => parseUrl(url)?.hostname,\n   *       'invalid-url' as const\n   *     );\n   *   const { val, err } = getHostname('foobar').unwrap();\n   *   expect(val).toBeUndefined();\n   *   expect(err).toBe('invalid-url');\n   *\n   *   // ASYNC\n   *   const { val, err } = await Result.wrapNullable(\n   *     readLocalFile('yarn.lock'),\n   *     'file-read-error' as const\n   *   ).unwrap();\n   *\n   *   ```\n   */\n  static wrapNullable<\n    T extends Val,\n    E extends Val = Error,\n    ErrForNullable extends Val = Error,\n  >(\n    callback: () => Nullable<T>,\n    errForNullable: ErrForNullable,\n  ): Result<T, E | ErrForNullable>;\n  static wrapNullable<\n    T extends Val,\n    E extends Val = Error,\n    ErrForNull extends Val = Error,\n    ErrForUndefined extends Val = Error,\n  >(\n    callback: () => Nullable<T>,\n    errForNull: ErrForNull,\n    errForUndefined: ErrForUndefined,\n  ): Result<T, E | ErrForNull | ErrForUndefined>;\n  static wrapNullable<\n    T extends Val,\n    E extends Val = Error,\n    ErrForNullable extends Val = Error,\n  >(\n    promise: Promise<Nullable<T>>,\n    errForNullable: ErrForNullable,\n  ): AsyncResult<T, E | ErrForNullable>;\n  static wrapNullable<\n    T extends Val,\n    E extends Val = Error,\n    ErrForNull extends Val = Error,\n    ErrForUndefined extends Val = Error,\n  >(\n    promise: Promise<Nullable<T>>,\n    errForNull: ErrForNull,\n    errForUndefined: ErrForUndefined,\n  ): AsyncResult<T, E | ErrForNull | ErrForUndefined>;\n  static wrapNullable<\n    T extends Val,\n    E extends Val = Error,\n    ErrForNullable extends Val = Error,\n  >(\n    value: Nullable<T>,\n    errForNullable: ErrForNullable,\n  ): Result<T, E | ErrForNullable>;\n  static wrapNullable<\n    T extends Val,\n    E extends Val = Error,\n    ErrForNull extends Val = Error,\n    ErrForUndefined extends Val = Error,\n  >(\n    value: Nullable<T>,\n    errForNull: ErrForNull,\n    errForUndefined: ErrForUndefined,\n  ): Result<T, E | ErrForNull | ErrForUndefined>;\n  static wrapNullable<\n    T extends Val,\n    E extends Val = Error,\n    ErrForNull extends Val = Error,\n    ErrForUndefined extends Val = Error,\n  >(\n    input: (() => Nullable<T>) | Promise<Nullable<T>> | Nullable<T>,\n    arg2: ErrForNull,\n    arg3?: ErrForUndefined,\n  ):\n    | Result<T, E | ErrForNull | ErrForUndefined>\n    | AsyncResult<T, E | ErrForNull | ErrForUndefined> {\n    const errForNull = arg2;\n    const errForUndefined = arg3 ?? arg2;\n\n    if (input instanceof Promise) {\n      return AsyncResult.wrapNullable(input, errForNull, errForUndefined);\n    }\n\n    if (input instanceof Function) {\n      try {\n        const result = input();\n        return fromNullable(result, errForNull, errForUndefined);\n      } catch (error) {\n        return Result.err(error);\n      }\n    }\n\n    return fromNullable(input, errForNull, errForUndefined);\n  }\n\n  /**\n   * Returns a discriminated union for type-safe consumption of the result.\n   * When error was uncaught during transformation, it's being re-thrown here.\n   *\n   *   ```ts\n   *\n   *   const { val, err } = Result.ok('foo').unwrap();\n   *   expect(val).toBe('foo');\n   *   expect(err).toBeUndefined();\n   *\n   *   ```\n   */\n  unwrap(): Res<T, E> {\n    if (this.res.ok) {\n      return this.res;\n    }\n\n    if (this.res._uncaught) {\n      // TODO: fix, should only allow `Error` type\n      // eslint-disable-next-line @typescript-eslint/only-throw-error\n      throw this.res.err;\n    }\n\n    return this.res;\n  }\n\n  /**\n   * Returns a success value or a fallback value.\n   * When error was uncaught during transformation, it's being re-thrown here.\n   *\n   *   ```ts\n   *\n   *   const value = Result.err('bar').unwrapOr('foo');\n   *   expect(val).toBe('foo');\n   *\n   *   ```\n   */\n  unwrapOr(fallback: T): T {\n    if (this.res.ok) {\n      return this.res.val;\n    }\n\n    if (this.res._uncaught) {\n      // TODO: fix, should only allow `Error` type\n      // eslint-disable-next-line @typescript-eslint/only-throw-error\n      throw this.res.err;\n    }\n\n    return fallback;\n  }\n\n  /**\n   * Returns the ok-value or throw the error.\n   */\n  unwrapOrThrow(): T {\n    if (this.res.ok) {\n      return this.res.val;\n    }\n\n    // TODO: fix, should only allow `Error` type\n    // eslint-disable-next-line @typescript-eslint/only-throw-error\n    throw this.res.err;\n  }\n\n  /**\n   * Returns the ok-value or `null`.\n   * When error was uncaught during transformation, it's being re-thrown here.\n   */\n  unwrapOrNull(): T | null {\n    if (this.res.ok) {\n      return this.res.val;\n    }\n\n    if (this.res._uncaught) {\n      // TODO: fix, should only allow `Error` type\n      // eslint-disable-next-line @typescript-eslint/only-throw-error\n      throw this.res.err;\n    }\n\n    return null;\n  }\n\n  /**\n   * Transforms the ok-value, sync or async way.\n   *\n   * Transform functions SHOULD NOT throw.\n   * Uncaught errors are logged and wrapped to `Result._uncaught()`,\n   * which leads to re-throwing them in `unwrap()`.\n   *\n   * Zod `.safeParse()` results are converted automatically.\n   *\n   *   ```ts\n   *\n   *   // SYNC\n   *   const { val, err } = Result.ok('foo')\n   *     .transform((x) => x.length)\n   *     .unwrap();\n   *   expect(val).toBe(3);\n   *\n   *   // ASYNC\n   *   const { val, err } = await Result.wrap(\n   *     http.getJson('https://api.example.com/data.json')\n   *   )\n   *     .transform(({ body }) => body)\n   *     .unwrap();\n   *\n   *   ```\n   */\n  transform<U extends Val, EE extends Val>(\n    fn: (value: T) => Result<U, E | EE>,\n  ): Result<U, E | EE>;\n  transform<U extends Val, EE extends Val>(\n    fn: (value: T) => AsyncResult<U, E | EE>,\n  ): AsyncResult<U, E | EE>;\n  transform<U extends Val, Input = unknown>(\n    fn: (value: T) => SafeParseReturnType<Input, NonNullable<U>>,\n  ): Result<U, E | ZodError<Input>>;\n  transform<U extends Val, Input = unknown>(\n    fn: (value: T) => Promise<SafeParseReturnType<Input, NonNullable<U>>>,\n  ): AsyncResult<U, E | ZodError<Input>>;\n  transform<U extends Val, EE extends Val>(\n    fn: (value: T) => Promise<Result<U, E | EE>>,\n  ): AsyncResult<U, E | EE>;\n  transform<U extends Val>(\n    fn: (value: T) => Promise<RawValue<U>>,\n  ): AsyncResult<U, E>;\n  transform<U extends Val>(fn: (value: T) => RawValue<U>): Result<U, E>;\n  transform<U extends Val, EE extends Val, Input = unknown>(\n    fn: (\n      value: T,\n    ) =>\n      | Result<U, E | EE>\n      | AsyncResult<U, E | EE>\n      | SafeParseReturnType<Input, NonNullable<U>>\n      | Promise<SafeParseReturnType<Input, NonNullable<U>>>\n      | Promise<Result<U, E | EE>>\n      | Promise<RawValue<U>>\n      | RawValue<U>,\n  ):\n    | Result<U, E | EE | ZodError<Input>>\n    | AsyncResult<U, E | EE | ZodError<Input>> {\n    if (!this.res.ok) {\n      return Result.err(this.res.err);\n    }\n\n    try {\n      const result = fn(this.res.val);\n\n      if (result instanceof Result) {\n        return result;\n      }\n\n      if (result instanceof AsyncResult) {\n        return result;\n      }\n\n      if (isZodResult<Input, U>(result)) {\n        return fromZodResult(result);\n      }\n\n      if (result instanceof Promise) {\n        return AsyncResult.wrap(result, (err) => {\n          logger.warn({ err }, 'Result: unhandled async transform error');\n          return Result._uncaught(err);\n        });\n      }\n\n      return Result.ok(result);\n    } catch (err) {\n      logger.warn({ err }, 'Result: unhandled transform error');\n      return Result._uncaught(err);\n    }\n  }\n\n  catch<U extends Val = T, EE extends Val = E>(\n    fn: (err: E) => Result<U, EE>,\n  ): Result<T | U, EE>;\n  catch<U extends Val = T, EE extends Val = E>(\n    fn: (err: E) => AsyncResult<U, EE>,\n  ): AsyncResult<T | U, EE>;\n  catch<U extends Val = T, EE extends Val = E>(\n    fn: (err: E) => Promise<Result<U, EE>>,\n  ): AsyncResult<T | U, EE>;\n  catch<U extends Val = T, EE extends Val = E>(\n    fn: (err: E) => Result<U, EE> | AsyncResult<U, EE> | Promise<Result<U, EE>>,\n  ): Result<T | U, EE> | AsyncResult<T | U, EE> {\n    if (this.res.ok) {\n      return this as never;\n    }\n\n    if (this.res._uncaught) {\n      return this as never;\n    }\n\n    try {\n      const result = fn(this.res.err);\n\n      if (result instanceof Promise) {\n        return AsyncResult.wrap(result, (err) => {\n          logger.warn(\n            { err },\n            'Result: unexpected error in async catch handler',\n          );\n          return Result._uncaught(err);\n        });\n      }\n\n      return result;\n    } catch (err) {\n      logger.warn({ err }, 'Result: unexpected error in catch handler');\n      return Result._uncaught(err);\n    }\n  }\n\n  /**\n   * Given a `schema` and `input`, returns a `Result` with `val` being the parsed value.\n   * Additionally, `null` and `undefined` values are converted into Zod error.\n   */\n  static parse<Schema extends ZodType<any, any, any>>(\n    input: unknown,\n    schema: Schema,\n  ): Result<NonNullable<ZodOutput<Schema>>, ZodError<ZodInput<Schema>>> {\n    const parseResult = schema\n      .transform((result, ctx): NonNullable<ZodOutput<Schema>> => {\n        if (result === undefined) {\n          ctx.addIssue({\n            code: ZodIssueCode.custom,\n            message: `Result can't accept nullish values, but input was parsed by Zod schema to undefined`,\n          });\n          return NEVER;\n        }\n\n        if (result === null) {\n          ctx.addIssue({\n            code: ZodIssueCode.custom,\n            message: `Result can't accept nullish values, but input was parsed by Zod schema to null`,\n          });\n          return NEVER;\n        }\n\n        return result;\n      })\n      .safeParse(input);\n\n    return fromZodResult(parseResult);\n  }\n\n  /**\n   * Given a `schema`, returns a `Result` with `val` being the parsed value.\n   * Additionally, `null` and `undefined` values are converted into Zod error.\n   */\n  parse<Schema extends ZodType<any, any, any>>(\n    schema: Schema,\n  ): Result<NonNullable<ZodOutput<Schema>>, E | ZodError<ZodInput<Schema>>> {\n    if (this.res.ok) {\n      return Result.parse(this.res.val, schema);\n    }\n\n    const err = this.res.err;\n\n    if (this.res._uncaught) {\n      return Result._uncaught(err);\n    }\n\n    return Result.err(err);\n  }\n\n  /**\n   * Call `fn` on the `val` if the result is ok.\n   */\n  onValue(fn: (value: T) => void): Result<T, E> {\n    if (this.res.ok) {\n      try {\n        fn(this.res.val);\n      } catch (err) {\n        return Result._uncaught(err);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Call `fn` on the `err` if the result is err.\n   */\n  onError(fn: (err: E) => void): Result<T, E> {\n    if (!this.res.ok) {\n      try {\n        fn(this.res.err);\n      } catch (err) {\n        return Result._uncaught(err);\n      }\n    }\n\n    return this;\n  }\n}\n\n/**\n * This class is being used when `Result` methods encounter async code.\n * It isn't meant to be used directly, but exported for usage in type annotations.\n *\n * All the methods resemble `Result` methods, but work asynchronously.\n */\nexport class AsyncResult<T extends Val, E extends Val>\n  implements PromiseLike<Result<T, E>>\n{\n  private constructor(private asyncResult: Promise<Result<T, E>>) {}\n\n  then<TResult1 = Result<T, E>>(\n    onfulfilled?:\n      | ((value: Result<T, E>) => TResult1 | PromiseLike<TResult1>)\n      | null,\n  ): PromiseLike<TResult1> {\n    return this.asyncResult.then(onfulfilled);\n  }\n\n  static ok<T extends Val>(val: T): AsyncResult<T, never> {\n    return new AsyncResult(Promise.resolve(Result.ok(val)));\n  }\n\n  static err<E extends Val>(err: NonNullable<E>): AsyncResult<never, E> {\n    // eslint-disable-next-line promise/no-promise-in-callback\n    return new AsyncResult(Promise.resolve(Result.err(err)));\n  }\n\n  static wrap<\n    T extends Val,\n    E extends Val = Error,\n    EE extends Val = never,\n    Input = unknown,\n  >(\n    promise:\n      | Promise<SafeParseReturnType<Input, T>>\n      | Promise<Result<T, EE>>\n      | Promise<RawValue<T>>,\n    onErr?: (err: NonNullable<E>) => Result<T, E>,\n  ): AsyncResult<T, E | EE> {\n    return new AsyncResult(\n      promise\n        .then((value) => {\n          if (value instanceof Result) {\n            return value;\n          }\n\n          if (isZodResult<Input, T>(value)) {\n            return fromZodResult(value);\n          }\n\n          return Result.ok(value);\n        })\n        .catch((err) => {\n          if (onErr) {\n            return onErr(err);\n          }\n          return Result.err(err);\n        }),\n    );\n  }\n\n  static wrapNullable<\n    T extends Val,\n    E extends Val,\n    ErrForNull extends Val,\n    ErrForUndefined extends Val,\n  >(\n    promise: Promise<Nullable<T>>,\n    errForNull: NonNullable<ErrForNull>,\n    errForUndefined: NonNullable<ErrForUndefined>,\n  ): AsyncResult<T, E | ErrForNull | ErrForUndefined> {\n    return new AsyncResult(\n      promise\n        .then((value) => fromNullable(value, errForNull, errForUndefined))\n        .catch((err) => Result.err(err)),\n    );\n  }\n\n  /**\n   * Returns a discriminated union for type-safe consumption of the result.\n   *\n   *   ```ts\n   *\n   *   const { val, err } = await Result.wrap(readFile('foo.txt')).unwrap();\n   *   expect(val).toBe('foo');\n   *   expect(err).toBeUndefined();\n   *\n   *   ```\n   */\n  unwrap(): Promise<Res<T, E>> {\n    return this.asyncResult.then<Res<T, E>>((res) => res.unwrap());\n  }\n\n  /**\n   * Returns a success value or a fallback value.\n   *\n   *   ```ts\n   *\n   *   const val = await Result.wrap(readFile('foo.txt')).unwrapOr('bar');\n   *   expect(val).toBe('bar');\n   *   expect(err).toBeUndefined();\n   *\n   *   ```\n   */\n  unwrapOr(fallback: T): Promise<T> {\n    return this.asyncResult.then<T>((res) => res.unwrapOr(fallback));\n  }\n\n  /**\n   * Returns the ok-value or throw the error.\n   */\n  async unwrapOrThrow(): Promise<T> {\n    const result = await this.asyncResult;\n    return result.unwrapOrThrow();\n  }\n\n  /**\n   * Returns the ok-value or `null`.\n   */\n  unwrapOrNull(): Promise<T | null> {\n    return this.asyncResult.then<T | null>((res) => res.unwrapOrNull());\n  }\n\n  /**\n   * Transforms the ok-value, sync or async way.\n   *\n   * Transform functions SHOULD NOT throw.\n   * Uncaught errors are logged and wrapped to `Result._uncaught()`,\n   * which leads to re-throwing them in `unwrap()`.\n   *\n   * Zod `.safeParse()` results are converted automatically.\n   *\n   *   ```ts\n   *\n   *   const { val, err } = await Result.wrap(\n   *     http.getJson('https://api.example.com/data.json')\n   *   )\n   *     .transform(({ body }) => body)\n   *     .unwrap();\n   *\n   *   ```\n   */\n  transform<U extends Val, EE extends Val>(\n    fn: (value: T) => Result<U, E | EE>,\n  ): AsyncResult<U, E | EE>;\n  transform<U extends Val, EE extends Val>(\n    fn: (value: T) => AsyncResult<U, E | EE>,\n  ): AsyncResult<U, E | EE>;\n  transform<U extends Val, Input = unknown>(\n    fn: (value: T) => SafeParseReturnType<Input, NonNullable<U>>,\n  ): AsyncResult<U, E | ZodError<Input>>;\n  transform<U extends Val, Input = unknown>(\n    fn: (value: T) => Promise<SafeParseReturnType<Input, NonNullable<U>>>,\n  ): AsyncResult<U, E | ZodError<Input>>;\n  transform<U extends Val, EE extends Val>(\n    fn: (value: T) => Promise<Result<U, E | EE>>,\n  ): AsyncResult<U, E | EE>;\n  transform<U extends Val>(\n    fn: (value: T) => Promise<RawValue<U>>,\n  ): AsyncResult<U, E>;\n  transform<U extends Val>(fn: (value: T) => RawValue<U>): AsyncResult<U, E>;\n  transform<U extends Val, EE extends Val, Input = unknown>(\n    fn: (\n      value: T,\n    ) =>\n      | Result<U, E | EE>\n      | AsyncResult<U, E | EE>\n      | SafeParseReturnType<Input, NonNullable<U>>\n      | Promise<SafeParseReturnType<Input, NonNullable<U>>>\n      | Promise<Result<U, E | EE>>\n      | Promise<RawValue<U>>\n      | RawValue<U>,\n  ): AsyncResult<U, E | EE | ZodError<Input>> {\n    return new AsyncResult(\n      this.asyncResult\n        .then((oldResult) => {\n          const { ok, val: value, err: error } = oldResult.unwrap();\n          if (!ok) {\n            return Result.err(error);\n          }\n\n          try {\n            const result = fn(value);\n\n            if (result instanceof Result) {\n              return result;\n            }\n\n            if (result instanceof AsyncResult) {\n              return result;\n            }\n\n            if (isZodResult<Input, U>(result)) {\n              return fromZodResult(result);\n            }\n\n            if (result instanceof Promise) {\n              return AsyncResult.wrap(result, (err) => {\n                logger.warn(\n                  { err },\n                  'AsyncResult: unhandled async transform error',\n                );\n                return Result._uncaught(err);\n              });\n            }\n\n            return Result.ok(result);\n          } catch (err) {\n            logger.warn({ err }, 'AsyncResult: unhandled transform error');\n            return Result._uncaught(err);\n          }\n        })\n        .catch((err) => {\n          // Happens when `.unwrap()` of `oldResult` throws\n          return Result._uncaught(err);\n        }),\n    );\n  }\n\n  catch<U extends Val = T, EE extends Val = E>(\n    fn: (err: NonNullable<E>) => Result<U, EE>,\n  ): AsyncResult<T | U, EE>;\n  catch<U extends Val = T, EE extends Val = E>(\n    fn: (err: NonNullable<E>) => AsyncResult<U, EE>,\n  ): AsyncResult<T | U, EE>;\n  catch<U extends Val = T, EE extends Val = E>(\n    fn: (err: NonNullable<E>) => Promise<Result<U, EE>>,\n  ): AsyncResult<T | U, EE>;\n  catch<U extends Val = T, EE extends Val = E>(\n    fn: (\n      err: NonNullable<E>,\n    ) => Result<U, EE> | AsyncResult<U, EE> | Promise<Result<U, EE>>,\n  ): AsyncResult<T | U, EE> {\n    const caughtAsyncResult: Promise<Result<T, EE>> = this.asyncResult.then(\n      (result) =>\n        // eslint-disable-next-line promise/no-nesting\n        result.catch(fn as never),\n    );\n    return AsyncResult.wrap(caughtAsyncResult);\n  }\n\n  /**\n   * Given a `schema`, returns a `Result` with `val` being the parsed value.\n   * Additionally, `null` and `undefined` values are converted into Zod error.\n   */\n  parse<Schema extends ZodType<any, any, any>>(\n    schema: Schema,\n  ): AsyncResult<\n    NonNullable<ZodOutput<Schema>>,\n    E | ZodError<ZodInput<Schema>>\n  > {\n    return new AsyncResult(\n      this.asyncResult\n        .then((oldResult) => oldResult.parse(schema))\n        .catch(\n          /* istanbul ignore next: should never happen */\n          (err) => Result._uncaught(err),\n        ),\n    );\n  }\n\n  onValue(fn: (value: T) => void): AsyncResult<T, E> {\n    return new AsyncResult(\n      this.asyncResult\n        .then((result) => result.onValue(fn))\n        .catch(\n          /* istanbul ignore next: should never happen */\n          (err) => Result._uncaught(err),\n        ),\n    );\n  }\n\n  onError(fn: (err: E) => void): AsyncResult<T, E> {\n    return new AsyncResult(\n      this.asyncResult\n        .then((result) => result.onError(fn))\n        .catch(\n          /* istanbul ignore next: should never happen */\n          (err) => Result._uncaught(err),\n        ),\n    );\n  }\n}\n"]}