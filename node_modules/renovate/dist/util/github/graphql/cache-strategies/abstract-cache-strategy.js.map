{"version":3,"file":"abstract-cache-strategy.js","sourceRoot":"","sources":["../../../../../lib/util/github/graphql/cache-strategies/abstract-cache-strategy.ts"],"names":[],"mappings":"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","sourcesContent":["import { dequal } from 'dequal';\nimport { DateTime } from 'luxon';\nimport type { PackageCacheNamespace } from '../../../cache/package/types';\nimport type {\n  GithubDatasourceItem,\n  GithubGraphqlCacheRecord,\n  GithubGraphqlCacheStrategy,\n} from '../types';\nimport { isDateExpired } from '../util';\n\n/**\n * Cache strategy handles the caching Github GraphQL items\n * and reconciling them with newly obtained ones from paginated queries.\n */\nexport abstract class AbstractGithubGraphqlCacheStrategy<\n  GithubItem extends GithubDatasourceItem,\n> implements GithubGraphqlCacheStrategy<GithubItem>\n{\n  /**\n   * Time period after which a cache record is considered expired.\n   */\n  protected static readonly cacheTTLDays = 30;\n\n  /**\n   * The time which is used during single cache access cycle.\n   */\n  protected readonly now = DateTime.now().toUTC();\n\n  /**\n   * Set of all versions which were reconciled\n   * during the current cache access cycle.\n   */\n  private reconciledVersions: Set<string> | undefined;\n\n  /**\n   * These fields will be persisted.\n   */\n  private items: Record<string, GithubItem> | undefined;\n  protected createdAt: DateTime = this.now;\n\n  /**\n   * This flag indicates whether there is any new or updated items\n   */\n  protected hasNovelty = false;\n\n  /**\n   * Loading and persisting data is delegated to the concrete strategy.\n   */\n  abstract load(): Promise<GithubGraphqlCacheRecord<GithubItem> | undefined>;\n  abstract persist(\n    cacheRecord: GithubGraphqlCacheRecord<GithubItem>,\n  ): Promise<void>;\n\n  constructor(\n    protected readonly cacheNs: PackageCacheNamespace,\n    protected readonly cacheKey: string,\n  ) {}\n\n  /**\n   * Load data previously persisted by this strategy\n   * for given `cacheNs` and `cacheKey`.\n   */\n  private async getItems(): Promise<Record<string, GithubItem>> {\n    if (this.items) {\n      return this.items;\n    }\n\n    let result: GithubGraphqlCacheRecord<GithubItem> = {\n      items: {},\n      createdAt: this.createdAt.toISO()!,\n    };\n\n    const storedData = await this.load();\n    if (storedData) {\n      const cacheTTLDuration = {\n        hours: AbstractGithubGraphqlCacheStrategy.cacheTTLDays * 24,\n      };\n      if (!isDateExpired(this.now, storedData.createdAt, cacheTTLDuration)) {\n        result = storedData;\n      }\n    }\n\n    this.createdAt = DateTime.fromISO(result.createdAt).toUTC();\n    this.items = result.items;\n    return this.items;\n  }\n\n  /**\n   * If package release exists longer than this cache can exist,\n   * we assume it won't updated/removed on the Github side.\n   */\n  private isStabilized(item: GithubItem): boolean {\n    const unstableDuration = {\n      hours: AbstractGithubGraphqlCacheStrategy.cacheTTLDays * 24,\n    };\n    return isDateExpired(this.now, item.releaseTimestamp, unstableDuration);\n  }\n\n  /**\n   * Process items received from GraphQL page\n   * ordered by `releaseTimestamp` in descending order\n   * (fresh versions go first).\n   */\n  async reconcile(items: GithubItem[]): Promise<boolean> {\n    const cachedItems = await this.getItems();\n\n    let isPaginationDone = false;\n    for (const item of items) {\n      const { version } = item;\n      const oldItem = cachedItems[version];\n\n      // If we reached previously stored item that is stabilized,\n      // we assume the further pagination will not yield any new items.\n      //\n      // However, we don't break the loop here, allowing to reconcile\n      // the entire page of items. This protects us from unusual cases\n      // when release authors intentionally break the timeline. Therefore,\n      // while it feels appealing to break early, please don't do that.\n      if (oldItem && this.isStabilized(oldItem)) {\n        isPaginationDone = true;\n      }\n\n      // Check if item is new or updated\n      if (!oldItem || !dequal(oldItem, item)) {\n        this.hasNovelty = true;\n      }\n\n      cachedItems[version] = item;\n      this.reconciledVersions ??= new Set();\n      this.reconciledVersions.add(version);\n    }\n\n    this.items = cachedItems;\n    return isPaginationDone;\n  }\n\n  /**\n   * Handle removed items for packages that are not stabilized\n   * and return the list of all items.\n   */\n  async finalizeAndReturn(): Promise<GithubItem[]> {\n    const cachedItems = await this.getItems();\n    let resultItems: Record<string, GithubItem>;\n\n    let hasDeletedItems = false;\n    if (this.reconciledVersions) {\n      resultItems = {};\n      for (const [version, item] of Object.entries(cachedItems)) {\n        if (this.reconciledVersions.has(version) || this.isStabilized(item)) {\n          resultItems[version] = item;\n        } else {\n          hasDeletedItems = true;\n        }\n      }\n    } else {\n      resultItems = cachedItems;\n    }\n\n    if (this.hasNovelty || hasDeletedItems) {\n      await this.store(resultItems);\n    }\n\n    return Object.values(resultItems);\n  }\n\n  private async store(cachedItems: Record<string, GithubItem>): Promise<void> {\n    const cacheRecord: GithubGraphqlCacheRecord<GithubItem> = {\n      items: cachedItems,\n      createdAt: this.createdAt.toISO()!,\n    };\n    await this.persist(cacheRecord);\n  }\n}\n"]}