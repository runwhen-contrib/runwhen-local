{"version":3,"file":"host-rules.js","sourceRoot":"","sources":["../../lib/util/host-rules.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { logger } from '../logger';\nimport type { CombinedHostRule, HostRule } from '../types';\nimport { clone } from './clone';\nimport * as sanitize from './sanitize';\nimport { toBase64 } from './string';\nimport { isHttpUrl, massageHostUrl, parseUrl } from './url';\n\nlet hostRules: HostRule[] = [];\n\nexport interface LegacyHostRule {\n  hostName?: string;\n  domainName?: string;\n  baseUrl?: string;\n  host?: string;\n  endpoint?: string;\n}\n\nexport function migrateRule(rule: LegacyHostRule & HostRule): HostRule {\n  const cloned: LegacyHostRule & HostRule = clone(rule);\n  delete cloned.hostName;\n  delete cloned.domainName;\n  delete cloned.baseUrl;\n  const result: HostRule = cloned;\n\n  const { matchHost } = result;\n  const { hostName, domainName, baseUrl } = rule;\n  const hostValues = [matchHost, hostName, domainName, baseUrl].filter(Boolean);\n  if (hostValues.length === 1) {\n    const [matchHost] = hostValues;\n    result.matchHost = matchHost;\n  } else if (hostValues.length > 1) {\n    throw new Error(\n      `hostRules cannot contain more than one host-matching field - use \"matchHost\" only.`,\n    );\n  }\n\n  return result;\n}\n\nexport function add(params: HostRule): void {\n  const rule = migrateRule(params);\n\n  const confidentialFields: (keyof HostRule)[] = ['password', 'token'];\n  if (rule.matchHost) {\n    rule.matchHost = massageHostUrl(rule.matchHost);\n    const parsedUrl = parseUrl(rule.matchHost);\n    rule.resolvedHost = parsedUrl?.hostname ?? rule.matchHost;\n    confidentialFields.forEach((field) => {\n      if (rule[field]) {\n        logger.debug(\n          // TODO: types (#22198)\n          `Adding ${field} authentication for ${rule.matchHost!} (hostType=${\n            rule.hostType\n          }) to hostRules`,\n        );\n      }\n    });\n  }\n  confidentialFields.forEach((field) => {\n    const secret = rule[field];\n    if (is.string(secret) && secret.length > 3) {\n      sanitize.addSecretForSanitizing(secret);\n    }\n  });\n  if (rule.username && rule.password) {\n    sanitize.addSecretForSanitizing(\n      toBase64(`${rule.username}:${rule.password}`),\n    );\n  }\n  hostRules.push(rule);\n}\n\nexport interface HostRuleSearch {\n  hostType?: string;\n  url?: string;\n  readOnly?: boolean;\n}\n\nexport function matchesHost(url: string, matchHost: string): boolean {\n  if (isHttpUrl(url) && isHttpUrl(matchHost)) {\n    return url.startsWith(matchHost);\n  }\n\n  const parsedUrl = parseUrl(url);\n  if (!parsedUrl) {\n    return false;\n  }\n\n  const { hostname } = parsedUrl;\n  if (!hostname) {\n    return false;\n  }\n\n  if (hostname === matchHost) {\n    return true;\n  }\n\n  const topLevelSuffix = matchHost.startsWith('.')\n    ? matchHost\n    : `.${matchHost}`;\n  return hostname.endsWith(topLevelSuffix);\n}\n\nfunction fromShorterToLongerMatchHost(a: HostRule, b: HostRule): number {\n  if (!a.matchHost || !b.matchHost) {\n    return 0;\n  }\n  return a.matchHost.length - b.matchHost.length;\n}\n\nfunction hostRuleRank({ hostType, matchHost, readOnly }: HostRule): number {\n  if ((hostType || readOnly) && matchHost) {\n    return 3;\n  }\n\n  if (matchHost) {\n    return 2;\n  }\n\n  if (hostType) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction fromLowerToHigherRank(a: HostRule, b: HostRule): number {\n  return hostRuleRank(a) - hostRuleRank(b);\n}\n\nexport function find(search: HostRuleSearch): CombinedHostRule {\n  if ([search.hostType, search.url].every(is.falsy)) {\n    logger.warn({ search }, 'Invalid hostRules search');\n    return {};\n  }\n\n  // Sort primarily by rank, and secondarily by matchHost length\n  const sortedRules = hostRules\n    .sort(fromShorterToLongerMatchHost)\n    .sort(fromLowerToHigherRank);\n\n  const matchedRules: HostRule[] = [];\n  for (const rule of sortedRules) {\n    let hostTypeMatch = true;\n    let hostMatch = true;\n    let readOnlyMatch = true;\n\n    if (rule.hostType) {\n      hostTypeMatch = false;\n      if (search.hostType === rule.hostType) {\n        hostTypeMatch = true;\n      }\n    }\n\n    if (rule.matchHost && rule.resolvedHost) {\n      hostMatch = false;\n      if (search.url) {\n        hostMatch = matchesHost(search.url, rule.matchHost);\n      }\n    }\n\n    if (!is.undefined(rule.readOnly)) {\n      readOnlyMatch = false;\n      if (search.readOnly === rule.readOnly) {\n        readOnlyMatch = true;\n        hostTypeMatch = true; // When we match `readOnly`, we don't care about `hostType`\n      }\n    }\n\n    if (hostTypeMatch && readOnlyMatch && hostMatch) {\n      matchedRules.push(clone(rule));\n    }\n  }\n\n  const res: HostRule = Object.assign({}, ...matchedRules);\n  delete res.hostType;\n  delete res.resolvedHost;\n  delete res.matchHost;\n  delete res.readOnly;\n  return res;\n}\n\nexport function hosts({ hostType }: { hostType: string }): string[] {\n  return hostRules\n    .filter((rule) => rule.hostType === hostType)\n    .map((rule) => rule.resolvedHost)\n    .filter(is.truthy);\n}\n\nexport function hostType({ url }: { url: string }): string | null {\n  return (\n    hostRules\n      .filter((rule) => rule.matchHost && matchesHost(url, rule.matchHost))\n      .sort(fromShorterToLongerMatchHost)\n      .map((rule) => rule.hostType)\n      .filter(is.truthy)\n      .pop() ?? null\n  );\n}\n\nexport function findAll({ hostType }: { hostType: string }): HostRule[] {\n  return hostRules.filter((rule) => rule.hostType === hostType);\n}\n\n/**\n * @returns a deep copy of all known host rules without any filtering\n */\nexport function getAll(): HostRule[] {\n  return clone(hostRules);\n}\n\nexport function clear(): void {\n  logger.debug('Clearing hostRules');\n  hostRules = [];\n  sanitize.clearRepoSanitizedSecretsList();\n}\n"]}