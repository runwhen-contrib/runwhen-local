{"version":3,"file":"promises.js","sourceRoot":"","sources":["../../lib/util/promises.ts"],"names":[],"mappings":";;AAqCA,kBAcC;AAED,kBAeC;;AApED,8EAA6C;AAC7C,0DAAyB;AACzB,0DAAyB;AACzB,sCAAmC;AACnC,6EAAwE;AAIxE,SAAS,mBAAmB,CAAC,GAAQ;IACnC,OAAO,GAAG,YAAY,uCAAiB,CAAC;AAC1C,CAAC;AAED,SAAS,oBAAoB,CAAC,MAAe;IAC3C,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;IACnD,IAAI,SAAS,EAAE,CAAC;QACd,MAAM,SAAS,CAAC;IAClB,CAAC;IACD,IACE,MAAM,CAAC,MAAM,KAAK,CAAC;QACnB,IAAI,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,EACxD,CAAC;QACD,MAAM,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC;QACvB,MAAM,KAAK,CAAC;IACd,CAAC;IAED,MAAM,IAAI,yBAAc,CAAC,MAAM,CAAC,CAAC;AACnC,CAAC;AAED,SAAS,WAAW,CAAC,GAAQ;IAC3B,IAAI,CAAC,CAAC,GAAG,YAAY,yBAAc,CAAC,EAAE,CAAC;QACrC,MAAM,GAAG,CAAC;IACZ,CAAC;IAED,eAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,EAAE,2BAA2B,CAAC,CAAC;IACnD,oBAAoB,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AACjC,CAAC;AAEM,KAAK,UAAU,GAAG,CACvB,KAA0B,EAC1B,OAAsB;IAEtB,IAAI,CAAC;QACH,MAAM,GAAG,GAAG,MAAM,IAAA,eAAI,EAAC,KAAK,EAAE;YAC5B,WAAW,EAAE,CAAC;YACd,WAAW,EAAE,KAAK;YAClB,GAAG,OAAO;SACX,CAAC,CAAC;QACH,OAAO,GAAG,CAAC;IACb,CAAC;IAAC,OAAO,GAAG,EAAE,CAAC;QACb,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC;IAC1B,CAAC;AACH,CAAC;AAEM,KAAK,UAAU,GAAG,CACvB,KAAwB,EACxB,MAAwC,EACxC,OAAsB;IAEtB,IAAI,CAAC;QACH,MAAM,GAAG,GAAG,MAAM,IAAA,eAAI,EAAC,KAAK,EAAE,MAAM,EAAE;YACpC,WAAW,EAAE,CAAC;YACd,WAAW,EAAE,KAAK;YAClB,GAAG,OAAO;SACX,CAAC,CAAC;QACH,OAAO,GAAG,CAAC;IACb,CAAC;IAAC,OAAO,GAAG,EAAE,CAAC;QACb,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC;IAC1B,CAAC;AACH,CAAC","sourcesContent":["import AggregateError from 'aggregate-error';\nimport pAll from 'p-all';\nimport pMap from 'p-map';\nimport { logger } from '../logger';\nimport { ExternalHostError } from '../types/errors/external-host-error';\n\ntype PromiseFactory<T> = () => Promise<T>;\n\nfunction isExternalHostError(err: any): err is ExternalHostError {\n  return err instanceof ExternalHostError;\n}\n\nfunction handleMultipleErrors(errors: Error[]): never {\n  const hostError = errors.find(isExternalHostError);\n  if (hostError) {\n    throw hostError;\n  }\n  if (\n    errors.length === 1 ||\n    new Set(errors.map(({ message }) => message)).size === 1\n  ) {\n    const [error] = errors;\n    throw error;\n  }\n\n  throw new AggregateError(errors);\n}\n\nfunction handleError(err: any): never {\n  if (!(err instanceof AggregateError)) {\n    throw err;\n  }\n\n  logger.debug({ err }, 'Aggregate error is thrown');\n  handleMultipleErrors([...err]);\n}\n\nexport async function all<T>(\n  tasks: PromiseFactory<T>[],\n  options?: pAll.Options,\n): Promise<T[]> {\n  try {\n    const res = await pAll(tasks, {\n      concurrency: 5,\n      stopOnError: false,\n      ...options,\n    });\n    return res;\n  } catch (err) {\n    return handleError(err);\n  }\n}\n\nexport async function map<Element, NewElement>(\n  input: Iterable<Element>,\n  mapper: pMap.Mapper<Element, NewElement>,\n  options?: pMap.Options,\n): Promise<NewElement[]> {\n  try {\n    const res = await pMap(input, mapper, {\n      concurrency: 5,\n      stopOnError: false,\n      ...options,\n    });\n    return res;\n  } catch (err) {\n    return handleError(err);\n  }\n}\n"]}