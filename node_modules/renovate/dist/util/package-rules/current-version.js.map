{"version":3,"file":"current-version.js","sourceRoot":"","sources":["../../../lib/util/package-rules/current-version.ts"],"names":[],"mappings":";;;;AAAA,kEAAkC;AAElC,yCAAsC;AACtC,gFAA0D;AAC1D,kDAAoD;AACpD,iCAAiC;AAEjC,MAAa,qBAAsB,SAAQ,cAAO;IACvC,OAAO,CACd,EACE,UAAU,EACV,aAAa,EACb,YAAY,EACZ,cAAc,GACS,EACzB,EAAE,mBAAmB,EAAe;QAEpC,IAAI,YAAE,CAAC,SAAS,CAAC,mBAAmB,CAAC,EAAE,CAAC;YACtC,OAAO,IAAI,CAAC;QACd,CAAC;QACD,MAAM,oBAAoB,GACxB,CAAC,CAAC,aAAa,IAAI,YAAE,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC;QACtD,MAAM,aAAa,GAAG,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QACpD,MAAM,sBAAsB,GAAG,mBAAmB,CAAC,QAAQ,EAAE,CAAC;QAC9D,MAAM,uBAAuB,GAAG,IAAA,gCAAiB,EAAC,sBAAsB,CAAC,CAAC;QAE1E,IAAI,uBAAuB,EAAE,CAAC;YAC5B,MAAM,cAAc,GAAG,aAAa,IAAI,cAAc,IAAI,YAAY,CAAC;YACvE,OAAO,CACL,CAAC,YAAE,CAAC,eAAe,CAAC,cAAc,CAAC;gBACnC,uBAAuB,CAAC,cAAc,CAAC,CACxC,CAAC;QACJ,CAAC;QACD,IAAI,aAAa,CAAC,SAAS,CAAC,sBAAsB,CAAC,EAAE,CAAC;YACpD,IAAI,CAAC;gBACH,OAAO,CACL,oBAAoB;oBACpB,CAAC,CAAC,CACA,YAAY;wBACZ,aAAa,CAAC,OAAO,CAAC,YAAY,CAAC;wBACnC,aAAa,CAAC,OAAO,CAAC,sBAAsB,EAAE,YAAY,CAAC,CAC5D,CACF,CAAC;YACJ,CAAC;YAAC,MAAM,CAAC;gBACP,OAAO,KAAK,CAAC;YACf,CAAC;QACH,CAAC;QAED,MAAM,cAAc,GAAG,aAAa,CAAC,SAAS,CAAC,YAAY,CAAC;YAC1D,CAAC,CAAC,YAAY,CAAC,4CAA4C;YAC3D,CAAC,CAAC,CAAC,aAAa,IAAI,cAAc,CAAC,CAAC,CAAC,0DAA0D;QACjG,IAAI,YAAE,CAAC,eAAe,CAAC,cAAc,CAAC,EAAE,CAAC;YACvC,OAAO,KAAK,CAAC;QACf,CAAC;QACD,IAAI,aAAa,CAAC,SAAS,CAAC,cAAc,CAAC,EAAE,CAAC;YAC5C,OAAO,aAAa,CAAC,OAAO,CAAC,cAAc,EAAE,mBAAmB,CAAC,CAAC;QACpE,CAAC;QACD,eAAM,CAAC,KAAK,CACV,EAAE,sBAAsB,EAAE,YAAY,EAAE,EACxC,qCAAqC,CACtC,CAAC;QACF,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAxDD,sDAwDC","sourcesContent":["import is from '@sindresorhus/is';\nimport type { PackageRule, PackageRuleInputConfig } from '../../config/types';\nimport { logger } from '../../logger';\nimport * as allVersioning from '../../modules/versioning';\nimport { getRegexPredicate } from '../string-match';\nimport { Matcher } from './base';\n\nexport class CurrentVersionMatcher extends Matcher {\n  override matches(\n    {\n      versioning,\n      lockedVersion,\n      currentValue,\n      currentVersion,\n    }: PackageRuleInputConfig,\n    { matchCurrentVersion }: PackageRule,\n  ): boolean | null {\n    if (is.undefined(matchCurrentVersion)) {\n      return null;\n    }\n    const isUnconstrainedValue =\n      !!lockedVersion && is.nullOrUndefined(currentValue);\n    const versioningApi = allVersioning.get(versioning);\n    const matchCurrentVersionStr = matchCurrentVersion.toString();\n    const matchCurrentVersionPred = getRegexPredicate(matchCurrentVersionStr);\n\n    if (matchCurrentVersionPred) {\n      const compareVersion = lockedVersion ?? currentVersion ?? currentValue;\n      return (\n        !is.nullOrUndefined(compareVersion) &&\n        matchCurrentVersionPred(compareVersion)\n      );\n    }\n    if (versioningApi.isVersion(matchCurrentVersionStr)) {\n      try {\n        return (\n          isUnconstrainedValue ||\n          !!(\n            currentValue &&\n            versioningApi.isValid(currentValue) &&\n            versioningApi.matches(matchCurrentVersionStr, currentValue)\n          )\n        );\n      } catch {\n        return false;\n      }\n    }\n\n    const compareVersion = versioningApi.isVersion(currentValue)\n      ? currentValue // it's a version so we can match against it\n      : (lockedVersion ?? currentVersion); // need to match against this currentVersion, if available\n    if (is.nullOrUndefined(compareVersion)) {\n      return false;\n    }\n    if (versioningApi.isVersion(compareVersion)) {\n      return versioningApi.matches(compareVersion, matchCurrentVersion);\n    }\n    logger.debug(\n      { matchCurrentVersionStr, currentValue },\n      'Could not find a version to compare',\n    );\n    return false;\n  }\n}\n"]}