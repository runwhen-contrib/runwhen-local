{"version":3,"file":"jsonata.js","sourceRoot":"","sources":["../../../lib/util/package-rules/jsonata.ts"],"names":[],"mappings":";;;AACA,yCAAsC;AACtC,wCAA2C;AAC3C,iCAAiC;AAEjC,MAAa,cAAe,SAAQ,cAAO;IAChC,KAAK,CAAC,OAAO,CACpB,WAAmC,EACnC,EAAE,YAAY,EAAe;QAE7B,IAAI,CAAC,YAAY,EAAE,CAAC;YAClB,OAAO,IAAI,CAAC;QACd,CAAC;QAED,KAAK,MAAM,aAAa,IAAI,YAAY,EAAE,CAAC;YACzC,MAAM,UAAU,GAAG,IAAA,uBAAa,EAAC,aAAa,CAAC,CAAC;YAChD,IAAI,UAAU,YAAY,KAAK,EAAE,CAAC;gBAChC,eAAM,CAAC,IAAI,CACT,EAAE,YAAY,EAAE,UAAU,CAAC,OAAO,EAAE,EACpC,4BAA4B,CAC7B,CAAC;YACJ,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC;oBACH,MAAM,MAAM,GAAG,MAAM,UAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;oBACtD,IAAI,MAAM,EAAE,CAAC;wBACX,2CAA2C;wBAC3C,OAAO,IAAI,CAAC;oBACd,CAAC;gBACH,CAAC;gBAAC,OAAO,GAAG,EAAE,CAAC;oBACb,eAAM,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE,qCAAqC,CAAC,CAAC;gBAC9D,CAAC;YACH,CAAC;QACH,CAAC;QACD,gCAAgC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AA/BD,wCA+BC","sourcesContent":["import type { PackageRule, PackageRuleInputConfig } from '../../config/types';\nimport { logger } from '../../logger';\nimport { getExpression } from '../jsonata';\nimport { Matcher } from './base';\n\nexport class JsonataMatcher extends Matcher {\n  override async matches(\n    inputConfig: PackageRuleInputConfig,\n    { matchJsonata }: PackageRule,\n  ): Promise<boolean | null> {\n    if (!matchJsonata) {\n      return null;\n    }\n\n    for (const expressionStr of matchJsonata) {\n      const expression = getExpression(expressionStr);\n      if (expression instanceof Error) {\n        logger.warn(\n          { errorMessage: expression.message },\n          'Invalid JSONata expression',\n        );\n      } else {\n        try {\n          const result = await expression.evaluate(inputConfig);\n          if (result) {\n            // Only one needs to match, so return early\n            return true;\n          }\n        } catch (err) {\n          logger.warn({ err }, 'Error evaluating JSONata expression');\n        }\n      }\n    }\n    // None matched, so return false\n    return false;\n  }\n}\n"]}