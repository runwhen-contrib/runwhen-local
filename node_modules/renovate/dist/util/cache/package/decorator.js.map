{"version":3,"file":"decorator.js","sourceRoot":"","sources":["../../../../lib/util/cache/package/decorator.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { DateTime } from 'luxon';\nimport { GlobalConfig } from '../../../config/global';\nimport { logger } from '../../../logger';\nimport type { Decorator } from '../../decorator';\nimport { decorate } from '../../decorator';\nimport { acquireLock } from '../../mutex';\nimport { resolveTtlValues } from './ttl';\nimport type { DecoratorCachedRecord, PackageCacheNamespace } from './types';\nimport * as packageCache from '.';\n\ntype HashFunction<T extends any[] = any[]> = (...args: T) => string;\ntype NamespaceFunction<T extends any[] = any[]> = (\n  ...args: T\n) => PackageCacheNamespace;\ntype BooleanFunction<T extends any[] = any[]> = (...args: T) => boolean;\n\n/**\n * The cache decorator parameters.\n */\ninterface CacheParameters {\n  /**\n   * The cache namespace\n   * Either a string or a hash function that generates a string\n   */\n  namespace: PackageCacheNamespace | NamespaceFunction;\n\n  /**\n   * The cache key\n   * Either a string or a hash function that generates a string\n   */\n  key: string | HashFunction;\n\n  /**\n   * A function that returns true if a result is cacheable\n   * Used to prevent caching of private, sensitive, results\n   */\n  cacheable?: BooleanFunction;\n\n  /**\n   * The TTL (or expiry) of the key in minutes\n   */\n  ttlMinutes?: number;\n}\n\n/**\n * caches the result of a decorated method.\n */\nexport function cache<T>({\n  namespace,\n  key,\n  cacheable = () => true,\n  ttlMinutes = 30,\n}: CacheParameters): Decorator<T> {\n  return decorate(async ({ args, instance, callback, methodName }) => {\n    const cachePrivatePackages = GlobalConfig.get(\n      'cachePrivatePackages',\n      false,\n    );\n    const isCacheable = cachePrivatePackages || cacheable.apply(instance, args);\n    if (!isCacheable) {\n      return callback();\n    }\n\n    let finalNamespace: PackageCacheNamespace | undefined;\n    if (is.string(namespace)) {\n      finalNamespace = namespace;\n    } else if (is.function_(namespace)) {\n      finalNamespace = namespace.apply(instance, args);\n    }\n\n    let finalKey: string | undefined;\n    if (is.string(key)) {\n      finalKey = key;\n    } else if (is.function_(key)) {\n      finalKey = key.apply(instance, args);\n    }\n\n    // istanbul ignore if\n    if (!finalNamespace || !finalKey) {\n      return callback();\n    }\n\n    finalKey = `cache-decorator:${finalKey}`;\n\n    // prevent concurrent processing and cache writes\n    const releaseLock = await acquireLock(finalKey, finalNamespace);\n\n    try {\n      const oldRecord = await packageCache.get<DecoratorCachedRecord>(\n        finalNamespace,\n        finalKey,\n      );\n\n      const ttlValues = resolveTtlValues(finalNamespace, ttlMinutes);\n      const softTtl = ttlValues.softTtlMinutes;\n      const hardTtl =\n        methodName === 'getReleases' || methodName === 'getDigest'\n          ? ttlValues.hardTtlMinutes\n          : // Skip two-tier TTL for any intermediate data fetching\n            softTtl;\n\n      let oldData: unknown;\n      if (oldRecord) {\n        const now = DateTime.local();\n        const cachedAt = DateTime.fromISO(oldRecord.cachedAt);\n\n        const softDeadline = cachedAt.plus({ minutes: softTtl });\n        if (now < softDeadline) {\n          return oldRecord.value;\n        }\n\n        const hardDeadline = cachedAt.plus({ minutes: hardTtl });\n        if (now < hardDeadline) {\n          oldData = oldRecord.value;\n        }\n      }\n\n      let newData: unknown;\n      if (oldData) {\n        try {\n          newData = (await callback()) as T | undefined;\n        } catch (err) {\n          logger.debug(\n            { err },\n            'Package cache decorator: callback error, returning old data',\n          );\n          return oldData;\n        }\n      } else {\n        newData = (await callback()) as T | undefined;\n      }\n\n      if (!is.undefined(newData)) {\n        const newRecord: DecoratorCachedRecord = {\n          cachedAt: DateTime.local().toISO(),\n          value: newData,\n        };\n        await packageCache.set(finalNamespace, finalKey, newRecord, hardTtl);\n      }\n\n      return newData;\n    } finally {\n      releaseLock();\n    }\n  });\n}\n"]}