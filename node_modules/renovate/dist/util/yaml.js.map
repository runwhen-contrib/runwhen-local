{"version":3,"file":"yaml.js","sourceRoot":"","sources":["../../lib/util/yaml.ts"],"names":[],"mappings":";;AA0DA,8BAoDC;AAaD,0CAaC;AAUD,0DAeC;AAED,oBAEC;AA7JD,+BAAmE;AAEnE,sCAAmC;AACnC,qCAA0C;AAgC1C;;;;;;;;;;;;;;GAcG;AACH,SAAgB,SAAS,CACvB,OAAe,EACf,OAAmC;IAEnC,MAAM,eAAe,GAAG,cAAc,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IAEzD,MAAM,YAAY,GAAG,IAAA,wBAAiB,EACpC,eAAe,EACf,kBAAkB,CAAC,OAAO,CAAC,CAC5B,CAAC;IAEF,MAAM,MAAM,GAAG,OAAO,EAAE,YAAY,CAAC;IAErC,MAAM,OAAO,GAAW,EAAE,CAAC;IAC3B,KAAK,MAAM,WAAW,IAAI,YAAY,EAAE,CAAC;QACvC,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;QAClC,2BAA2B;QAC3B,IAAI,MAAM,EAAE,MAAM,EAAE,CAAC;YACnB,MAAM,KAAK,GAAG,IAAI,cAAc,CAAC,MAAM,EAAE,2BAA2B,CAAC,CAAC;YACtE,IAAI,OAAO,EAAE,gBAAgB,KAAK,QAAQ,EAAE,CAAC;gBAC3C,eAAM,CAAC,KAAK,CAAC,2BAA2B,CAAC,CAAC;gBAC1C,SAAS;YACX,CAAC;YACD,MAAM,KAAK,CAAC;QACd,CAAC;QAED,MAAM,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,EAAE,aAAa,EAAE,KAAK,EAAE,CAAC,CAAC;QAE5D,kDAAkD;QAClD,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,OAAO,CAAC,IAAI,CAAC,QAAgB,CAAC,CAAC;YAC/B,SAAS;QACX,CAAC;QAED,MAAM,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;QAC1C,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;YACnB,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC1B,SAAS;QACX,CAAC;QAED,kCAAkC;QAClC,IAAI,OAAO,EAAE,gBAAgB,KAAK,QAAQ,EAAE,CAAC;YAC3C,eAAM,CAAC,KAAK,CACV,EAAE,KAAK,EAAE,MAAM,CAAC,KAAK,EAAE,QAAQ,EAAE,EACjC,iCAAiC,CAClC,CAAC;YACF,SAAS;QACX,CAAC;QACD,MAAM,IAAI,KAAK,CAAC,2BAA2B,EAAE,EAAE,KAAK,EAAE,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;IACxE,CAAC;IAED,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,eAAe,CAC7B,OAAe,EACf,OAA2B;IAE3B,MAAM,WAAW,GAAG,uBAAuB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IAE9D,MAAM,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,EAAE,aAAa,EAAE,KAAK,EAAE,CAAC,CAAC;IAC5D,MAAM,MAAM,GAAG,OAAO,EAAE,YAAY,CAAC;IACrC,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO,QAAgB,CAAC;IAC1B,CAAC;IAED,OAAO,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;AAChC,CAAC;AAED;;;;;;;GAOG;AACH,SAAgB,uBAAuB,CACrC,OAAe,EACf,OAAkC;IAElC,MAAM,eAAe,GAAG,cAAc,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IACzD,MAAM,WAAW,GAAG,IAAA,oBAAa,EAC/B,eAAe,EACf,kBAAkB,CAAC,OAAO,CAAC,CAC5B,CAAC;IAEF,IAAI,WAAW,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC;QAChC,MAAM,IAAI,cAAc,CAAC,WAAW,CAAC,MAAM,EAAE,2BAA2B,CAAC,CAAC;IAC5E,CAAC;IAED,OAAO,WAAW,CAAC;AACrB,CAAC;AAED,SAAgB,IAAI,CAAC,GAAQ,EAAE,IAAkB;IAC/C,OAAO,IAAA,gBAAS,EAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAC9B,CAAC;AAED,SAAS,cAAc,CAAC,OAAe,EAAE,OAAqB;IAC5D,IAAI,OAAO,EAAE,eAAe,EAAE,CAAC;QAC7B,OAAO,IAAA,uBAAc,EAAC,OAAO,CAAC,CAAC;IACjC,CAAC;IAED,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,SAAS,kBAAkB,CAAC,OAAgC;IAC1D,OAAO;QACL,YAAY,EAAE,IAAI;QAClB,0FAA0F;QAC1F,UAAU,EAAE,CAAC,OAAO,EAAE,eAAe;QACrC,MAAM,EAAE,KAAK;QACb,GAAG,OAAO;KACX,CAAC;AACJ,CAAC","sourcesContent":["import type {\n  CreateNodeOptions,\n  Document,\n  DocumentOptions,\n  ParseOptions,\n  SchemaOptions,\n  ToStringOptions,\n} from 'yaml';\nimport { parseAllDocuments, parseDocument, stringify } from 'yaml';\nimport type { ZodType } from 'zod';\nimport { logger } from '../logger';\nimport { stripTemplates } from './string';\n\nexport interface YamlOptions<\n  ResT = unknown,\n  Schema extends ZodType<ResT> = ZodType<ResT>,\n> extends ParseOptions,\n    DocumentOptions,\n    SchemaOptions {\n  customSchema?: Schema;\n  removeTemplates?: boolean;\n}\n\ninterface YamlParseDocumentOptions\n  extends ParseOptions,\n    DocumentOptions,\n    SchemaOptions {\n  removeTemplates?: boolean;\n}\n\nexport interface YamlOptionsMultiple<\n  ResT = unknown,\n  Schema extends ZodType<ResT> = ZodType<ResT>,\n> extends YamlOptions<ResT, Schema> {\n  failureBehaviour?: 'throw' | 'filter';\n}\n\nexport type DumpOptions = DocumentOptions &\n  SchemaOptions &\n  ParseOptions &\n  CreateNodeOptions &\n  ToStringOptions;\n\n/**\n * Parse a YAML string into a JavaScript object.\n *\n * Multiple documents are supported.\n *\n * If a schema is provided, the parsed object will be validated against it.\n *\n * If failureBehaviour is set to 'filter',\n *      the function will return an empty array if the YAML parsing or schema validation fails and therefore will not throw an error.\n *\n * If failureBehaviour is set to 'throw',\n *      the function will throw an error if the YAML parsing or schema validation fails for ANY document.\n * @param content\n * @param options\n */\nexport function parseYaml<ResT = unknown>(\n  content: string,\n  options?: YamlOptionsMultiple<ResT>,\n): ResT[] {\n  const massagedContent = massageContent(content, options);\n\n  const rawDocuments = parseAllDocuments(\n    massagedContent,\n    prepareParseOption(options),\n  );\n\n  const schema = options?.customSchema;\n\n  const results: ResT[] = [];\n  for (const rawDocument of rawDocuments) {\n    const errors = rawDocument.errors;\n    // handle YAML parse errors\n    if (errors?.length) {\n      const error = new AggregateError(errors, 'Failed to parse YAML file');\n      if (options?.failureBehaviour === 'filter') {\n        logger.debug(`Failed to parse YAML file`);\n        continue;\n      }\n      throw error;\n    }\n\n    const document = rawDocument.toJS({ maxAliasCount: 10000 });\n\n    // skip schema validation if no schema is provided\n    if (!schema) {\n      results.push(document as ResT);\n      continue;\n    }\n\n    const result = schema.safeParse(document);\n    if (result.success) {\n      results.push(result.data);\n      continue;\n    }\n\n    // handle schema validation errors\n    if (options?.failureBehaviour === 'filter') {\n      logger.trace(\n        { error: result.error, document },\n        'Failed to parse schema for YAML',\n      );\n      continue;\n    }\n    throw new Error('Failed to parse YAML file', { cause: result.error });\n  }\n\n  return results;\n}\n\n/**\n * Parse a YAML string into a JavaScript object.\n *\n * Only a single document is supported.\n *\n * If a schema is provided, the parsed object will be validated against it.\n * Should the YAML parsing or schemata validation fail, an error will be thrown.\n *\n * @param content\n * @param options\n */\nexport function parseSingleYaml<ResT = unknown>(\n  content: string,\n  options?: YamlOptions<ResT>,\n): ResT {\n  const rawDocument = parseSingleYamlDocument(content, options);\n\n  const document = rawDocument.toJS({ maxAliasCount: 10000 });\n  const schema = options?.customSchema;\n  if (!schema) {\n    return document as ResT;\n  }\n\n  return schema.parse(document);\n}\n\n/**\n * Parse a YAML string into a Document representation.\n *\n * Only a single document is supported.\n *\n * @param content\n * @param options\n */\nexport function parseSingleYamlDocument(\n  content: string,\n  options?: YamlParseDocumentOptions,\n): Document {\n  const massagedContent = massageContent(content, options);\n  const rawDocument = parseDocument(\n    massagedContent,\n    prepareParseOption(options),\n  );\n\n  if (rawDocument?.errors?.length) {\n    throw new AggregateError(rawDocument.errors, 'Failed to parse YAML file');\n  }\n\n  return rawDocument;\n}\n\nexport function dump(obj: any, opts?: DumpOptions): string {\n  return stringify(obj, opts);\n}\n\nfunction massageContent(content: string, options?: YamlOptions): string {\n  if (options?.removeTemplates) {\n    return stripTemplates(content);\n  }\n\n  return content;\n}\n\nfunction prepareParseOption(options: YamlOptions | undefined): YamlOptions {\n  return {\n    prettyErrors: true,\n    // if we're removing templates, we can run into the situation where we have duplicate keys\n    uniqueKeys: !options?.removeTemplates,\n    strict: false,\n    ...options,\n  };\n}\n"]}