{"version":3,"file":"jsonata.js","sourceRoot":"","sources":["../../lib/util/jsonata.ts"],"names":[],"mappings":";;AAIA,sCAgBC;;AApBD,8DAA8B;AAC9B,iEAA2C;AAC3C,iCAAkC;AAElC,SAAgB,aAAa,CAAC,KAAa;IACzC,MAAM,QAAQ,GAAG,WAAW,IAAA,eAAQ,EAAC,KAAK,CAAC,EAAE,CAAC;IAC9C,MAAM,gBAAgB,GAAG,QAAQ,CAAC,GAAG,CAA6B,QAAQ,CAAC,CAAC;IAC5E,kCAAkC;IAClC,IAAI,gBAAgB,EAAE,CAAC;QACrB,OAAO,gBAAgB,CAAC;IAC1B,CAAC;IACD,IAAI,MAAkC,CAAC;IACvC,IAAI,CAAC;QACH,MAAM,GAAG,IAAA,iBAAO,EAAC,KAAK,CAAC,CAAC;IAC1B,CAAC;IAAC,OAAO,GAAG,EAAE,CAAC;QACb,iDAAiD;QACjD,MAAM,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IAClC,CAAC;IACD,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IAC/B,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["import jsonata from 'jsonata';\nimport * as memCache from './cache/memory';\nimport { toSha256 } from './hash';\n\nexport function getExpression(input: string): jsonata.Expression | Error {\n  const cacheKey = `jsonata:${toSha256(input)}`;\n  const cachedExpression = memCache.get<jsonata.Expression | Error>(cacheKey);\n  // istanbul ignore if: cannot test\n  if (cachedExpression) {\n    return cachedExpression;\n  }\n  let result: jsonata.Expression | Error;\n  try {\n    result = jsonata(input);\n  } catch (err) {\n    // JSONata errors aren't detected as TypeOf Error\n    result = new Error(err.message);\n  }\n  memCache.set(cacheKey, result);\n  return result;\n}\n"]}