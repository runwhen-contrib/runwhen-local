{"version":3,"file":"string-match.js","sourceRoot":"","sources":["../../lib/util/string-match.ts"],"names":[],"mappings":";;;AAMA,wCAEC;AAED,0DAQC;AAED,4CAMC;AAED,oDA+BC;AAED,0DAKC;AASD,oCAIC;AAcD,8CAYC;;AAzGD,kEAAkC;AAClC,2CAAwC;AACxC,mCAAgC;AAIhC,SAAgB,cAAc,CAAC,KAAa;IAC1C,OAAO,wBAAwB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC9C,CAAC;AAED,SAAgB,uBAAuB,CAAC,OAAe;IACrD,MAAM,cAAc,GAAG,iBAAiB,CAAC,OAAO,CAAC,CAAC;IAClD,IAAI,cAAc,EAAE,CAAC;QACnB,OAAO,cAAc,CAAC;IACxB,CAAC;IAED,MAAM,EAAE,GAAG,IAAA,qBAAS,EAAC,OAAO,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;IAC3D,OAAO,CAAC,CAAS,EAAW,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AAC7C,CAAC;AAED,SAAgB,gBAAgB,CAAC,KAAa,EAAE,OAAe;IAC7D,IAAI,OAAO,KAAK,GAAG,EAAE,CAAC;QACpB,OAAO,IAAI,CAAC;IACd,CAAC;IACD,MAAM,SAAS,GAAG,uBAAuB,CAAC,OAAO,CAAC,CAAC;IACnD,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC;AAC1B,CAAC;AAED,SAAgB,oBAAoB,CAClC,KAAa,EACb,QAAkB;IAElB,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;QACrB,OAAO,KAAK,CAAC;IACf,CAAC;IAED,6DAA6D;IAC7D,MAAM,gBAAgB,GAAG,QAAQ,CAAC,MAAM,CACtC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CACtC,CAAC;IACF,IACE,gBAAgB,CAAC,MAAM;QACvB,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,gBAAgB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,EACrE,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED,qDAAqD;IACrD,MAAM,gBAAgB,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE,CACnD,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CACxB,CAAC;IACF,IACE,gBAAgB,CAAC,MAAM;QACvB,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,gBAAgB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,EACtE,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAgB,uBAAuB,CACrC,MAAgB,EAChB,QAAkB;IAElB,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,oBAAoB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC;AACvE,CAAC;AAEY,QAAA,SAAS,GAAG,IAAA,aAAK,EAC5B,4EAA4E,CAC7E,CAAC;AAEF,MAAM,cAAc,GAAG,IAAA,aAAK,EAAC,OAAO,CAAC,CAAC;AACtC,MAAM,YAAY,GAAG,IAAA,aAAK,EAAC,OAAO,CAAC,CAAC;AAEpC,SAAgB,YAAY,CAAC,KAAc;IACzC,OAAO,CACL,YAAE,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAC3E,CAAC;AACJ,CAAC;AAED,SAAS,eAAe,CAAC,KAAa;IACpC,IAAI,CAAC;QACH,MAAM,WAAW,GAAG,KAAK;aACtB,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC;aAC3B,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;QAC7B,OAAO,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAA,aAAK,EAAC,WAAW,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,IAAA,aAAK,EAAC,WAAW,CAAC,CAAC;IAC5E,CAAC;IAAC,MAAM,CAAC;QACP,QAAQ;IACV,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAgB,iBAAiB,CAAC,KAAa;IAC7C,IAAI,YAAY,CAAC,KAAK,CAAC,EAAE,CAAC;QACxB,MAAM,WAAW,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC;QAC3C,IAAI,WAAW,EAAE,CAAC;YAChB,MAAM,UAAU,GAAG,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YAC1C,OAAO,CAAC,CAAS,EAAW,EAAE;gBAC5B,MAAM,GAAG,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAChC,OAAO,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;YACjC,CAAC,CAAC;QACJ,CAAC;IACH,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["import is from '@sindresorhus/is';\nimport { minimatch } from './minimatch';\nimport { regEx } from './regex';\n\nexport type StringMatchPredicate = (s: string) => boolean;\n\nexport function isDockerDigest(input: string): boolean {\n  return /^sha256:[a-f0-9]{64}$/i.test(input);\n}\n\nexport function getRegexOrGlobPredicate(pattern: string): StringMatchPredicate {\n  const regExPredicate = getRegexPredicate(pattern);\n  if (regExPredicate) {\n    return regExPredicate;\n  }\n\n  const mm = minimatch(pattern, { dot: true, nocase: true });\n  return (x: string): boolean => mm.match(x);\n}\n\nexport function matchRegexOrGlob(input: string, pattern: string): boolean {\n  if (pattern === '*') {\n    return true;\n  }\n  const predicate = getRegexOrGlobPredicate(pattern);\n  return predicate(input);\n}\n\nexport function matchRegexOrGlobList(\n  input: string,\n  patterns: string[],\n): boolean {\n  if (!patterns.length) {\n    return false;\n  }\n\n  // Return false if there are positive patterns and none match\n  const positivePatterns = patterns.filter(\n    (pattern) => !pattern.startsWith('!'),\n  );\n  if (\n    positivePatterns.length &&\n    !positivePatterns.some((pattern) => matchRegexOrGlob(input, pattern))\n  ) {\n    return false;\n  }\n\n  // Every negative pattern must be true to return true\n  const negativePatterns = patterns.filter((pattern) =>\n    pattern.startsWith('!'),\n  );\n  if (\n    negativePatterns.length &&\n    !negativePatterns.every((pattern) => matchRegexOrGlob(input, pattern))\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function anyMatchRegexOrGlobList(\n  inputs: string[],\n  patterns: string[],\n): boolean {\n  return inputs.some((input) => matchRegexOrGlobList(input, patterns));\n}\n\nexport const UUIDRegex = regEx(\n  /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,\n);\n\nconst configValStart = regEx(/^!?\\//);\nconst configValEnd = regEx(/\\/i?$/);\n\nexport function isRegexMatch(input: unknown): input is string {\n  return (\n    is.string(input) && configValStart.test(input) && configValEnd.test(input)\n  );\n}\n\nfunction parseRegexMatch(input: string): RegExp | null {\n  try {\n    const regexString = input\n      .replace(configValStart, '')\n      .replace(configValEnd, '');\n    return input.endsWith('i') ? regEx(regexString, 'i') : regEx(regexString);\n  } catch {\n    // no-op\n  }\n  return null;\n}\n\nexport function getRegexPredicate(input: string): StringMatchPredicate | null {\n  if (isRegexMatch(input)) {\n    const configRegex = parseRegexMatch(input);\n    if (configRegex) {\n      const isPositive = !input.startsWith('!');\n      return (x: string): boolean => {\n        const res = configRegex.test(x);\n        return isPositive ? res : !res;\n      };\n    }\n  }\n  return null;\n}\n"]}