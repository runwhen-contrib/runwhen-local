{"version":3,"file":"retry-after.js","sourceRoot":"","sources":["../../../lib/util/http/retry-after.ts"],"names":[],"mappings":"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","sourcesContent":["import { setTimeout } from 'timers/promises';\nimport { RequestError } from 'got';\nimport { DateTime } from 'luxon';\nimport { logger } from '../../logger';\nimport { parseUrl } from '../url';\nimport type { Task } from './types';\n\nconst hostDelays = new Map<string, Promise<unknown>>();\n\nconst maxRetries = 2;\n\n/**\n * Given a task that returns a promise, retry the task if it fails with a\n * 429 Too Many Requests or 403 Forbidden response, using the Retry-After\n * header to determine the delay.\n *\n * For response codes other than 429 or 403, or if the Retry-After header\n * is not present or invalid, the task is not retried, throwing the error.\n */\nexport async function wrapWithRetry<T>(\n  task: Task<T>,\n  url: string,\n  getRetryAfter: (err: unknown) => number | null,\n  maxRetryAfter: number,\n): Promise<T> {\n  const key = parseUrl(url)?.host ?? url;\n\n  let retries = 0;\n  for (;;) {\n    try {\n      await hostDelays.get(key);\n      hostDelays.delete(key);\n\n      return await task();\n    } catch (err) {\n      const delaySeconds = getRetryAfter(err);\n      if (delaySeconds === null) {\n        throw err;\n      }\n\n      if (retries === maxRetries) {\n        logger.debug(\n          `Retry-After: reached maximum retries (${maxRetries}) for ${url}`,\n        );\n        throw err;\n      }\n\n      if (delaySeconds > maxRetryAfter) {\n        logger.debug(\n          `Retry-After: delay ${delaySeconds} seconds exceeds maxRetryAfter ${maxRetryAfter} seconds for ${url}`,\n        );\n        throw err;\n      }\n\n      logger.debug(\n        `Retry-After: will retry ${url} after ${delaySeconds} seconds`,\n      );\n\n      const delay = Promise.all([\n        hostDelays.get(key),\n        setTimeout(1000 * delaySeconds),\n      ]);\n      hostDelays.set(key, delay);\n      retries += 1;\n    }\n  }\n}\n\nexport function getRetryAfter(err: unknown): number | null {\n  if (!(err instanceof RequestError)) {\n    return null;\n  }\n\n  if (!err.response) {\n    return null;\n  }\n\n  if (err.response.statusCode < 400 || err.response.statusCode >= 500) {\n    logger.debug(\n      { url: err.response.url },\n      `Retry-After: unexpected status code ${err.response.statusCode}`,\n    );\n    return null;\n  }\n\n  const retryAfter = err.response.headers['retry-after']?.trim();\n  if (!retryAfter) {\n    return null;\n  }\n\n  const date = DateTime.fromHTTP(retryAfter);\n  if (date.isValid) {\n    const seconds = Math.floor(date.diffNow('seconds').seconds);\n    if (seconds < 0) {\n      logger.debug(\n        { url: err.response.url, retryAfter },\n        'Retry-After: date in the past',\n      );\n      return null;\n    }\n\n    return seconds;\n  }\n\n  const seconds = parseInt(retryAfter, 10);\n  if (!Number.isNaN(seconds) && seconds >= 0) {\n    return seconds;\n  }\n\n  logger.debug(\n    { url: err.response.url, retryAfter },\n    'Retry-After: unsupported format',\n  );\n  return null;\n}\n"]}