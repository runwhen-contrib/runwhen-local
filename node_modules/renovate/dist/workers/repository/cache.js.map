{"version":3,"file":"cache.js","sourceRoot":"","sources":["../../../lib/workers/repository/cache.ts"],"names":[],"mappings":"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","sourcesContent":["import { REPOSITORY_CHANGED } from '../../constants/error-messages';\nimport { logger } from '../../logger';\nimport { platform } from '../../modules/platform';\nimport { scm } from '../../modules/platform/scm';\nimport { getCache } from '../../util/cache/repository';\nimport type {\n  BranchCache,\n  BranchUpgradeCache,\n} from '../../util/cache/repository/types';\nimport { getCachedBehindBaseResult } from '../../util/git/behind-base-branch-cache';\nimport { getCachedConflictResult } from '../../util/git/conflicts-cache';\nimport { getCachedModifiedResult } from '../../util/git/modified-cache';\nimport { getCachedPristineResult } from '../../util/git/pristine';\nimport type { BranchConfig, BranchUpgradeConfig } from '../types';\nimport { getPrCache } from './update/pr/pr-cache';\n\nfunction generateBranchUpgradeCache(\n  upgrade: BranchUpgradeConfig,\n): BranchUpgradeCache {\n  const {\n    datasource,\n    depName,\n    depType,\n    displayPending,\n    packageName,\n    fixedVersion,\n    currentVersion,\n    newVersion,\n    currentValue,\n    newValue,\n    currentDigest,\n    newDigest,\n    packageFile,\n    sourceUrl,\n    remediationNotPossible,\n    updateType,\n  } = upgrade;\n  const result: BranchUpgradeCache = {\n    datasource,\n    depName,\n    depType,\n    displayPending,\n    fixedVersion,\n    currentVersion,\n    currentValue,\n    newValue,\n    newVersion,\n    currentDigest,\n    newDigest,\n    packageFile,\n    sourceUrl,\n    remediationNotPossible,\n    updateType,\n  };\n  if (packageName) {\n    result.packageName = packageName;\n  }\n  return result;\n}\n\nasync function generateBranchCache(\n  branch: BranchConfig,\n): Promise<BranchCache | null> {\n  const { baseBranch, branchName, prBlockedBy, prTitle, result } = branch;\n  try {\n    const branchSha = await scm.getBranchCommit(branchName);\n    const baseBranchSha = await scm.getBranchCommit(baseBranch);\n    const pristine = getCachedPristineResult(branchName);\n    let prNo = null;\n    let isModified: boolean | undefined;\n    let isBehindBase: boolean | undefined;\n    let isConflicted: boolean | undefined;\n    if (baseBranchSha && branchSha) {\n      const branchPr = await platform.getBranchPr(branchName, baseBranch);\n      if (branchPr) {\n        prNo = branchPr.number;\n      }\n      isModified = getCachedModifiedResult(branchName, branchSha) ?? undefined;\n      isBehindBase =\n        getCachedBehindBaseResult(\n          branchName,\n          branchSha,\n          baseBranch,\n          baseBranchSha,\n        ) ?? undefined;\n      isConflicted =\n        getCachedConflictResult(\n          branchName,\n          branchSha,\n          baseBranch,\n          baseBranchSha,\n        ) ?? undefined;\n    } else if (baseBranchSha && !branchSha && branch.prNo) {\n      // if branch was deleted/ PR exists and ignored\n      prNo = branch.prNo;\n    }\n\n    const automerge = !!branch.automerge;\n    const upgrades: BranchUpgradeCache[] = branch.upgrades\n      ? branch.upgrades.map(generateBranchUpgradeCache)\n      : [];\n    const commitFingerprint = branch.commitFingerprint;\n    const prCache = getPrCache(branchName);\n\n    return {\n      automerge,\n      baseBranchSha,\n      baseBranch,\n      commitFingerprint,\n      branchName,\n      isBehindBase,\n      isConflicted,\n      isModified,\n      prBlockedBy,\n      pristine,\n      prCache,\n      prNo,\n      prTitle,\n      result,\n      sha: branchSha,\n      upgrades,\n    };\n  } catch (error) {\n    const err = error.err ?? error; // external host error nests err\n    const errCodes = [401, 404];\n    // istanbul ignore if\n    if (errCodes.includes(err.response?.statusCode)) {\n      logger.warn({ err, branchName }, 'HTTP error generating branch cache');\n      return null;\n    }\n    if (err.message === REPOSITORY_CHANGED) {\n      throw err;\n    }\n    logger.error({ err, branchName }, 'Error generating branch cache');\n    return null;\n  }\n}\n\nexport async function setBranchCache(branches: BranchConfig[]): Promise<void> {\n  const branchCaches: BranchCache[] = [];\n  for (const branch of branches) {\n    const branchCache = await generateBranchCache(branch);\n    if (branchCache) {\n      branchCaches.push(branchCache);\n    }\n  }\n  getCache().branches = branchCaches;\n}\n"]}