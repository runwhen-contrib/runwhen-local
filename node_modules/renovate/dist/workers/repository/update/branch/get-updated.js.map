{"version":3,"file":"get-updated.js","sourceRoot":"","sources":["../../../../../lib/workers/repository/update/branch/get-updated.ts"],"names":[],"mappings":";;AA8FA,wDAgWC;;AA9bD,qEAAqE;AACrE,kEAAkC;AAClC,yEAAiF;AACjF,+CAA4C;AAC5C,yDAAkD;AASlD,8CAA+C;AAE/C,oDAAuD;AAEvD,iDAA+C;AAU/C,KAAK,UAAU,cAAc,CAC3B,mBAA2C,EAC3C,QAAgB,EAChB,MAAoB;IAEpB,IAAI,WAAW,GAAkB,mBAAmB,CAAC,QAAQ,CAAC,CAAC;IAC/D,IAAI,CAAC,WAAW,EAAE,CAAC;QACjB,WAAW,GAAG,MAAM,IAAA,aAAO,EACzB,QAAQ,EACR,MAAM,CAAC,mBAAmB,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CACnE,CAAC;IACJ,CAAC;IACD,OAAO,WAAW,CAAC;AACrB,CAAC;AAED,SAAS,gBAAgB,CACvB,MAAoB,EACpB,OAAe,EACf,YAAwB;IAExB,MAAM,mBAAmB,GAAG,MAAM,CAAC,YAAY,EAAE,CAAC,OAAO,CAAC,CAAC;IAC3D,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACzB,OAAO;IACT,CAAC;IACD,YAAY,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;QAC7B,MAAM,QAAQ,GAAG,mBAAmB,CAAC,SAAS,CAC5C,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,WAAW,KAAK,GAAG,CAAC,IAAI,CAC1C,CAAC;QACF,MAAM,QAAQ,GAAG,mBAAmB,CAAC,SAAS,CAC5C,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,WAAW,KAAK,GAAG,CAAC,IAAI,CAC1C,CAAC;QACF,OAAO,QAAQ,GAAG,QAAQ,CAAC;IAC7B,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,MAAM,CAAC,GAAgB,EAAE,OAAyB;IACzD,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;QAC7B,IAAI,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;YACpB,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAID,SAAS,0BAA0B,CACjC,YAAiB,EACjB,mBAAgD;IAEhD,MAAM,gBAAgB,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAC7E,OAAO,IAAI,GAAG,CACZ,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE,CAClD,MAAM,CAAC,mBAAmB,CAAC,OAAO,CAAC,EAAE,gBAAgB,CAAC,CACvD,CACF,CAAC;AACJ,CAAC;AAED,SAAS,yBAAyB,CAChC,YAAiB,EACjB,mBAAgC;IAEhC,OAAO,YAAY,CAAC,MAAM,CAAC,CAAC,WAAW,EAAE,EAAE,CACzC,mBAAmB,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAC1C,CAAC;AACJ,CAAC;AAEM,KAAK,UAAU,sBAAsB,CAC1C,MAAoB;IAEpB,eAAM,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC;IACzB,MAAM,mBAAmB,GAAG,MAAM,CAAC,mBAAoB,CAAC;IACxD,eAAM,CAAC,KAAK,CACV,wDAAwD,mBAAmB,EAAE,CAC9E,CAAC;IACF,IAAI,mBAAmB,GAA2B,EAAE,CAAC;IACrD,MAAM,sBAAsB,GAA2B,EAAE,CAAC;IAC1D,MAAM,mBAAmB,GAAgC,EAAE,CAAC;IAC5D,MAAM,sBAAsB,GAAwC,EAAE,CAAC;IACvE,MAAM,wBAAwB,GAAa,EAAE,CAAC;IAC9C,IAAI,WAAW,GAAG,IAAI,CAAC;IACvB,KAAK,MAAM,OAAO,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;QACtC,MAAM,OAAO,GAAG,OAAO,CAAC,OAAQ,CAAC;QACjC,MAAM,WAAW,GAAG,OAAO,CAAC,WAAY,CAAC;QACzC,MAAM,OAAO,GAAG,OAAO,CAAC,OAAQ,CAAC;QACjC,6CAA6C;QAC7C,MAAM,UAAU,GAAG,OAAO,CAAC,UAAW,CAAC;QACvC,MAAM,cAAc,GAAG,OAAO,CAAC,cAAe,CAAC;QAC/C,MAAM,sBAAsB,GAAG,IAAA,aAAG,EAAC,OAAO,EAAE,wBAAwB,CAAE,CAAC;QACvE,mBAAmB,CAAC,OAAO,CAAC,KAAK,IAAI,GAAG,EAAU,CAAC;QACnD,mBAAmB,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAC9C,sBAAsB,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;QAC3C,sBAAsB,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,EAAE,GAAG,OAAO,EAAE,CAAC,CAAC;QACzD,MAAM,kBAAkB,GAAG,MAAM,cAAc,CAC7C,mBAAmB,EACnB,WAAW,EACX,MAAM,CACP,CAAC;QACF,IAAI,eAAe,GAAkB,IAAI,CAAC;QAC1C,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;QAClE,IAAI,QAAQ,EAAE,CAAC;YACb,eAAe,GAAG,MAAM,cAAc,CACpC,mBAAmB,EACnB,QAAQ,EACR,MAAM,CACP,CAAC;QACJ,CAAC;QACD,qBAAqB;QACrB,IACE,mBAAmB;YACnB,CAAC,CAAC,kBAAkB,IAAI,CAAC,QAAQ,IAAI,CAAC,eAAe,CAAC,CAAC,EACvD,CAAC;YACD,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,sCAAsC,CACvC,CAAC;YACF,OAAO,sBAAsB,CAAC;gBAC5B,GAAG,MAAM;gBACT,mBAAmB,EAAE,KAAK;aAC3B,CAAC,CAAC;QACL,CAAC;QACD,IAAI,OAAO,CAAC,UAAU,KAAK,qBAAqB,EAAE,CAAC;YACjD,wBAAwB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC7C,CAAC;aAAM,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC;YACjC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,sBAAsB,CAAC;gBACrD,GAAG,OAAO;gBACV,OAAO;gBACP,UAAU;gBACV,cAAc;gBACd,WAAW;gBACX,kBAAkB,EAAE,kBAAmB;gBACvC,QAAQ;gBACR,eAAe,EAAE,eAAgB;gBACjC,kBAAkB,EAAE,IAAI;gBACxB,oBAAoB,EAAE,IAAI;aAC3B,CAAC,CAAC;YACH,IAAI,mBAAmB,IAAI,MAAM,KAAK,iBAAiB,EAAE,CAAC;gBACxD,eAAM,CAAC,KAAK,CACV,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,EAC7B,sDAAsD,CACvD,CAAC;gBACF,OAAO,sBAAsB,CAAC;oBAC5B,GAAG,MAAM;oBACT,mBAAmB,EAAE,KAAK;iBAC3B,CAAC,CAAC;YACL,CAAC;YACD,IAAI,KAAK,EAAE,CAAC;gBACV,mBAAmB,GAAG,EAAE,GAAG,mBAAmB,EAAE,GAAG,KAAK,EAAE,CAAC;gBAC3D,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CACxB,CAAC,IAAI,EAAE,EAAE,CAAC,OAAO,sBAAsB,CAAC,IAAI,CAAC,CAC9C,CAAC;YACJ,CAAC;YACD,IAAI,MAAM,KAAK,eAAe,IAAI,MAAM,KAAK,aAAa,EAAE,CAAC;gBAC3D,OAAO,CAAC,sBAAsB,GAAG,IAAI,CAAC;YACxC,CAAC;QACH,CAAC;aAAM,IAAI,OAAO,CAAC,gBAAgB,EAAE,CAAC;YACpC,IAAI,sBAAsB,EAAE,CAAC;gBAC3B,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,sBAAsB,CAAC;oBACrD,GAAG,OAAO;oBACV,OAAO;oBACP,UAAU;oBACV,cAAc;oBACd,WAAW;oBACX,kBAAkB,EAAE,kBAAmB;oBACvC,QAAQ;oBACR,eAAe,EAAE,eAAgB;oBACjC,kBAAkB,EAAE,KAAK;iBAC1B,CAAC,CAAC;gBACH,IAAI,MAAM,KAAK,aAAa,EAAE,CAAC;oBAC7B,yBAAyB;oBACzB,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,EAAE,CAAC;wBACtC,sBAAsB,CAAC,WAAW,CAAC,GAAG,kBAAmB,CAAC;oBAC5D,CAAC;gBACH,CAAC;qBAAM,IAAI,MAAM,KAAK,iBAAiB,EAAE,CAAC;oBACxC,eAAM,CAAC,KAAK,CACV,cAAc,OAAO,OAAO,UAAU,qCAAqC,CAC5E,CAAC;gBACJ,CAAC;qBAAM,CAAC;oBACN,oBAAoB;oBACpB,IAAI,mBAAmB,EAAE,CAAC;wBACxB,eAAM,CAAC,KAAK,CACV,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,EAC7B,2DAA2D,CAC5D,CAAC;wBACF,OAAO,sBAAsB,CAAC;4BAC5B,GAAG,MAAM;4BACT,mBAAmB,EAAE,KAAK;yBAC3B,CAAC,CAAC;oBACL,CAAC;oBACD,IAAI,KAAK,EAAE,CAAC;wBACV,mBAAmB,GAAG,EAAE,GAAG,mBAAmB,EAAE,GAAG,KAAK,EAAE,CAAC;wBAC3D,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CACxB,CAAC,IAAI,EAAE,EAAE,CAAC,OAAO,sBAAsB,CAAC,IAAI,CAAC,CAC9C,CAAC;oBACJ,CAAC;gBACH,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,eAAM,CAAC,KAAK,CACV,EAAE,OAAO,EAAE,EACX,iDAAiD,CAClD,CAAC;gBACF,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,EAAE,CAAC;oBACtC,sBAAsB,CAAC,WAAW,CAAC,GAAG,kBAAmB,CAAC;gBAC5D,CAAC;YACH,CAAC;QACH,CAAC;aAAM,CAAC;YACN,MAAM,gBAAgB,GAAG,IAAA,aAAG,EAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;YAC1D,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBACtB,IAAI,GAAG,GAAG,MAAM,IAAA,4BAAa,EAC3B,OAAO,EACP,kBAAmB,EACnB,mBAAmB,EACnB,WAAW,CACZ,CAAC;gBACF,WAAW,GAAG,KAAK,CAAC;gBACpB,IAAI,GAAG,EAAE,CAAC;oBACR,GAAG,GAAG,MAAM,8BAA8B,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;oBACzD,IAAI,GAAG,KAAK,kBAAkB,EAAE,CAAC;wBAC/B,eAAM,CAAC,KAAK,CAAC,EAAE,WAAW,EAAE,OAAO,EAAE,EAAE,oBAAoB,CAAC,CAAC;oBAC/D,CAAC;yBAAM,CAAC;wBACN,eAAM,CAAC,KAAK,CAAC,EAAE,WAAW,EAAE,OAAO,EAAE,EAAE,kBAAkB,CAAC,CAAC;wBAC3D,mBAAmB,CAAC,WAAW,CAAC,GAAG,GAAI,CAAC;wBACxC,OAAO,sBAAsB,CAAC,WAAW,CAAC,CAAC;oBAC7C,CAAC;oBACD,SAAS;gBACX,CAAC;qBAAM,IAAI,mBAAmB,EAAE,CAAC;oBAC/B,OAAO,sBAAsB,CAAC;wBAC5B,GAAG,MAAM;wBACT,mBAAmB,EAAE,KAAK;qBAC3B,CAAC,CAAC;gBACL,CAAC;gBACD,eAAM,CAAC,KAAK,CAAC,EAAE,WAAW,EAAE,OAAO,EAAE,EAAE,uBAAuB,CAAC,CAAC;gBAChE,MAAM,IAAI,KAAK,CAAC,0CAAyB,CAAC,CAAC;YAC7C,CAAC;YACD,IAAI,UAAU,GAAG,MAAM,gBAAgB,CAAC;gBACtC,WAAW,EAAE,kBAAmB;gBAChC,OAAO;aACR,CAAC,CAAC;YACH,UAAU,GAAG,MAAM,8BAA8B,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;YACvE,IAAI,CAAC,UAAU,EAAE,CAAC;gBAChB,IAAI,mBAAmB,EAAE,CAAC;oBACxB,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,8CAA8C,CAC/C,CAAC;oBACF,OAAO,sBAAsB,CAAC;wBAC5B,GAAG,MAAM;wBACT,mBAAmB,EAAE,KAAK;qBAC3B,CAAC,CAAC;gBACL,CAAC;gBACD,eAAM,CAAC,KAAK,CACV,EAAE,eAAe,EAAE,kBAAkB,EAAE,MAAM,EAAE,OAAO,EAAE,EACxD,qBAAqB,CACtB,CAAC;gBACF,MAAM,IAAI,KAAK,CAAC,0CAAyB,CAAC,CAAC;YAC7C,CAAC;YACD,IAAI,UAAU,KAAK,kBAAkB,EAAE,CAAC;gBACtC,IAAI,mBAAmB,EAAE,CAAC;oBACxB,gDAAgD;oBAChD,eAAM,CAAC,KAAK,CACV,EAAE,WAAW,EAAE,OAAO,EAAE,EACxB,kDAAkD,CACnD,CAAC;oBACF,OAAO,sBAAsB,CAAC;wBAC5B,GAAG,MAAM;wBACT,mBAAmB,EAAE,KAAK;qBAC3B,CAAC,CAAC;gBACL,CAAC;gBACD,eAAM,CAAC,KAAK,CACV,YAAY,OAAO,OAAO,IAAA,qBAAY,EAAC,WAAW,EAAE,QAAQ,CAAC,EAAE,CAChE,CAAC;gBACF,mBAAmB,CAAC,WAAW,CAAC,GAAG,UAAU,CAAC;gBAC9C,OAAO,sBAAsB,CAAC,WAAW,CAAC,CAAC;YAC7C,CAAC;YACD,IAAI,UAAU,KAAK,kBAAkB,EAAE,CAAC;gBACtC,IAAI,OAAO,CAAC,OAAO,KAAK,gBAAgB,EAAE,CAAC;oBACzC,mBAAmB,CAAC,WAAW,CAAC,GAAG,UAAU,CAAC;oBAC9C,OAAO,sBAAsB,CAAC,WAAW,CAAC,CAAC;gBAC7C,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACD,MAAM,mBAAmB,GAAmB,MAAM,CAAC,IAAI,CACrD,mBAAmB,CACpB,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QACf,IAAI,EAAE,UAAU;QAChB,IAAI,EAAE,IAAI;QACV,QAAQ,EAAE,mBAAmB,CAAC,IAAI,CAAC;KACpC,CAAC,CAAC,CAAC;IACJ,MAAM,gBAAgB,GAAiB,EAAE,CAAC;IAC1C,MAAM,cAAc,GAAoB,EAAE,CAAC;IAC3C,MAAM,eAAe,GAAqB,EAAE,CAAC;IAC7C,IAAI,YAAE,CAAC,aAAa,CAAC,mBAAmB,CAAC,EAAE,CAAC;QAC1C,eAAM,CAAC,KAAK,CAAC,yCAAyC,CAAC,CAAC;QACxD,MAAM,0BAA0B,GAAG,0BAA0B,CAC3D,mBAAmB,EACnB,mBAAmB,CACpB,CAAC;QACF,KAAK,MAAM,OAAO,IAAI,0BAA0B,EAAE,CAAC;YACjD,MAAM,sBAAsB,GAAG,yBAAyB,CACtD,mBAAmB,EACnB,mBAAmB,CAAC,OAAO,CAAC,CAC7B,CAAC;YACF,gBAAgB,CAAC,MAAM,EAAE,OAAO,EAAE,sBAAsB,CAAC,CAAC;YAC1D,KAAK,MAAM,WAAW,IAAI,sBAAsB,EAAE,CAAC;gBACjD,MAAM,WAAW,GAAG,sBAAsB,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAC7D,MAAM,OAAO,GAAG,MAAM,sBAAsB,CAAC,OAAO,EAAE;oBACpD,eAAe,EAAE,WAAW,CAAC,IAAI;oBACjC,WAAW;oBACX,cAAc;oBACd,qBAAqB,EAAE,WAAW,CAAC,QAAS,CAAC,QAAQ,EAAE;oBACvD,MAAM,EAAE,6BAA6B,CACnC,MAAM,EACN,OAAO,EACP,WAAW,CAAC,IAAI,CACjB;iBACF,CAAC,CAAC;gBACH,4BAA4B,CAC1B,OAAO,EACP,gBAAgB,EAChB,cAAc,EACd,eAAe,CAChB,CAAC;YACJ,CAAC;QACH,CAAC;IACH,CAAC;IACD,MAAM,sBAAsB,GAAmB,MAAM,CAAC,IAAI,CACxD,sBAAsB,CACvB,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QACf,IAAI,EAAE,UAAU;QAChB,IAAI,EAAE,IAAI;QACV,QAAQ,EAAE,sBAAsB,CAAC,IAAI,CAAC;KACvC,CAAC,CAAC,CAAC;IACJ,IAAI,YAAE,CAAC,aAAa,CAAC,sBAAsB,CAAC,EAAE,CAAC;QAC7C,eAAM,CAAC,KAAK,CAAC,4CAA4C,CAAC,CAAC;QAC3D,MAAM,6BAA6B,GAAG,0BAA0B,CAC9D,sBAAsB,EACtB,mBAAmB,CACpB,CAAC;QACF,KAAK,MAAM,OAAO,IAAI,6BAA6B,EAAE,CAAC;YACpD,MAAM,sBAAsB,GAAG,yBAAyB,CACtD,sBAAsB,EACtB,mBAAmB,CAAC,OAAO,CAAC,CAC7B,CAAC;YACF,gBAAgB,CAAC,MAAM,EAAE,OAAO,EAAE,sBAAsB,CAAC,CAAC;YAC1D,KAAK,MAAM,WAAW,IAAI,sBAAsB,EAAE,CAAC;gBACjD,MAAM,WAAW,GAAG,sBAAsB,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAC7D,MAAM,OAAO,GAAG,MAAM,sBAAsB,CAAC,OAAO,EAAE;oBACpD,eAAe,EAAE,WAAW,CAAC,IAAI;oBACjC,WAAW;oBACX,cAAc;oBACd,qBAAqB,EAAE,WAAW,CAAC,QAAS,CAAC,QAAQ,EAAE;oBACvD,MAAM,EAAE,6BAA6B,CACnC,MAAM,EACN,OAAO,EACP,WAAW,CAAC,IAAI,CACjB;iBACF,CAAC,CAAC;gBACH,4BAA4B,CAC1B,OAAO,EACP,gBAAgB,EAChB,cAAc,EACd,eAAe,CAChB,CAAC;gBACF,IAAI,YAAE,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC;oBAC9B,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBACxC,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACD,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACzB,MAAM,+BAA+B,GACnC,wBAAwB,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;YACtC,IAAI,EAAE,IAAI;SACX,CAAC,CAAC,CAAC;QACN,4DAA4D;QAC5D,IAAI,YAAE,CAAC,aAAa,CAAC,wBAAwB,CAAC,EAAE,CAAC;YAC/C,eAAM,CAAC,KAAK,CAAC,8CAA8C,CAAC,CAAC;YAC7D,MAAM,2BAA2B,GAAG,0BAA0B,CAC5D,+BAA+B,EAC/B,mBAAmB,CACpB,CAAC;YACF,KAAK,MAAM,OAAO,IAAI,2BAA2B,EAAE,CAAC;gBAClD,MAAM,sBAAsB,GAAG,yBAAyB,CACtD,+BAA+B,EAC/B,mBAAmB,CAAC,OAAO,CAAC,CAC7B,CAAC;gBACF,gBAAgB,CAAC,MAAM,EAAE,OAAO,EAAE,sBAAsB,CAAC,CAAC;gBAC1D,KAAK,MAAM,WAAW,IAAI,sBAAsB,EAAE,CAAC;oBACjD,MAAM,QAAQ,GACZ,mBAAmB,CAAC,WAAW,CAAC,IAAI,CAAC;wBACrC,CAAC,MAAM,IAAA,aAAO,EAAC,WAAW,CAAC,IAAI,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;oBACvD,MAAM,OAAO,GAAG,MAAM,sBAAsB,CAAC,OAAO,EAAE;wBACpD,eAAe,EAAE,WAAW,CAAC,IAAI;wBACjC,WAAW,EAAE,EAAE;wBACf,qBAAqB,EAAE,QAAS;wBAChC,MAAM,EAAE,6BAA6B,CACnC,MAAM,EACN,OAAO,EACP,WAAW,CAAC,IAAI,CACjB;qBACF,CAAC,CAAC;oBACH,4BAA4B,CAC1B,OAAO,EACP,gBAAgB,EAChB,cAAc,EACd,eAAe,CAChB,CAAC;gBACJ,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO;QACL,mBAAmB,EAAE,oCAAoC;QACzD,mBAAmB;QACnB,gBAAgB;QAChB,cAAc;QACd,eAAe;KAChB,CAAC;AACJ,CAAC;AAED,yBAAyB;AACzB,SAAS,6BAA6B,CACpC,MAAoB,EACpB,OAAe,EACf,eAAuB;IAEvB,MAAM,aAAa,GAAG,EAAE,GAAG,MAAM,EAAE,CAAC;IACpC,IAAI,YAAE,CAAC,aAAa,CAAC,aAAa,CAAC,YAAY,EAAE,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC;QAC5D,MAAM,mBAAmB,GACvB,aAAa,CAAC,YAAY,EAAE,CAAC,OAAO,CAAC,CAAC;QACxC,MAAM,WAAW,GAAG,mBAAmB,CAAC,IAAI,CAC1C,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,KAAK,eAAe,CACzC,CAAC;QACF,IACE,WAAW;YACX,YAAE,CAAC,aAAa,CAAC,aAAa,CAAC,SAAS,CAAC;YACzC,YAAE,CAAC,aAAa,CAAC,WAAW,CAAC,SAAS,CAAC,EACvC,CAAC;YACD,aAAa,CAAC,SAAS,GAAG,WAAW,CAAC,SAAS,CAAC;QAClD,CAAC;IACH,CAAC;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;AAED,KAAK,UAAU,sBAAsB,CACnC,OAAe,EACf,cAA8B;IAE9B,MAAM,eAAe,GAAG,IAAA,aAAG,EAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC;IACxD,IAAI,eAAe,EAAE,CAAC;QACpB,OAAO,MAAM,eAAe,CAAC,cAAc,CAAC,CAAC;IAC/C,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,4BAA4B,CACnC,OAAuC,EACvC,gBAA8B,EAC9B,cAA+B,EAC/B,eAAiC;IAEjC,IAAI,YAAE,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC;QAC9B,KAAK,MAAM,GAAG,IAAI,OAAO,EAAE,CAAC;YAC1B,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,aAAa,EAAE,GAAG,GAAG,CAAC;YAC5C,IAAI,IAAI,EAAE,CAAC;gBACT,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC9B,CAAC;YAED,IAAI,aAAa,EAAE,CAAC;gBAClB,cAAc,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YACrC,CAAC;YAED,IAAI,MAAM,EAAE,CAAC;gBACX,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC/B,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC;AAED,KAAK,UAAU,8BAA8B,CAC3C,kBAAiC,EACjC,OAA4B;IAE5B,MAAM,kBAAkB,GAAG,IAAA,aAAG,EAAC,OAAO,CAAC,OAAO,EAAE,oBAAoB,CAAC,CAAC;IACtE,IACE,CAAC,kBAAkB;QACnB,CAAC,kBAAkB;QACnB,CAAC,OAAO,CAAC,WAAW;QACpB,CAAC,OAAO,CAAC,kBAAkB,EAC3B,CAAC;QACD,OAAO,kBAAkB,CAAC;IAC5B,CAAC;IAED,MAAM,MAAM,GAAG,MAAM,kBAAkB,CACrC,kBAAkB,EAClB,OAAO,CAAC,kBAAkB,EAC1B,OAAO,CAAC,WAAW,EACnB,OAAO,CAAC,WAAY,CACrB,CAAC;IAEF,OAAO,MAAM,CAAC,aAAa,CAAC;AAC9B,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\nimport is from '@sindresorhus/is';\nimport { WORKER_FILE_UPDATE_FAILED } from '../../../../constants/error-messages';\nimport { logger } from '../../../../logger';\nimport { get } from '../../../../modules/manager';\nimport type {\n  ArtifactError,\n  ArtifactNotice,\n  PackageDependency,\n  PackageFile,\n  UpdateArtifact,\n  UpdateArtifactsResult,\n} from '../../../../modules/manager/types';\nimport { getFile } from '../../../../util/git';\nimport type { FileAddition, FileChange } from '../../../../util/git/types';\nimport { coerceString } from '../../../../util/string';\nimport type { BranchConfig, BranchUpgradeConfig } from '../../../types';\nimport { doAutoReplace } from './auto-replace';\n\nexport interface PackageFilesResult {\n  artifactErrors: ArtifactError[];\n  reuseExistingBranch?: boolean;\n  updatedPackageFiles: FileChange[];\n  updatedArtifacts: FileChange[];\n  artifactNotices: ArtifactNotice[];\n}\n\nasync function getFileContent(\n  updatedFileContents: Record<string, string>,\n  filePath: string,\n  config: BranchConfig,\n): Promise<string | null> {\n  let fileContent: string | null = updatedFileContents[filePath];\n  if (!fileContent) {\n    fileContent = await getFile(\n      filePath,\n      config.reuseExistingBranch ? config.branchName : config.baseBranch,\n    );\n  }\n  return fileContent;\n}\n\nfunction sortPackageFiles(\n  config: BranchConfig,\n  manager: string,\n  packageFiles: FilePath[],\n): void {\n  const managerPackageFiles = config.packageFiles?.[manager];\n  if (!managerPackageFiles) {\n    return;\n  }\n  packageFiles.sort((lhs, rhs) => {\n    const lhsIndex = managerPackageFiles.findIndex(\n      (entry) => entry.packageFile === lhs.path,\n    );\n    const rhsIndex = managerPackageFiles.findIndex(\n      (entry) => entry.packageFile === rhs.path,\n    );\n    return lhsIndex - rhsIndex;\n  });\n}\n\nfunction hasAny(set: Set<string>, targets: Iterable<string>): boolean {\n  for (const target of targets) {\n    if (set.has(target)) {\n      return true;\n    }\n  }\n  return false;\n}\n\ntype FilePath = Pick<FileChange, 'path'>;\n\nfunction getManagersForPackageFiles<T extends FilePath>(\n  packageFiles: T[],\n  managerPackageFiles: Record<string, Set<string>>,\n): Set<string> {\n  const packageFileNames = packageFiles.map((packageFile) => packageFile.path);\n  return new Set(\n    Object.keys(managerPackageFiles).filter((manager) =>\n      hasAny(managerPackageFiles[manager], packageFileNames),\n    ),\n  );\n}\n\nfunction getPackageFilesForManager<T extends FilePath>(\n  packageFiles: T[],\n  managerPackageFiles: Set<string>,\n): T[] {\n  return packageFiles.filter((packageFile) =>\n    managerPackageFiles.has(packageFile.path),\n  );\n}\n\nexport async function getUpdatedPackageFiles(\n  config: BranchConfig,\n): Promise<PackageFilesResult> {\n  logger.trace({ config });\n  const reuseExistingBranch = config.reuseExistingBranch!;\n  logger.debug(\n    `manager.getUpdatedPackageFiles() reuseExistingBranch=${reuseExistingBranch}`,\n  );\n  let updatedFileContents: Record<string, string> = {};\n  const nonUpdatedFileContents: Record<string, string> = {};\n  const managerPackageFiles: Record<string, Set<string>> = {};\n  const packageFileUpdatedDeps: Record<string, PackageDependency[]> = {};\n  const lockFileMaintenanceFiles: string[] = [];\n  let firstUpdate = true;\n  for (const upgrade of config.upgrades) {\n    const manager = upgrade.manager!;\n    const packageFile = upgrade.packageFile!;\n    const depName = upgrade.depName!;\n    // TODO: fix types, can be undefined (#22198)\n    const newVersion = upgrade.newVersion!;\n    const currentVersion = upgrade.currentVersion!;\n    const updateLockedDependency = get(manager, 'updateLockedDependency')!;\n    managerPackageFiles[manager] ??= new Set<string>();\n    managerPackageFiles[manager].add(packageFile);\n    packageFileUpdatedDeps[packageFile] ??= [];\n    packageFileUpdatedDeps[packageFile].push({ ...upgrade });\n    const packageFileContent = await getFileContent(\n      updatedFileContents,\n      packageFile,\n      config,\n    );\n    let lockFileContent: string | null = null;\n    const lockFile = upgrade.lockFile ?? upgrade.lockFiles?.[0] ?? '';\n    if (lockFile) {\n      lockFileContent = await getFileContent(\n        updatedFileContents,\n        lockFile,\n        config,\n      );\n    }\n    // istanbul ignore if\n    if (\n      reuseExistingBranch &&\n      (!packageFileContent || (lockFile && !lockFileContent))\n    ) {\n      logger.debug(\n        { packageFile, depName },\n        'Rebasing branch after file not found',\n      );\n      return getUpdatedPackageFiles({\n        ...config,\n        reuseExistingBranch: false,\n      });\n    }\n    if (upgrade.updateType === 'lockFileMaintenance') {\n      lockFileMaintenanceFiles.push(packageFile);\n    } else if (upgrade.isRemediation) {\n      const { status, files } = await updateLockedDependency({\n        ...upgrade,\n        depName,\n        newVersion,\n        currentVersion,\n        packageFile,\n        packageFileContent: packageFileContent!,\n        lockFile,\n        lockFileContent: lockFileContent!,\n        allowParentUpdates: true,\n        allowHigherOrRemoved: true,\n      });\n      if (reuseExistingBranch && status !== 'already-updated') {\n        logger.debug(\n          { lockFile, depName, status },\n          'Need to retry branch as it is not already up-to-date',\n        );\n        return getUpdatedPackageFiles({\n          ...config,\n          reuseExistingBranch: false,\n        });\n      }\n      if (files) {\n        updatedFileContents = { ...updatedFileContents, ...files };\n        Object.keys(files).forEach(\n          (file) => delete nonUpdatedFileContents[file],\n        );\n      }\n      if (status === 'update-failed' || status === 'unsupported') {\n        upgrade.remediationNotPossible = true;\n      }\n    } else if (upgrade.isLockfileUpdate) {\n      if (updateLockedDependency) {\n        const { status, files } = await updateLockedDependency({\n          ...upgrade,\n          depName,\n          newVersion,\n          currentVersion,\n          packageFile,\n          packageFileContent: packageFileContent!,\n          lockFile,\n          lockFileContent: lockFileContent!,\n          allowParentUpdates: false,\n        });\n        if (status === 'unsupported') {\n          // incompatible lock file\n          if (!updatedFileContents[packageFile]) {\n            nonUpdatedFileContents[packageFile] = packageFileContent!;\n          }\n        } else if (status === 'already-updated') {\n          logger.debug(\n            `Upgrade of ${depName} to ${newVersion} is already done in existing branch`,\n          );\n        } else {\n          // something changed\n          if (reuseExistingBranch) {\n            logger.debug(\n              { lockFile, depName, status },\n              'Need to retry branch as upgrade requirements are not mets',\n            );\n            return getUpdatedPackageFiles({\n              ...config,\n              reuseExistingBranch: false,\n            });\n          }\n          if (files) {\n            updatedFileContents = { ...updatedFileContents, ...files };\n            Object.keys(files).forEach(\n              (file) => delete nonUpdatedFileContents[file],\n            );\n          }\n        }\n      } else {\n        logger.debug(\n          { manager },\n          'isLockFileUpdate without updateLockedDependency',\n        );\n        if (!updatedFileContents[packageFile]) {\n          nonUpdatedFileContents[packageFile] = packageFileContent!;\n        }\n      }\n    } else {\n      const updateDependency = get(manager, 'updateDependency');\n      if (!updateDependency) {\n        let res = await doAutoReplace(\n          upgrade,\n          packageFileContent!,\n          reuseExistingBranch,\n          firstUpdate,\n        );\n        firstUpdate = false;\n        if (res) {\n          res = await applyManagerBumpPackageVersion(res, upgrade);\n          if (res === packageFileContent) {\n            logger.debug({ packageFile, depName }, 'No content changed');\n          } else {\n            logger.debug({ packageFile, depName }, 'Contents updated');\n            updatedFileContents[packageFile] = res!;\n            delete nonUpdatedFileContents[packageFile];\n          }\n          continue;\n        } else if (reuseExistingBranch) {\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.error({ packageFile, depName }, 'Could not autoReplace');\n        throw new Error(WORKER_FILE_UPDATE_FAILED);\n      }\n      let newContent = await updateDependency({\n        fileContent: packageFileContent!,\n        upgrade,\n      });\n      newContent = await applyManagerBumpPackageVersion(newContent, upgrade);\n      if (!newContent) {\n        if (reuseExistingBranch) {\n          logger.debug(\n            { packageFile, depName },\n            'Rebasing branch after error updating content',\n          );\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.debug(\n          { existingContent: packageFileContent, config: upgrade },\n          'Error updating file',\n        );\n        throw new Error(WORKER_FILE_UPDATE_FAILED);\n      }\n      if (newContent !== packageFileContent) {\n        if (reuseExistingBranch) {\n          // This ensure it's always 1 commit from the bot\n          logger.debug(\n            { packageFile, depName },\n            'Need to update package file so will rebase first',\n          );\n          return getUpdatedPackageFiles({\n            ...config,\n            reuseExistingBranch: false,\n          });\n        }\n        logger.debug(\n          `Updating ${depName} in ${coerceString(packageFile, lockFile)}`,\n        );\n        updatedFileContents[packageFile] = newContent;\n        delete nonUpdatedFileContents[packageFile];\n      }\n      if (newContent === packageFileContent) {\n        if (upgrade.manager === 'git-submodules') {\n          updatedFileContents[packageFile] = newContent;\n          delete nonUpdatedFileContents[packageFile];\n        }\n      }\n    }\n  }\n  const updatedPackageFiles: FileAddition[] = Object.keys(\n    updatedFileContents,\n  ).map((name) => ({\n    type: 'addition',\n    path: name,\n    contents: updatedFileContents[name],\n  }));\n  const updatedArtifacts: FileChange[] = [];\n  const artifactErrors: ArtifactError[] = [];\n  const artifactNotices: ArtifactNotice[] = [];\n  if (is.nonEmptyArray(updatedPackageFiles)) {\n    logger.debug('updateArtifacts for updatedPackageFiles');\n    const updatedPackageFileManagers = getManagersForPackageFiles(\n      updatedPackageFiles,\n      managerPackageFiles,\n    );\n    for (const manager of updatedPackageFileManagers) {\n      const packageFilesForManager = getPackageFilesForManager(\n        updatedPackageFiles,\n        managerPackageFiles[manager],\n      );\n      sortPackageFiles(config, manager, packageFilesForManager);\n      for (const packageFile of packageFilesForManager) {\n        const updatedDeps = packageFileUpdatedDeps[packageFile.path];\n        const results = await managerUpdateArtifacts(manager, {\n          packageFileName: packageFile.path,\n          updatedDeps,\n          // TODO #22198\n          newPackageFileContent: packageFile.contents!.toString(),\n          config: patchConfigForArtifactsUpdate(\n            config,\n            manager,\n            packageFile.path,\n          ),\n        });\n        processUpdateArtifactResults(\n          results,\n          updatedArtifacts,\n          artifactErrors,\n          artifactNotices,\n        );\n      }\n    }\n  }\n  const nonUpdatedPackageFiles: FileAddition[] = Object.keys(\n    nonUpdatedFileContents,\n  ).map((name) => ({\n    type: 'addition',\n    path: name,\n    contents: nonUpdatedFileContents[name],\n  }));\n  if (is.nonEmptyArray(nonUpdatedPackageFiles)) {\n    logger.debug('updateArtifacts for nonUpdatedPackageFiles');\n    const nonUpdatedPackageFileManagers = getManagersForPackageFiles(\n      nonUpdatedPackageFiles,\n      managerPackageFiles,\n    );\n    for (const manager of nonUpdatedPackageFileManagers) {\n      const packageFilesForManager = getPackageFilesForManager(\n        nonUpdatedPackageFiles,\n        managerPackageFiles[manager],\n      );\n      sortPackageFiles(config, manager, packageFilesForManager);\n      for (const packageFile of packageFilesForManager) {\n        const updatedDeps = packageFileUpdatedDeps[packageFile.path];\n        const results = await managerUpdateArtifacts(manager, {\n          packageFileName: packageFile.path,\n          updatedDeps,\n          // TODO #22198\n          newPackageFileContent: packageFile.contents!.toString(),\n          config: patchConfigForArtifactsUpdate(\n            config,\n            manager,\n            packageFile.path,\n          ),\n        });\n        processUpdateArtifactResults(\n          results,\n          updatedArtifacts,\n          artifactErrors,\n          artifactNotices,\n        );\n        if (is.nonEmptyArray(results)) {\n          updatedPackageFiles.push(packageFile);\n        }\n      }\n    }\n  }\n  if (!reuseExistingBranch) {\n    const lockFileMaintenancePackageFiles: FilePath[] =\n      lockFileMaintenanceFiles.map((name) => ({\n        path: name,\n      }));\n    // Only perform lock file maintenance if it's a fresh commit\n    if (is.nonEmptyArray(lockFileMaintenanceFiles)) {\n      logger.debug('updateArtifacts for lockFileMaintenanceFiles');\n      const lockFileMaintenanceManagers = getManagersForPackageFiles(\n        lockFileMaintenancePackageFiles,\n        managerPackageFiles,\n      );\n      for (const manager of lockFileMaintenanceManagers) {\n        const packageFilesForManager = getPackageFilesForManager(\n          lockFileMaintenancePackageFiles,\n          managerPackageFiles[manager],\n        );\n        sortPackageFiles(config, manager, packageFilesForManager);\n        for (const packageFile of packageFilesForManager) {\n          const contents =\n            updatedFileContents[packageFile.path] ||\n            (await getFile(packageFile.path, config.baseBranch));\n          const results = await managerUpdateArtifacts(manager, {\n            packageFileName: packageFile.path,\n            updatedDeps: [],\n            newPackageFileContent: contents!,\n            config: patchConfigForArtifactsUpdate(\n              config,\n              manager,\n              packageFile.path,\n            ),\n          });\n          processUpdateArtifactResults(\n            results,\n            updatedArtifacts,\n            artifactErrors,\n            artifactNotices,\n          );\n        }\n      }\n    }\n  }\n  return {\n    reuseExistingBranch, // Need to overwrite original config\n    updatedPackageFiles,\n    updatedArtifacts,\n    artifactErrors,\n    artifactNotices,\n  };\n}\n\n// workaround, see #27319\nfunction patchConfigForArtifactsUpdate(\n  config: BranchConfig,\n  manager: string,\n  packageFileName: string,\n): BranchConfig {\n  const updatedConfig = { ...config };\n  if (is.nonEmptyArray(updatedConfig.packageFiles?.[manager])) {\n    const managerPackageFiles: PackageFile[] =\n      updatedConfig.packageFiles?.[manager];\n    const packageFile = managerPackageFiles.find(\n      (p) => p.packageFile === packageFileName,\n    );\n    if (\n      packageFile &&\n      is.nonEmptyArray(updatedConfig.lockFiles) &&\n      is.nonEmptyArray(packageFile.lockFiles)\n    ) {\n      updatedConfig.lockFiles = packageFile.lockFiles;\n    }\n  }\n  return updatedConfig;\n}\n\nasync function managerUpdateArtifacts(\n  manager: string,\n  updateArtifact: UpdateArtifact,\n): Promise<UpdateArtifactsResult[] | null> {\n  const updateArtifacts = get(manager, 'updateArtifacts');\n  if (updateArtifacts) {\n    return await updateArtifacts(updateArtifact);\n  }\n  return null;\n}\n\nfunction processUpdateArtifactResults(\n  results: UpdateArtifactsResult[] | null,\n  updatedArtifacts: FileChange[],\n  artifactErrors: ArtifactError[],\n  artifactNotices: ArtifactNotice[],\n): void {\n  if (is.nonEmptyArray(results)) {\n    for (const res of results) {\n      const { file, notice, artifactError } = res;\n      if (file) {\n        updatedArtifacts.push(file);\n      }\n\n      if (artifactError) {\n        artifactErrors.push(artifactError);\n      }\n\n      if (notice) {\n        artifactNotices.push(notice);\n      }\n    }\n  }\n}\n\nasync function applyManagerBumpPackageVersion(\n  packageFileContent: string | null,\n  upgrade: BranchUpgradeConfig,\n): Promise<string | null> {\n  const bumpPackageVersion = get(upgrade.manager, 'bumpPackageVersion');\n  if (\n    !bumpPackageVersion ||\n    !packageFileContent ||\n    !upgrade.bumpVersion ||\n    !upgrade.packageFileVersion\n  ) {\n    return packageFileContent;\n  }\n\n  const result = await bumpPackageVersion(\n    packageFileContent,\n    upgrade.packageFileVersion,\n    upgrade.bumpVersion,\n    upgrade.packageFile!,\n  );\n\n  return result.bumpedContent;\n}\n"]}