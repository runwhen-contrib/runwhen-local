{"version":3,"file":"reuse.js","sourceRoot":"","sources":["../../../../../lib/workers/repository/update/branch/reuse.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from '../../../../logger';\nimport { platform } from '../../../../modules/platform';\nimport { scm } from '../../../../modules/platform/scm';\nimport type { RangeStrategy } from '../../../../types';\nimport type { BranchConfig } from '../../../types';\n\nasync function shouldKeepUpdated(\n  config: BranchConfig,\n  baseBranch: string,\n  branchName: string,\n): Promise<boolean> {\n  const keepUpdatedLabel = config.keepUpdatedLabel;\n  if (!keepUpdatedLabel) {\n    return false;\n  }\n\n  const branchPr = await platform.getBranchPr(\n    config.branchName,\n    config.baseBranch,\n  );\n\n  if (branchPr?.labels?.includes(keepUpdatedLabel)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport async function shouldReuseExistingBranch(\n  config: BranchConfig,\n): Promise<BranchConfig> {\n  const { baseBranch, branchName } = config;\n  const result: BranchConfig = { ...config, reuseExistingBranch: false };\n\n  const keepUpdated = await shouldKeepUpdated(result, baseBranch, branchName);\n  await determineRebaseWhenValue(result, keepUpdated);\n\n  // Check if branch exists\n  if (!(await scm.branchExists(branchName))) {\n    logger.debug(`Branch needs creating`);\n    return result;\n  }\n  logger.debug(`Branch already exists`);\n\n  if (result.rebaseWhen === 'behind-base-branch' || keepUpdated) {\n    if (await scm.isBranchBehindBase(branchName, baseBranch)) {\n      logger.debug(`Branch is behind base branch and needs rebasing`);\n      // We can rebase the branch only if no PR or PR can be rebased\n      if (await scm.isBranchModified(branchName, baseBranch)) {\n        logger.debug('Cannot rebase branch as it has been modified');\n        result.reuseExistingBranch = true;\n        result.isModified = true;\n        return result;\n      }\n      logger.debug('Branch is unmodified, so can be rebased');\n      return result;\n    }\n    logger.debug('Branch is up-to-date');\n  } else {\n    logger.debug(\n      `Skipping behind base branch check due to rebaseWhen=${result.rebaseWhen!}`,\n    );\n  }\n\n  // Now check if PR is unmergeable. If so then we also rebase\n  result.isConflicted = await scm.isBranchConflicted(baseBranch, branchName);\n  if (result.isConflicted) {\n    logger.debug('Branch is conflicted');\n\n    if ((await scm.isBranchModified(branchName, baseBranch)) === false) {\n      logger.debug(`Branch is not mergeable and needs rebasing`);\n      if (result.rebaseWhen === 'never' && !keepUpdated) {\n        logger.debug('Rebasing disabled by config');\n        result.reuseExistingBranch = true;\n        result.isModified = false;\n      }\n      // Setting reuseExistingBranch back to undefined means that we'll use the default branch\n      return result;\n    }\n    // Don't do anything different, but warn\n    // TODO: Add warning to PR (#9720)\n    logger.debug(`Branch is not mergeable but can't be rebased`);\n  }\n  logger.debug(`Branch does not need rebasing`);\n\n  // Branches can get in an inconsistent state if \"update-lockfile\" is used at the same time as other strategies\n  // On the first execution, everything is executed, but if on a second execution the package.json modification is\n  // skipped but the lockfile update is executed, the lockfile will have a different result than if it was executed\n  // along with the changes to the package.json. Thus ending up with an incomplete branch update\n  // This is why we are skipping branch reuse in this case (#10050)\n  const groupedByPackageFile: Record<string, Set<RangeStrategy>> = {};\n  for (const upgrade of result.upgrades) {\n    const packageFile = upgrade.packageFile!;\n    groupedByPackageFile[packageFile] ??= new Set();\n    groupedByPackageFile[packageFile].add(upgrade.rangeStrategy!);\n\n    if (\n      groupedByPackageFile[packageFile].size > 1 &&\n      groupedByPackageFile[packageFile].has('update-lockfile')\n    ) {\n      logger.debug(\n        `Detected multiple rangeStrategies along with update-lockfile`,\n      );\n      result.reuseExistingBranch = false;\n      result.isModified = false;\n      return result;\n    }\n  }\n\n  result.reuseExistingBranch = true;\n  result.isModified = false;\n  return result;\n}\n\n/**\n * This method updates rebaseWhen value when it's set to auto(default) or automerging\n *\n * @param result BranchConfig\n * @param keepUpdated boolean\n */\nasync function determineRebaseWhenValue(\n  result: BranchConfig,\n  keepUpdated: boolean,\n): Promise<void> {\n  if (result.rebaseWhen === 'auto' || result.rebaseWhen === 'automerging') {\n    let reason;\n    let newValue = 'behind-base-branch';\n    if (result.automerge === true) {\n      reason = 'automerge=true';\n    } else if (keepUpdated) {\n      reason = 'keep-updated label is set';\n    } else if (result.rebaseWhen === 'automerging') {\n      newValue = 'never';\n      reason = 'no keep-updated label and automerging is set';\n    } else if (await platform.getBranchForceRebase?.(result.baseBranch)) {\n      reason = 'platform is configured to require up-to-date branches';\n    } else {\n      newValue = 'conflicted';\n      reason = 'no rule for behind-base-branch applies';\n    }\n\n    logger.debug(\n      `Converting rebaseWhen=${result.rebaseWhen} to rebaseWhen=${newValue} because ${reason}`,\n    );\n    result.rebaseWhen = newValue;\n  }\n}\n"]}