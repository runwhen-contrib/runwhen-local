{"version":3,"file":"timestamps.js","sourceRoot":"","sources":["../../../../../lib/workers/repository/process/lookup/timestamps.ts"],"names":[],"mappings":";;AAwBA,gEAuEC;AA/FD,iCAAiC;AACjC,+CAA4C;AAM5C,0DAAyD;AAEzD;;;;;;;;;;;;;;GAcG;AACH,SAAgB,0BAA0B,CACxC,aAA4B,EAC5B,aAA4B;IAE5B,MAAM,EAAE,UAAU,EAAE,GAAG,aAAa,CAAC;IAErC,IAAI,cAAmC,CAAC;IACxC,KAAK,MAAM,OAAO,IAAI,aAAa,CAAC,QAAQ,EAAE,CAAC;QAC7C,IAAI,CAAC,cAAc,EAAE,CAAC;YACpB,IAAI,aAAa,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC;gBAC7C,cAAc,GAAG,OAAO,CAAC;YAC3B,CAAC;YAED,SAAS;QACX,CAAC;QAED,IAAI,CAAC;YACH,IACE,aAAa,CAAC,aAAa,CAAC,OAAO,CAAC,OAAO,EAAE,cAAc,CAAC,OAAO,CAAC,EACpE,CAAC;gBACD,cAAc,GAAG,OAAO,CAAC;gBACzB,SAAS;YACX,CAAC;QACH,CAAC;QAAC,MAAM,CAAC;YACP,eAAM,CAAC,KAAK,CAAC,EAAE,UAAU,EAAE,EAAE,oCAAoC,CAAC,CAAC;QACrE,CAAC;IACH,CAAC;IAED,IAAI,CAAC,cAAc,EAAE,CAAC;QACpB,eAAM,CAAC,KAAK,CACV,EAAE,UAAU,EAAE,EACd,uEAAuE,CACxE,CAAC;QACF,OAAO,aAAa,CAAC;IACvB,CAAC;IAED,IAAI,cAAc,CAAC,YAAY,EAAE,CAAC;QAChC,eAAM,CAAC,KAAK,CACV,EAAE,UAAU,EAAE,EACd,kEAAkE,CACnE,CAAC;QACF,OAAO,aAAa,CAAC;IACvB,CAAC;IAED,MAAM,uBAAuB,GAAG,IAAA,uBAAW,EAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;IAC7E,IAAI,uBAAuB,EAAE,CAAC;QAC5B,MAAM,sBAAsB,GAAG,gBAAQ,CAAC,OAAO,CAAC,uBAAuB,CAAC,CAAC;QACzE,MAAM,qBAAqB,GAAG,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE;YACpE,MAAM,gBAAgB,GAAG,IAAA,uBAAW,EAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;YAC/D,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBACtB,OAAO,KAAK,CAAC;YACf,CAAC;YAED,OAAO,gBAAQ,CAAC,OAAO,CAAC,gBAAgB,CAAC,GAAG,sBAAsB,CAAC;QACrE,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,qBAAqB,EAAE,CAAC;YAC3B,eAAM,CAAC,KAAK,CACV,EAAE,UAAU,EAAE,EACd,2FAA2F,CAC5F,CAAC;YACF,aAAa,CAAC,QAAQ,GAAG,uBAAuB,CAAC;YACjD,OAAO,aAAa,CAAC;QACvB,CAAC;IACH,CAAC;IAED,eAAM,CAAC,KAAK,CACV,EAAE,UAAU,EAAE,EACd,mFAAmF,CACpF,CAAC;IACF,OAAO,aAAa,CAAC;AACvB,CAAC","sourcesContent":["import { DateTime } from 'luxon';\nimport { logger } from '../../../../logger';\nimport type {\n  Release,\n  ReleaseResult,\n} from '../../../../modules/datasource/types';\nimport type { VersioningApi } from '../../../../modules/versioning/types';\nimport { asTimestamp } from '../../../../util/timestamp';\n\n/**\n * Calculates the `bumpedAt` value for a set of releases.\n *\n * This function determines the highest release (a release with the highest version)\n * and checks if its timestamp is also the highest among all releases.\n * If so, it assigns that timestamp as the `bumpedAt` value in the result.\n * This helps identify if the package was abandoned.\n *\n * The function skips setting `bumpedAt` if:\n * - No releases could be determined as the highest (e.g. for invalid versions)\n * - The highest release is deprecated\n * - A lower version has a more recent timestamp than the highest version\n *\n * @returns The `ReleaseResult` value, potentially updated with a `bumpedAt` timestamp\n */\nexport function calculateLatestReleaseBump(\n  versioningApi: VersioningApi,\n  releaseResult: ReleaseResult,\n): ReleaseResult {\n  const { lookupName } = releaseResult;\n\n  let highestRelease: Release | undefined;\n  for (const release of releaseResult.releases) {\n    if (!highestRelease) {\n      if (versioningApi.isVersion(release.version)) {\n        highestRelease = release;\n      }\n\n      continue;\n    }\n\n    try {\n      if (\n        versioningApi.isGreaterThan(release.version, highestRelease.version)\n      ) {\n        highestRelease = release;\n        continue;\n      }\n    } catch {\n      logger.trace({ lookupName }, 'Error calculating \"bumpedAt\" value');\n    }\n  }\n\n  if (!highestRelease) {\n    logger.trace(\n      { lookupName },\n      'Could not determine the highest release to calculate \"bumpedAt\" value',\n    );\n    return releaseResult;\n  }\n\n  if (highestRelease.isDeprecated) {\n    logger.trace(\n      { lookupName },\n      'Highest release is deprecated, skip calculating \"bumpedAt\" value',\n    );\n    return releaseResult;\n  }\n\n  const highestReleaseTimestamp = asTimestamp(highestRelease.releaseTimestamp);\n  if (highestReleaseTimestamp) {\n    const highestReleaseDatetime = DateTime.fromISO(highestReleaseTimestamp);\n    const higherTimestampExists = releaseResult.releases.some((release) => {\n      const releaseTimestamp = asTimestamp(release.releaseTimestamp);\n      if (!releaseTimestamp) {\n        return false;\n      }\n\n      return DateTime.fromISO(releaseTimestamp) > highestReleaseDatetime;\n    });\n\n    if (!higherTimestampExists) {\n      logger.trace(\n        { lookupName },\n        'Using \"bumpedAt\" value because it is the highest timestamp of the highest release version',\n      );\n      releaseResult.bumpedAt = highestReleaseTimestamp;\n      return releaseResult;\n    }\n  }\n\n  logger.trace(\n    { lookupName },\n    'Skip using \"bumpedAt\" value because the higher timestamp exists for lower version',\n  );\n  return releaseResult;\n}\n"]}