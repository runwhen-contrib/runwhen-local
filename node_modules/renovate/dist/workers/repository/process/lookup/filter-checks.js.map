{"version":3,"file":"filter-checks.js","sourceRoot":"","sources":["../../../../../lib/workers/repository/process/lookup/filter-checks.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { mergeChildConfig } from '../../../../config';\nimport { logger } from '../../../../logger';\nimport type { Release } from '../../../../modules/datasource';\nimport { postprocessRelease } from '../../../../modules/datasource/postprocess-release';\nimport type { VersioningApi } from '../../../../modules/versioning';\nimport { getElapsedMs } from '../../../../util/date';\nimport {\n  getMergeConfidenceLevel,\n  isActiveConfidenceLevel,\n  satisfiesConfidenceLevel,\n} from '../../../../util/merge-confidence';\nimport { coerceNumber } from '../../../../util/number';\nimport { applyPackageRules } from '../../../../util/package-rules';\nimport { toMs } from '../../../../util/pretty-time';\nimport type { LookupUpdateConfig, UpdateResult } from './types';\nimport { getUpdateType } from './update-type';\n\nexport interface InternalChecksResult {\n  release?: Release;\n  pendingChecks: boolean;\n  pendingReleases?: Release[];\n}\n\nexport async function filterInternalChecks(\n  config: Partial<LookupUpdateConfig & UpdateResult>,\n  versioningApi: VersioningApi,\n  bucket: string,\n  sortedReleases: Release[],\n): Promise<InternalChecksResult> {\n  const { currentVersion, datasource, depName, internalChecksFilter } = config;\n  let release: Release | undefined = undefined;\n  let pendingChecks = false;\n  let pendingReleases: Release[] = [];\n  if (internalChecksFilter === 'none') {\n    // Don't care if minimumReleaseAge or minimumConfidence are unmet\n    release = sortedReleases.pop();\n  } else {\n    // iterate through releases from highest to lowest, looking for the first which will pass checks if present\n    for (let candidateRelease of sortedReleases.reverse()) {\n      // merge the release data into dependency config\n      let releaseConfig = mergeChildConfig(config, candidateRelease);\n      // calculate updateType and then apply it\n      releaseConfig.updateType = getUpdateType(\n        releaseConfig,\n        versioningApi,\n        // TODO #22198\n        currentVersion!,\n        candidateRelease.version,\n      );\n      releaseConfig = mergeChildConfig(\n        releaseConfig,\n        releaseConfig[releaseConfig.updateType]!,\n      );\n      // Apply packageRules in case any apply to updateType\n      releaseConfig = await applyPackageRules(releaseConfig, 'update-type');\n\n      const updatedCandidateRelease = await postprocessRelease(\n        releaseConfig,\n        candidateRelease,\n      );\n      if (!updatedCandidateRelease) {\n        continue;\n      }\n      candidateRelease = updatedCandidateRelease;\n\n      // Now check for a minimumReleaseAge config\n      const { minimumConfidence, minimumReleaseAge, updateType } =\n        releaseConfig;\n      if (\n        is.nonEmptyString(minimumReleaseAge) &&\n        candidateRelease.releaseTimestamp\n      ) {\n        if (\n          getElapsedMs(candidateRelease.releaseTimestamp) <\n          coerceNumber(toMs(minimumReleaseAge), 0)\n        ) {\n          // Skip it if it doesn't pass checks\n          logger.trace(\n            { depName, check: 'minimumReleaseAge' },\n            `Release ${candidateRelease.version} is pending status checks`,\n          );\n          pendingReleases.unshift(candidateRelease);\n          continue;\n        }\n      }\n\n      // TODO #22198\n      if (isActiveConfidenceLevel(minimumConfidence!)) {\n        const confidenceLevel =\n          (await getMergeConfidenceLevel(\n            datasource!,\n            depName!,\n            currentVersion!,\n            candidateRelease.version,\n            updateType!,\n          )) ?? 'neutral';\n        // TODO #22198\n        if (!satisfiesConfidenceLevel(confidenceLevel, minimumConfidence!)) {\n          logger.trace(\n            { depName, check: 'minimumConfidence' },\n            `Release ${candidateRelease.version} is pending status checks`,\n          );\n          pendingReleases.unshift(candidateRelease);\n          continue;\n        }\n      }\n      // If we get to here, then the release is OK and we can stop iterating\n      release = candidateRelease;\n      break;\n    }\n    if (!release) {\n      if (pendingReleases.length) {\n        // If all releases were pending then just take the highest\n        logger.trace(\n          { depName, bucket },\n          'All releases are pending - using latest',\n        );\n        release = pendingReleases.pop();\n        // None are pending anymore because we took the latest, so empty the array\n        pendingReleases = [];\n        if (internalChecksFilter === 'strict') {\n          pendingChecks = true;\n        }\n      }\n    }\n  }\n\n  return { release, pendingChecks, pendingReleases };\n}\n"]}