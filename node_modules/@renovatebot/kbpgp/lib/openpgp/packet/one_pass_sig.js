// Generated by IcedCoffeeScript 112.8.1
var C, OPS_Parser, OnePassSignature, Packet, asymmetric, hash, iced, uint_to_buffer,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

iced = require('iced-runtime-3');

Packet = require('./base').Packet;

C = require('../../const').openpgp;

asymmetric = require('../../asymmetric');

hash = require('../../hash');

uint_to_buffer = require('../../util').uint_to_buffer;

OnePassSignature = (function(superClass) {
  extend(OnePassSignature, superClass);

  function OnePassSignature(arg) {
    this.sig_type = arg.sig_type, this.hasher = arg.hasher, this.sig_klass = arg.sig_klass, this.key_id = arg.key_id, this.is_final = arg.is_final;
  }

  OnePassSignature.parse = function(slice) {
    return (new OPS_Parser(slice)).parse();
  };

  OnePassSignature.prototype.write_unframed = function(cb) {
    var bufs, unframed, vals, x;
    vals = [C.versions.one_pass_sig, this.sig_type, this.hasher.type, this.sig_klass.type];
    bufs = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = vals.length; i < len; i++) {
        x = vals[i];
        results.push(uint_to_buffer(8, x));
      }
      return results;
    })();
    bufs.push(this.key_id);
    bufs.push(uint_to_buffer(8, this.is_final));
    unframed = Buffer.concat(bufs);
    return cb(null, unframed);
  };

  OnePassSignature.prototype.write = function(cb) {
    var __iced_it, __iced_passed_deferral;
    __iced_passed_deferral = iced.findDeferral(arguments);
    __iced_it = (function(_this) {
      var err, framed, unframed;
      return function*() {
        var __iced_deferrals;
        __iced_deferrals = new iced.Deferrals(__iced_it, {
          parent: __iced_passed_deferral,
          funcname: "OnePassSignature::write",
          filename: "/home/runner/work/kbpgp/kbpgp/src/openpgp/packet/one_pass_sig.iced"
        });
        _this.write_unframed(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return unframed = arguments[1];
            };
          })(),
          lineno: 38
        }));
        if (__iced_deferrals.await_exit()) {
          yield;
        }
        framed = _this.frame_packet(C.packet_tags.one_pass_sig, unframed);
        return cb(err, framed);
      };
    })(this)();
    __iced_it.next();
    return null;
  };

  return OnePassSignature;

})(Packet);

OPS_Parser = (function() {
  function OPS_Parser(slice1) {
    this.slice = slice1;
  }

  OPS_Parser.prototype.parse = function() {
    var hasher, is_final, key_id, sig_klass, sig_type, v;
    if ((v = this.slice.read_uint8()) !== C.versions.one_pass_sig) {
      throw new Error("Unknown OnePassSignature version " + v);
    }
    sig_type = this.slice.read_uint8();
    hasher = hash.alloc_or_throw(this.slice.read_uint8());
    sig_klass = asymmetric.get_class(this.slice.read_uint8());
    key_id = this.slice.read_buffer(8);
    is_final = this.slice.read_uint8();
    return new OnePassSignature({
      sig_type: sig_type,
      hasher: hasher,
      sig_klass: sig_klass,
      key_id: key_id,
      is_final: is_final
    });
  };

  return OPS_Parser;

})();

exports.OnePassSignature = OnePassSignature;

//# sourceMappingURL=one_pass_sig.js.map
