// Generated by IcedCoffeeScript 112.8.1
var ASP, BaseKey, BaseKeyPair, C, K, MRF, Pair, Priv, Pub, SRF, bn, bufeq_secure, eme_pkcs1_decode, eme_pkcs1_encode, konst, make_esc, ref, ref1, ref2, ref3,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

bn = require('./bn');

ref = require('./util'), bufeq_secure = ref.bufeq_secure, ASP = ref.ASP;

make_esc = require('iced-error').make_esc;

konst = require('./const');

C = konst.openpgp;

K = konst.kb;

ref1 = require('./basekeypair'), BaseKeyPair = ref1.BaseKeyPair, BaseKey = ref1.BaseKey;

ref2 = require('./rand'), SRF = ref2.SRF, MRF = ref2.MRF;

ref3 = require('./pad'), eme_pkcs1_encode = ref3.eme_pkcs1_encode, eme_pkcs1_decode = ref3.eme_pkcs1_decode;

Pub = (function(superClass) {
  extend(Pub, superClass);

  Pub.type = C.public_key_algorithms.ELGAMAL_SIGN_AND_ENCRYPT;

  Pub.prototype.type = Pub.type;

  Pub.ORDER = [];

  Pub.prototype.ORDER = Pub.ORDER;

  function Pub(raw1) {
    this.raw = raw1;
  }

  Pub.alloc = function(raw) {
    return BaseKey.alloc(Pub, raw);
  };

  Pub.prototype.encrypt = function(m, cb) {
    return cb(null);
  };

  return Pub;

})(BaseKey);

Priv = (function(superClass) {
  extend(Priv, superClass);

  Priv.ORDER = [];

  Priv.prototype.ORDER = Priv.ORDER;

  function Priv(raw1) {
    this.raw = raw1;
  }

  Priv.prototype.serialize = function() {
    return null;
  };

  Priv.alloc = function(raw, pub) {
    return BaseKey.alloc(Priv, raw, {
      pub: pub
    });
  };

  Priv.prototype.decrypt = function(c, cb) {
    return cb(null);
  };

  return Priv;

})(BaseKey);

Pair = (function(superClass) {
  extend(Pair, superClass);

  Pair.Pub = Pub;

  Pair.prototype.Pub = Pub;

  Pair.Priv = Priv;

  Pair.prototype.Priv = Priv;

  Pair.type = C.public_key_algorithms.ELGAMAL_SIGN_AND_ENCRYPT;

  Pair.prototype.type = Pair.type;

  Pair.prototype.fulfills_flags = function(flags) {
    return false;
  };

  Pair.prototype.is_toxic = function() {
    return true;
  };

  function Pair(arg) {
    var priv, pub;
    pub = arg.pub, priv = arg.priv;
    Pair.__super__.constructor.call(this, {
      pub: pub,
      priv: priv
    });
  }

  Pair.prototype.can_sign = function() {
    return false;
  };

  Pair.prototype.can_decrypt = function() {
    return false;
  };

  Pair.prototype.err = function() {
    return new Error("refusing to use ElGamal Sign+Encrypt");
  };

  Pair.parse = function(pub_raw) {
    var ret;
    ret = BaseKeyPair.parse(Pair, pub_raw);
    return ret;
  };

  Pair.prototype.pad_and_encrypt = function(data, cb) {
    return cb(this.err(), null);
  };

  Pair.prototype.decrypt_and_unpad = function(ciphertext, params, cb) {
    return cb(this.err(), null);
  };

  Pair.parse_output = function(buf) {
    return null;
  };

  Pair.prototype.export_output = function(args) {
    return null;
  };

  return Pair;

})(BaseKeyPair);

exports.ElGamalSignEncrypt = exports.Pair = Pair;

//# sourceMappingURL=elgamalse.js.map
