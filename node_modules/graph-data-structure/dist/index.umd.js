!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).graphDataStructure={})}(this,(function(e){"use strict";function t(e,t){if(!1===e||null==e)throw console.warn("Test invariant failed:",t),new Error(t)}class o{nodes=new Set;edges=new Map;edgeWeights=new Map;edgeProperties=new Map;addNode(e){return this.nodes.has(e)||this.nodes.add(e),this.edges.has(e)||this.edges.set(e,new Set),this}removeNode(e){this.edges.delete(e),this.nodes.delete(e);for(const t of this.edges.values())t.delete(e);return this}adjacent(e){return this.edges.get(e)}setEdgeWeight(e,o,r){this.edgeWeights.has(e)||this.edgeWeights.set(e,new Map);const n=this.edgeWeights.get(e);return t(n),n.set(o,r),this}getEdgeWeight(e,t){return this.edgeWeights.get(e)?.get(t)??1}setEdgeProperties(e,o,r){this.edgeProperties.has(e)||this.edgeProperties.set(e,new Map);const n=this.edgeProperties.get(e);return t(n),n.set(o,r),this}getEdgeProperties(e,t){return this.edgeProperties.get(e)?.get(t)}addEdge(e,o,...r){let n,s;const d=r[0];"number"==typeof d&&(n=d),"object"==typeof d&&(n=d.weight,d&&(s=Object.prototype.hasOwnProperty.call(d,"props")?d.props:void 0)),this.addNode(e),this.addNode(o);const i=this.adjacent(e);return t(i),i.add(o),void 0!==n&&this.setEdgeWeight(e,o,n),void 0!==s&&this.setEdgeProperties(e,o,s),this}removeEdge(e,t){return this.edges.get(e)?.delete(t),this.edgeProperties.get(e)?.delete(t),this}hasEdge(e,t){return this.edges.get(e)?.has(t)??!1}}class r extends Error{constructor(e){super(e),Object.setPrototypeOf(this,r.prototype)}}function n(e,t,o,s,d,i){const{errorOnCycle:h=!1,shouldFollow:g}=i;if(s.has(d)&&h)throw new r("Cycle found");o.has(d)||(o.add(d),s.add(d),e.adjacent(d)?.forEach((r=>{(void 0===g||g({source:d,target:r,graph:e,props:e.getEdgeProperties(d,r)}))&&n(e,t,o,s,r,i)})),s.delete(d),t.push(d))}function s(e,t={}){const{sourceNodes:o=Array.from(e.nodes),includeSourceNodes:r=!0}=t,s=new Set,d=new Set,i=[];if(r){for(let r=0;r<o.length;r++){const h=o[r];h&&n(e,i,s,d,h,t)}return i}for(let e=0;e<o.length;e++){const t=o[e];t&&s.add(t)}for(let r=0;r<o.length;r++){const h=o[r];h&&e.adjacent(h)?.forEach((o=>n(e,i,s,d,o,t)))}return i}function d(e){let t,o=1/0;const{d:r,q:n}=e;return n.forEach((e=>{const n=r.get(e)??1/0;n<o&&(o=n,t=e)})),void 0===t?(n.clear(),null):(n.delete(t),t)}function i(e,o,r,n){const{d:s,p:d}=o,i=e.getEdgeWeight(r,n),h=s.get(r),g=s.get(n);t(h,"Missing source distance"),t(g,"Missing target distance"),g>h+i&&(s.set(n,h+i),d.set(n,r))}function h(e,t,o,r){const n=e.nodes,{q:s}=t;for(!function(e,{d:t},o,r){if(e.forEach((e=>{t.set(e,1/0)})),t.get(o)!==1/0)throw new Error("Source node is not in the graph");if(t.get(r)!==1/0)throw new Error("Destination node is not in the graph");t.set(o,0)}(n,t,o,r),function(e,{q:t}){e.forEach((e=>{t.add(e)}))}(n,t);0!==s.size;){const o=d(t);if(null===o)return;e.adjacent(o)?.forEach((r=>{i(e,t,o,r)}))}}function g(e){return void 0===e.currentPathWeight?e.edgeWeight:e.edgeWeight+e.currentPathWeight}function c(e,o,r,n=g){const s={d:new Map,p:new Map,q:new Set};return h(e,s,o,r),function(e,o,r,n,s=g){const{p:d}=o,i=[];let h,c=n;for(;d.has(c);){const e=d.get(c);i.push(c),c=e}if(c!==r)throw new Error("No path found");i.push(c),i.reverse(),t(i.length>=2,"The path should have a least two nodes");for(let t=1;t<i.length;t++){const o=i[t-1],r=i[t],n=e.getEdgeWeight(o,r),d=e.getEdgeProperties(o,r);h=s({edgeWeight:n,currentPathWeight:h,hop:t,graph:e,path:i,previousNode:o,currentNode:r,props:d})}return{nodes:i,weight:h}}(e,s,o,r,n)}function a(e,t,o,r,n,s){return!!r.has(n)||(r.add(n),t.push(n),n==s?(o.push(n),!1):Array.from(e.adjacent(n)??[]).every((n=>a(e,t,o,r,n,s))))}function u(e,t,o,r,n){r.has(n)||(r.add(n),t.indexOf(n)>=0?o.push(n):0==o.length&&e.adjacent(n)?.forEach((n=>{u(e,t,o,r,n)})))}e.CycleError=r,e.Graph=o,e.cloneGraph=function(e){const t=new o;for(let[o,r]of e.edges.entries())r.forEach((r=>{t.addEdge.apply(t,[o,r]);const n=e.edgeWeights.get(o)?.get(r);n&&t.setEdgeWeight(o,r,n);const s=e.getEdgeProperties(o,r);s&&t.setEdgeProperties(o,r,s)}));return t},e.depthFirstSearch=s,e.deserializeGraph=function(...e){const[t,r]=e,n=new o,s=new Map;return t.nodes.forEach((e=>{n.addNode(e),r&&s.set(r(e),e)})),t.links.forEach((e=>{if(!r)return void n.addEdge.apply(n,[e.source,e.target,e.weight,e.props]);const t=s.get(r(e.source))??e.source,o=s.get(r(e.target))??e.target;n.addEdge.apply(n,[t,o,e.weight,e.props])})),n},e.findNodes=function(e,t){const o=[];return e.nodes.forEach((e=>{t(e)&&o.push(e)})),o},e.getFirstNode=function(e,t){for(const o of e.nodes)if(t(o))return o;throw new Error("Node not found.")},e.getNode=function(e,t){const o=[];for(const r of e.nodes)t(r)&&o.push(r);if(0===o.length)throw new Error("Node not found.");if(o.length>1)throw new Error("More than one node found.");return o[0]},e.hasCycle=function(e,t){try{return s(e,{...t,includeSourceNodes:!0,errorOnCycle:!0}),!1}catch(e){if(e instanceof r)return!0;throw e}},e.indegree=function(e,t){let o=0;for(const r of e.edges.values())for(let e of r)e===t&&o++;return o},e.lowestCommonAncestors=function(e,t,o){const r=[],n=[];return a(e,r,n,new Set,t,o)&&u(e,r,n,new Set,o),n},e.outdegree=function(e,t){return e.edges.get(t)?.size??0},e.serializeGraph=function(e,...t){const o="function"==typeof t[0]?t[0]:void 0,r="function"==typeof t[0]?t[1]:t[0],{includeDefaultWeight:n=!1}=r??{},s={nodes:Array.from(e.nodes),links:[]},d=new Map;return s.nodes.forEach((t=>{const r=t;e.adjacent(r)?.forEach((t=>{const i=e.getEdgeWeight(r,t),h=e.getEdgeProperties(r,t);o&&!d.has(r)&&d.set(r,o(r)),o&&!d.has(t)&&d.set(t,o(t));const g={source:d.get(r)??r,target:d.get(t)??t};(1!=i||n)&&(g.weight=i),h&&(g.props=h),s.links.push(g)}))})),s},e.shortestPath=c,e.shortestPaths=function(e,t,o){let r=c(e,t,o);const n=[r],s=r.weight,d=[];for(;r.weight;){const i=r.nodes[0],h=r.nodes[1];e.hasEdge(i,h)&&(d.push({u:i,v:h,weight:e.getEdgeWeight(i,h),props:e.getEdgeProperties(i,h)}),e.removeEdge(i,h)),e.hasEdge(h,i)&&(d.push({u:h,v:i,weight:e.getEdgeWeight(h,i),props:e.getEdgeProperties(h,i)}),e.removeEdge(h,i));try{if(r=c(e,t,o),!r.weight||!s||s<r.weight)break;n.push(r)}catch(e){break}}for(const{u:t,v:o,weight:r,props:n}of d)e.addEdge(t,o,r,n);return n},e.topologicalSort=function(e,t={}){return s(e,{...t,errorOnCycle:!0}).reverse()}}));
//# sourceMappingURL=index.umd.js.map
