{"version":3,"file":"noble_hashes.min.mjs","sources":["../../node_modules/@noble/hashes/esm/sha1.js","../../node_modules/@noble/hashes/esm/ripemd160.js","../../../../../src/crypto/hash/md5.ts","../../src/crypto/hash/noble_hashes.js"],"sourcesContent":["import { HashMD, Chi, Maj } from './_md.js';\nimport { rotl, wrapConstructor } from './utils.js';\n// SHA1 (RFC 3174). It was cryptographically broken: prefer newer algorithms.\n// Initial state\nconst SHA1_IV = /* @__PURE__ */ new Uint32Array([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA1 extends HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = Chi(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = Maj(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = rotl(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        SHA1_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * SHA1 (RFC 3174) hash function.\n * It was cryptographically broken: prefer newer algorithms.\n * @param message - data that would be hashed\n */\nexport const sha1 = /* @__PURE__ */ wrapConstructor(() => new SHA1());\n//# sourceMappingURL=sha1.js.map","import { HashMD } from './_md.js';\nimport { rotl, wrapConstructor } from './utils.js';\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst R_BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            R_BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        R_BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map","// Copied from https://github.com/paulmillr/noble-hashes/blob/main/test/misc/md5.ts\n\nimport { HashMD } from '@noble/hashes/_md';\nimport { rotl, wrapConstructor } from '@noble/hashes/utils';\n\n// Per-round constants\nconst K = Array.from({ length: 64 }, (_, i) => Math.floor(2 ** 32 * Math.abs(Math.sin(i + 1))));\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Initial state (same as sha1, but 4 u32 instead of 5)\nconst IV = /* @__PURE__ */ new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);\n// Temporary buffer, not used to store anything between runs\n// Named this way for SHA1 compat\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\nclass MD5 extends HashMD<MD5> {\n  private A = IV[0] | 0;\n  private B = IV[1] | 0;\n  private C = IV[2] | 0;\n  private D = IV[3] | 0;\n  constructor() {\n    super(64, 16, 8, true);\n  }\n  protected get(): [number, number, number, number] {\n    const { A, B, C, D } = this;\n    return [A, B, C, D];\n  }\n  protected set(A: number, B: number, C: number, D: number) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D } = this;\n    for (let i = 0; i < 64; i++) {\n      // eslint-disable-next-line one-var, one-var-declaration-per-line\n      let F, g, s;\n      if (i < 16) {\n        // eslint-disable-next-line new-cap\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        // eslint-disable-next-line new-cap\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = (7 * i) % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    this.set(A, B, C, D);\n  }\n  protected roundClean() {\n    MD5_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\nexport const md5 = /* @__PURE__ */ wrapConstructor(() => new MD5());\n","/**\n * This file is needed to dynamic import the noble-hashes.\n * Separate dynamic imports are not convenient as they result in too many chunks,\n * which share a lot of code anyway.\n */\n\nimport { sha1 } from '@noble/hashes/sha1';\nimport { sha224, sha256 } from '@noble/hashes/sha256';\nimport { sha384, sha512 } from '@noble/hashes/sha512';\nimport { sha3_256, sha3_512 } from '@noble/hashes/sha3';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { md5 } from './md5';\n\nexport const nobleHashes = new Map(Object.entries({\n  md5,\n  sha1,\n  sha224,\n  sha256,\n  sha384,\n  sha512,\n  sha3_256,\n  sha3_512,\n  ripemd160\n}));\n"],"names":["SHA1_IV","Uint32Array","SHA1_W","SHA1","HashMD","constructor","super","this","A","B","C","D","E","get","set","process","view","offset","i","getUint32","rotl","F","K","Chi","Maj","T","roundClean","fill","destroy","buffer","sha1","wrapConstructor","Rho","Uint8Array","Id","Array","map","_","idxL","idxR","j","push","k","shifts","shiftsL","idx","shiftsR","Kl","Kr","f","group","x","y","z","R_BUF","RIPEMD160","h0","h1","h2","h3","h4","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","destroyed","ripemd160","from","length","Math","floor","abs","sin","a","b","c","IV","MD5_W","MD5","g","s","nobleHashes","Map","Object","entries","md5","sha224","sha256","sha384","sha512","sha3_256","sha3_512"],"mappings":"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","x_google_ignoreList":[0,1]}