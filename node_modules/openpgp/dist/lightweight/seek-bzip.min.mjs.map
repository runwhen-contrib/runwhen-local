{"version":3,"file":"seek-bzip.min.mjs","sources":["../../node_modules/@openpgp/seek-bzip/lib/bitreader.js","../../node_modules/@openpgp/seek-bzip/lib/stream.js","../../node_modules/@openpgp/seek-bzip/lib/crc32.js","../../node_modules/@openpgp/seek-bzip/lib/index.js"],"sourcesContent":["/*\nnode-bzip - a pure-javascript Node.JS module for decoding bzip2 data\n\nCopyright (C) 2012 Eli Skeggs\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, see\nhttp://www.gnu.org/licenses/lgpl-2.1.html\n\nAdapted from bzip2.js, copyright 2011 antimatter15 (antimatter15@gmail.com).\n\nBased on micro-bunzip by Rob Landley (rob@landley.net).\n\nBased on bzip2 decompression code by Julian R Seward (jseward@acm.org),\nwhich also acknowledges contributions by Mike Burrows, David Wheeler,\nPeter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,\nRobert Sedgewick, and Jon L. Bentley.\n*/\n\nvar BITMASK = [0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];\n\n// offset in bytes\nvar BitReader = function(stream) {\n  this.stream = stream;\n  this.bitOffset = 0;\n  this.curByte = 0;\n  this.hasByte = false;\n};\n\nBitReader.prototype._ensureByte = function() {\n  if (!this.hasByte) {\n    this.curByte = this.stream.readByte();\n    this.hasByte = true;\n  }\n};\n\n// reads bits from the buffer\nBitReader.prototype.read = function(bits) {\n  var result = 0;\n  while (bits > 0) {\n    this._ensureByte();\n    var remaining = 8 - this.bitOffset;\n    // if we're in a byte\n    if (bits >= remaining) {\n      result <<= remaining;\n      result |= BITMASK[remaining] & this.curByte;\n      this.hasByte = false;\n      this.bitOffset = 0;\n      bits -= remaining;\n    } else {\n      result <<= bits;\n      var shift = remaining - bits;\n      result |= (this.curByte & (BITMASK[bits] << shift)) >> shift;\n      this.bitOffset += bits;\n      bits = 0;\n    }\n  }\n  return result;\n};\n\n// seek to an arbitrary point in the buffer (expressed in bits)\nBitReader.prototype.seek = function(pos) {\n  var n_bit = pos % 8;\n  var n_byte = (pos - n_bit) / 8;\n  this.bitOffset = n_bit;\n  this.stream.seek(n_byte);\n  this.hasByte = false;\n};\n\n// reads 6 bytes worth of data using the read method\nBitReader.prototype.pi = function() {\n  var buf = new Uint8Array(6), i;\n  for (i = 0; i < buf.length; i++) {\n    buf[i] = this.read(8);\n  }\n  return bufToHex(buf);\n};\n\nfunction bufToHex(buf) {\n  return Array.prototype.map.call(buf, x => ('00' + x.toString(16)).slice(-2)).join('');\n}\n\nmodule.exports = BitReader;\n","/* very simple input/output stream interface */\nvar Stream = function() {\n};\n\n// input streams //////////////\n/** Returns the next byte, or -1 for EOF. */\nStream.prototype.readByte = function() {\n  throw new Error(\"abstract method readByte() not implemented\");\n};\n/** Attempts to fill the buffer; returns number of bytes read, or\n *  -1 for EOF. */\nStream.prototype.read = function(buffer, bufOffset, length) {\n  var bytesRead = 0;\n  while (bytesRead < length) {\n    var c = this.readByte();\n    if (c < 0) { // EOF\n      return (bytesRead===0) ? -1 : bytesRead;\n    }\n    buffer[bufOffset++] = c;\n    bytesRead++;\n  }\n  return bytesRead;\n};\nStream.prototype.seek = function(new_pos) {\n  throw new Error(\"abstract method seek() not implemented\");\n};\n\n// output streams ///////////\nStream.prototype.writeByte = function(_byte) {\n  throw new Error(\"abstract method readByte() not implemented\");\n};\nStream.prototype.write = function(buffer, bufOffset, length) {\n  var i;\n  for (i=0; i<length; i++) {\n    this.writeByte(buffer[bufOffset++]);\n  }\n  return length;\n};\nStream.prototype.flush = function() {\n};\n\nmodule.exports = Stream;\n","/* CRC32, used in Bzip2 implementation.\n * This is a port of CRC32.java from the jbzip2 implementation at\n *   https://code.google.com/p/jbzip2\n * which is:\n *   Copyright (c) 2011 Matthew Francis\n *\n *   Permission is hereby granted, free of charge, to any person\n *   obtaining a copy of this software and associated documentation\n *   files (the \"Software\"), to deal in the Software without\n *   restriction, including without limitation the rights to use,\n *   copy, modify, merge, publish, distribute, sublicense, and/or sell\n *   copies of the Software, and to permit persons to whom the\n *   Software is furnished to do so, subject to the following\n *   conditions:\n *\n *   The above copyright notice and this permission notice shall be\n *   included in all copies or substantial portions of the Software.\n *\n *   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n *   OTHER DEALINGS IN THE SOFTWARE.\n * This JavaScript implementation is:\n *   Copyright (c) 2013 C. Scott Ananian\n * with the same licensing terms as Matthew Francis' original implementation.\n */\nmodule.exports = (function() {\n\n  /**\n   * A static CRC lookup table\n   */\n  var crc32Lookup = new Uint32Array([\n    0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n    0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n    0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n    0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n    0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n    0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n    0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n    0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n    0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n    0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n    0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n    0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n    0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n    0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n    0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n    0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n    0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n    0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n    0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n    0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n    0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n    0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n    0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n    0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n    0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n    0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n    0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n    0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n    0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n    0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n    0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n  ]);\n\n  var CRC32 = function() {\n    /**\n     * The current CRC\n     */\n    var crc = 0xffffffff;\n\n    /**\n     * @return The current CRC\n     */\n    this.getCRC = function() {\n      return (~crc) >>> 0; // return an unsigned value\n    };\n\n    /**\n     * Update the CRC with a single byte\n     * @param value The value to update the CRC with\n     */\n    this.updateCRC = function(value) {\n      crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];\n    };\n\n    /**\n     * Update the CRC with a sequence of identical bytes\n     * @param value The value to update the CRC with\n     * @param count The number of bytes\n     */\n    this.updateCRCRun = function(value, count) {\n      while (count-- > 0) {\n        crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];\n      }\n    };\n  };\n  return CRC32;\n})();\n","/*\nseek-bzip - a pure-javascript module for seeking within bzip2 data\n\nCopyright (C) 2013 C. Scott Ananian\nCopyright (C) 2012 Eli Skeggs\nCopyright (C) 2011 Kevin Kwok\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, see\nhttp://www.gnu.org/licenses/lgpl-2.1.html\n\nAdapted from node-bzip, copyright 2012 Eli Skeggs.\nAdapted from bzip2.js, copyright 2011 Kevin Kwok (antimatter15@gmail.com).\n\nBased on micro-bunzip by Rob Landley (rob@landley.net).\n\nBased on bzip2 decompression code by Julian R Seward (jseward@acm.org),\nwhich also acknowledges contributions by Mike Burrows, David Wheeler,\nPeter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,\nRobert Sedgewick, and Jon L. Bentley.\n*/\n\nvar BitReader = require('./bitreader');\nvar Stream = require('./stream');\nvar CRC32 = require('./crc32');\n\nvar MAX_HUFCODE_BITS = 20;\nvar MAX_SYMBOLS = 258;\nvar SYMBOL_RUNA = 0;\nvar SYMBOL_RUNB = 1;\nvar MIN_GROUPS = 2;\nvar MAX_GROUPS = 6;\nvar GROUP_SIZE = 50;\n\nvar WHOLEPI = \"314159265359\";\nvar SQRTPI = \"177245385090\";\n\nvar mtf = function(array, index) {\n  var src = array[index], i;\n  for (i = index; i > 0; i--) {\n    array[i] = array[i-1];\n  }\n  array[0] = src;\n  return src;\n};\n\nvar Err = {\n  OK: 0,\n  LAST_BLOCK: -1,\n  NOT_BZIP_DATA: -2,\n  UNEXPECTED_INPUT_EOF: -3,\n  UNEXPECTED_OUTPUT_EOF: -4,\n  DATA_ERROR: -5,\n  OUT_OF_MEMORY: -6,\n  OBSOLETE_INPUT: -7,\n  END_OF_BLOCK: -8\n};\nvar ErrorMessages = {};\nErrorMessages[Err.LAST_BLOCK] =            \"Bad file checksum\";\nErrorMessages[Err.NOT_BZIP_DATA] =         \"Not bzip data\";\nErrorMessages[Err.UNEXPECTED_INPUT_EOF] =  \"Unexpected input EOF\";\nErrorMessages[Err.UNEXPECTED_OUTPUT_EOF] = \"Unexpected output EOF\";\nErrorMessages[Err.DATA_ERROR] =            \"Data error\";\nErrorMessages[Err.OUT_OF_MEMORY] =         \"Out of memory\";\nErrorMessages[Err.OBSOLETE_INPUT] = \"Obsolete (pre 0.9.5) bzip format not supported.\";\n\nvar _throw = function(status, optDetail) {\n  var msg = ErrorMessages[status] || 'unknown error';\n  if (optDetail) { msg += ': '+optDetail; }\n  var e = new TypeError(msg);\n  e.errorCode = status;\n  throw e;\n};\n\nvar Bunzip = function(inputStream, outputStream) {\n  this.writePos = this.writeCurrent = this.writeCount = 0;\n\n  this._start_bunzip(inputStream, outputStream);\n};\nBunzip.prototype._init_block = function() {\n  var moreBlocks = this._get_next_block();\n  if ( !moreBlocks ) {\n    this.writeCount = -1;\n    return false; /* no more blocks */\n  }\n  this.blockCRC = new CRC32();\n  return true;\n};\n/* XXX micro-bunzip uses (inputStream, inputBuffer, len) as arguments */\nBunzip.prototype._start_bunzip = function(inputStream, outputStream) {\n  /* Ensure that file starts with \"BZh['1'-'9'].\" */\n  var buf = new Uint8Array(4);\n  if (inputStream.read(buf, 0, 4) !== 4 ||\n      String.fromCharCode(buf[0], buf[1], buf[2]) !== 'BZh')\n    _throw(Err.NOT_BZIP_DATA, 'bad magic');\n\n  var level = buf[3] - 0x30;\n  if (level < 1 || level > 9)\n    _throw(Err.NOT_BZIP_DATA, 'level out of range');\n\n  this.reader = new BitReader(inputStream);\n\n  /* Fourth byte (ascii '1'-'9'), indicates block size in units of 100k of\n     uncompressed data.  Allocate intermediate buffer for block. */\n  this.dbufSize = 100000 * level;\n  this.nextoutput = 0;\n  this.outputStream = outputStream;\n  this.streamCRC = 0;\n};\nBunzip.prototype._get_next_block = function() {\n  var i, j, k;\n  var reader = this.reader;\n  // this is get_next_block() function from micro-bunzip:\n  /* Read in header signature and CRC, then validate signature.\n     (last block signature means CRC is for whole file, return now) */\n  var h = reader.pi();\n  if (h === SQRTPI) { // last block\n    return false; /* no more blocks */\n  }\n  if (h !== WHOLEPI)\n    _throw(Err.NOT_BZIP_DATA);\n  this.targetBlockCRC = reader.read(32) >>> 0; // (convert to unsigned)\n  this.streamCRC = (this.targetBlockCRC ^\n                    ((this.streamCRC << 1) | (this.streamCRC>>>31))) >>> 0;\n  /* We can add support for blockRandomised if anybody complains.  There was\n     some code for this in busybox 1.0.0-pre3, but nobody ever noticed that\n     it didn't actually work. */\n  if (reader.read(1))\n    _throw(Err.OBSOLETE_INPUT);\n  var origPointer = reader.read(24);\n  if (origPointer > this.dbufSize)\n    _throw(Err.DATA_ERROR, 'initial position out of bounds');\n  /* mapping table: if some byte values are never used (encoding things\n     like ascii text), the compression code removes the gaps to have fewer\n     symbols to deal with, and writes a sparse bitfield indicating which\n     values were present.  We make a translation table to convert the symbols\n     back to the corresponding bytes. */\n  var t = reader.read(16);\n  var symToByte = new Uint8Array(256), symTotal = 0;\n  for (i = 0; i < 16; i++) {\n    if (t & (1 << (0xF - i))) {\n      var o = i * 16;\n      k = reader.read(16);\n      for (j = 0; j < 16; j++)\n        if (k & (1 << (0xF - j)))\n          symToByte[symTotal++] = o + j;\n    }\n  }\n\n  /* How many different huffman coding groups does this block use? */\n  var groupCount = reader.read(3);\n  if (groupCount < MIN_GROUPS || groupCount > MAX_GROUPS)\n    _throw(Err.DATA_ERROR);\n  /* nSelectors: Every GROUP_SIZE many symbols we select a new huffman coding\n     group.  Read in the group selector list, which is stored as MTF encoded\n     bit runs.  (MTF=Move To Front, as each value is used it's moved to the\n     start of the list.) */\n  var nSelectors = reader.read(15);\n  if (nSelectors === 0)\n    _throw(Err.DATA_ERROR);\n\n  var mtfSymbol = new Uint8Array(256);\n  for (i = 0; i < groupCount; i++)\n    mtfSymbol[i] = i;\n\n  var selectors = new Uint8Array(nSelectors); // was 32768...\n\n  for (i = 0; i < nSelectors; i++) {\n    /* Get next value */\n    for (j = 0; reader.read(1); j++)\n      if (j >= groupCount) _throw(Err.DATA_ERROR);\n    /* Decode MTF to get the next selector */\n    selectors[i] = mtf(mtfSymbol, j);\n  }\n\n  /* Read the huffman coding tables for each group, which code for symTotal\n     literal symbols, plus two run symbols (RUNA, RUNB) */\n  var symCount = symTotal + 2;\n  var groups = [], hufGroup;\n  for (j = 0; j < groupCount; j++) {\n    var length = new Uint8Array(symCount), temp = new Uint16Array(MAX_HUFCODE_BITS + 1);\n    /* Read huffman code lengths for each symbol.  They're stored in\n       a way similar to mtf; record a starting value for the first symbol,\n       and an offset from the previous value for everys symbol after that. */\n    t = reader.read(5); // lengths\n    for (i = 0; i < symCount; i++) {\n      for (;;) {\n        if (t < 1 || t > MAX_HUFCODE_BITS) _throw(Err.DATA_ERROR);\n        /* If first bit is 0, stop.  Else second bit indicates whether\n           to increment or decrement the value. */\n        if(!reader.read(1))\n          break;\n        if(!reader.read(1))\n          t++;\n        else\n          t--;\n      }\n      length[i] = t;\n    }\n\n    /* Find largest and smallest lengths in this group */\n    var minLen,  maxLen;\n    minLen = maxLen = length[0];\n    for (i = 1; i < symCount; i++) {\n      if (length[i] > maxLen)\n        maxLen = length[i];\n      else if (length[i] < minLen)\n        minLen = length[i];\n    }\n\n    /* Calculate permute[], base[], and limit[] tables from length[].\n     *\n     * permute[] is the lookup table for converting huffman coded symbols\n     * into decoded symbols.  base[] is the amount to subtract from the\n     * value of a huffman symbol of a given length when using permute[].\n     *\n     * limit[] indicates the largest numerical value a symbol with a given\n     * number of bits can have.  This is how the huffman codes can vary in\n     * length: each code with a value>limit[length] needs another bit.\n     */\n    hufGroup = {};\n    groups.push(hufGroup);\n    hufGroup.permute = new Uint16Array(MAX_SYMBOLS);\n    hufGroup.limit = new Uint32Array(MAX_HUFCODE_BITS + 2);\n    hufGroup.base = new Uint32Array(MAX_HUFCODE_BITS + 1);\n    hufGroup.minLen = minLen;\n    hufGroup.maxLen = maxLen;\n    /* Calculate permute[].  Concurently, initialize temp[] and limit[]. */\n    var pp = 0;\n    for (i = minLen; i <= maxLen; i++) {\n      temp[i] = hufGroup.limit[i] = 0;\n      for (t = 0; t < symCount; t++)\n        if (length[t] === i)\n          hufGroup.permute[pp++] = t;\n    }\n    /* Count symbols coded for at each bit length */\n    for (i = 0; i < symCount; i++)\n      temp[length[i]]++;\n    /* Calculate limit[] (the largest symbol-coding value at each bit\n     * length, which is (previous limit<<1)+symbols at this level), and\n     * base[] (number of symbols to ignore at each bit length, which is\n     * limit minus the cumulative count of symbols coded for already). */\n    pp = t = 0;\n    for (i = minLen; i < maxLen; i++) {\n      pp += temp[i];\n      /* We read the largest possible symbol size and then unget bits\n         after determining how many we need, and those extra bits could\n         be set to anything.  (They're noise from future symbols.)  At\n         each level we're really only interested in the first few bits,\n         so here we set all the trailing to-be-ignored bits to 1 so they\n         don't affect the value>limit[length] comparison. */\n      hufGroup.limit[i] = pp - 1;\n      pp <<= 1;\n      t += temp[i];\n      hufGroup.base[i + 1] = pp - t;\n    }\n    hufGroup.limit[maxLen + 1] = Number.MAX_VALUE; /* Sentinal value for reading next sym. */\n    hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;\n    hufGroup.base[minLen] = 0;\n  }\n  /* We've finished reading and digesting the block header.  Now read this\n     block's huffman coded symbols from the file and undo the huffman coding\n     and run length encoding, saving the result into dbuf[dbufCount++]=uc */\n\n  /* Initialize symbol occurrence counters and symbol Move To Front table */\n  var byteCount = new Uint32Array(256);\n  for (i = 0; i < 256; i++)\n    mtfSymbol[i] = i;\n  /* Loop through compressed symbols. */\n  var runPos = 0, dbufCount = 0, selector = 0, uc;\n  var dbuf = this.dbuf = new Uint32Array(this.dbufSize);\n  symCount = 0;\n  for (;;) {\n    /* Determine which huffman coding group to use. */\n    if (!(symCount--)) {\n      symCount = GROUP_SIZE - 1;\n      if (selector >= nSelectors) { _throw(Err.DATA_ERROR); }\n      hufGroup = groups[selectors[selector++]];\n    }\n    /* Read next huffman-coded symbol. */\n    i = hufGroup.minLen;\n    j = reader.read(i);\n    for (;;i++) {\n      if (i > hufGroup.maxLen) { _throw(Err.DATA_ERROR); }\n      if (j <= hufGroup.limit[i])\n        break;\n      j = (j << 1) | reader.read(1);\n    }\n    /* Huffman decode value to get nextSym (with bounds checking) */\n    j -= hufGroup.base[i];\n    if (j < 0 || j >= MAX_SYMBOLS) { _throw(Err.DATA_ERROR); }\n    var nextSym = hufGroup.permute[j];\n    /* We have now decoded the symbol, which indicates either a new literal\n       byte, or a repeated run of the most recent literal byte.  First,\n       check if nextSym indicates a repeated run, and if so loop collecting\n       how many times to repeat the last literal. */\n    if (nextSym === SYMBOL_RUNA || nextSym === SYMBOL_RUNB) {\n      /* If this is the start of a new run, zero out counter */\n      if (!runPos){\n        runPos = 1;\n        t = 0;\n      }\n      /* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at\n         each bit position, add 1 or 2 instead.  For example,\n         1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.\n         You can make any bit pattern that way using 1 less symbol than\n         the basic or 0/1 method (except all bits 0, which would use no\n         symbols, but a run of length 0 doesn't mean anything in this\n         context).  Thus space is saved. */\n      if (nextSym === SYMBOL_RUNA)\n        t += runPos;\n      else\n        t += 2 * runPos;\n      runPos <<= 1;\n      continue;\n    }\n    /* When we hit the first non-run symbol after a run, we now know\n       how many times to repeat the last literal, so append that many\n       copies to our buffer of decoded symbols (dbuf) now.  (The last\n       literal used is the one at the head of the mtfSymbol array.) */\n    if (runPos){\n      runPos = 0;\n      if (dbufCount + t > this.dbufSize) { _throw(Err.DATA_ERROR); }\n      uc = symToByte[mtfSymbol[0]];\n      byteCount[uc] += t;\n      while (t--)\n        dbuf[dbufCount++] = uc;\n    }\n    /* Is this the terminating symbol? */\n    if (nextSym > symTotal)\n      break;\n    /* At this point, nextSym indicates a new literal character.  Subtract\n       one to get the position in the MTF array at which this literal is\n       currently to be found.  (Note that the result can't be -1 or 0,\n       because 0 and 1 are RUNA and RUNB.  But another instance of the\n       first symbol in the mtf array, position 0, would have been handled\n       as part of a run above.  Therefore 1 unused mtf position minus\n       2 non-literal nextSym values equals -1.) */\n    if (dbufCount >= this.dbufSize) { _throw(Err.DATA_ERROR); }\n    i = nextSym - 1;\n    uc = mtf(mtfSymbol, i);\n    uc = symToByte[uc];\n    /* We have our literal byte.  Save it into dbuf. */\n    byteCount[uc]++;\n    dbuf[dbufCount++] = uc;\n  }\n  /* At this point, we've read all the huffman-coded symbols (and repeated\n     runs) for this block from the input stream, and decoded them into the\n     intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].\n     Now undo the Burrows-Wheeler transform on dbuf.\n     See http://dogma.net/markn/articles/bwt/bwt.htm\n  */\n  if (origPointer < 0 || origPointer >= dbufCount) { _throw(Err.DATA_ERROR); }\n  /* Turn byteCount into cumulative occurrence counts of 0 to n-1. */\n  j = 0;\n  for (i = 0; i < 256; i++) {\n    k = j + byteCount[i];\n    byteCount[i] = j;\n    j = k;\n  }\n  /* Figure out what order dbuf would be in if we sorted it. */\n  for (i = 0; i < dbufCount; i++) {\n    uc = dbuf[i] & 0xff;\n    dbuf[byteCount[uc]] |= (i << 8);\n    byteCount[uc]++;\n  }\n  /* Decode first byte by hand to initialize \"previous\" byte.  Note that it\n     doesn't get output, and if the first three characters are identical\n     it doesn't qualify as a run (hence writeRunCountdown=5). */\n  var pos = 0, current = 0, run = 0;\n  if (dbufCount) {\n    pos = dbuf[origPointer];\n    current = (pos & 0xff);\n    pos >>= 8;\n    run = -1;\n  }\n  this.writePos = pos;\n  this.writeCurrent = current;\n  this.writeCount = dbufCount;\n  this.writeRun = run;\n\n  return true; /* more blocks to come */\n};\n/* Undo burrows-wheeler transform on intermediate buffer to produce output.\n   If start_bunzip was initialized with out_fd=-1, then up to len bytes of\n   data are written to outbuf.  Return value is number of bytes written or\n   error (all errors are negative numbers).  If out_fd!=-1, outbuf and len\n   are ignored, data is written to out_fd and return is RETVAL_OK or error.\n*/\nBunzip.prototype._read_bunzip = function(outputBuffer, len) {\n    var copies, previous, outbyte;\n    /* james@jamestaylor.org: writeCount goes to -1 when the buffer is fully\n       decoded, which results in this returning RETVAL_LAST_BLOCK, also\n       equal to -1... Confusing, I'm returning 0 here to indicate no\n       bytes written into the buffer */\n  if (this.writeCount < 0) { return 0; }\n\n  var gotcount = 0;\n  var dbuf = this.dbuf, pos = this.writePos, current = this.writeCurrent;\n  var dbufCount = this.writeCount, outputsize = this.outputsize;\n  var run = this.writeRun;\n\n  while (dbufCount) {\n    dbufCount--;\n    previous = current;\n    pos = dbuf[pos];\n    current = pos & 0xff;\n    pos >>= 8;\n    if (run++ === 3){\n      copies = current;\n      outbyte = previous;\n      current = -1;\n    } else {\n      copies = 1;\n      outbyte = current;\n    }\n    this.blockCRC.updateCRCRun(outbyte, copies);\n    while (copies--) {\n      this.outputStream.writeByte(outbyte);\n      this.nextoutput++;\n    }\n    if (current != previous)\n      run = 0;\n  }\n  this.writeCount = dbufCount;\n  // check CRC\n  if (this.blockCRC.getCRC() !== this.targetBlockCRC) {\n    _throw(Err.DATA_ERROR, \"Bad block CRC \"+\n           \"(got \"+this.blockCRC.getCRC().toString(16)+\n           \" expected \"+this.targetBlockCRC.toString(16)+\")\");\n  }\n  return this.nextoutput;\n};\n\nvar coerceInputStream = function(input) {\n  if ('readByte' in input) { return input; }\n  var inputStream = new Stream();\n  inputStream.pos = 0;\n  inputStream.readByte = function() { return input[this.pos++]; };\n  inputStream.seek = function(pos) { this.pos = pos; };\n  inputStream.eof = function() { return this.pos >= input.length; };\n  return inputStream;\n};\nvar coerceOutputStream = function(output) {\n  var outputStream = new Stream();\n  var resizeOk = true;\n  if (output) {\n    if (typeof(output)==='number') {\n      outputStream.buffer = new Uint8Array(output);\n      resizeOk = false;\n    } else if ('writeByte' in output) {\n      return output;\n    } else {\n      outputStream.buffer = output;\n      resizeOk = false;\n    }\n  } else {\n    outputStream.buffer = new Uint8Array(16384);\n  }\n  outputStream.pos = 0;\n  outputStream.writeByte = function(_byte) {\n    if (resizeOk && this.pos >= this.buffer.length) {\n      var newBuffer = new Uint8Array(this.buffer.length*2);\n      newBuffer.set(this.buffer);\n      this.buffer = newBuffer;\n    }\n    this.buffer[this.pos++] = _byte;\n  };\n  outputStream.getBuffer = function() {\n    // trim buffer\n    if (this.pos !== this.buffer.length) {\n      if (!resizeOk)\n        throw new TypeError('outputsize does not match decoded input');\n      var newBuffer = new Uint8Array(this.pos);\n      newBuffer.set(this.buffer.subarray(0, this.pos));\n      this.buffer = newBuffer;\n    }\n    return this.buffer;\n  };\n  outputStream._coerced = true;\n  return outputStream;\n};\n\n/* Static helper functions */\n// 'input' can be a stream or a buffer\n// 'output' can be a stream or a buffer or a number (buffer size)\nconst decode = function(input, output, multistream) {\n  // make a stream from a buffer, if necessary\n  var inputStream = coerceInputStream(input);\n  var outputStream = coerceOutputStream(output);\n\n  var bz = new Bunzip(inputStream, outputStream);\n  while (true) {\n    if ('eof' in inputStream && inputStream.eof()) break;\n    if (bz._init_block()) {\n      bz._read_bunzip();\n    } else {\n      var targetStreamCRC = bz.reader.read(32) >>> 0; // (convert to unsigned)\n      if (targetStreamCRC !== bz.streamCRC) {\n        _throw(Err.DATA_ERROR, \"Bad stream CRC \"+\n               \"(got \"+bz.streamCRC.toString(16)+\n               \" expected \"+targetStreamCRC.toString(16)+\")\");\n      }\n      if (multistream &&\n          'eof' in inputStream &&\n          !inputStream.eof()) {\n        // note that start_bunzip will also resync the bit reader to next byte\n        bz._start_bunzip(inputStream, outputStream);\n      } else break;\n    }\n  }\n  if ('getBuffer' in outputStream)\n    return outputStream.getBuffer();\n};\nconst decodeBlock = function(input, pos, output) {\n  // make a stream from a buffer, if necessary\n  var inputStream = coerceInputStream(input);\n  var outputStream = coerceOutputStream(output);\n  var bz = new Bunzip(inputStream, outputStream);\n  bz.reader.seek(pos);\n  /* Fill the decode buffer for the block */\n  var moreBlocks = bz._get_next_block();\n  if (moreBlocks) {\n    /* Init the CRC for writing */\n    bz.blockCRC = new CRC32();\n\n    /* Zero this so the current byte from before the seek is not written */\n    bz.writeCopies = 0;\n\n    /* Decompress the block and write to stdout */\n    bz._read_bunzip();\n    // XXX keep writing?\n  }\n  if ('getBuffer' in outputStream)\n    return outputStream.getBuffer();\n};\n/* Reads bzip2 file from stream or buffer `input`, and invoke\n * `callback(position, size)` once for each bzip2 block,\n * where position gives the starting position (in *bits*)\n * and size gives uncompressed size of the block (in *bytes*). */\nconst table = function(input, callback, multistream) {\n  // make a stream from a buffer, if necessary\n  var inputStream = new Stream();\n  inputStream.delegate = coerceInputStream(input);\n  inputStream.pos = 0;\n  inputStream.readByte = function() {\n    this.pos++;\n    return this.delegate.readByte();\n  };\n  if (inputStream.delegate.eof) {\n    inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);\n  }\n  var outputStream = new Stream();\n  outputStream.pos = 0;\n  outputStream.writeByte = function() { this.pos++; };\n\n  var bz = new Bunzip(inputStream, outputStream);\n  var blockSize = bz.dbufSize;\n  while (true) {\n    if ('eof' in inputStream && inputStream.eof()) break;\n\n    var position = inputStream.pos*8 + bz.reader.bitOffset;\n    if (bz.reader.hasByte) { position -= 8; }\n\n    if (bz._init_block()) {\n      var start = outputStream.pos;\n      bz._read_bunzip();\n      callback(position, outputStream.pos - start);\n    } else {\n      var crc = bz.reader.read(32); // (but we ignore the crc)\n      if (multistream &&\n          'eof' in inputStream &&\n          !inputStream.eof()) {\n        // note that start_bunzip will also resync the bit reader to next byte\n        bz._start_bunzip(inputStream, outputStream);\n        console.assert(bz.dbufSize === blockSize,\n                       \"shouldn't change block size within multistream file\");\n      } else break;\n    }\n  }\n};\n\nmodule.exports = {\n  Bunzip,\n  Stream,\n  Err,\n  decode,\n  decodeBlock,\n  table\n};\n"],"names":["BITMASK","BitReader","stream","this","bitOffset","curByte","hasByte","prototype","_ensureByte","readByte","read","bits","result","remaining","shift","seek","pos","n_bit","n_byte","pi","i","buf","Uint8Array","length","Array","map","call","x","toString","slice","join","bufToHex","bitreader","Stream","Error","buffer","bufOffset","bytesRead","c","new_pos","writeByte","_byte","write","flush","crc32Lookup","crc32","Uint32Array","crc","getCRC","updateCRC","value","updateCRCRun","count","require$$0","require$$1","CRC32","require$$2","mtf","array","index","src","Err","OK","LAST_BLOCK","NOT_BZIP_DATA","UNEXPECTED_INPUT_EOF","UNEXPECTED_OUTPUT_EOF","DATA_ERROR","OUT_OF_MEMORY","OBSOLETE_INPUT","END_OF_BLOCK","ErrorMessages","_throw","status","optDetail","msg","e","TypeError","errorCode","Bunzip","inputStream","outputStream","writePos","writeCurrent","writeCount","_start_bunzip","_init_block","_get_next_block","blockCRC","String","fromCharCode","level","reader","dbufSize","nextoutput","streamCRC","j","k","h","targetBlockCRC","origPointer","t","symToByte","symTotal","o","groupCount","nSelectors","mtfSymbol","selectors","hufGroup","symCount","groups","minLen","maxLen","temp","Uint16Array","MAX_HUFCODE_BITS","push","permute","limit","base","pp","Number","MAX_VALUE","byteCount","uc","runPos","dbufCount","selector","dbuf","GROUP_SIZE","nextSym","current","run","writeRun","_read_bunzip","outputBuffer","len","copies","previous","outbyte","outputsize","coerceInputStream","input","eof","coerceOutputStream","output","resizeOk","newBuffer","set","getBuffer","subarray","_coerced","decode","multistream","bz","targetStreamCRC","decodeBlock","writeCopies","table","callback","delegate","bind","blockSize","position","start","console","assert"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}