{"version":3,"file":"argon2id.min.mjs","sources":["../../node_modules/argon2id/lib/blake2b.js","../../node_modules/argon2id/lib/argon2id.js","../../node_modules/argon2id/lib/setup.js","../../node_modules/argon2id/index.js"],"sourcesContent":["// Adapted from the reference implementation in RFC7693\n// Initial port to Javascript by https://github.com/dcposch and https://github.com/emilbayes\n\n// Uint64 values are represented using two Uint32s, stored as little endian\n// NB: Uint32Arrays endianness depends on the underlying system, so for interoperability, conversions between Uint8Array and Uint32Arrays\n// need to be manually handled\n\n// 64-bit unsigned addition (little endian, in place)\n// Sets a[i,i+1] += b[j,j+1]\n// `a` and `b` must be Uint32Array(2)\nfunction ADD64 (a, i, b, j) {\n  a[i] += b[j];\n  a[i+1] += b[j+1] + (a[i] < b[j]); // add carry\n}\n\n// Increment 64-bit little-endian unsigned value by `c` (in place)\n// `a` must be Uint32Array(2)\nfunction INC64 (a, c) {\n  a[0] += c;\n  a[1] += (a[0] < c);\n}\n\n// G Mixing function\n// The ROTRs are inlined for speed\nfunction G (v, m, a, b, c, d, ix, iy) {\n  ADD64(v, a, v, b) // v[a,a+1] += v[b,b+1]\n  ADD64(v, a, m, ix) // v[a, a+1] += x ... x0\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits\n  let xor0 = v[d] ^ v[a]\n  let xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = xor1\n  v[d + 1] = xor0\n\n  ADD64(v, c, v, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor0 >>> 24) ^ (xor1 << 8)\n  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)\n\n  ADD64(v, a, v, b)\n  ADD64(v, a, m, iy)\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits\n  xor0 = v[d] ^ v[a]\n  xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = (xor0 >>> 16) ^ (xor1 << 16)\n  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)\n\n  ADD64(v, c, v, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor1 >>> 31) ^ (xor0 << 1)\n  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)\n}\n\n// Initialization Vector\nconst BLAKE2B_IV32 = new Uint32Array([\n  0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85,\n  0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A,\n  0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C,\n  0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19\n])\n\n// These are offsets into a Uint64 buffer.\n// Multiply them all by 2 to make them offsets into a Uint32 buffer\nconst SIGMA = new Uint8Array([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3\n].map(x => x * 2))\n\n// Compression function. 'last' flag indicates last block.\n// Note: we're representing 16 uint64s as 32 uint32s\nfunction compress(S, last) {\n  const v = new Uint32Array(32)\n  const m = new Uint32Array(S.b.buffer, S.b.byteOffset, 32)\n\n  // init work variables\n  for (let i = 0; i < 16; i++) {\n    v[i] = S.h[i]\n    v[i + 16] = BLAKE2B_IV32[i]\n  }\n\n  // low 64 bits of offset\n  v[24] ^= S.t0[0]\n  v[25] ^= S.t0[1]\n  // high 64 bits not supported (`t1`), offset may not be higher than 2**53-1\n\n  // if last block\n  const f0 = last ? 0xFFFFFFFF : 0;\n  v[28] ^= f0;\n  v[29] ^= f0;\n\n  // twelve rounds of mixing\n  for (let i = 0; i < 12; i++) {\n    // ROUND(r)\n    const i16 = i << 4;\n    G(v, m, 0, 8, 16, 24,  SIGMA[i16 + 0], SIGMA[i16 + 1])\n    G(v, m, 2, 10, 18, 26, SIGMA[i16 + 2], SIGMA[i16 + 3])\n    G(v, m, 4, 12, 20, 28, SIGMA[i16 + 4], SIGMA[i16 + 5])\n    G(v, m, 6, 14, 22, 30, SIGMA[i16 + 6], SIGMA[i16 + 7])\n    G(v, m, 0, 10, 20, 30, SIGMA[i16 + 8], SIGMA[i16 + 9])\n    G(v, m, 2, 12, 22, 24, SIGMA[i16 + 10], SIGMA[i16 + 11])\n    G(v, m, 4, 14, 16, 26, SIGMA[i16 + 12], SIGMA[i16 + 13])\n    G(v, m, 6, 8, 18, 28,  SIGMA[i16 + 14], SIGMA[i16 + 15])\n  }\n\n  for (let i = 0; i < 16; i++) {\n    S.h[i] ^= v[i] ^ v[i + 16]\n  }\n}\n\n// Creates a BLAKE2b hashing context\n// Requires an output length between 1 and 64 bytes\n// Takes an optional Uint8Array key\nclass Blake2b {\n  constructor(outlen, key, salt, personal) {\n    const params = new Uint8Array(64)\n    //  0: outlen, keylen, fanout, depth\n    //  4: leaf length, sequential mode\n    //  8: node offset\n    // 12: node offset\n    // 16: node depth, inner length, rfu\n    // 20: rfu\n    // 24: rfu\n    // 28: rfu\n    // 32: salt\n    // 36: salt\n    // 40: salt\n    // 44: salt\n    // 48: personal\n    // 52: personal\n    // 56: personal\n    // 60: personal\n\n    // init internal state\n    this.S = {\n      b: new Uint8Array(BLOCKBYTES),\n      h: new Uint32Array(OUTBYTES_MAX / 4),\n      t0: new Uint32Array(2), // input counter `t`, lower 64-bits only\n      c: 0, // `fill`, pointer within buffer, up to `BLOCKBYTES`\n      outlen // output length in bytes\n    }\n\n    // init parameter block\n    params[0] = outlen\n    if (key) params[1] = key.length\n    params[2] = 1 // fanout\n    params[3] = 1 // depth\n    if (salt) params.set(salt, 32)\n    if (personal) params.set(personal, 48)\n    const params32 = new Uint32Array(params.buffer, params.byteOffset, params.length / Uint32Array.BYTES_PER_ELEMENT);\n\n    // initialize hash state\n    for (let i = 0; i < 16; i++) {\n      this.S.h[i] = BLAKE2B_IV32[i] ^ params32[i];\n    }\n\n    // key the hash, if applicable\n    if (key) {\n      const block = new Uint8Array(BLOCKBYTES)\n      block.set(key)\n      this.update(block)\n    }\n  }\n\n  // Updates a BLAKE2b streaming hash\n  // Requires Uint8Array (byte array)\n  update(input) {\n    if (!(input instanceof Uint8Array)) throw new Error('Input must be Uint8Array or Buffer')\n    // for (let i = 0; i < input.length; i++) {\n    //   if (this.S.c === BLOCKBYTES) { // buffer full\n    //     INC64(this.S.t0, this.S.c) // add counters\n    //     compress(this.S, false)\n    //     this.S.c = 0 // empty buffer\n    //   }\n    //   this.S.b[this.S.c++] = input[i]\n    // }\n    let i = 0\n    while(i < input.length) {\n      if (this.S.c === BLOCKBYTES) { // buffer full\n        INC64(this.S.t0, this.S.c) // add counters\n        compress(this.S, false)\n        this.S.c = 0 // empty buffer\n      }\n      let left = BLOCKBYTES - this.S.c\n      this.S.b.set(input.subarray(i, i + left), this.S.c) // end index can be out of bounds\n      const fill = Math.min(left, input.length - i)\n      this.S.c += fill\n      i += fill\n    }\n    return this\n  }\n\n  /**\n   * Return a BLAKE2b hash, either filling the given Uint8Array or allocating a new one\n   * @param {Uint8Array} [prealloc] - optional preallocated buffer\n   * @returns {ArrayBuffer} message digest\n   */\n  digest(prealloc) {\n    INC64(this.S.t0, this.S.c) // mark last block offset\n\n    // final block, padded\n    this.S.b.fill(0, this.S.c);\n    this.S.c = BLOCKBYTES;\n    compress(this.S, true)\n\n    const out = prealloc || new Uint8Array(this.S.outlen);\n    for (let i = 0; i < this.S.outlen; i++) {\n      // must be loaded individually since default Uint32 endianness is platform dependant\n      out[i] = this.S.h[i >> 2] >> (8 * (i & 3))\n    }\n    this.S.h = null; // prevent calling `update` after `digest`\n    return out.buffer;\n  }\n}\n\n\nexport default function createHash(outlen, key, salt, personal) {\n  if (outlen > OUTBYTES_MAX) throw new Error(`outlen must be at most ${OUTBYTES_MAX} (given: ${outlen})`)\n  if (key) {\n    if (!(key instanceof Uint8Array)) throw new Error('key must be Uint8Array or Buffer')\n    if (key.length > KEYBYTES_MAX) throw new Error(`key size must be at most ${KEYBYTES_MAX} (given: ${key.length})`)\n  }\n  if (salt) {\n    if (!(salt instanceof Uint8Array)) throw new Error('salt must be Uint8Array or Buffer')\n    if (salt.length !== SALTBYTES) throw new Error(`salt must be exactly ${SALTBYTES} (given: ${salt.length}`)\n  }\n  if (personal) {\n    if (!(personal instanceof Uint8Array)) throw new Error('personal must be Uint8Array or Buffer')\n    if (personal.length !== PERSONALBYTES) throw new Error(`salt must be exactly ${PERSONALBYTES} (given: ${personal.length}`)\n  }\n\n  return new Blake2b(outlen, key, salt, personal)\n}\n\nconst OUTBYTES_MAX = 64;\nconst KEYBYTES_MAX = 64;\nconst SALTBYTES = 16;\nconst PERSONALBYTES = 16;\nconst BLOCKBYTES = 128;\n\n","import blake2b from \"./blake2b.js\"\nconst TYPE = 2;  // Argon2id\nconst VERSION = 0x13;\nconst TAGBYTES_MAX = 0xFFFFFFFF; // Math.pow(2, 32) - 1;\nconst TAGBYTES_MIN = 4; // Math.pow(2, 32) - 1;\nconst SALTBYTES_MAX = 0xFFFFFFFF; // Math.pow(2, 32) - 1;\nconst SALTBYTES_MIN = 8;\nconst passwordBYTES_MAX = 0xFFFFFFFF;// Math.pow(2, 32) - 1;\nconst passwordBYTES_MIN = 8;\nconst MEMBYTES_MAX = 0xFFFFFFFF;// Math.pow(2, 32) - 1;\nconst ADBYTES_MAX = 0xFFFFFFFF; // Math.pow(2, 32) - 1; // associated data (optional)\nconst SECRETBYTES_MAX = 32; // key (optional)\n\nconst ARGON2_BLOCK_SIZE = 1024;\nconst ARGON2_PREHASH_DIGEST_LENGTH = 64;\n\nconst isLittleEndian = new Uint8Array(new Uint16Array([0xabcd]).buffer)[0] === 0xcd;\n\n// store n as a little-endian 32-bit Uint8Array inside buf (at buf[i:i+3])\nfunction LE32(buf, n, i) {\n  buf[i+0] = n;\n  buf[i+1] = n >>  8;\n  buf[i+2] = n >> 16;\n  buf[i+3] = n >> 24;\n  return buf;\n}\n\n/**\n * Store n as a 64-bit LE number in the given buffer (from buf[i] to buf[i+7])\n * @param {Uint8Array} buf\n * @param {Number} n\n * @param {Number} i\n */\nfunction LE64(buf, n, i) {\n  if (n > Number.MAX_SAFE_INTEGER) throw new Error(\"LE64: large numbers unsupported\");\n  // ECMAScript standard has engines convert numbers to 32-bit integers for bitwise operations\n  // shifting by 32 or more bits is not supported (https://stackoverflow.com/questions/6729122/javascript-bit-shift-number-wraps)\n  // so we manually extract each byte\n  let remainder = n;\n  for (let offset = i; offset < i+7; offset++) { // last byte can be ignored as it would overflow MAX_SAFE_INTEGER\n    buf[offset] = remainder; // implicit & 0xff\n    remainder = (remainder - buf[offset]) / 256;\n  }\n  return buf;\n}\n\n/**\n * Variable-Length Hash Function H'\n * @param {Number} outlen - T\n * @param {Uint8Array} X - value to hash\n * @param {Uint8Array} res - output buffer, of length `outlength` or larger\n */\nfunction H_(outlen, X, res) {\n  const V = new Uint8Array(64); // no need to keep around all V_i\n\n  const V1_in = new Uint8Array(4 + X.length);\n  LE32(V1_in, outlen, 0);\n  V1_in.set(X, 4);\n  if (outlen <= 64) {\n    // H'^T(A) = H^T(LE32(T)||A)\n    blake2b(outlen).update(V1_in).digest(res);\n    return res\n  }\n\n  const r = Math.ceil(outlen / 32) - 2;\n\n  // Let V_i be a 64-byte block and W_i be its first 32 bytes.\n  // V_1 = H^(64)(LE32(T)||A)\n  // V_2 = H^(64)(V_1)\n  // ...\n  // V_r = H^(64)(V_{r-1})\n  // V_{r+1} = H^(T-32*r)(V_{r})\n  // H'^T(X) = W_1 || W_2 || ... || W_r || V_{r+1}\n  for (let i = 0; i < r; i++) {\n    blake2b(64).update(i === 0 ? V1_in : V).digest(V);\n    // store W_i in result buffer already\n    res.set(V.subarray(0, 32), i*32)\n  }\n  // V_{r+1}\n  const V_r1 = new Uint8Array(blake2b(outlen - 32*r).update(V).digest());\n  res.set(V_r1, r*32);\n\n  return res;\n}\n\n// compute buf = xs ^ ys\nfunction XOR(wasmContext, buf, xs, ys) {\n  wasmContext.fn.XOR(\n    buf.byteOffset,\n    xs.byteOffset,\n    ys.byteOffset,\n  );\n  return buf\n}\n\n/**\n * @param {Uint8Array} X (read-only)\n * @param {Uint8Array} Y (read-only)\n * @param {Uint8Array} R - output buffer\n * @returns\n */\nfunction G(wasmContext, X, Y, R) {\n  wasmContext.fn.G(\n    X.byteOffset,\n    Y.byteOffset,\n    R.byteOffset,\n    wasmContext.refs.gZ.byteOffset\n  );\n  return R;\n}\n\nfunction G2(wasmContext, X, Y, R) {\n  wasmContext.fn.G2(\n    X.byteOffset,\n    Y.byteOffset,\n    R.byteOffset,\n    wasmContext.refs.gZ.byteOffset\n  );\n  return R;\n}\n\n// Generator for data-independent J1, J2. Each `next()` invocation returns a new pair of values.\nfunction* makePRNG(wasmContext, pass, lane, slice, m_, totalPasses, segmentLength, segmentOffset) {\n  // For each segment, we do the following. First, we compute the value Z as:\n  // Z= ( LE64(r) || LE64(l) || LE64(sl) || LE64(m') || LE64(t) || LE64(y) )\n  wasmContext.refs.prngTmp.fill(0);\n  const Z = wasmContext.refs.prngTmp.subarray(0, 6 * 8);\n  LE64(Z, pass, 0);\n  LE64(Z, lane, 8);\n  LE64(Z, slice, 16);\n  LE64(Z, m_, 24);\n  LE64(Z, totalPasses, 32);\n  LE64(Z, TYPE, 40);\n\n  // Then we compute q/(128*SL) 1024-byte values\n  // G( ZERO(1024),\n  //    G( ZERO(1024), Z || LE64(1) || ZERO(968) ) ),\n  // ...,\n  // G( ZERO(1024),\n  //    G( ZERO(1024), Z || LE64(q/(128*SL)) || ZERO(968) )),\n  for(let i = 1; i <= segmentLength; i++) {\n    // tmp.set(Z); // no need to re-copy\n    LE64(wasmContext.refs.prngTmp, i, Z.length); // tmp.set(ZER0968) not necessary, memory already zeroed\n    const g2 = G2(wasmContext, wasmContext.refs.ZERO1024, wasmContext.refs.prngTmp, wasmContext.refs.prngR );\n\n    // each invocation of G^2 outputs 1024 bytes that are to be partitioned into 8-bytes values, take as X1 || X2\n    // NB: the first generated pair must be used for the first block of the segment, and so on.\n    // Hence, if some blocks are skipped (e.g. during the first pass), the corresponding J1J2 are discarded based on the given segmentOffset.\n    for(let k = i === 1 ? segmentOffset*8 : 0; k < g2.length; k += 8) {\n       yield g2.subarray(k, k+8);\n    }\n  }\n  return [];\n}\n\nfunction validateParams({ type, version, tagLength, password, salt, ad, secret, parallelism, memorySize, passes }) {\n  const assertLength = (name, value, min, max) => {\n    if (value < min || value > max) { throw new Error(`${name} size should be between ${min} and ${max} bytes`); }\n  }\n\n  if (type !== TYPE || version !== VERSION) throw new Error('Unsupported type or version');\n  assertLength('password', password, passwordBYTES_MIN, passwordBYTES_MAX);\n  assertLength('salt', salt, SALTBYTES_MIN, SALTBYTES_MAX);\n  assertLength('tag', tagLength, TAGBYTES_MIN, TAGBYTES_MAX);\n  assertLength('memory', memorySize, 8*parallelism, MEMBYTES_MAX);\n  // optional fields\n  ad && assertLength('associated data', ad, 0, ADBYTES_MAX);\n  secret && assertLength('secret', secret, 0, SECRETBYTES_MAX);\n\n  return { type, version, tagLength, password, salt, ad, secret, lanes: parallelism, memorySize, passes };\n}\n\nconst KB = 1024;\nconst WASM_PAGE_SIZE = 64 * KB;\n\nexport default function argon2id(params, { memory, instance: wasmInstance }) {\n  if (!isLittleEndian) throw new Error('BigEndian system not supported'); // optmisations assume LE system\n\n  const ctx = validateParams({ type: TYPE, version: VERSION, ...params });\n\n  const { G:wasmG, G2:wasmG2, xor:wasmXOR, getLZ:wasmLZ } = wasmInstance.exports;\n  const wasmRefs = {};\n  const wasmFn = {};\n  wasmFn.G = wasmG;\n  wasmFn.G2 = wasmG2;\n  wasmFn.XOR = wasmXOR;\n\n  // The actual number of blocks is m', which is m rounded down to the nearest multiple of 4*p.\n  const m_ = 4 * ctx.lanes * Math.floor(ctx.memorySize / (4 * ctx.lanes));\n  const requiredMemory = m_ * ARGON2_BLOCK_SIZE + 10 * KB; // Additional KBs for utility references\n  if (memory.buffer.byteLength < requiredMemory) {\n    const missing = Math.ceil((requiredMemory - memory.buffer.byteLength) / WASM_PAGE_SIZE)\n    // If enough memory is available, the `memory.buffer` is internally detached and the reference updated.\n    // Otherwise, the operation fails, and the original memory can still be used.\n    memory.grow(missing)\n  }\n\n  let offset = 0;\n  // Init wasm memory needed in other functions\n  wasmRefs.gZ = new Uint8Array(memory.buffer, offset, ARGON2_BLOCK_SIZE); offset+= wasmRefs.gZ.length;\n  wasmRefs.prngR = new Uint8Array(memory.buffer, offset, ARGON2_BLOCK_SIZE); offset+=wasmRefs.prngR.length;\n  wasmRefs.prngTmp = new Uint8Array(memory.buffer, offset, ARGON2_BLOCK_SIZE); offset+=wasmRefs.prngTmp.length;\n  wasmRefs.ZERO1024 = new Uint8Array(memory.buffer, offset, 1024); offset+=wasmRefs.ZERO1024.length;\n  // Init wasm memory needed locally\n  const lz = new Uint32Array(memory.buffer, offset, 2); offset+=lz.length * Uint32Array.BYTES_PER_ELEMENT;\n  const wasmContext = { fn: wasmFn, refs: wasmRefs };\n  const newBlock = new Uint8Array(memory.buffer, offset, ARGON2_BLOCK_SIZE); offset+=newBlock.length;\n  const blockMemory = new Uint8Array(memory.buffer, offset, ctx.memorySize * ARGON2_BLOCK_SIZE);\n  const allocatedMemory = new Uint8Array(memory.buffer, 0, offset);\n\n  // 1. Establish H_0\n  const H0 = getH0(ctx);\n\n  // 2. Allocate the memory as m' 1024-byte blocks\n  // For p lanes, the memory is organized in a matrix B[i][j] of blocks with p rows (lanes) and q = m' / p columns.\n  const q = m_ / ctx.lanes;\n  const B = new Array(ctx.lanes).fill(null).map(() => new Array(q));\n  const initBlock = (i, j) => {\n    B[i][j] = blockMemory.subarray(i*q*1024 + j*1024, (i*q*1024 + j*1024) + ARGON2_BLOCK_SIZE);\n    return B[i][j];\n  }\n\n  for (let i = 0; i < ctx.lanes; i++) {\n    // const LEi = LE0; //  since p = 1 for us\n    const tmp = new Uint8Array(H0.length + 8);\n    // 3. Compute B[i][0] for all i ranging from (and including) 0 to (not including) p\n    // B[i][0] = H'^(1024)(H_0 || LE32(0) || LE32(i))\n    tmp.set(H0); LE32(tmp, 0, H0.length); LE32(tmp, i, H0.length + 4);\n    H_(ARGON2_BLOCK_SIZE, tmp, initBlock(i, 0));\n    // 4. Compute B[i][1] for all i ranging from (and including) 0 to (not including) p\n    // B[i][1] = H'^(1024)(H_0 || LE32(1) || LE32(i))\n    LE32(tmp, 1, H0.length);\n    H_(ARGON2_BLOCK_SIZE, tmp, initBlock(i, 1));\n  }\n\n    // 5. Compute B[i][j] for all i ranging from (and including) 0 to (not including) p and for all j ranging from (and including) 2\n    // to (not including) q. The computation MUST proceed slicewise (Section 3.4) : first, blocks from slice 0 are computed for all lanes\n    // (in an arbitrary order of lanes), then blocks from slice 1 are computed, etc.\n  const SL = 4; // vertical slices\n  const segmentLength = q / SL;\n  for (let pass = 0; pass < ctx.passes; pass++) {\n      // The intersection of a slice and a lane is called a segment, which has a length of q/SL. Segments of the same slice can be computed in parallel\n    for (let sl = 0; sl < SL; sl++) {\n      const isDataIndependent = pass === 0 && sl <= 1;\n      for (let i = 0; i < ctx.lanes; i++) { // lane\n        // On the first slice of the first pass, blocks 0 and 1 are already filled\n        let segmentOffset = sl === 0 && pass === 0 ? 2 : 0;\n        // no need to generate all J1J2s, use iterator/generator that creates the value on the fly (to save memory)\n        const PRNG = isDataIndependent ? makePRNG(wasmContext, pass, i, sl, m_, ctx.passes, segmentLength, segmentOffset) : null;\n        for (segmentOffset; segmentOffset < segmentLength; segmentOffset++) {\n          const j = sl * segmentLength + segmentOffset;\n          const prevBlock = j > 0 ? B[i][j-1] : B[i][q-1]; // B[i][(j-1) mod q]\n\n          // we can assume the PRNG is never done\n          const J1J2 = isDataIndependent ? PRNG.next().value : prevBlock; // .subarray(0, 8) not required since we only pass the byteOffset to wasm\n          // The block indices l and z are determined for each i, j differently for Argon2d, Argon2i, and Argon2id.\n          wasmLZ(lz.byteOffset, J1J2.byteOffset, i, ctx.lanes, pass, sl, segmentOffset, SL, segmentLength)\n          const l = lz[0]; const z = lz[1];\n          // for (let i = 0; i < p; i++ )\n          // B[i][j] = G(B[i][j-1], B[l][z])\n          // The block indices l and z are determined for each i, j differently for Argon2d, Argon2i, and Argon2id.\n          if (pass === 0) initBlock(i, j);\n          G(wasmContext, prevBlock, B[l][z], pass > 0 ? newBlock : B[i][j]);\n\n          // 6. If the number of passes t is larger than 1, we repeat step 5. However, blocks are computed differently as the old value is XORed with the new one\n          if (pass > 0) XOR(wasmContext, B[i][j], newBlock, B[i][j])\n        }\n      }\n    }\n  }\n\n  // 7. After t steps have been iterated, the final block C is computed as the XOR of the last column:\n  // C = B[0][q-1] XOR B[1][q-1] XOR ... XOR B[p-1][q-1]\n  const C = B[0][q-1];\n  for(let i = 1; i < ctx.lanes; i++) {\n    XOR(wasmContext, C, C, B[i][q-1])\n  }\n\n  const tag = H_(ctx.tagLength, C, new Uint8Array(ctx.tagLength));\n  // clear memory since the module might be cached\n  allocatedMemory.fill(0) // clear sensitive contents\n  memory.grow(0) // allow deallocation\n  // 8. The output tag is computed as H'^T(C).\n  return tag;\n\n}\n\nfunction getH0(ctx) {\n  const H = blake2b(ARGON2_PREHASH_DIGEST_LENGTH);\n  const ZERO32 = new Uint8Array(4);\n  const params = new Uint8Array(24);\n  LE32(params, ctx.lanes, 0);\n  LE32(params, ctx.tagLength, 4);\n  LE32(params, ctx.memorySize, 8);\n  LE32(params, ctx.passes, 12);\n  LE32(params, ctx.version, 16);\n  LE32(params, ctx.type, 20);\n\n  const toHash = [params];\n  if (ctx.password) {\n    toHash.push(LE32(new Uint8Array(4), ctx.password.length, 0))\n    toHash.push(ctx.password)\n  } else {\n    toHash.push(ZERO32) // context.password.length\n  }\n\n  if (ctx.salt) {\n    toHash.push(LE32(new Uint8Array(4), ctx.salt.length, 0))\n    toHash.push(ctx.salt)\n  } else {\n    toHash.push(ZERO32) // context.salt.length\n  }\n\n  if (ctx.secret) {\n    toHash.push(LE32(new Uint8Array(4), ctx.secret.length, 0))\n    toHash.push(ctx.secret)\n    // todo clear secret?\n  } else {\n    toHash.push(ZERO32) // context.secret.length\n  }\n\n  if (ctx.ad) {\n    toHash.push(LE32(new Uint8Array(4), ctx.ad.length, 0))\n    toHash.push(ctx.ad)\n  } else {\n    toHash.push(ZERO32) // context.ad.length\n  }\n  H.update(concatArrays(toHash))\n\n  const outputBuffer = H.digest();\n  return new Uint8Array(outputBuffer);\n}\n\nfunction concatArrays(arrays) {\n  if (arrays.length === 1) return arrays[0];\n\n  let totalLength = 0;\n  for (let i = 0; i < arrays.length; i++) {\n      if (!(arrays[i] instanceof Uint8Array)) {\n          throw new Error('concatArrays: Data must be in the form of a Uint8Array');\n      }\n\n      totalLength += arrays[i].length;\n  }\n\n  const result = new Uint8Array(totalLength);\n  let pos = 0;\n  arrays.forEach((element) => {\n      result.set(element, pos);\n      pos += element.length;\n  });\n\n  return result;\n}\n","import argon2id from \"./argon2id.js\";\n\nlet isSIMDSupported;\nasync function wasmLoader(memory, getSIMD, getNonSIMD) {\n  const importObject = { env: { memory } };\n  if (isSIMDSupported === undefined) {\n    try {\n      const loaded = await getSIMD(importObject);\n      isSIMDSupported = true;\n      return loaded;\n    } catch(e) {\n      isSIMDSupported = false;\n    }\n  }\n\n  const loader = isSIMDSupported ? getSIMD : getNonSIMD;\n  return loader(importObject);\n}\n\nexport default async function setupWasm(getSIMD, getNonSIMD) {\n  const memory = new WebAssembly.Memory({\n    // in pages of 64KiB each\n    // these values need to be compatible with those declared when building in `build-wasm`\n    initial: 1040,  // 65MB\n    maximum: 65536, // 4GB\n  });\n  const wasmModule = await wasmLoader(memory, getSIMD, getNonSIMD);\n\n  /**\n   * Argon2id hash function\n   * @callback computeHash\n   * @param {Object} params\n   * @param {Uint8Array} params.password - password\n   * @param {Uint8Array} params.salt - salt\n   * @param {Integer} params.parallelism\n   * @param {Integer} params.passes\n   * @param {Integer} params.memorySize - in kibibytes\n   * @param {Integer} params.tagLength - output tag length\n   * @param {Uint8Array} [params.ad] - associated data (optional)\n   * @param {Uint8Array} [params.secret] - secret data (optional)\n   * @return {Uint8Array} argon2id hash\n   */\n  const computeHash = (params) => argon2id(params, { instance: wasmModule.instance, memory });\n\n  return computeHash;\n}\n","import setupWasm from './lib/setup.js';\nimport wasmSIMD from './dist/simd.wasm';\nimport wasmNonSIMD from './dist/no-simd.wasm';\n\nconst loadWasm = async () => setupWasm(\n  (instanceObject) => wasmSIMD(instanceObject),\n  (instanceObject) => wasmNonSIMD(instanceObject),\n);\n\nexport default loadWasm;\n"],"names":["ADD64","a","i","b","j","INC64","c","G","v","m","d","ix","iy","xor0","xor1","BLAKE2B_IV32","Uint32Array","SIGMA","Uint8Array","map","x","compress","S","last","buffer","byteOffset","h","t0","f0","i16","Blake2b","constructor","outlen","key","salt","personal","params","this","BLOCKBYTES","OUTBYTES_MAX","length","set","params32","BYTES_PER_ELEMENT","block","update","input","Error","left","subarray","fill","Math","min","digest","prealloc","out","createHash","TYPE","VERSION","TAGBYTES_MAX","TAGBYTES_MIN","SALTBYTES_MAX","SALTBYTES_MIN","passwordBYTES_MAX","passwordBYTES_MIN","MEMBYTES_MAX","ADBYTES_MAX","SECRETBYTES_MAX","ARGON2_BLOCK_SIZE","ARGON2_PREHASH_DIGEST_LENGTH","isLittleEndian","Uint16Array","LE32","buf","n","LE64","Number","MAX_SAFE_INTEGER","remainder","offset","H_","X","res","V","V1_in","blake2b","r","ceil","V_r1","XOR","wasmContext","xs","ys","fn","Y","R","refs","gZ","G2","makePRNG","pass","lane","slice","m_","totalPasses","segmentLength","segmentOffset","prngTmp","Z","g2","ZERO1024","prngR","k","KB","WASM_PAGE_SIZE","argon2id","memory","instance","wasmInstance","ctx","type","version","tagLength","password","ad","secret","parallelism","memorySize","passes","assertLength","name","value","max","lanes","validateParams","wasmG","wasmG2","xor","wasmXOR","getLZ","wasmLZ","exports","wasmRefs","wasmFn","floor","requiredMemory","byteLength","missing","grow","lz","newBlock","blockMemory","allocatedMemory","H0","H","ZERO32","toHash","push","arrays","totalLength","result","pos","forEach","element","concatArrays","outputBuffer","getH0","q","B","Array","initBlock","tmp","sl","isDataIndependent","PRNG","prevBlock","J1J2","next","l","z","C","tag","isSIMDSupported","async","setupWasm","getSIMD","getNonSIMD","WebAssembly","Memory","initial","maximum","wasmModule","importObject","env","undefined","loaded","e","wasmLoader","loadWasm","instanceObject"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}