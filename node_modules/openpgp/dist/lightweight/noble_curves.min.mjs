/*! OpenPGP.js v6.1.0 - 2025-01-30 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */
"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;import{H as t,h as e,t as n,e as r,b as f,c as o,r as i,s,a,d as c,w as d,u,f as l}from"./sha3.min.mjs";class h extends t{constructor(t,r){super(),this.finished=!1,this.destroyed=!1,e(t);const f=n(r);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(f.length>o?t.create().update(f).digest():f);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),i.fill(0)}update(t){return r(this),this.iHash.update(t),this}digestInto(t){r(this),f(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:f,blockLen:o,outputLen:i}=this;return t.finished=r,t.destroyed=f,t.blockLen=o,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const g=(t,e,n)=>new h(t,e).update(n).digest();g.create=(t,e)=>new h(t,e)
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */;const b=/* @__PURE__ */BigInt(0),y=/* @__PURE__ */BigInt(1),p=/* @__PURE__ */BigInt(2);function m(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function w(t){if(!m(t))throw Error("Uint8Array expected")}function B(t,e){if("boolean"!=typeof e)throw Error(`${t} must be valid boolean, got "${e}".`)}const E=/* @__PURE__ */Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function x(t){w(t);let e="";for(let n=0;n<t.length;n++)e+=E[t[n]];return e}function I(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function v(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":"0x"+t)}const S={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function A(t){return t>=S._0&&t<=S._9?t-S._0:t>=S._A&&t<=S._F?t-(S._A-10):t>=S._a&&t<=S._f?t-(S._a-10):void 0}function O(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,f=0;e<n;e++,f+=2){const n=A(t.charCodeAt(f)),o=A(t.charCodeAt(f+1));if(void 0===n||void 0===o){const e=t[f]+t[f+1];throw Error('hex string expected, got non-hex character "'+e+'" at index '+f)}r[e]=16*n+o}return r}function R(t){return v(x(t))}function q(t){return w(t),v(x(Uint8Array.from(t).reverse()))}function z(t,e){return O(t.toString(16).padStart(2*e,"0"))}function P(t,e){return z(t,e).reverse()}function L(t,e,n){let r;if("string"==typeof e)try{r=O(e)}catch(n){throw Error(`${t} must be valid hex string, got "${e}". Cause: ${n}`)}else{if(!m(e))throw Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(e)}const f=r.length;if("number"==typeof n&&f!==n)throw Error(`${t} expected ${n} bytes, got ${f}`);return r}function N(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];w(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const f=t[e];n.set(f,r),r+=f.length}return n}const H=t=>"bigint"==typeof t&&b<=t;function T(t,e,n){return H(t)&&H(e)&&H(n)&&e<=t&&t<n}function F(t,e,n,r){if(!T(e,n,r))throw Error(`expected valid ${t}: ${n} <= n < ${r}, got ${typeof e} ${e}`)}function Z(t){let e;for(e=0;t>b;t>>=y,e+=1);return e}const $=t=>(p<<BigInt(t-1))-y,_=t=>new Uint8Array(t),k=t=>Uint8Array.from(t);function G(t,e,n){if("number"!=typeof t||t<2)throw Error("hashLen must be a number");if("number"!=typeof e||e<2)throw Error("qByteLen must be a number");if("function"!=typeof n)throw Error("hmacFn must be a function");let r=_(t),f=_(t),o=0;const i=()=>{r.fill(1),f.fill(0),o=0},s=(...t)=>n(f,r,...t),a=(t=_())=>{f=s(k([0]),t),r=s(),0!==t.length&&(f=s(k([1]),t),r=s())},c=()=>{if(o++>=1e3)throw Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){r=s();const e=r.slice();n.push(e),t+=r.length}return N(...n)};return(t,e)=>{let n;for(i(),a(t);!(n=e(c()));)a();return i(),n}}const U={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||m(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function j(t,e,n={}){const r=(e,n,r)=>{const f=U[n];if("function"!=typeof f)throw Error(`Invalid validator "${n}", expected function`);const o=t[e];if(!(r&&void 0===o||f(o,t)))throw Error(`Invalid param ${e+""}=${o} (${typeof o}), expected ${n}`)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t}function C(t){const e=new WeakMap;return(n,...r)=>{const f=e.get(n);if(void 0!==f)return f;const o=t(n,...r);return e.set(n,o),o}}var V=/*#__PURE__*/Object.freeze({__proto__:null,aInRange:F,abool:B,abytes:w,bitGet:function(t,e){return t>>BigInt(e)&y},bitLen:Z,bitMask:$,bitSet:function(t,e,n){return t|(n?y:b)<<BigInt(e)},bytesToHex:x,bytesToNumberBE:R,bytesToNumberLE:q,concatBytes:N,createHmacDrbg:G,ensureBytes:L,equalBytes:function(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return 0===n},hexToBytes:O,hexToNumber:v,inRange:T,isBytes:m,memoized:C,notImplemented:()=>{throw Error("not implemented")},numberToBytesBE:z,numberToBytesLE:P,numberToHexUnpadded:I,numberToVarBytesBE:function(t){return O(I(t))},utf8ToBytes:function(t){if("string"!=typeof t)throw Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))},validateObject:j});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const K=BigInt(0),Y=BigInt(1),M=BigInt(2),W=BigInt(3),D=BigInt(4),J=BigInt(5),Q=BigInt(8);function X(t,e){const n=t%e;return n>=K?n:e+n}function tt(t,e,n){if(n<=K||e<K)throw Error("Expected power/modulo > 0");if(n===Y)return K;let r=Y;for(;e>K;)e&Y&&(r=r*t%n),t=t*t%n,e>>=Y;return r}function et(t,e,n){let r=t;for(;e-- >K;)r*=r,r%=n;return r}function nt(t,e){if(t===K||e<=K)throw Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=X(t,e),r=e,f=K,o=Y;for(;n!==K;){const t=r%n,e=f-o*(r/n);r=n,n=t,f=o,o=e}if(r!==Y)throw Error("invert: does not exist");return X(f,e)}function rt(t){if(t%D===W){const e=(t+Y)/D;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw Error("Cannot find square root");return r}}if(t%Q===J){const e=(t-J)/Q;return function(t,n){const r=t.mul(n,M),f=t.pow(r,e),o=t.mul(n,f),i=t.mul(t.mul(o,M),f),s=t.mul(o,t.sub(i,t.ONE));if(!t.eql(t.sqr(s),n))throw Error("Cannot find square root");return s}}return function(t){const e=(t-Y)/M;let n,r,f;for(n=t-Y,r=0;n%M===K;n/=M,r++);for(f=M;f<t&&tt(f,e,t)!==t-Y;f++);if(1===r){const e=(t+Y)/D;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw Error("Cannot find square root");return r}}const o=(n+Y)/M;return function(t,i){if(t.pow(i,e)===t.neg(t.ONE))throw Error("Cannot find square root");let s=r,a=t.pow(t.mul(t.ONE,f),n),c=t.pow(i,o),d=t.pow(i,n);for(;!t.eql(d,t.ONE);){if(t.eql(d,t.ZERO))return t.ZERO;let e=1;for(let n=t.sqr(d);e<s&&!t.eql(n,t.ONE);e++)n=t.sqr(n);const n=t.pow(a,Y<<BigInt(s-e-1));a=t.sqr(n),c=t.mul(c,n),d=t.mul(d,a),s=e}return c}}(t)}BigInt(9),BigInt(16);const ft=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ot(t,e){const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function it(t,e,n=!1,r={}){if(t<=K)throw Error("Expected Field ORDER > 0, got "+t);const{nBitLength:f,nByteLength:o}=ot(t,e);if(o>2048)throw Error("Field lengths over 2048 bytes are not supported");const i=rt(t),s=Object.freeze({ORDER:t,BITS:f,BYTES:o,MASK:$(f),ZERO:K,ONE:Y,create:e=>X(e,t),isValid:e=>{if("bigint"!=typeof e)throw Error("Invalid field element: expected bigint, got "+typeof e);return K<=e&&e<t},is0:t=>t===K,isOdd:t=>(t&Y)===Y,neg:e=>X(-e,t),eql:(t,e)=>t===e,sqr:e=>X(e*e,t),add:(e,n)=>X(e+n,t),sub:(e,n)=>X(e-n,t),mul:(e,n)=>X(e*n,t),pow:(t,e)=>function(t,e,n){if(n<K)throw Error("Expected power > 0");if(n===K)return t.ONE;if(n===Y)return e;let r=t.ONE,f=e;for(;n>K;)n&Y&&(r=t.mul(r,f)),f=t.sqr(f),n>>=Y;return r}(s,t,e),div:(e,n)=>X(e*nt(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>nt(e,t),sqrt:r.sqrt||(t=>i(s,t)),invertBatch:t=>function(t,e){const n=Array(e.length),r=e.reduce(((e,r,f)=>t.is0(r)?e:(n[f]=e,t.mul(e,r))),t.ONE),f=t.inv(r);return e.reduceRight(((e,r,f)=>t.is0(r)?e:(n[f]=t.mul(e,n[f]),t.mul(e,r))),f),n}(s,t),cmov:(t,e,n)=>n?e:t,toBytes:t=>n?P(t,o):z(t,o),fromBytes:t=>{if(t.length!==o)throw Error(`Fp.fromBytes: expected ${o}, got ${t.length}`);return n?q(t):R(t)}});return Object.freeze(s)}function st(t){if("bigint"!=typeof t)throw Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function at(t){const e=st(t);return e+Math.ceil(e/2)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ct=BigInt(0),dt=BigInt(1),ut=new WeakMap,lt=new WeakMap;function ht(t,e){const n=(t,e)=>{const n=e.negate();return t?n:e},r=t=>{if(!Number.isSafeInteger(t)||t<=0||t>e)throw Error(`Wrong window size=${t}, should be [1..${e}]`)},f=t=>{r(t);return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1)}};return{constTimeNegate:n,unsafeLadder(e,n){let r=t.ZERO,f=e;for(;n>ct;)n&dt&&(r=r.add(f)),f=f.double(),n>>=dt;return r},precomputeWindow(t,e){const{windows:n,windowSize:r}=f(e),o=[];let i=t,s=i;for(let t=0;t<n;t++){s=i,o.push(s);for(let t=1;t<r;t++)s=s.add(i),o.push(s);i=s.double()}return o},wNAF(e,r,o){const{windows:i,windowSize:s}=f(e);let a=t.ZERO,c=t.BASE;const d=BigInt(2**e-1),u=2**e,l=BigInt(e);for(let t=0;t<i;t++){const e=t*s;let f=Number(o&d);o>>=l,f>s&&(f-=u,o+=dt);const i=e,h=e+Math.abs(f)-1,g=t%2!=0,b=f<0;0===f?c=c.add(n(g,r[i])):a=a.add(n(b,r[h]))}return{p:a,f:c}},wNAFCached(t,e,n){const r=lt.get(t)||1;let f=ut.get(t);return f||(f=this.precomputeWindow(t,r),1!==r&&ut.set(t,n(f))),this.wNAF(r,f,e)},setWindowSize(t,e){r(e),lt.set(t,e),ut.delete(t)}}}function gt(t,e,n,r){if(!Array.isArray(n)||!Array.isArray(r)||r.length!==n.length)throw Error("arrays of points and scalars must have equal length");r.forEach(((t,n)=>{if(!e.isValid(t))throw Error("wrong scalar at index "+n)})),n.forEach(((e,n)=>{if(!(e instanceof t))throw Error("wrong point at index "+n)}));const f=Z(BigInt(n.length)),o=f>12?f-3:f>4?f-2:f?2:1,i=(1<<o)-1,s=Array(i+1).fill(t.ZERO),a=Math.floor((e.BITS-1)/o)*o;let c=t.ZERO;for(let e=a;e>=0;e-=o){s.fill(t.ZERO);for(let t=0;t<r.length;t++){const f=r[t],o=Number(f>>BigInt(e)&BigInt(i));s[o]=s[o].add(n[t])}let f=t.ZERO;for(let e=s.length-1,n=t.ZERO;e>0;e--)n=n.add(s[e]),f=f.add(n);if(c=c.add(f),0!==e)for(let t=0;t<o;t++)c=c.double()}return c}function bt(t){return j(t.Fp,ft.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),j(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ot(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function yt(t){void 0!==t.lowS&&B("lowS",t.lowS),void 0!==t.prehash&&B("prehash",t.prehash)}const{bytesToNumberBE:pt,hexToBytes:mt}=V,wt={Err:class extends Error{constructor(t=""){super(t)}},_tlv:{encode:(t,e)=>{const{Err:n}=wt;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(1&e.length)throw new n("tlv.encode: unpadded data");const r=e.length/2,f=I(r);if(f.length/2&128)throw new n("tlv.encode: long form length too big");const o=r>127?I(f.length/2|128):"";return`${I(t)}${o}${f}${e}`},decode(t,e){const{Err:n}=wt;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const f=e[r++];let o=0;if(!!(128&f)){const t=127&f;if(!t)throw new n("tlv.decode(long): indefinite length not supported");if(t>4)throw new n("tlv.decode(long): byte length is too big");const i=e.subarray(r,r+t);if(i.length!==t)throw new n("tlv.decode: length bytes not complete");if(0===i[0])throw new n("tlv.decode(long): zero leftmost byte");for(const t of i)o=o<<8|t;if(r+=t,o<128)throw new n("tlv.decode(long): not minimal encoding")}else o=f;const i=e.subarray(r,r+o);if(i.length!==o)throw new n("tlv.decode: wrong value length");return{v:i,l:e.subarray(r+o)}}},_int:{encode(t){const{Err:e}=wt;if(t<Bt)throw new e("integer: negative integers are not allowed");let n=I(t);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new e("unexpected assertion");return n},decode(t){const{Err:e}=wt;if(128&t[0])throw new e("Invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("Invalid signature integer: unnecessary leading zero");return pt(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=wt,f="string"==typeof t?mt(t):t;w(f);const{v:o,l:i}=r.decode(48,f);if(i.length)throw new e("Invalid signature: left bytes after parsing");const{v:s,l:a}=r.decode(2,o),{v:c,l:d}=r.decode(2,a);if(d.length)throw new e("Invalid signature: left bytes after parsing");return{r:n.decode(s),s:n.decode(c)}},hexFromSig(t){const{_tlv:e,_int:n}=wt,r=`${e.encode(2,n.encode(t.r))}${e.encode(2,n.encode(t.s))}`;return e.encode(48,r)}},Bt=BigInt(0),Et=BigInt(1);BigInt(2);const xt=BigInt(3);function It(t){const e=function(t){const e=bt(t);j(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:f}=e;if(n){if(!r.eql(f,r.ZERO))throw Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,r=it(e.n,e.nBitLength),f=e.toBytes||((t,e,r)=>{const f=e.toAffine();return N(Uint8Array.from([4]),n.toBytes(f.x),n.toBytes(f.y))}),o=e.fromBytes||(t=>{const e=t.subarray(1);return{x:n.fromBytes(e.subarray(0,n.BYTES)),y:n.fromBytes(e.subarray(n.BYTES,2*n.BYTES))}});function i(t){const{a:r,b:f}=e,o=n.sqr(t),i=n.mul(o,t);return n.add(n.add(i,n.mul(t,r)),f)}if(!n.eql(n.sqr(e.Gy),i(e.Gx)))throw Error("bad generator point: equation left != right");function s(t){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:f,n:o}=e;if(n&&"bigint"!=typeof t){if(m(t)&&(t=x(t)),"string"!=typeof t||!n.includes(t.length))throw Error("Invalid key");t=t.padStart(2*r,"0")}let i;try{i="bigint"==typeof t?t:R(L("private key",t,r))}catch(e){throw Error(`private key must be ${r} bytes, hex or bigint, not ${typeof t}`)}return f&&(i=X(i,o)),F("private key",i,Et,o),i}function a(t){if(!(t instanceof u))throw Error("ProjectivePoint expected")}const c=C(((t,e)=>{const{px:r,py:f,pz:o}=t;if(n.eql(o,n.ONE))return{x:r,y:f};const i=t.is0();null==e&&(e=i?n.ONE:n.inv(o));const s=n.mul(r,e),a=n.mul(f,e),c=n.mul(o,e);if(i)return{x:n.ZERO,y:n.ZERO};if(!n.eql(c,n.ONE))throw Error("invZ was invalid");return{x:s,y:a}})),d=C((t=>{if(t.is0()){if(e.allowInfinityPoint&&!n.is0(t.py))return;throw Error("bad point: ZERO")}const{x:r,y:f}=t.toAffine();if(!n.isValid(r)||!n.isValid(f))throw Error("bad point: x or y not FE");const o=n.sqr(f),s=i(r);if(!n.eql(o,s))throw Error("bad point: equation left != right");if(!t.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0}));class u{constructor(t,e,r){if(this.px=t,this.py=e,this.pz=r,null==t||!n.isValid(t))throw Error("x required");if(null==e||!n.isValid(e))throw Error("y required");if(null==r||!n.isValid(r))throw Error("z required");Object.freeze(this)}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw Error("invalid affine point");if(t instanceof u)throw Error("projective point not allowed");const f=t=>n.eql(t,n.ZERO);return f(e)&&f(r)?u.ZERO:new u(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(u.fromAffine)}static fromHex(t){const e=u.fromAffine(o(L("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return u.BASE.multiply(s(t))}static msm(t,e){return gt(u,r,t,e)}_setWindowSize(t){h.setWindowSize(this,t)}assertValidity(){d(this)}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw Error("Field doesn't support isOdd")}equals(t){a(t);const{px:e,py:r,pz:f}=this,{px:o,py:i,pz:s}=t,c=n.eql(n.mul(e,s),n.mul(o,f)),d=n.eql(n.mul(r,s),n.mul(i,f));return c&&d}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,f=n.mul(r,xt),{px:o,py:i,pz:s}=this;let a=n.ZERO,c=n.ZERO,d=n.ZERO,l=n.mul(o,o),h=n.mul(i,i),g=n.mul(s,s),b=n.mul(o,i);return b=n.add(b,b),d=n.mul(o,s),d=n.add(d,d),a=n.mul(t,d),c=n.mul(f,g),c=n.add(a,c),a=n.sub(h,c),c=n.add(h,c),c=n.mul(a,c),a=n.mul(b,a),d=n.mul(f,d),g=n.mul(t,g),b=n.sub(l,g),b=n.mul(t,b),b=n.add(b,d),d=n.add(l,l),l=n.add(d,l),l=n.add(l,g),l=n.mul(l,b),c=n.add(c,l),g=n.mul(i,s),g=n.add(g,g),l=n.mul(g,b),a=n.sub(a,l),d=n.mul(g,h),d=n.add(d,d),d=n.add(d,d),new u(a,c,d)}add(t){a(t);const{px:r,py:f,pz:o}=this,{px:i,py:s,pz:c}=t;let d=n.ZERO,l=n.ZERO,h=n.ZERO;const g=e.a,b=n.mul(e.b,xt);let y=n.mul(r,i),p=n.mul(f,s),m=n.mul(o,c),w=n.add(r,f),B=n.add(i,s);w=n.mul(w,B),B=n.add(y,p),w=n.sub(w,B),B=n.add(r,o);let E=n.add(i,c);return B=n.mul(B,E),E=n.add(y,m),B=n.sub(B,E),E=n.add(f,o),d=n.add(s,c),E=n.mul(E,d),d=n.add(p,m),E=n.sub(E,d),h=n.mul(g,B),d=n.mul(b,m),h=n.add(d,h),d=n.sub(p,h),h=n.add(p,h),l=n.mul(d,h),p=n.add(y,y),p=n.add(p,y),m=n.mul(g,m),B=n.mul(b,B),p=n.add(p,m),m=n.sub(y,m),m=n.mul(g,m),B=n.add(B,m),y=n.mul(p,B),l=n.add(l,y),y=n.mul(E,B),d=n.mul(w,d),d=n.sub(d,y),y=n.mul(w,p),h=n.mul(E,h),h=n.add(h,y),new u(d,l,h)}subtract(t){return this.add(t.negate())}is0(){return this.equals(u.ZERO)}wNAF(t){return h.wNAFCached(this,t,u.normalizeZ)}multiplyUnsafe(t){F("scalar",t,Bt,e.n);const r=u.ZERO;if(t===Bt)return r;if(t===Et)return this;const{endo:f}=e;if(!f)return h.unsafeLadder(this,t);let{k1neg:o,k1:i,k2neg:s,k2:a}=f.splitScalar(t),c=r,d=r,l=this;for(;i>Bt||a>Bt;)i&Et&&(c=c.add(l)),a&Et&&(d=d.add(l)),l=l.double(),i>>=Et,a>>=Et;return o&&(c=c.negate()),s&&(d=d.negate()),d=new u(n.mul(d.px,f.beta),d.py,d.pz),c.add(d)}multiply(t){const{endo:r,n:f}=e;let o,i;if(F("scalar",t,Et,f),r){const{k1neg:e,k1:f,k2neg:s,k2:a}=r.splitScalar(t);let{p:c,f:d}=this.wNAF(f),{p:l,f:g}=this.wNAF(a);c=h.constTimeNegate(e,c),l=h.constTimeNegate(s,l),l=new u(n.mul(l.px,r.beta),l.py,l.pz),o=c.add(l),i=d.add(g)}else{const{p:e,f:n}=this.wNAF(t);o=e,i=n}return u.normalizeZ([o,i])[0]}multiplyAndAddUnsafe(t,e,n){const r=u.BASE,f=(t,e)=>e!==Bt&&e!==Et&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),o=f(this,e).add(f(t,n));return o.is0()?void 0:o}toAffine(t){return c(this,t)}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===Et)return!0;if(n)return n(u,this);throw Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===Et?this:n?n(u,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return B("isCompressed",t),this.assertValidity(),f(u,this,t)}toHex(t=!0){return B("isCompressed",t),x(this.toRawBytes(t))}}u.BASE=new u(e.Gx,e.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const l=e.nBitLength,h=ht(u,e.endo?Math.ceil(l/2):l);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:s,weierstrassEquation:i,isWithinCurveOrder:function(t){return T(t,Et,e.n)}}}function vt(t){const e=function(t){const e=bt(t);return j(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:r}=e,f=n.BYTES+1,o=2*n.BYTES+1;function i(t){return X(t,r)}function s(t){return nt(t,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:c,weierstrassEquation:d,isWithinCurveOrder:u}=It({...e,toBytes(t,e,r){const f=e.toAffine(),o=n.toBytes(f.x),i=N;return B("isCompressed",r),r?i(Uint8Array.from([e.hasEvenY()?2:3]),o):i(Uint8Array.from([4]),o,n.toBytes(f.y))},fromBytes(t){const e=t.length,r=t[0],i=t.subarray(1);if(e!==f||2!==r&&3!==r){if(e===o&&4===r){return{x:n.fromBytes(i.subarray(0,n.BYTES)),y:n.fromBytes(i.subarray(n.BYTES,2*n.BYTES))}}throw Error(`Point of length ${e} was invalid. Expected ${f} compressed bytes or ${o} uncompressed bytes`)}{const t=R(i);if(!T(t,Et,n.ORDER))throw Error("Point is not on curve");const e=d(t);let f;try{f=n.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw Error("Point is not on curve"+e)}return!(1&~r)!==((f&Et)===Et)&&(f=n.neg(f)),{x:t,y:f}}}}),l=t=>x(z(t,e.nByteLength));function h(t){return t>r>>Et}const g=(t,e,n)=>R(t.slice(e,n));class b{constructor(t,e,n){this.r=t,this.s=e,this.recovery=n,this.assertValidity()}static fromCompact(t){const n=e.nByteLength;return t=L("compactSignature",t,2*n),new b(g(t,0,n),g(t,n,2*n))}static fromDER(t){const{r:e,s:n}=wt.toSig(L("DER",t));return new b(e,n)}assertValidity(){F("r",this.r,Et,r),F("s",this.s,Et,r)}addRecoveryBit(t){return new b(this.r,this.s,t)}recoverPublicKey(t){const{r,s:f,recovery:o}=this,c=E(L("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw Error("recovery id invalid");const d=2===o||3===o?r+e.n:r;if(d>=n.ORDER)throw Error("recovery id 2 or 3 invalid");const u=1&o?"03":"02",h=a.fromHex(u+l(d)),g=s(d),b=i(-c*g),y=i(f*g),p=a.BASE.multiplyAndAddUnsafe(h,b,y);if(!p)throw Error("point at infinify");return p.assertValidity(),p}hasHighS(){return h(this.s)}normalizeS(){return this.hasHighS()?new b(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return O(this.toDERHex())}toDERHex(){return wt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return O(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const y={isValidPrivateKey(t){try{return c(t),!0}catch(t){return!1}},normPrivateKeyToScalar:c,randomPrivateKey:()=>{const t=at(e.n);return function(t,e,n=!1){const r=t.length,f=st(e),o=at(e);if(r<16||r<o||r>1024)throw Error(`expected ${o}-1024 bytes of input, got ${r}`);const i=X(n?R(t):q(t),e-Y)+Y;return n?P(i,f):z(i,f)}(e.randomBytes(t),e.n)},precompute:(t=8,e=a.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function p(t){const e=m(t),n="string"==typeof t,r=(e||n)&&t.length;return e?r===f||r===o:n?r===2*f||r===2*o:t instanceof a}const w=e.bits2int||function(t){const n=R(t),r=8*t.length-e.nBitLength;return r>0?n>>BigInt(r):n},E=e.bits2int_modN||function(t){return i(w(t))},I=$(e.nBitLength);function v(t){return F("num < 2^"+e.nBitLength,t,Bt,I),z(t,e.nByteLength)}function S(t,r,f=A){if(["recovered","canonical"].some((t=>t in f)))throw Error("sign() legacy options not supported");const{hash:o,randomBytes:d}=e;let{lowS:l,prehash:g,extraEntropy:y}=f;null==l&&(l=!0),t=L("msgHash",t),yt(f),g&&(t=L("prehashed msgHash",o(t)));const p=E(t),m=c(r),B=[v(m),v(p)];if(null!=y&&!1!==y){const t=!0===y?d(n.BYTES):y;B.push(L("extraEntropy",t))}const x=N(...B),I=p;return{seed:x,k2sig:function(t){const e=w(t);if(!u(e))return;const n=s(e),r=a.BASE.multiply(e).toAffine(),f=i(r.x);if(f===Bt)return;const o=i(n*i(I+f*m));if(o===Bt)return;let c=(r.x===f?0:2)|Number(r.y&Et),d=o;return l&&h(o)&&(d=function(t){return h(t)?i(-t):t}(o),c^=1),new b(f,d,c)}}}const A={lowS:e.lowS,prehash:!1},H={lowS:e.lowS,prehash:!1};return a.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return a.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,n=!0){if(p(t))throw Error("first arg must be private key");if(!p(e))throw Error("second arg must be public key");return a.fromHex(e).multiply(c(t)).toRawBytes(n)},sign:function(t,n,r=A){const{seed:f,k2sig:o}=S(t,n,r),i=e;return G(i.hash.outputLen,i.nByteLength,i.hmac)(f,o)},verify:function(t,n,r,f=H){const o=t;if(n=L("msgHash",n),r=L("publicKey",r),"strict"in f)throw Error("options.strict was renamed to lowS");yt(f);const{lowS:c,prehash:d}=f;let u,l;try{if("string"==typeof o||m(o))try{u=b.fromDER(o)}catch(t){if(!(t instanceof wt.Err))throw t;u=b.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw Error("PARSE");{const{r:t,s:e}=o;u=new b(t,e)}}l=a.fromHex(r)}catch(t){if("PARSE"===t.message)throw Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(c&&u.hasHighS())return!1;d&&(n=e.hash(n));const{r:h,s:g}=u,y=E(n),p=s(g),w=i(y*p),B=i(h*p),x=a.BASE.multiplyAndAddUnsafe(l,w,B)?.toAffine();return!!x&&i(x.x)===h},ProjectivePoint:a,Signature:b,utils:y}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function St(t){return{hash:t,hmac:(e,...n)=>g(t,e,o(...n)),randomBytes:i}}function At(t,e){const n=e=>vt({...t,...St(e)});return Object.freeze({...n(e),create:n})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(4);const Ot=it(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),Rt=At({a:Ot.create(BigInt("-3")),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Fp:Ot,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},s),qt=it(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff")),zt=At({a:qt.create(BigInt("-3")),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Fp:qt,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},a),Pt=it(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")),Lt={a:Pt.create(BigInt("-3")),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Fp:Pt,n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),h:BigInt(1)},Nt=At({a:Lt.a,b:Lt.b,Fp:Pt,n:Lt.n,Gx:Lt.Gx,Gy:Lt.Gy,h:Lt.h,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},c),Ht=BigInt(0),Tt=BigInt(1),Ft=BigInt(2),Zt=BigInt(8),$t={zip215:!0};function _t(t){const e=function(t){const e=bt(t);return j(t,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}(t),{Fp:n,n:r,prehash:f,hash:o,randomBytes:i,nByteLength:s,h:a}=e,c=Ft<<BigInt(8*s)-Tt,d=n.create,u=it(e.n,e.nBitLength),l=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:n.sqrt(t*n.inv(e))}}catch(t){return{isValid:!1,value:Ht}}}),h=e.adjustScalarBytes||(t=>t),g=e.domain||((t,e,n)=>{if(B("phflag",n),e.length||n)throw Error("Contexts/pre-hash are not supported");return t});function b(t,e){F("coordinate "+t,e,Ht,c)}function y(t){if(!(t instanceof w))throw Error("ExtendedPoint expected")}const p=C(((t,e)=>{const{ex:r,ey:f,ez:o}=t,i=t.is0();null==e&&(e=i?Zt:n.inv(o));const s=d(r*e),a=d(f*e),c=d(o*e);if(i)return{x:Ht,y:Tt};if(c!==Tt)throw Error("invZ was invalid");return{x:s,y:a}})),m=C((t=>{const{a:n,d:r}=e;if(t.is0())throw Error("bad point: ZERO");const{ex:f,ey:o,ez:i,et:s}=t,a=d(f*f),c=d(o*o),u=d(i*i),l=d(u*u),h=d(a*n);if(d(u*d(h+c))!==d(l+d(r*d(a*c))))throw Error("bad point: equation left != right (1)");if(d(f*o)!==d(i*s))throw Error("bad point: equation left != right (2)");return!0}));class w{constructor(t,e,n,r){this.ex=t,this.ey=e,this.ez=n,this.et=r,b("x",t),b("y",e),b("z",n),b("t",r),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(t){if(t instanceof w)throw Error("extended point not allowed");const{x:e,y:n}=t||{};return b("x",e),b("y",n),new w(e,n,Tt,d(e*n))}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.ez)));return t.map(((t,n)=>t.toAffine(e[n]))).map(w.fromAffine)}static msm(t,e){return gt(w,u,t,e)}_setWindowSize(t){v.setWindowSize(this,t)}assertValidity(){m(this)}equals(t){y(t);const{ex:e,ey:n,ez:r}=this,{ex:f,ey:o,ez:i}=t,s=d(e*i),a=d(f*r),c=d(n*i),u=d(o*r);return s===a&&c===u}is0(){return this.equals(w.ZERO)}negate(){return new w(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){const{a:t}=e,{ex:n,ey:r,ez:f}=this,o=d(n*n),i=d(r*r),s=d(Ft*d(f*f)),a=d(t*o),c=n+r,u=d(d(c*c)-o-i),l=a+i,h=l-s,g=a-i,b=d(u*h),y=d(l*g),p=d(u*g),m=d(h*l);return new w(b,y,m,p)}add(t){y(t);const{a:n,d:r}=e,{ex:f,ey:o,ez:i,et:s}=this,{ex:a,ey:c,ez:u,et:l}=t;if(n===BigInt(-1)){const t=d((o-f)*(c+a)),e=d((o+f)*(c-a)),n=d(e-t);if(n===Ht)return this.double();const r=d(i*Ft*l),h=d(s*Ft*u),g=h+r,b=e+t,y=h-r,p=d(g*n),m=d(b*y),B=d(g*y),E=d(n*b);return new w(p,m,E,B)}const h=d(f*a),g=d(o*c),b=d(s*r*l),p=d(i*u),m=d((f+o)*(a+c)-h-g),B=p-b,E=p+b,x=d(g-n*h),I=d(m*B),v=d(E*x),S=d(m*x),A=d(B*E);return new w(I,v,A,S)}subtract(t){return this.add(t.negate())}wNAF(t){return v.wNAFCached(this,t,w.normalizeZ)}multiply(t){const e=t;F("scalar",e,Tt,r);const{p:n,f}=this.wNAF(e);return w.normalizeZ([n,f])[0]}multiplyUnsafe(t){const e=t;return F("scalar",e,Ht,r),e===Ht?I:this.equals(I)||e===Tt?this:this.equals(E)?this.wNAF(e).p:v.unsafeLadder(this,e)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return v.unsafeLadder(this,r).is0()}toAffine(t){return p(this,t)}clearCofactor(){const{h:t}=e;return t===Tt?this:this.multiplyUnsafe(t)}static fromHex(t,r=!1){const{d:f,a:o}=e,i=n.BYTES;t=L("pointHex",t,i),B("zip215",r);const s=t.slice(),a=t[i-1];s[i-1]=-129&a;const u=q(s),h=r?c:n.ORDER;F("pointHex.y",u,Ht,h);const g=d(u*u),b=d(g-Tt),y=d(f*g-o);let{isValid:p,value:m}=l(b,y);if(!p)throw Error("Point.fromHex: invalid y coordinate");const E=(m&Tt)===Tt,x=!!(128&a);if(!r&&m===Ht&&x)throw Error("Point.fromHex: x=0 and x_0=1");return x!==E&&(m=d(-m)),w.fromAffine({x:m,y:u})}static fromPrivateKey(t){return O(t).point}toRawBytes(){const{x:t,y:e}=this.toAffine(),r=P(e,n.BYTES);return r[r.length-1]|=t&Tt?128:0,r}toHex(){return x(this.toRawBytes())}}w.BASE=new w(e.Gx,e.Gy,Tt,d(e.Gx*e.Gy)),w.ZERO=new w(Ht,Tt,Tt,Ht);const{BASE:E,ZERO:I}=w,v=ht(w,8*s);function S(t){return X(t,r)}function A(t){return S(q(t))}function O(t){const e=s;t=L("private key",t,e);const n=L("hashed private key",o(t),2*e),r=h(n.slice(0,e)),f=n.slice(e,2*e),i=A(r),a=E.multiply(i),c=a.toRawBytes();return{head:r,prefix:f,scalar:i,point:a,pointBytes:c}}function R(t=new Uint8Array,...e){const n=N(...e);return A(o(g(n,L("context",t),!!f)))}const z=$t;E._setWindowSize(8);return{CURVE:e,getPublicKey:function(t){return O(t).pointBytes},sign:function(t,e,o={}){t=L("message",t),f&&(t=f(t));const{prefix:i,scalar:a,pointBytes:c}=O(e),d=R(o.context,i,t),u=E.multiply(d).toRawBytes(),l=S(d+R(o.context,u,c,t)*a);return F("signature.s",l,Ht,r),L("result",N(u,P(l,n.BYTES)),2*s)},verify:function(t,e,r,o=z){const{context:i,zip215:s}=o,a=n.BYTES;t=L("signature",t,2*a),e=L("message",e),void 0!==s&&B("zip215",s),f&&(e=f(e));const c=q(t.slice(a,2*a));let d,u,l;try{d=w.fromHex(r,s),u=w.fromHex(t.slice(0,a),s),l=E.multiplyUnsafe(c)}catch(t){return!1}if(!s&&d.isSmallOrder())return!1;const h=R(i,u.toRawBytes(),d.toRawBytes(),e);return u.add(d.multiplyUnsafe(h)).subtract(l).clearCofactor().equals(w.ZERO)},ExtendedPoint:w,utils:{getExtendedPublicKey:O,randomPrivateKey:()=>i(n.BYTES),precompute:(t=8,e=w.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)}}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const kt=BigInt(0),Gt=BigInt(1);function Ut(t){const e=(j(n=t,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...n}));var n;const{P:r}=e,f=t=>X(t,r),o=e.montgomeryBits,i=Math.ceil(o/8),s=e.nByteLength,a=e.adjustScalarBytes||(t=>t),c=e.powPminus2||(t=>tt(t,r-BigInt(2),r));function d(t,e,n){const r=f(t*(e-n));return[e=f(e-r),n=f(n+r)]}const u=(e.a-BigInt(2))/BigInt(4);function l(t){return P(f(t),i)}function h(t,e){const n=function(t){const e=L("u coordinate",t,i);return 32===s&&(e[31]&=127),q(e)}(e),h=function(t){const e=L("scalar",t),n=e.length;if(n!==i&&n!==s)throw Error(`Expected ${i} or ${s} bytes, got ${n}`);return q(a(e))}(t),g=function(t,e){F("u",t,kt,r),F("scalar",e,kt,r);const n=e,i=t;let s,a=Gt,l=kt,h=t,g=Gt,b=kt;for(let t=BigInt(o-1);t>=kt;t--){const e=n>>t&Gt;b^=e,s=d(b,a,h),a=s[0],h=s[1],s=d(b,l,g),l=s[0],g=s[1],b=e;const r=a+l,o=f(r*r),c=a-l,y=f(c*c),p=o-y,m=h+g,w=f((h-g)*r),B=f(m*c),E=w+B,x=w-B;h=f(E*E),g=f(i*f(x*x)),a=f(o*y),l=f(p*(o+f(u*p)))}s=d(b,a,h),a=s[0],h=s[1],s=d(b,l,g),l=s[0],g=s[1];const y=c(l);return f(a*y)}(n,h);if(g===kt)throw Error("Invalid private or public key received");return l(g)}const g=l(e.Gu);function b(t){return h(t,g)}return{scalarMult:h,scalarMultBase:b,getSharedSecret:(t,e)=>h(t,e),getPublicKey:t=>b(t),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:g}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jt=d((()=>l.create({dkLen:114}))),Ct=(d((()=>l.create({dkLen:64}))),BigInt("726838724295606890549323807888004534353641360687318060281490199180612328166730772686396383698676545930088884461843637361053498018365439")),Vt=BigInt(1),Kt=BigInt(2),Yt=BigInt(3);BigInt(4);const Mt=BigInt(11),Wt=BigInt(22),Dt=BigInt(44),Jt=BigInt(88),Qt=BigInt(223);function Xt(t){const e=Ct,n=t*t*t%e,r=n*n*t%e,f=et(r,Yt,e)*r%e,o=et(f,Yt,e)*r%e,i=et(o,Kt,e)*n%e,s=et(i,Mt,e)*i%e,a=et(s,Wt,e)*s%e,c=et(a,Dt,e)*a%e,d=et(c,Jt,e)*c%e,u=et(d,Dt,e)*a%e,l=et(u,Kt,e)*n%e,h=et(l,Vt,e)*t%e;return et(h,Qt,e)*l%e}function te(t){return t[0]&=252,t[55]|=128,t[56]=0,t}const ee=it(Ct,456,!0),ne={a:BigInt(1),d:BigInt("726838724295606890549323807888004534353641360687318060281490199180612328166730772686396383698676545930088884461843637361053498018326358"),Fp:ee,n:BigInt("181709681073901722637330951972001133588410340171829515070372549795146003961539585716195755291692375963310293709091662304773755859649779"),nBitLength:456,h:BigInt(4),Gx:BigInt("224580040295924300187604334099896036246789641632564134246125461686950415467406032909029192869357953282578032075146446173674602635247710"),Gy:BigInt("298819210078481492676017930443930673437544040154080242095928241372331506189835876003536878655418784733982303233503462500531545062832660"),hash:jt,randomBytes:i,adjustScalarBytes:te,domain:(t,e,n)=>{if(e.length>255)throw Error("Context is too big: "+e.length);return o(u("SigEd448"),new Uint8Array([n?1:0,e.length]),e,t)},uvRatio:function(t,e){const n=Ct,r=X(t*t*e,n),f=X(r*t,n),o=X(f*r*e,n),i=X(f*Xt(o),n),s=X(i*i,n);return{isValid:X(s*e,n)===t,value:i}}},re=/* @__PURE__ */_t(ne),fe=/* @__PURE__ */(()=>Ut({a:BigInt(156326),montgomeryBits:448,nByteLength:56,P:Ct,Gu:BigInt(5),powPminus2:t=>{const e=Ct;return X(et(Xt(t),BigInt(2),e)*t,e)},adjustScalarBytes:te,randomBytes:i}))();ee.ORDER,BigInt(3),BigInt(4),BigInt(156326),BigInt("39082"),BigInt("78163"),BigInt("98944233647732219769177004876929019128417576295529901074099889598043702116001257856802131563896515373927712232092845883226922417596214"),BigInt("315019913931389607337177038330951043522456072897266928557328499619017160722351061360252776265186336876723201881398623946864393857820716"),BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const oe=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ie=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),se=BigInt(1),ae=BigInt(2),ce=(t,e)=>(t+e/ae)/e;const de=it(oe,void 0,void 0,{sqrt:function(t){const e=oe,n=BigInt(3),r=BigInt(6),f=BigInt(11),o=BigInt(22),i=BigInt(23),s=BigInt(44),a=BigInt(88),c=t*t*t%e,d=c*c*t%e,u=et(d,n,e)*d%e,l=et(u,n,e)*d%e,h=et(l,ae,e)*c%e,g=et(h,f,e)*h%e,b=et(g,o,e)*g%e,y=et(b,s,e)*b%e,p=et(y,a,e)*y%e,m=et(p,s,e)*b%e,w=et(m,n,e)*d%e,B=et(w,i,e)*g%e,E=et(B,r,e)*c%e,x=et(E,ae,e);if(!de.eql(de.sqr(x),t))throw Error("Cannot find square root");return x}}),ue=At({a:BigInt(0),b:BigInt(7),Fp:de,n:ie,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=ie,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-se*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),f=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=n,i=BigInt("0x100000000000000000000000000000000"),s=ce(o*t,e),a=ce(-r*t,e);let c=X(t-s*n-a*f,e),d=X(-s*r-a*o,e);const u=c>i,l=d>i;if(u&&(c=e-c),l&&(d=e-d),c>i||d>i)throw Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:c,k2neg:l,k2:d}}}},s);BigInt(0),ue.ProjectivePoint;const le=it(BigInt("0xa9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377")),he=At({a:le.create(BigInt("0x7d5a0975fc2c3057eef67530417affe7fb8055c126dc5c6ce94a4b44f330b5d9")),b:BigInt("0x26dc5c6ce94a4b44f330b5d9bbd77cbf958416295cf7e1ce6bccdc18ff8c07b6"),Fp:le,n:BigInt("0xa9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7"),Gx:BigInt("0x8bd2aeb9cb7e57cb2c4b482ffc81b7afb9de27e1e3bd23c23a4453bd9ace3262"),Gy:BigInt("0x547ef835c3dac4fd97f8461a14611dc9c27745132ded8e545c1d54c72f046997"),h:BigInt(1),lowS:!1},s),ge=it(BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53")),be=At({a:ge.create(BigInt("0x7bc382c63d8c150c3c72080ace05afa0c2bea28e4fb22787139165efba91f90f8aa5814a503ad4eb04a8c7dd22ce2826")),b:BigInt("0x04a8c7dd22ce28268b39b55416f0447c2fb77de107dcd2a62e880ea53eeb62d57cb4390295dbc9943ab78696fa504c11"),Fp:ge,n:BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e9046565"),Gx:BigInt("0x1d1c64f068cf45ffa2a63a81b7c13f6b8847a3e77ef14fe3db7fcafe0cbd10e8e826e03436d646aaef87b2e247d4af1e"),Gy:BigInt("0x8abe1d7520f9c2a45cb1eb8e95cfd55262b70b29feec5864e19c054ff99129280e4646217791811142820341263c5315"),h:BigInt(1),lowS:!1},a),ye=it(BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f3")),pe=At({a:ye.create(BigInt("0x7830a3318b603b89e2327145ac234cc594cbdd8d3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94ca")),b:BigInt("0x3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94cadc083e67984050b75ebae5dd2809bd638016f723"),Fp:ye,n:BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069"),Gx:BigInt("0x81aee4bdd82ed9645a21322e9c4c6a9385ed9f70b5d916c1b43b62eef4d0098eff3b1f78e2d0d48d50d1687b93b97d5f7c6d5047406a5e688b352209bcb9f822"),Gy:BigInt("0x7dde385d566332ecc0eabfa9cf7822fdf209f70024a57b1aa000c55b881f8111b2dcde494a5f485e5bca4bd88a2763aed1ca2b2fa8f0540678cd1e0f3ad80892"),h:BigInt(1),lowS:!1},c),me=new Map(Object.entries({nistP256:Rt,nistP384:zt,nistP521:Nt,brainpoolP256r1:he,brainpoolP384r1:be,brainpoolP512r1:pe,secp256k1:ue,x448:fe,ed448:re}));export{me as nobleCurves};
//# sourceMappingURL=noble_curves.min.mjs.map
