import { parseXmlBody as parseBody, parseXmlErrorBody as parseErrorBody } from "@aws-sdk/core";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeDateTime as __serializeDateTime, serializeFloat as __serializeFloat, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { EC2ServiceException as __BaseException } from "../models/EC2ServiceException";
export const se_AcceptAddressTransferCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AcceptAddressTransferRequest(input, context),
        [_A]: _AAT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AcceptCapacityReservationBillingOwnershipCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AcceptCapacityReservationBillingOwnershipRequest(input, context),
        [_A]: _ACRBO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AcceptReservedInstancesExchangeQuoteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AcceptReservedInstancesExchangeQuoteRequest(input, context),
        [_A]: _ARIEQ,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AcceptTransitGatewayMulticastDomainAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AcceptTransitGatewayMulticastDomainAssociationsRequest(input, context),
        [_A]: _ATGMDA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AcceptTransitGatewayPeeringAttachmentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AcceptTransitGatewayPeeringAttachmentRequest(input, context),
        [_A]: _ATGPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AcceptTransitGatewayVpcAttachmentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AcceptTransitGatewayVpcAttachmentRequest(input, context),
        [_A]: _ATGVA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AcceptVpcEndpointConnectionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AcceptVpcEndpointConnectionsRequest(input, context),
        [_A]: _AVEC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AcceptVpcPeeringConnectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AcceptVpcPeeringConnectionRequest(input, context),
        [_A]: _AVPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AdvertiseByoipCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AdvertiseByoipCidrRequest(input, context),
        [_A]: _ABC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AllocateAddressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AllocateAddressRequest(input, context),
        [_A]: _AA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AllocateHostsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AllocateHostsRequest(input, context),
        [_A]: _AH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AllocateIpamPoolCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AllocateIpamPoolCidrRequest(input, context),
        [_A]: _AIPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ApplySecurityGroupsToClientVpnTargetNetworkCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ApplySecurityGroupsToClientVpnTargetNetworkRequest(input, context),
        [_A]: _ASGTCVTN,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssignIpv6AddressesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssignIpv6AddressesRequest(input, context),
        [_A]: _AIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssignPrivateIpAddressesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssignPrivateIpAddressesRequest(input, context),
        [_A]: _APIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssignPrivateNatGatewayAddressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssignPrivateNatGatewayAddressRequest(input, context),
        [_A]: _APNGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateAddressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateAddressRequest(input, context),
        [_A]: _AAs,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateCapacityReservationBillingOwnerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateCapacityReservationBillingOwnerRequest(input, context),
        [_A]: _ACRBOs,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateClientVpnTargetNetworkCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateClientVpnTargetNetworkRequest(input, context),
        [_A]: _ACVTN,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateDhcpOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateDhcpOptionsRequest(input, context),
        [_A]: _ADO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateEnclaveCertificateIamRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateEnclaveCertificateIamRoleRequest(input, context),
        [_A]: _AECIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateIamInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateIamInstanceProfileRequest(input, context),
        [_A]: _AIIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateInstanceEventWindowCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateInstanceEventWindowRequest(input, context),
        [_A]: _AIEW,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateIpamByoasnCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateIpamByoasnRequest(input, context),
        [_A]: _AIB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateIpamResourceDiscoveryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateIpamResourceDiscoveryRequest(input, context),
        [_A]: _AIRD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateNatGatewayAddressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateNatGatewayAddressRequest(input, context),
        [_A]: _ANGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateRouteServerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateRouteServerRequest(input, context),
        [_A]: _ARS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateRouteTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateRouteTableRequest(input, context),
        [_A]: _ART,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateSecurityGroupVpcCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateSecurityGroupVpcRequest(input, context),
        [_A]: _ASGV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateSubnetCidrBlockCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateSubnetCidrBlockRequest(input, context),
        [_A]: _ASCB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateTransitGatewayMulticastDomainCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateTransitGatewayMulticastDomainRequest(input, context),
        [_A]: _ATGMD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateTransitGatewayPolicyTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateTransitGatewayPolicyTableRequest(input, context),
        [_A]: _ATGPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateTransitGatewayRouteTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateTransitGatewayRouteTableRequest(input, context),
        [_A]: _ATGRT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateTrunkInterfaceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateTrunkInterfaceRequest(input, context),
        [_A]: _ATI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateVpcCidrBlockCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateVpcCidrBlockRequest(input, context),
        [_A]: _AVCB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachClassicLinkVpcCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachClassicLinkVpcRequest(input, context),
        [_A]: _ACLV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachInternetGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachInternetGatewayRequest(input, context),
        [_A]: _AIG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachNetworkInterfaceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachNetworkInterfaceRequest(input, context),
        [_A]: _ANI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachVerifiedAccessTrustProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachVerifiedAccessTrustProviderRequest(input, context),
        [_A]: _AVATP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachVolumeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachVolumeRequest(input, context),
        [_A]: _AV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachVpnGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachVpnGatewayRequest(input, context),
        [_A]: _AVG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AuthorizeClientVpnIngressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AuthorizeClientVpnIngressRequest(input, context),
        [_A]: _ACVI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AuthorizeSecurityGroupEgressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AuthorizeSecurityGroupEgressRequest(input, context),
        [_A]: _ASGE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AuthorizeSecurityGroupIngressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AuthorizeSecurityGroupIngressRequest(input, context),
        [_A]: _ASGI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_BundleInstanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_BundleInstanceRequest(input, context),
        [_A]: _BI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelBundleTaskCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelBundleTaskRequest(input, context),
        [_A]: _CBT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelCapacityReservationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelCapacityReservationRequest(input, context),
        [_A]: _CCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelCapacityReservationFleetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelCapacityReservationFleetsRequest(input, context),
        [_A]: _CCRF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelConversionTaskCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelConversionRequest(input, context),
        [_A]: _CCT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelDeclarativePoliciesReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelDeclarativePoliciesReportRequest(input, context),
        [_A]: _CDPR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelExportTaskCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelExportTaskRequest(input, context),
        [_A]: _CET,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelImageLaunchPermissionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelImageLaunchPermissionRequest(input, context),
        [_A]: _CILP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelImportTaskCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelImportTaskRequest(input, context),
        [_A]: _CIT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelReservedInstancesListingCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelReservedInstancesListingRequest(input, context),
        [_A]: _CRIL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelSpotFleetRequestsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelSpotFleetRequestsRequest(input, context),
        [_A]: _CSFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelSpotInstanceRequestsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelSpotInstanceRequestsRequest(input, context),
        [_A]: _CSIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ConfirmProductInstanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ConfirmProductInstanceRequest(input, context),
        [_A]: _CPI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopyFpgaImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CopyFpgaImageRequest(input, context),
        [_A]: _CFI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopyImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CopyImageRequest(input, context),
        [_A]: _CI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopySnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CopySnapshotRequest(input, context),
        [_A]: _CS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCapacityReservationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCapacityReservationRequest(input, context),
        [_A]: _CCRr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCapacityReservationBySplittingCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCapacityReservationBySplittingRequest(input, context),
        [_A]: _CCRBS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCapacityReservationFleetCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCapacityReservationFleetRequest(input, context),
        [_A]: _CCRFr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCarrierGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCarrierGatewayRequest(input, context),
        [_A]: _CCG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateClientVpnEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateClientVpnEndpointRequest(input, context),
        [_A]: _CCVE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateClientVpnRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateClientVpnRouteRequest(input, context),
        [_A]: _CCVR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCoipCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCoipCidrRequest(input, context),
        [_A]: _CCC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCoipPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCoipPoolRequest(input, context),
        [_A]: _CCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCustomerGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCustomerGatewayRequest(input, context),
        [_A]: _CCGr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDefaultSubnetCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateDefaultSubnetRequest(input, context),
        [_A]: _CDS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDefaultVpcCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateDefaultVpcRequest(input, context),
        [_A]: _CDV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDhcpOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateDhcpOptionsRequest(input, context),
        [_A]: _CDO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateEgressOnlyInternetGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateEgressOnlyInternetGatewayRequest(input, context),
        [_A]: _CEOIG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateFleetCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateFleetRequest(input, context),
        [_A]: _CF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateFlowLogsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateFlowLogsRequest(input, context),
        [_A]: _CFL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateFpgaImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateFpgaImageRequest(input, context),
        [_A]: _CFIr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateImageRequest(input, context),
        [_A]: _CIr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateInstanceConnectEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateInstanceConnectEndpointRequest(input, context),
        [_A]: _CICE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateInstanceEventWindowCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateInstanceEventWindowRequest(input, context),
        [_A]: _CIEW,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateInstanceExportTaskCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateInstanceExportTaskRequest(input, context),
        [_A]: _CIET,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateInternetGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateInternetGatewayRequest(input, context),
        [_A]: _CIG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateIpamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateIpamRequest(input, context),
        [_A]: _CIre,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateIpamExternalResourceVerificationTokenCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateIpamExternalResourceVerificationTokenRequest(input, context),
        [_A]: _CIERVT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateIpamPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateIpamPoolRequest(input, context),
        [_A]: _CIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateIpamResourceDiscoveryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateIpamResourceDiscoveryRequest(input, context),
        [_A]: _CIRD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateIpamScopeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateIpamScopeRequest(input, context),
        [_A]: _CIS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateKeyPairCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateKeyPairRequest(input, context),
        [_A]: _CKP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLaunchTemplateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLaunchTemplateRequest(input, context),
        [_A]: _CLT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLaunchTemplateVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLaunchTemplateVersionRequest(input, context),
        [_A]: _CLTV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocalGatewayRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLocalGatewayRouteRequest(input, context),
        [_A]: _CLGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocalGatewayRouteTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLocalGatewayRouteTableRequest(input, context),
        [_A]: _CLGRT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest(input, context),
        [_A]: _CLGRTVIGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLocalGatewayRouteTableVpcAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLocalGatewayRouteTableVpcAssociationRequest(input, context),
        [_A]: _CLGRTVA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateManagedPrefixListCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateManagedPrefixListRequest(input, context),
        [_A]: _CMPL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateNatGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateNatGatewayRequest(input, context),
        [_A]: _CNG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateNetworkAclCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateNetworkAclRequest(input, context),
        [_A]: _CNA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateNetworkAclEntryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateNetworkAclEntryRequest(input, context),
        [_A]: _CNAE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateNetworkInsightsAccessScopeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateNetworkInsightsAccessScopeRequest(input, context),
        [_A]: _CNIAS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateNetworkInsightsPathCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateNetworkInsightsPathRequest(input, context),
        [_A]: _CNIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateNetworkInterfaceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateNetworkInterfaceRequest(input, context),
        [_A]: _CNI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateNetworkInterfacePermissionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateNetworkInterfacePermissionRequest(input, context),
        [_A]: _CNIPr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreatePlacementGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreatePlacementGroupRequest(input, context),
        [_A]: _CPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreatePublicIpv4PoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreatePublicIpv4PoolRequest(input, context),
        [_A]: _CPIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateReplaceRootVolumeTaskCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateReplaceRootVolumeTaskRequest(input, context),
        [_A]: _CRRVT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateReservedInstancesListingCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateReservedInstancesListingRequest(input, context),
        [_A]: _CRILr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateRestoreImageTaskCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRestoreImageTaskRequest(input, context),
        [_A]: _CRIT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRouteRequest(input, context),
        [_A]: _CR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateRouteServerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRouteServerRequest(input, context),
        [_A]: _CRS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateRouteServerEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRouteServerEndpointRequest(input, context),
        [_A]: _CRSE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateRouteServerPeerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRouteServerPeerRequest(input, context),
        [_A]: _CRSP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateRouteTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRouteTableRequest(input, context),
        [_A]: _CRT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSecurityGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSecurityGroupRequest(input, context),
        [_A]: _CSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSnapshotRequest(input, context),
        [_A]: _CSr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSnapshotsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSnapshotsRequest(input, context),
        [_A]: _CSre,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSpotDatafeedSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSpotDatafeedSubscriptionRequest(input, context),
        [_A]: _CSDS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateStoreImageTaskCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateStoreImageTaskRequest(input, context),
        [_A]: _CSIT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSubnetCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSubnetRequest(input, context),
        [_A]: _CSrea,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSubnetCidrReservationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSubnetCidrReservationRequest(input, context),
        [_A]: _CSCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTagsRequest(input, context),
        [_A]: _CT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTrafficMirrorFilterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTrafficMirrorFilterRequest(input, context),
        [_A]: _CTMF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTrafficMirrorFilterRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTrafficMirrorFilterRuleRequest(input, context),
        [_A]: _CTMFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTrafficMirrorSessionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTrafficMirrorSessionRequest(input, context),
        [_A]: _CTMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTrafficMirrorTargetCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTrafficMirrorTargetRequest(input, context),
        [_A]: _CTMT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayRequest(input, context),
        [_A]: _CTG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayConnectCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayConnectRequest(input, context),
        [_A]: _CTGC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayConnectPeerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayConnectPeerRequest(input, context),
        [_A]: _CTGCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayMulticastDomainCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayMulticastDomainRequest(input, context),
        [_A]: _CTGMD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayPeeringAttachmentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayPeeringAttachmentRequest(input, context),
        [_A]: _CTGPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayPolicyTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayPolicyTableRequest(input, context),
        [_A]: _CTGPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayPrefixListReferenceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayPrefixListReferenceRequest(input, context),
        [_A]: _CTGPLR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayRouteRequest(input, context),
        [_A]: _CTGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayRouteTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayRouteTableRequest(input, context),
        [_A]: _CTGRT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayRouteTableAnnouncementCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayRouteTableAnnouncementRequest(input, context),
        [_A]: _CTGRTA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTransitGatewayVpcAttachmentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTransitGatewayVpcAttachmentRequest(input, context),
        [_A]: _CTGVA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVerifiedAccessEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVerifiedAccessEndpointRequest(input, context),
        [_A]: _CVAE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVerifiedAccessGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVerifiedAccessGroupRequest(input, context),
        [_A]: _CVAG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVerifiedAccessInstanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVerifiedAccessInstanceRequest(input, context),
        [_A]: _CVAI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVerifiedAccessTrustProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVerifiedAccessTrustProviderRequest(input, context),
        [_A]: _CVATP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVolumeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVolumeRequest(input, context),
        [_A]: _CV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVpcCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVpcRequest(input, context),
        [_A]: _CVr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVpcBlockPublicAccessExclusionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVpcBlockPublicAccessExclusionRequest(input, context),
        [_A]: _CVBPAE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVpcEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVpcEndpointRequest(input, context),
        [_A]: _CVE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVpcEndpointConnectionNotificationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVpcEndpointConnectionNotificationRequest(input, context),
        [_A]: _CVECN,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVpcEndpointServiceConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVpcEndpointServiceConfigurationRequest(input, context),
        [_A]: _CVESC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVpcPeeringConnectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVpcPeeringConnectionRequest(input, context),
        [_A]: _CVPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVpnConnectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVpnConnectionRequest(input, context),
        [_A]: _CVC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVpnConnectionRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVpnConnectionRouteRequest(input, context),
        [_A]: _CVCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVpnGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVpnGatewayRequest(input, context),
        [_A]: _CVG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteCarrierGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteCarrierGatewayRequest(input, context),
        [_A]: _DCG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteClientVpnEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteClientVpnEndpointRequest(input, context),
        [_A]: _DCVE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteClientVpnRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteClientVpnRouteRequest(input, context),
        [_A]: _DCVR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteCoipCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteCoipCidrRequest(input, context),
        [_A]: _DCC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteCoipPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteCoipPoolRequest(input, context),
        [_A]: _DCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteCustomerGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteCustomerGatewayRequest(input, context),
        [_A]: _DCGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDhcpOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteDhcpOptionsRequest(input, context),
        [_A]: _DDO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteEgressOnlyInternetGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteEgressOnlyInternetGatewayRequest(input, context),
        [_A]: _DEOIG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteFleetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteFleetsRequest(input, context),
        [_A]: _DF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteFlowLogsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteFlowLogsRequest(input, context),
        [_A]: _DFL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteFpgaImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteFpgaImageRequest(input, context),
        [_A]: _DFI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteInstanceConnectEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteInstanceConnectEndpointRequest(input, context),
        [_A]: _DICE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteInstanceEventWindowCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteInstanceEventWindowRequest(input, context),
        [_A]: _DIEW,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteInternetGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteInternetGatewayRequest(input, context),
        [_A]: _DIG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteIpamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteIpamRequest(input, context),
        [_A]: _DI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteIpamExternalResourceVerificationTokenCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteIpamExternalResourceVerificationTokenRequest(input, context),
        [_A]: _DIERVT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteIpamPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteIpamPoolRequest(input, context),
        [_A]: _DIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteIpamResourceDiscoveryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteIpamResourceDiscoveryRequest(input, context),
        [_A]: _DIRD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteIpamScopeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteIpamScopeRequest(input, context),
        [_A]: _DIS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteKeyPairCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteKeyPairRequest(input, context),
        [_A]: _DKP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLaunchTemplateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLaunchTemplateRequest(input, context),
        [_A]: _DLT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLaunchTemplateVersionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLaunchTemplateVersionsRequest(input, context),
        [_A]: _DLTV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLocalGatewayRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLocalGatewayRouteRequest(input, context),
        [_A]: _DLGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLocalGatewayRouteTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLocalGatewayRouteTableRequest(input, context),
        [_A]: _DLGRT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest(input, context),
        [_A]: _DLGRTVIGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLocalGatewayRouteTableVpcAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLocalGatewayRouteTableVpcAssociationRequest(input, context),
        [_A]: _DLGRTVA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteManagedPrefixListCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteManagedPrefixListRequest(input, context),
        [_A]: _DMPL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNatGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNatGatewayRequest(input, context),
        [_A]: _DNG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNetworkAclCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNetworkAclRequest(input, context),
        [_A]: _DNA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNetworkAclEntryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNetworkAclEntryRequest(input, context),
        [_A]: _DNAE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNetworkInsightsAccessScopeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNetworkInsightsAccessScopeRequest(input, context),
        [_A]: _DNIAS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNetworkInsightsAccessScopeAnalysisCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNetworkInsightsAccessScopeAnalysisRequest(input, context),
        [_A]: _DNIASA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNetworkInsightsAnalysisCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNetworkInsightsAnalysisRequest(input, context),
        [_A]: _DNIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNetworkInsightsPathCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNetworkInsightsPathRequest(input, context),
        [_A]: _DNIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNetworkInterfaceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNetworkInterfaceRequest(input, context),
        [_A]: _DNI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNetworkInterfacePermissionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNetworkInterfacePermissionRequest(input, context),
        [_A]: _DNIPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeletePlacementGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeletePlacementGroupRequest(input, context),
        [_A]: _DPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeletePublicIpv4PoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeletePublicIpv4PoolRequest(input, context),
        [_A]: _DPIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteQueuedReservedInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteQueuedReservedInstancesRequest(input, context),
        [_A]: _DQRI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRouteRequest(input, context),
        [_A]: _DR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRouteServerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRouteServerRequest(input, context),
        [_A]: _DRS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRouteServerEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRouteServerEndpointRequest(input, context),
        [_A]: _DRSE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRouteServerPeerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRouteServerPeerRequest(input, context),
        [_A]: _DRSP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRouteTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRouteTableRequest(input, context),
        [_A]: _DRT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSecurityGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSecurityGroupRequest(input, context),
        [_A]: _DSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSnapshotRequest(input, context),
        [_A]: _DS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSpotDatafeedSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSpotDatafeedSubscriptionRequest(input, context),
        [_A]: _DSDS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSubnetCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSubnetRequest(input, context),
        [_A]: _DSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSubnetCidrReservationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSubnetCidrReservationRequest(input, context),
        [_A]: _DSCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTagsRequest(input, context),
        [_A]: _DT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTrafficMirrorFilterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTrafficMirrorFilterRequest(input, context),
        [_A]: _DTMF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTrafficMirrorFilterRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTrafficMirrorFilterRuleRequest(input, context),
        [_A]: _DTMFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTrafficMirrorSessionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTrafficMirrorSessionRequest(input, context),
        [_A]: _DTMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTrafficMirrorTargetCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTrafficMirrorTargetRequest(input, context),
        [_A]: _DTMT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayRequest(input, context),
        [_A]: _DTG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayConnectCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayConnectRequest(input, context),
        [_A]: _DTGC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayConnectPeerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayConnectPeerRequest(input, context),
        [_A]: _DTGCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayMulticastDomainCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayMulticastDomainRequest(input, context),
        [_A]: _DTGMD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayPeeringAttachmentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayPeeringAttachmentRequest(input, context),
        [_A]: _DTGPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayPolicyTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayPolicyTableRequest(input, context),
        [_A]: _DTGPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayPrefixListReferenceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayPrefixListReferenceRequest(input, context),
        [_A]: _DTGPLR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayRouteRequest(input, context),
        [_A]: _DTGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayRouteTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayRouteTableRequest(input, context),
        [_A]: _DTGRT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayRouteTableAnnouncementCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayRouteTableAnnouncementRequest(input, context),
        [_A]: _DTGRTA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTransitGatewayVpcAttachmentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTransitGatewayVpcAttachmentRequest(input, context),
        [_A]: _DTGVA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVerifiedAccessEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVerifiedAccessEndpointRequest(input, context),
        [_A]: _DVAE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVerifiedAccessGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVerifiedAccessGroupRequest(input, context),
        [_A]: _DVAG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVerifiedAccessInstanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVerifiedAccessInstanceRequest(input, context),
        [_A]: _DVAI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVerifiedAccessTrustProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVerifiedAccessTrustProviderRequest(input, context),
        [_A]: _DVATP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVolumeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVolumeRequest(input, context),
        [_A]: _DV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVpcCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVpcRequest(input, context),
        [_A]: _DVe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVpcBlockPublicAccessExclusionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVpcBlockPublicAccessExclusionRequest(input, context),
        [_A]: _DVBPAE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVpcEndpointConnectionNotificationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVpcEndpointConnectionNotificationsRequest(input, context),
        [_A]: _DVECN,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVpcEndpointsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVpcEndpointsRequest(input, context),
        [_A]: _DVE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVpcEndpointServiceConfigurationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVpcEndpointServiceConfigurationsRequest(input, context),
        [_A]: _DVESC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVpcPeeringConnectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVpcPeeringConnectionRequest(input, context),
        [_A]: _DVPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVpnConnectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVpnConnectionRequest(input, context),
        [_A]: _DVC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVpnConnectionRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVpnConnectionRouteRequest(input, context),
        [_A]: _DVCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVpnGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVpnGatewayRequest(input, context),
        [_A]: _DVG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeprovisionByoipCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeprovisionByoipCidrRequest(input, context),
        [_A]: _DBC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeprovisionIpamByoasnCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeprovisionIpamByoasnRequest(input, context),
        [_A]: _DIB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeprovisionIpamPoolCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeprovisionIpamPoolCidrRequest(input, context),
        [_A]: _DIPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeprovisionPublicIpv4PoolCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeprovisionPublicIpv4PoolCidrRequest(input, context),
        [_A]: _DPIPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeregisterImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeregisterImageRequest(input, context),
        [_A]: _DIe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeregisterInstanceEventNotificationAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeregisterInstanceEventNotificationAttributesRequest(input, context),
        [_A]: _DIENA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeregisterTransitGatewayMulticastGroupMembersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeregisterTransitGatewayMulticastGroupMembersRequest(input, context),
        [_A]: _DTGMGM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeregisterTransitGatewayMulticastGroupSourcesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeregisterTransitGatewayMulticastGroupSourcesRequest(input, context),
        [_A]: _DTGMGS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAccountAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAccountAttributesRequest(input, context),
        [_A]: _DAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAddressesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAddressesRequest(input, context),
        [_A]: _DA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAddressesAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAddressesAttributeRequest(input, context),
        [_A]: _DAAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAddressTransfersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAddressTransfersRequest(input, context),
        [_A]: _DAT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAggregateIdFormatCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAggregateIdFormatRequest(input, context),
        [_A]: _DAIF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAvailabilityZonesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAvailabilityZonesRequest(input, context),
        [_A]: _DAZ,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAwsNetworkPerformanceMetricSubscriptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAwsNetworkPerformanceMetricSubscriptionsRequest(input, context),
        [_A]: _DANPMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeBundleTasksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeBundleTasksRequest(input, context),
        [_A]: _DBT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeByoipCidrsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeByoipCidrsRequest(input, context),
        [_A]: _DBCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCapacityBlockExtensionHistoryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCapacityBlockExtensionHistoryRequest(input, context),
        [_A]: _DCBEH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCapacityBlockExtensionOfferingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCapacityBlockExtensionOfferingsRequest(input, context),
        [_A]: _DCBEO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCapacityBlockOfferingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCapacityBlockOfferingsRequest(input, context),
        [_A]: _DCBO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCapacityReservationBillingRequestsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCapacityReservationBillingRequestsRequest(input, context),
        [_A]: _DCRBR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCapacityReservationFleetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCapacityReservationFleetsRequest(input, context),
        [_A]: _DCRF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCapacityReservationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCapacityReservationsRequest(input, context),
        [_A]: _DCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCarrierGatewaysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCarrierGatewaysRequest(input, context),
        [_A]: _DCGes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClassicLinkInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClassicLinkInstancesRequest(input, context),
        [_A]: _DCLI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClientVpnAuthorizationRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClientVpnAuthorizationRulesRequest(input, context),
        [_A]: _DCVAR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClientVpnConnectionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClientVpnConnectionsRequest(input, context),
        [_A]: _DCVC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClientVpnEndpointsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClientVpnEndpointsRequest(input, context),
        [_A]: _DCVEe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClientVpnRoutesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClientVpnRoutesRequest(input, context),
        [_A]: _DCVRe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClientVpnTargetNetworksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClientVpnTargetNetworksRequest(input, context),
        [_A]: _DCVTN,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCoipPoolsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCoipPoolsRequest(input, context),
        [_A]: _DCPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeConversionTasksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeConversionTasksRequest(input, context),
        [_A]: _DCT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCustomerGatewaysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCustomerGatewaysRequest(input, context),
        [_A]: _DCGesc,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDeclarativePoliciesReportsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDeclarativePoliciesReportsRequest(input, context),
        [_A]: _DDPR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDhcpOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDhcpOptionsRequest(input, context),
        [_A]: _DDOe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEgressOnlyInternetGatewaysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEgressOnlyInternetGatewaysRequest(input, context),
        [_A]: _DEOIGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeElasticGpusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeElasticGpusRequest(input, context),
        [_A]: _DEG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeExportImageTasksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeExportImageTasksRequest(input, context),
        [_A]: _DEIT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeExportTasksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeExportTasksRequest(input, context),
        [_A]: _DET,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFastLaunchImagesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeFastLaunchImagesRequest(input, context),
        [_A]: _DFLI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFastSnapshotRestoresCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeFastSnapshotRestoresRequest(input, context),
        [_A]: _DFSR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFleetHistoryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeFleetHistoryRequest(input, context),
        [_A]: _DFH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFleetInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeFleetInstancesRequest(input, context),
        [_A]: _DFIe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFleetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeFleetsRequest(input, context),
        [_A]: _DFe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFlowLogsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeFlowLogsRequest(input, context),
        [_A]: _DFLe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFpgaImageAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeFpgaImageAttributeRequest(input, context),
        [_A]: _DFIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFpgaImagesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeFpgaImagesRequest(input, context),
        [_A]: _DFIes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeHostReservationOfferingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeHostReservationOfferingsRequest(input, context),
        [_A]: _DHRO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeHostReservationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeHostReservationsRequest(input, context),
        [_A]: _DHR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeHostsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeHostsRequest(input, context),
        [_A]: _DH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIamInstanceProfileAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIamInstanceProfileAssociationsRequest(input, context),
        [_A]: _DIIPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIdentityIdFormatCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIdentityIdFormatRequest(input, context),
        [_A]: _DIIF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIdFormatCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIdFormatRequest(input, context),
        [_A]: _DIF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeImageAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeImageAttributeRequest(input, context),
        [_A]: _DIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeImagesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeImagesRequest(input, context),
        [_A]: _DIes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeImportImageTasksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeImportImageTasksRequest(input, context),
        [_A]: _DIIT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeImportSnapshotTasksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeImportSnapshotTasksRequest(input, context),
        [_A]: _DIST,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceAttributeRequest(input, context),
        [_A]: _DIAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceConnectEndpointsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceConnectEndpointsRequest(input, context),
        [_A]: _DICEe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceCreditSpecificationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceCreditSpecificationsRequest(input, context),
        [_A]: _DICS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceEventNotificationAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceEventNotificationAttributesRequest(input, context),
        [_A]: _DIENAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceEventWindowsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceEventWindowsRequest(input, context),
        [_A]: _DIEWe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceImageMetadataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceImageMetadataRequest(input, context),
        [_A]: _DIIM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstancesRequest(input, context),
        [_A]: _DIesc,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceStatusRequest(input, context),
        [_A]: _DISe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceTopologyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceTopologyRequest(input, context),
        [_A]: _DIT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceTypeOfferingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceTypeOfferingsRequest(input, context),
        [_A]: _DITO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceTypesRequest(input, context),
        [_A]: _DITe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInternetGatewaysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInternetGatewaysRequest(input, context),
        [_A]: _DIGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIpamByoasnCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIpamByoasnRequest(input, context),
        [_A]: _DIBe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIpamExternalResourceVerificationTokensCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIpamExternalResourceVerificationTokensRequest(input, context),
        [_A]: _DIERVTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIpamPoolsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIpamPoolsRequest(input, context),
        [_A]: _DIPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIpamResourceDiscoveriesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIpamResourceDiscoveriesRequest(input, context),
        [_A]: _DIRDe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIpamResourceDiscoveryAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIpamResourceDiscoveryAssociationsRequest(input, context),
        [_A]: _DIRDA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIpamsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIpamsRequest(input, context),
        [_A]: _DIescr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIpamScopesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIpamScopesRequest(input, context),
        [_A]: _DISes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIpv6PoolsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIpv6PoolsRequest(input, context),
        [_A]: _DIPes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeKeyPairsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeKeyPairsRequest(input, context),
        [_A]: _DKPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLaunchTemplatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLaunchTemplatesRequest(input, context),
        [_A]: _DLTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLaunchTemplateVersionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLaunchTemplateVersionsRequest(input, context),
        [_A]: _DLTVe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocalGatewayRouteTablesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLocalGatewayRouteTablesRequest(input, context),
        [_A]: _DLGRTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest(input, context),
        [_A]: _DLGRTVIGAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocalGatewayRouteTableVpcAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLocalGatewayRouteTableVpcAssociationsRequest(input, context),
        [_A]: _DLGRTVAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocalGatewaysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLocalGatewaysRequest(input, context),
        [_A]: _DLG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocalGatewayVirtualInterfaceGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLocalGatewayVirtualInterfaceGroupsRequest(input, context),
        [_A]: _DLGVIG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLocalGatewayVirtualInterfacesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLocalGatewayVirtualInterfacesRequest(input, context),
        [_A]: _DLGVI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLockedSnapshotsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLockedSnapshotsRequest(input, context),
        [_A]: _DLS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMacHostsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeMacHostsRequest(input, context),
        [_A]: _DMH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeManagedPrefixListsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeManagedPrefixListsRequest(input, context),
        [_A]: _DMPLe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMovingAddressesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeMovingAddressesRequest(input, context),
        [_A]: _DMA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNatGatewaysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNatGatewaysRequest(input, context),
        [_A]: _DNGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNetworkAclsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNetworkAclsRequest(input, context),
        [_A]: _DNAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNetworkInsightsAccessScopeAnalysesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNetworkInsightsAccessScopeAnalysesRequest(input, context),
        [_A]: _DNIASAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNetworkInsightsAccessScopesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNetworkInsightsAccessScopesRequest(input, context),
        [_A]: _DNIASe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNetworkInsightsAnalysesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNetworkInsightsAnalysesRequest(input, context),
        [_A]: _DNIAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNetworkInsightsPathsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNetworkInsightsPathsRequest(input, context),
        [_A]: _DNIPes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNetworkInterfaceAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNetworkInterfaceAttributeRequest(input, context),
        [_A]: _DNIAes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNetworkInterfacePermissionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNetworkInterfacePermissionsRequest(input, context),
        [_A]: _DNIPesc,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNetworkInterfacesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNetworkInterfacesRequest(input, context),
        [_A]: _DNIe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePlacementGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribePlacementGroupsRequest(input, context),
        [_A]: _DPGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePrefixListsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribePrefixListsRequest(input, context),
        [_A]: _DPL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePrincipalIdFormatCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribePrincipalIdFormatRequest(input, context),
        [_A]: _DPIF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePublicIpv4PoolsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribePublicIpv4PoolsRequest(input, context),
        [_A]: _DPIPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeRegionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeRegionsRequest(input, context),
        [_A]: _DRe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReplaceRootVolumeTasksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReplaceRootVolumeTasksRequest(input, context),
        [_A]: _DRRVT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReservedInstancesRequest(input, context),
        [_A]: _DRI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedInstancesListingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReservedInstancesListingsRequest(input, context),
        [_A]: _DRIL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedInstancesModificationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReservedInstancesModificationsRequest(input, context),
        [_A]: _DRIM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedInstancesOfferingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReservedInstancesOfferingsRequest(input, context),
        [_A]: _DRIO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeRouteServerEndpointsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeRouteServerEndpointsRequest(input, context),
        [_A]: _DRSEe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeRouteServerPeersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeRouteServerPeersRequest(input, context),
        [_A]: _DRSPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeRouteServersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeRouteServersRequest(input, context),
        [_A]: _DRSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeRouteTablesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeRouteTablesRequest(input, context),
        [_A]: _DRTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeScheduledInstanceAvailabilityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeScheduledInstanceAvailabilityRequest(input, context),
        [_A]: _DSIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeScheduledInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeScheduledInstancesRequest(input, context),
        [_A]: _DSI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSecurityGroupReferencesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSecurityGroupReferencesRequest(input, context),
        [_A]: _DSGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSecurityGroupRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSecurityGroupRulesRequest(input, context),
        [_A]: _DSGRe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSecurityGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSecurityGroupsRequest(input, context),
        [_A]: _DSGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSecurityGroupVpcAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSecurityGroupVpcAssociationsRequest(input, context),
        [_A]: _DSGVA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSnapshotAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSnapshotAttributeRequest(input, context),
        [_A]: _DSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSnapshotsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSnapshotsRequest(input, context),
        [_A]: _DSes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSnapshotTierStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSnapshotTierStatusRequest(input, context),
        [_A]: _DSTS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSpotDatafeedSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSpotDatafeedSubscriptionRequest(input, context),
        [_A]: _DSDSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSpotFleetInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSpotFleetInstancesRequest(input, context),
        [_A]: _DSFI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSpotFleetRequestHistoryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSpotFleetRequestHistoryRequest(input, context),
        [_A]: _DSFRH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSpotFleetRequestsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSpotFleetRequestsRequest(input, context),
        [_A]: _DSFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSpotInstanceRequestsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSpotInstanceRequestsRequest(input, context),
        [_A]: _DSIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSpotPriceHistoryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSpotPriceHistoryRequest(input, context),
        [_A]: _DSPH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeStaleSecurityGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeStaleSecurityGroupsRequest(input, context),
        [_A]: _DSSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeStoreImageTasksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeStoreImageTasksRequest(input, context),
        [_A]: _DSIT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSubnetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSubnetsRequest(input, context),
        [_A]: _DSesc,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTagsRequest(input, context),
        [_A]: _DTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTrafficMirrorFilterRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTrafficMirrorFilterRulesRequest(input, context),
        [_A]: _DTMFRe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTrafficMirrorFiltersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTrafficMirrorFiltersRequest(input, context),
        [_A]: _DTMFe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTrafficMirrorSessionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTrafficMirrorSessionsRequest(input, context),
        [_A]: _DTMSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTrafficMirrorTargetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTrafficMirrorTargetsRequest(input, context),
        [_A]: _DTMTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTransitGatewayAttachmentsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTransitGatewayAttachmentsRequest(input, context),
        [_A]: _DTGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTransitGatewayConnectPeersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTransitGatewayConnectPeersRequest(input, context),
        [_A]: _DTGCPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTransitGatewayConnectsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTransitGatewayConnectsRequest(input, context),
        [_A]: _DTGCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTransitGatewayMulticastDomainsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTransitGatewayMulticastDomainsRequest(input, context),
        [_A]: _DTGMDe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTransitGatewayPeeringAttachmentsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTransitGatewayPeeringAttachmentsRequest(input, context),
        [_A]: _DTGPAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTransitGatewayPolicyTablesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTransitGatewayPolicyTablesRequest(input, context),
        [_A]: _DTGPTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTransitGatewayRouteTableAnnouncementsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTransitGatewayRouteTableAnnouncementsRequest(input, context),
        [_A]: _DTGRTAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTransitGatewayRouteTablesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTransitGatewayRouteTablesRequest(input, context),
        [_A]: _DTGRTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTransitGatewaysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTransitGatewaysRequest(input, context),
        [_A]: _DTGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTransitGatewayVpcAttachmentsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTransitGatewayVpcAttachmentsRequest(input, context),
        [_A]: _DTGVAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTrunkInterfaceAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTrunkInterfaceAssociationsRequest(input, context),
        [_A]: _DTIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVerifiedAccessEndpointsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVerifiedAccessEndpointsRequest(input, context),
        [_A]: _DVAEe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVerifiedAccessGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVerifiedAccessGroupsRequest(input, context),
        [_A]: _DVAGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVerifiedAccessInstanceLoggingConfigurationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVerifiedAccessInstanceLoggingConfigurationsRequest(input, context),
        [_A]: _DVAILC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVerifiedAccessInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVerifiedAccessInstancesRequest(input, context),
        [_A]: _DVAIe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVerifiedAccessTrustProvidersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVerifiedAccessTrustProvidersRequest(input, context),
        [_A]: _DVATPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVolumeAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVolumeAttributeRequest(input, context),
        [_A]: _DVA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVolumesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVolumesRequest(input, context),
        [_A]: _DVes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVolumesModificationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVolumesModificationsRequest(input, context),
        [_A]: _DVM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVolumeStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVolumeStatusRequest(input, context),
        [_A]: _DVS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcAttributeRequest(input, context),
        [_A]: _DVAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcBlockPublicAccessExclusionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcBlockPublicAccessExclusionsRequest(input, context),
        [_A]: _DVBPAEe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcBlockPublicAccessOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcBlockPublicAccessOptionsRequest(input, context),
        [_A]: _DVBPAO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcClassicLinkCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcClassicLinkRequest(input, context),
        [_A]: _DVCL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcClassicLinkDnsSupportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcClassicLinkDnsSupportRequest(input, context),
        [_A]: _DVCLDS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcEndpointAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcEndpointAssociationsRequest(input, context),
        [_A]: _DVEA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcEndpointConnectionNotificationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcEndpointConnectionNotificationsRequest(input, context),
        [_A]: _DVECNe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcEndpointConnectionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcEndpointConnectionsRequest(input, context),
        [_A]: _DVEC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcEndpointsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcEndpointsRequest(input, context),
        [_A]: _DVEe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcEndpointServiceConfigurationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcEndpointServiceConfigurationsRequest(input, context),
        [_A]: _DVESCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcEndpointServicePermissionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcEndpointServicePermissionsRequest(input, context),
        [_A]: _DVESP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcEndpointServicesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcEndpointServicesRequest(input, context),
        [_A]: _DVES,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcPeeringConnectionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcPeeringConnectionsRequest(input, context),
        [_A]: _DVPCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpcsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpcsRequest(input, context),
        [_A]: _DVesc,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpnConnectionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpnConnectionsRequest(input, context),
        [_A]: _DVCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVpnGatewaysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeVpnGatewaysRequest(input, context),
        [_A]: _DVGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachClassicLinkVpcCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachClassicLinkVpcRequest(input, context),
        [_A]: _DCLV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachInternetGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachInternetGatewayRequest(input, context),
        [_A]: _DIGet,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachNetworkInterfaceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachNetworkInterfaceRequest(input, context),
        [_A]: _DNIet,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachVerifiedAccessTrustProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachVerifiedAccessTrustProviderRequest(input, context),
        [_A]: _DVATPet,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachVolumeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachVolumeRequest(input, context),
        [_A]: _DVet,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachVpnGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachVpnGatewayRequest(input, context),
        [_A]: _DVGet,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableAddressTransferCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableAddressTransferRequest(input, context),
        [_A]: _DATi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableAllowedImagesSettingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableAllowedImagesSettingsRequest(input, context),
        [_A]: _DAIS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableAwsNetworkPerformanceMetricSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableAwsNetworkPerformanceMetricSubscriptionRequest(input, context),
        [_A]: _DANPMSi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableEbsEncryptionByDefaultCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableEbsEncryptionByDefaultRequest(input, context),
        [_A]: _DEEBD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableFastLaunchCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableFastLaunchRequest(input, context),
        [_A]: _DFLi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableFastSnapshotRestoresCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableFastSnapshotRestoresRequest(input, context),
        [_A]: _DFSRi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableImageRequest(input, context),
        [_A]: _DIi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableImageBlockPublicAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableImageBlockPublicAccessRequest(input, context),
        [_A]: _DIBPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableImageDeprecationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableImageDeprecationRequest(input, context),
        [_A]: _DID,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableImageDeregistrationProtectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableImageDeregistrationProtectionRequest(input, context),
        [_A]: _DIDP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableIpamOrganizationAdminAccountCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableIpamOrganizationAdminAccountRequest(input, context),
        [_A]: _DIOAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableRouteServerPropagationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableRouteServerPropagationRequest(input, context),
        [_A]: _DRSPi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableSerialConsoleAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableSerialConsoleAccessRequest(input, context),
        [_A]: _DSCA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableSnapshotBlockPublicAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableSnapshotBlockPublicAccessRequest(input, context),
        [_A]: _DSBPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableTransitGatewayRouteTablePropagationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableTransitGatewayRouteTablePropagationRequest(input, context),
        [_A]: _DTGRTP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableVgwRoutePropagationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableVgwRoutePropagationRequest(input, context),
        [_A]: _DVRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableVpcClassicLinkCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableVpcClassicLinkRequest(input, context),
        [_A]: _DVCLi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableVpcClassicLinkDnsSupportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableVpcClassicLinkDnsSupportRequest(input, context),
        [_A]: _DVCLDSi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateAddressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateAddressRequest(input, context),
        [_A]: _DAi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateCapacityReservationBillingOwnerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateCapacityReservationBillingOwnerRequest(input, context),
        [_A]: _DCRBO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateClientVpnTargetNetworkCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateClientVpnTargetNetworkRequest(input, context),
        [_A]: _DCVTNi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateEnclaveCertificateIamRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateEnclaveCertificateIamRoleRequest(input, context),
        [_A]: _DECIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateIamInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateIamInstanceProfileRequest(input, context),
        [_A]: _DIIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateInstanceEventWindowCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateInstanceEventWindowRequest(input, context),
        [_A]: _DIEWi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateIpamByoasnCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateIpamByoasnRequest(input, context),
        [_A]: _DIBi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateIpamResourceDiscoveryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateIpamResourceDiscoveryRequest(input, context),
        [_A]: _DIRDi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateNatGatewayAddressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateNatGatewayAddressRequest(input, context),
        [_A]: _DNGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateRouteServerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateRouteServerRequest(input, context),
        [_A]: _DRSi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateRouteTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateRouteTableRequest(input, context),
        [_A]: _DRTi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateSecurityGroupVpcCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateSecurityGroupVpcRequest(input, context),
        [_A]: _DSGV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateSubnetCidrBlockCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateSubnetCidrBlockRequest(input, context),
        [_A]: _DSCB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateTransitGatewayMulticastDomainCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateTransitGatewayMulticastDomainRequest(input, context),
        [_A]: _DTGMDi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateTransitGatewayPolicyTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateTransitGatewayPolicyTableRequest(input, context),
        [_A]: _DTGPTi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateTransitGatewayRouteTableCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateTransitGatewayRouteTableRequest(input, context),
        [_A]: _DTGRTi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateTrunkInterfaceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateTrunkInterfaceRequest(input, context),
        [_A]: _DTI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateVpcCidrBlockCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateVpcCidrBlockRequest(input, context),
        [_A]: _DVCB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableAddressTransferCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableAddressTransferRequest(input, context),
        [_A]: _EAT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableAllowedImagesSettingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableAllowedImagesSettingsRequest(input, context),
        [_A]: _EAIS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableAwsNetworkPerformanceMetricSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableAwsNetworkPerformanceMetricSubscriptionRequest(input, context),
        [_A]: _EANPMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableEbsEncryptionByDefaultCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableEbsEncryptionByDefaultRequest(input, context),
        [_A]: _EEEBD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableFastLaunchCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableFastLaunchRequest(input, context),
        [_A]: _EFL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableFastSnapshotRestoresCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableFastSnapshotRestoresRequest(input, context),
        [_A]: _EFSR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableImageRequest(input, context),
        [_A]: _EI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableImageBlockPublicAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableImageBlockPublicAccessRequest(input, context),
        [_A]: _EIBPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableImageDeprecationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableImageDeprecationRequest(input, context),
        [_A]: _EID,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableImageDeregistrationProtectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableImageDeregistrationProtectionRequest(input, context),
        [_A]: _EIDP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableIpamOrganizationAdminAccountCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableIpamOrganizationAdminAccountRequest(input, context),
        [_A]: _EIOAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableReachabilityAnalyzerOrganizationSharingCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableReachabilityAnalyzerOrganizationSharingRequest(input, context),
        [_A]: _ERAOS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableRouteServerPropagationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableRouteServerPropagationRequest(input, context),
        [_A]: _ERSP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableSerialConsoleAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableSerialConsoleAccessRequest(input, context),
        [_A]: _ESCA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableSnapshotBlockPublicAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableSnapshotBlockPublicAccessRequest(input, context),
        [_A]: _ESBPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableTransitGatewayRouteTablePropagationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableTransitGatewayRouteTablePropagationRequest(input, context),
        [_A]: _ETGRTP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableVgwRoutePropagationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableVgwRoutePropagationRequest(input, context),
        [_A]: _EVRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableVolumeIOCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableVolumeIORequest(input, context),
        [_A]: _EVIO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableVpcClassicLinkCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableVpcClassicLinkRequest(input, context),
        [_A]: _EVCL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableVpcClassicLinkDnsSupportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableVpcClassicLinkDnsSupportRequest(input, context),
        [_A]: _EVCLDS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExportClientVpnClientCertificateRevocationListCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ExportClientVpnClientCertificateRevocationListRequest(input, context),
        [_A]: _ECVCCRL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExportClientVpnClientConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ExportClientVpnClientConfigurationRequest(input, context),
        [_A]: _ECVCC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExportImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ExportImageRequest(input, context),
        [_A]: _EIx,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExportTransitGatewayRoutesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ExportTransitGatewayRoutesRequest(input, context),
        [_A]: _ETGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExportVerifiedAccessInstanceClientConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ExportVerifiedAccessInstanceClientConfigurationRequest(input, context),
        [_A]: _EVAICC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAllowedImagesSettingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAllowedImagesSettingsRequest(input, context),
        [_A]: _GAIS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAssociatedEnclaveCertificateIamRolesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAssociatedEnclaveCertificateIamRolesRequest(input, context),
        [_A]: _GAECIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAssociatedIpv6PoolCidrsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAssociatedIpv6PoolCidrsRequest(input, context),
        [_A]: _GAIPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAwsNetworkPerformanceDataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAwsNetworkPerformanceDataRequest(input, context),
        [_A]: _GANPD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetCapacityReservationUsageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetCapacityReservationUsageRequest(input, context),
        [_A]: _GCRU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetCoipPoolUsageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetCoipPoolUsageRequest(input, context),
        [_A]: _GCPU,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetConsoleOutputCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetConsoleOutputRequest(input, context),
        [_A]: _GCO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetConsoleScreenshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetConsoleScreenshotRequest(input, context),
        [_A]: _GCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetDeclarativePoliciesReportSummaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetDeclarativePoliciesReportSummaryRequest(input, context),
        [_A]: _GDPRS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetDefaultCreditSpecificationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetDefaultCreditSpecificationRequest(input, context),
        [_A]: _GDCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetEbsDefaultKmsKeyIdCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetEbsDefaultKmsKeyIdRequest(input, context),
        [_A]: _GEDKKI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetEbsEncryptionByDefaultCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetEbsEncryptionByDefaultRequest(input, context),
        [_A]: _GEEBD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetFlowLogsIntegrationTemplateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetFlowLogsIntegrationTemplateRequest(input, context),
        [_A]: _GFLIT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetGroupsForCapacityReservationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetGroupsForCapacityReservationRequest(input, context),
        [_A]: _GGFCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetHostReservationPurchasePreviewCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetHostReservationPurchasePreviewRequest(input, context),
        [_A]: _GHRPP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetImageBlockPublicAccessStateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetImageBlockPublicAccessStateRequest(input, context),
        [_A]: _GIBPAS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetInstanceMetadataDefaultsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetInstanceMetadataDefaultsRequest(input, context),
        [_A]: _GIMD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetInstanceTpmEkPubCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetInstanceTpmEkPubRequest(input, context),
        [_A]: _GITEP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetInstanceTypesFromInstanceRequirementsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetInstanceTypesFromInstanceRequirementsRequest(input, context),
        [_A]: _GITFIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetInstanceUefiDataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetInstanceUefiDataRequest(input, context),
        [_A]: _GIUD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetIpamAddressHistoryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetIpamAddressHistoryRequest(input, context),
        [_A]: _GIAH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetIpamDiscoveredAccountsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetIpamDiscoveredAccountsRequest(input, context),
        [_A]: _GIDA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetIpamDiscoveredPublicAddressesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetIpamDiscoveredPublicAddressesRequest(input, context),
        [_A]: _GIDPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetIpamDiscoveredResourceCidrsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetIpamDiscoveredResourceCidrsRequest(input, context),
        [_A]: _GIDRC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetIpamPoolAllocationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetIpamPoolAllocationsRequest(input, context),
        [_A]: _GIPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetIpamPoolCidrsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetIpamPoolCidrsRequest(input, context),
        [_A]: _GIPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetIpamResourceCidrsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetIpamResourceCidrsRequest(input, context),
        [_A]: _GIRC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetLaunchTemplateDataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetLaunchTemplateDataRequest(input, context),
        [_A]: _GLTD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetManagedPrefixListAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetManagedPrefixListAssociationsRequest(input, context),
        [_A]: _GMPLA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetManagedPrefixListEntriesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetManagedPrefixListEntriesRequest(input, context),
        [_A]: _GMPLE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetNetworkInsightsAccessScopeAnalysisFindingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetNetworkInsightsAccessScopeAnalysisFindingsRequest(input, context),
        [_A]: _GNIASAF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetNetworkInsightsAccessScopeContentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetNetworkInsightsAccessScopeContentRequest(input, context),
        [_A]: _GNIASC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetPasswordDataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetPasswordDataRequest(input, context),
        [_A]: _GPD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetReservedInstancesExchangeQuoteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetReservedInstancesExchangeQuoteRequest(input, context),
        [_A]: _GRIEQ,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetRouteServerAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetRouteServerAssociationsRequest(input, context),
        [_A]: _GRSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetRouteServerPropagationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetRouteServerPropagationsRequest(input, context),
        [_A]: _GRSP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetRouteServerRoutingDatabaseCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetRouteServerRoutingDatabaseRequest(input, context),
        [_A]: _GRSRD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetSecurityGroupsForVpcCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSecurityGroupsForVpcRequest(input, context),
        [_A]: _GSGFV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetSerialConsoleAccessStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSerialConsoleAccessStatusRequest(input, context),
        [_A]: _GSCAS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetSnapshotBlockPublicAccessStateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSnapshotBlockPublicAccessStateRequest(input, context),
        [_A]: _GSBPAS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetSpotPlacementScoresCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSpotPlacementScoresRequest(input, context),
        [_A]: _GSPS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetSubnetCidrReservationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSubnetCidrReservationsRequest(input, context),
        [_A]: _GSCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetTransitGatewayAttachmentPropagationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetTransitGatewayAttachmentPropagationsRequest(input, context),
        [_A]: _GTGAP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetTransitGatewayMulticastDomainAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetTransitGatewayMulticastDomainAssociationsRequest(input, context),
        [_A]: _GTGMDA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetTransitGatewayPolicyTableAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetTransitGatewayPolicyTableAssociationsRequest(input, context),
        [_A]: _GTGPTA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetTransitGatewayPolicyTableEntriesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetTransitGatewayPolicyTableEntriesRequest(input, context),
        [_A]: _GTGPTE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetTransitGatewayPrefixListReferencesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetTransitGatewayPrefixListReferencesRequest(input, context),
        [_A]: _GTGPLR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetTransitGatewayRouteTableAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetTransitGatewayRouteTableAssociationsRequest(input, context),
        [_A]: _GTGRTA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetTransitGatewayRouteTablePropagationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetTransitGatewayRouteTablePropagationsRequest(input, context),
        [_A]: _GTGRTP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetVerifiedAccessEndpointPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetVerifiedAccessEndpointPolicyRequest(input, context),
        [_A]: _GVAEP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetVerifiedAccessEndpointTargetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetVerifiedAccessEndpointTargetsRequest(input, context),
        [_A]: _GVAET,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetVerifiedAccessGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetVerifiedAccessGroupPolicyRequest(input, context),
        [_A]: _GVAGP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetVpnConnectionDeviceSampleConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetVpnConnectionDeviceSampleConfigurationRequest(input, context),
        [_A]: _GVCDSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetVpnConnectionDeviceTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetVpnConnectionDeviceTypesRequest(input, context),
        [_A]: _GVCDT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetVpnTunnelReplacementStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetVpnTunnelReplacementStatusRequest(input, context),
        [_A]: _GVTRS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ImportClientVpnClientCertificateRevocationListCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ImportClientVpnClientCertificateRevocationListRequest(input, context),
        [_A]: _ICVCCRL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ImportImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ImportImageRequest(input, context),
        [_A]: _II,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ImportInstanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ImportInstanceRequest(input, context),
        [_A]: _IIm,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ImportKeyPairCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ImportKeyPairRequest(input, context),
        [_A]: _IKP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ImportSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ImportSnapshotRequest(input, context),
        [_A]: _IS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ImportVolumeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ImportVolumeRequest(input, context),
        [_A]: _IV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListImagesInRecycleBinCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListImagesInRecycleBinRequest(input, context),
        [_A]: _LIIRB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListSnapshotsInRecycleBinCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSnapshotsInRecycleBinRequest(input, context),
        [_A]: _LSIRB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_LockSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_LockSnapshotRequest(input, context),
        [_A]: _LS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyAddressAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyAddressAttributeRequest(input, context),
        [_A]: _MAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyAvailabilityZoneGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyAvailabilityZoneGroupRequest(input, context),
        [_A]: _MAZG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyCapacityReservationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyCapacityReservationRequest(input, context),
        [_A]: _MCR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyCapacityReservationFleetCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyCapacityReservationFleetRequest(input, context),
        [_A]: _MCRF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyClientVpnEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyClientVpnEndpointRequest(input, context),
        [_A]: _MCVE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyDefaultCreditSpecificationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyDefaultCreditSpecificationRequest(input, context),
        [_A]: _MDCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyEbsDefaultKmsKeyIdCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyEbsDefaultKmsKeyIdRequest(input, context),
        [_A]: _MEDKKI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyFleetCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyFleetRequest(input, context),
        [_A]: _MF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyFpgaImageAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyFpgaImageAttributeRequest(input, context),
        [_A]: _MFIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyHostsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyHostsRequest(input, context),
        [_A]: _MH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyIdentityIdFormatCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyIdentityIdFormatRequest(input, context),
        [_A]: _MIIF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyIdFormatCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyIdFormatRequest(input, context),
        [_A]: _MIF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyImageAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyImageAttributeRequest(input, context),
        [_A]: _MIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstanceAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstanceAttributeRequest(input, context),
        [_A]: _MIAo,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstanceCapacityReservationAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstanceCapacityReservationAttributesRequest(input, context),
        [_A]: _MICRA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstanceCpuOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstanceCpuOptionsRequest(input, context),
        [_A]: _MICO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstanceCreditSpecificationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstanceCreditSpecificationRequest(input, context),
        [_A]: _MICS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstanceEventStartTimeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstanceEventStartTimeRequest(input, context),
        [_A]: _MIEST,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstanceEventWindowCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstanceEventWindowRequest(input, context),
        [_A]: _MIEW,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstanceMaintenanceOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstanceMaintenanceOptionsRequest(input, context),
        [_A]: _MIMO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstanceMetadataDefaultsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstanceMetadataDefaultsRequest(input, context),
        [_A]: _MIMD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstanceMetadataOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstanceMetadataOptionsRequest(input, context),
        [_A]: _MIMOo,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstanceNetworkPerformanceOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstanceNetworkPerformanceRequest(input, context),
        [_A]: _MINPO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyInstancePlacementCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyInstancePlacementRequest(input, context),
        [_A]: _MIP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyIpamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyIpamRequest(input, context),
        [_A]: _MI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyIpamPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyIpamPoolRequest(input, context),
        [_A]: _MIPo,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyIpamResourceCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyIpamResourceCidrRequest(input, context),
        [_A]: _MIRC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyIpamResourceDiscoveryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyIpamResourceDiscoveryRequest(input, context),
        [_A]: _MIRD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyIpamScopeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyIpamScopeRequest(input, context),
        [_A]: _MIS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyLaunchTemplateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyLaunchTemplateRequest(input, context),
        [_A]: _MLT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyLocalGatewayRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyLocalGatewayRouteRequest(input, context),
        [_A]: _MLGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyManagedPrefixListCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyManagedPrefixListRequest(input, context),
        [_A]: _MMPL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyNetworkInterfaceAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyNetworkInterfaceAttributeRequest(input, context),
        [_A]: _MNIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyPrivateDnsNameOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyPrivateDnsNameOptionsRequest(input, context),
        [_A]: _MPDNO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyReservedInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyReservedInstancesRequest(input, context),
        [_A]: _MRI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyRouteServerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyRouteServerRequest(input, context),
        [_A]: _MRS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifySecurityGroupRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifySecurityGroupRulesRequest(input, context),
        [_A]: _MSGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifySnapshotAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifySnapshotAttributeRequest(input, context),
        [_A]: _MSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifySnapshotTierCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifySnapshotTierRequest(input, context),
        [_A]: _MST,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifySpotFleetRequestCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifySpotFleetRequestRequest(input, context),
        [_A]: _MSFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifySubnetAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifySubnetAttributeRequest(input, context),
        [_A]: _MSAo,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyTrafficMirrorFilterNetworkServicesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTrafficMirrorFilterNetworkServicesRequest(input, context),
        [_A]: _MTMFNS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyTrafficMirrorFilterRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTrafficMirrorFilterRuleRequest(input, context),
        [_A]: _MTMFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyTrafficMirrorSessionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTrafficMirrorSessionRequest(input, context),
        [_A]: _MTMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyTransitGatewayCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTransitGatewayRequest(input, context),
        [_A]: _MTG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyTransitGatewayPrefixListReferenceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTransitGatewayPrefixListReferenceRequest(input, context),
        [_A]: _MTGPLR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyTransitGatewayVpcAttachmentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTransitGatewayVpcAttachmentRequest(input, context),
        [_A]: _MTGVA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVerifiedAccessEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVerifiedAccessEndpointRequest(input, context),
        [_A]: _MVAE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVerifiedAccessEndpointPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVerifiedAccessEndpointPolicyRequest(input, context),
        [_A]: _MVAEP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVerifiedAccessGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVerifiedAccessGroupRequest(input, context),
        [_A]: _MVAG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVerifiedAccessGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVerifiedAccessGroupPolicyRequest(input, context),
        [_A]: _MVAGP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVerifiedAccessInstanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVerifiedAccessInstanceRequest(input, context),
        [_A]: _MVAI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVerifiedAccessInstanceLoggingConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVerifiedAccessInstanceLoggingConfigurationRequest(input, context),
        [_A]: _MVAILC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVerifiedAccessTrustProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVerifiedAccessTrustProviderRequest(input, context),
        [_A]: _MVATP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVolumeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVolumeRequest(input, context),
        [_A]: _MV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVolumeAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVolumeAttributeRequest(input, context),
        [_A]: _MVA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpcAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpcAttributeRequest(input, context),
        [_A]: _MVAo,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpcBlockPublicAccessExclusionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpcBlockPublicAccessExclusionRequest(input, context),
        [_A]: _MVBPAE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpcBlockPublicAccessOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpcBlockPublicAccessOptionsRequest(input, context),
        [_A]: _MVBPAO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpcEndpointCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpcEndpointRequest(input, context),
        [_A]: _MVE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpcEndpointConnectionNotificationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpcEndpointConnectionNotificationRequest(input, context),
        [_A]: _MVECN,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpcEndpointServiceConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpcEndpointServiceConfigurationRequest(input, context),
        [_A]: _MVESC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpcEndpointServicePayerResponsibilityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpcEndpointServicePayerResponsibilityRequest(input, context),
        [_A]: _MVESPR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpcEndpointServicePermissionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpcEndpointServicePermissionsRequest(input, context),
        [_A]: _MVESP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpcPeeringConnectionOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpcPeeringConnectionOptionsRequest(input, context),
        [_A]: _MVPCO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpcTenancyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpcTenancyRequest(input, context),
        [_A]: _MVT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpnConnectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpnConnectionRequest(input, context),
        [_A]: _MVC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpnConnectionOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpnConnectionOptionsRequest(input, context),
        [_A]: _MVCO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpnTunnelCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpnTunnelCertificateRequest(input, context),
        [_A]: _MVTC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyVpnTunnelOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyVpnTunnelOptionsRequest(input, context),
        [_A]: _MVTO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_MonitorInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_MonitorInstancesRequest(input, context),
        [_A]: _MIo,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_MoveAddressToVpcCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_MoveAddressToVpcRequest(input, context),
        [_A]: _MATV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_MoveByoipCidrToIpamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_MoveByoipCidrToIpamRequest(input, context),
        [_A]: _MBCTI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_MoveCapacityReservationInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_MoveCapacityReservationInstancesRequest(input, context),
        [_A]: _MCRI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ProvisionByoipCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ProvisionByoipCidrRequest(input, context),
        [_A]: _PBC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ProvisionIpamByoasnCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ProvisionIpamByoasnRequest(input, context),
        [_A]: _PIB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ProvisionIpamPoolCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ProvisionIpamPoolCidrRequest(input, context),
        [_A]: _PIPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ProvisionPublicIpv4PoolCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ProvisionPublicIpv4PoolCidrRequest(input, context),
        [_A]: _PPIPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PurchaseCapacityBlockCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PurchaseCapacityBlockRequest(input, context),
        [_A]: _PCB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PurchaseCapacityBlockExtensionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PurchaseCapacityBlockExtensionRequest(input, context),
        [_A]: _PCBE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PurchaseHostReservationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PurchaseHostReservationRequest(input, context),
        [_A]: _PHR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PurchaseReservedInstancesOfferingCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PurchaseReservedInstancesOfferingRequest(input, context),
        [_A]: _PRIO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PurchaseScheduledInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PurchaseScheduledInstancesRequest(input, context),
        [_A]: _PSI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RebootInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RebootInstancesRequest(input, context),
        [_A]: _RI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RegisterImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RegisterImageRequest(input, context),
        [_A]: _RIe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RegisterInstanceEventNotificationAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RegisterInstanceEventNotificationAttributesRequest(input, context),
        [_A]: _RIENA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RegisterTransitGatewayMulticastGroupMembersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RegisterTransitGatewayMulticastGroupMembersRequest(input, context),
        [_A]: _RTGMGM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RegisterTransitGatewayMulticastGroupSourcesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RegisterTransitGatewayMulticastGroupSourcesRequest(input, context),
        [_A]: _RTGMGS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RejectCapacityReservationBillingOwnershipCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RejectCapacityReservationBillingOwnershipRequest(input, context),
        [_A]: _RCRBO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RejectTransitGatewayMulticastDomainAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RejectTransitGatewayMulticastDomainAssociationsRequest(input, context),
        [_A]: _RTGMDA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RejectTransitGatewayPeeringAttachmentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RejectTransitGatewayPeeringAttachmentRequest(input, context),
        [_A]: _RTGPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RejectTransitGatewayVpcAttachmentCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RejectTransitGatewayVpcAttachmentRequest(input, context),
        [_A]: _RTGVA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RejectVpcEndpointConnectionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RejectVpcEndpointConnectionsRequest(input, context),
        [_A]: _RVEC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RejectVpcPeeringConnectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RejectVpcPeeringConnectionRequest(input, context),
        [_A]: _RVPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReleaseAddressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReleaseAddressRequest(input, context),
        [_A]: _RA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReleaseHostsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReleaseHostsRequest(input, context),
        [_A]: _RH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReleaseIpamPoolAllocationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReleaseIpamPoolAllocationRequest(input, context),
        [_A]: _RIPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReplaceIamInstanceProfileAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReplaceIamInstanceProfileAssociationRequest(input, context),
        [_A]: _RIIPA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReplaceImageCriteriaInAllowedImagesSettingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReplaceImageCriteriaInAllowedImagesSettingsRequest(input, context),
        [_A]: _RICIAIS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReplaceNetworkAclAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReplaceNetworkAclAssociationRequest(input, context),
        [_A]: _RNAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReplaceNetworkAclEntryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReplaceNetworkAclEntryRequest(input, context),
        [_A]: _RNAE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReplaceRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReplaceRouteRequest(input, context),
        [_A]: _RR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReplaceRouteTableAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReplaceRouteTableAssociationRequest(input, context),
        [_A]: _RRTA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReplaceTransitGatewayRouteCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReplaceTransitGatewayRouteRequest(input, context),
        [_A]: _RTGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReplaceVpnTunnelCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReplaceVpnTunnelRequest(input, context),
        [_A]: _RVT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReportInstanceStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ReportInstanceStatusRequest(input, context),
        [_A]: _RIS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RequestSpotFleetCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RequestSpotFleetRequest(input, context),
        [_A]: _RSF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RequestSpotInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RequestSpotInstancesRequest(input, context),
        [_A]: _RSI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetAddressAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetAddressAttributeRequest(input, context),
        [_A]: _RAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetEbsDefaultKmsKeyIdCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetEbsDefaultKmsKeyIdRequest(input, context),
        [_A]: _REDKKI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetFpgaImageAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetFpgaImageAttributeRequest(input, context),
        [_A]: _RFIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetImageAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetImageAttributeRequest(input, context),
        [_A]: _RIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetInstanceAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetInstanceAttributeRequest(input, context),
        [_A]: _RIAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetNetworkInterfaceAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetNetworkInterfaceAttributeRequest(input, context),
        [_A]: _RNIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetSnapshotAttributeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetSnapshotAttributeRequest(input, context),
        [_A]: _RSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RestoreAddressToClassicCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RestoreAddressToClassicRequest(input, context),
        [_A]: _RATC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RestoreImageFromRecycleBinCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RestoreImageFromRecycleBinRequest(input, context),
        [_A]: _RIFRB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RestoreManagedPrefixListVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RestoreManagedPrefixListVersionRequest(input, context),
        [_A]: _RMPLV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RestoreSnapshotFromRecycleBinCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RestoreSnapshotFromRecycleBinRequest(input, context),
        [_A]: _RSFRB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RestoreSnapshotTierCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RestoreSnapshotTierRequest(input, context),
        [_A]: _RST,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RevokeClientVpnIngressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RevokeClientVpnIngressRequest(input, context),
        [_A]: _RCVI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RevokeSecurityGroupEgressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RevokeSecurityGroupEgressRequest(input, context),
        [_A]: _RSGE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RevokeSecurityGroupIngressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RevokeSecurityGroupIngressRequest(input, context),
        [_A]: _RSGI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RunInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RunInstancesRequest(input, context),
        [_A]: _RIu,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RunScheduledInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RunScheduledInstancesRequest(input, context),
        [_A]: _RSIu,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SearchLocalGatewayRoutesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SearchLocalGatewayRoutesRequest(input, context),
        [_A]: _SLGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SearchTransitGatewayMulticastGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SearchTransitGatewayMulticastGroupsRequest(input, context),
        [_A]: _STGMG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SearchTransitGatewayRoutesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SearchTransitGatewayRoutesRequest(input, context),
        [_A]: _STGR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SendDiagnosticInterruptCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SendDiagnosticInterruptRequest(input, context),
        [_A]: _SDI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartDeclarativePoliciesReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartDeclarativePoliciesReportRequest(input, context),
        [_A]: _SDPR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartInstancesRequest(input, context),
        [_A]: _SI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartNetworkInsightsAccessScopeAnalysisCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartNetworkInsightsAccessScopeAnalysisRequest(input, context),
        [_A]: _SNIASA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartNetworkInsightsAnalysisCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartNetworkInsightsAnalysisRequest(input, context),
        [_A]: _SNIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartVpcEndpointServicePrivateDnsVerificationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartVpcEndpointServicePrivateDnsVerificationRequest(input, context),
        [_A]: _SVESPDV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StopInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StopInstancesRequest(input, context),
        [_A]: _SIt,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TerminateClientVpnConnectionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TerminateClientVpnConnectionsRequest(input, context),
        [_A]: _TCVC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TerminateInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TerminateInstancesRequest(input, context),
        [_A]: _TI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UnassignIpv6AddressesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UnassignIpv6AddressesRequest(input, context),
        [_A]: _UIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UnassignPrivateIpAddressesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UnassignPrivateIpAddressesRequest(input, context),
        [_A]: _UPIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UnassignPrivateNatGatewayAddressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UnassignPrivateNatGatewayAddressRequest(input, context),
        [_A]: _UPNGA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UnlockSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UnlockSnapshotRequest(input, context),
        [_A]: _US,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UnmonitorInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UnmonitorInstancesRequest(input, context),
        [_A]: _UI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateSecurityGroupRuleDescriptionsEgressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSecurityGroupRuleDescriptionsEgressRequest(input, context),
        [_A]: _USGRDE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateSecurityGroupRuleDescriptionsIngressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSecurityGroupRuleDescriptionsIngressRequest(input, context),
        [_A]: _USGRDI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_WithdrawByoipCidrCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_WithdrawByoipCidrRequest(input, context),
        [_A]: _WBC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AcceptAddressTransferCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AcceptAddressTransferResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AcceptCapacityReservationBillingOwnershipCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AcceptCapacityReservationBillingOwnershipResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AcceptReservedInstancesExchangeQuoteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AcceptReservedInstancesExchangeQuoteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AcceptTransitGatewayMulticastDomainAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AcceptTransitGatewayMulticastDomainAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AcceptTransitGatewayPeeringAttachmentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AcceptTransitGatewayPeeringAttachmentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AcceptTransitGatewayVpcAttachmentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AcceptTransitGatewayVpcAttachmentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AcceptVpcEndpointConnectionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AcceptVpcEndpointConnectionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AcceptVpcPeeringConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AcceptVpcPeeringConnectionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AdvertiseByoipCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AdvertiseByoipCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AllocateAddressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AllocateAddressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AllocateHostsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AllocateHostsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AllocateIpamPoolCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AllocateIpamPoolCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ApplySecurityGroupsToClientVpnTargetNetworkCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ApplySecurityGroupsToClientVpnTargetNetworkResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssignIpv6AddressesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssignIpv6AddressesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssignPrivateIpAddressesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssignPrivateIpAddressesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssignPrivateNatGatewayAddressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssignPrivateNatGatewayAddressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateAddressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateAddressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateCapacityReservationBillingOwnerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateCapacityReservationBillingOwnerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateClientVpnTargetNetworkCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateClientVpnTargetNetworkResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateDhcpOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_AssociateEnclaveCertificateIamRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateEnclaveCertificateIamRoleResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateIamInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateIamInstanceProfileResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateInstanceEventWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateInstanceEventWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateIpamByoasnCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateIpamByoasnResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateIpamResourceDiscoveryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateIpamResourceDiscoveryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateNatGatewayAddressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateNatGatewayAddressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateRouteServerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateRouteServerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateRouteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateRouteTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateSecurityGroupVpcCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateSecurityGroupVpcResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateSubnetCidrBlockCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateSubnetCidrBlockResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateTransitGatewayMulticastDomainCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateTransitGatewayMulticastDomainResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateTransitGatewayPolicyTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateTransitGatewayPolicyTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateTransitGatewayRouteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateTransitGatewayRouteTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateTrunkInterfaceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateTrunkInterfaceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateVpcCidrBlockCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateVpcCidrBlockResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AttachClassicLinkVpcCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachClassicLinkVpcResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AttachInternetGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_AttachNetworkInterfaceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachNetworkInterfaceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AttachVerifiedAccessTrustProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachVerifiedAccessTrustProviderResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AttachVolumeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_VolumeAttachment(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AttachVpnGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachVpnGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AuthorizeClientVpnIngressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AuthorizeClientVpnIngressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AuthorizeSecurityGroupEgressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AuthorizeSecurityGroupEgressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AuthorizeSecurityGroupIngressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AuthorizeSecurityGroupIngressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_BundleInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BundleInstanceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelBundleTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelBundleTaskResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelCapacityReservationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelCapacityReservationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelCapacityReservationFleetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelCapacityReservationFleetsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelConversionTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_CancelDeclarativePoliciesReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelDeclarativePoliciesReportResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelExportTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_CancelImageLaunchPermissionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelImageLaunchPermissionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelImportTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelImportTaskResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelReservedInstancesListingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelReservedInstancesListingResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelSpotFleetRequestsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelSpotFleetRequestsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelSpotInstanceRequestsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelSpotInstanceRequestsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ConfirmProductInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ConfirmProductInstanceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopyFpgaImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopyFpgaImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopyImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopyImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopySnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopySnapshotResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCapacityReservationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCapacityReservationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCapacityReservationBySplittingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCapacityReservationBySplittingResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCapacityReservationFleetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCapacityReservationFleetResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCarrierGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCarrierGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateClientVpnEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateClientVpnEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateClientVpnRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateClientVpnRouteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCoipCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCoipCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCoipPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCoipPoolResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCustomerGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCustomerGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDefaultSubnetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDefaultSubnetResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDefaultVpcCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDefaultVpcResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDhcpOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDhcpOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateEgressOnlyInternetGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateEgressOnlyInternetGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateFleetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateFleetResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateFlowLogsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateFlowLogsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateFpgaImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateFpgaImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateInstanceConnectEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateInstanceConnectEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateInstanceEventWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateInstanceEventWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateInstanceExportTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateInstanceExportTaskResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateInternetGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateInternetGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateIpamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateIpamResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateIpamExternalResourceVerificationTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateIpamExternalResourceVerificationTokenResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateIpamPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateIpamPoolResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateIpamResourceDiscoveryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateIpamResourceDiscoveryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateIpamScopeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateIpamScopeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateKeyPairCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_KeyPair(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLaunchTemplateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLaunchTemplateResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLaunchTemplateVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLaunchTemplateVersionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocalGatewayRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLocalGatewayRouteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocalGatewayRouteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLocalGatewayRouteTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLocalGatewayRouteTableVpcAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLocalGatewayRouteTableVpcAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateManagedPrefixListCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateManagedPrefixListResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateNatGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateNatGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateNetworkAclCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateNetworkAclResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateNetworkAclEntryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_CreateNetworkInsightsAccessScopeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateNetworkInsightsAccessScopeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateNetworkInsightsPathCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateNetworkInsightsPathResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateNetworkInterfaceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateNetworkInterfaceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateNetworkInterfacePermissionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateNetworkInterfacePermissionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreatePlacementGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePlacementGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreatePublicIpv4PoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePublicIpv4PoolResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateReplaceRootVolumeTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateReplaceRootVolumeTaskResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateReservedInstancesListingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateReservedInstancesListingResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateRestoreImageTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRestoreImageTaskResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRouteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateRouteServerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRouteServerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateRouteServerEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRouteServerEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateRouteServerPeerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRouteServerPeerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateRouteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRouteTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSecurityGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSecurityGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_Snapshot(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSnapshotsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSpotDatafeedSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSpotDatafeedSubscriptionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateStoreImageTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateStoreImageTaskResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSubnetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSubnetResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSubnetCidrReservationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSubnetCidrReservationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_CreateTrafficMirrorFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTrafficMirrorFilterResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTrafficMirrorFilterRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTrafficMirrorFilterRuleResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTrafficMirrorSessionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTrafficMirrorSessionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTrafficMirrorTargetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTrafficMirrorTargetResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayConnectCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayConnectResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayConnectPeerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayConnectPeerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayMulticastDomainCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayMulticastDomainResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayPeeringAttachmentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayPeeringAttachmentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayPolicyTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayPolicyTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayPrefixListReferenceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayPrefixListReferenceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayRouteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayRouteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayRouteTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayRouteTableAnnouncementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayRouteTableAnnouncementResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTransitGatewayVpcAttachmentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTransitGatewayVpcAttachmentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVerifiedAccessEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVerifiedAccessEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVerifiedAccessGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVerifiedAccessGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVerifiedAccessInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVerifiedAccessInstanceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVerifiedAccessTrustProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVerifiedAccessTrustProviderResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVolumeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_Volume(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVpcCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVpcResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVpcBlockPublicAccessExclusionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVpcBlockPublicAccessExclusionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVpcEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVpcEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVpcEndpointConnectionNotificationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVpcEndpointConnectionNotificationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVpcEndpointServiceConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVpcEndpointServiceConfigurationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVpcPeeringConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVpcPeeringConnectionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVpnConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVpnConnectionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVpnConnectionRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_CreateVpnGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVpnGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteCarrierGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteCarrierGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteClientVpnEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteClientVpnEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteClientVpnRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteClientVpnRouteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteCoipCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteCoipCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteCoipPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteCoipPoolResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteCustomerGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteDhcpOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteEgressOnlyInternetGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteEgressOnlyInternetGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteFleetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteFleetsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteFlowLogsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteFlowLogsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteFpgaImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteFpgaImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteInstanceConnectEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteInstanceConnectEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteInstanceEventWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteInstanceEventWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteInternetGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteIpamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteIpamResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteIpamExternalResourceVerificationTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteIpamExternalResourceVerificationTokenResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteIpamPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteIpamPoolResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteIpamResourceDiscoveryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteIpamResourceDiscoveryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteIpamScopeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteIpamScopeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteKeyPairCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteKeyPairResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLaunchTemplateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLaunchTemplateResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLaunchTemplateVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLaunchTemplateVersionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLocalGatewayRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLocalGatewayRouteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLocalGatewayRouteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLocalGatewayRouteTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLocalGatewayRouteTableVpcAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLocalGatewayRouteTableVpcAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteManagedPrefixListCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteManagedPrefixListResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteNatGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteNatGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteNetworkAclCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteNetworkAclEntryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteNetworkInsightsAccessScopeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteNetworkInsightsAccessScopeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteNetworkInsightsAccessScopeAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteNetworkInsightsAccessScopeAnalysisResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteNetworkInsightsAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteNetworkInsightsAnalysisResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteNetworkInsightsPathCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteNetworkInsightsPathResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteNetworkInterfaceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteNetworkInterfacePermissionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteNetworkInterfacePermissionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeletePlacementGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeletePublicIpv4PoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeletePublicIpv4PoolResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteQueuedReservedInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteQueuedReservedInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteRouteServerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteRouteServerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteRouteServerEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteRouteServerEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteRouteServerPeerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteRouteServerPeerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteRouteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteSecurityGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteSecurityGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteSpotDatafeedSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteSubnetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteSubnetCidrReservationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteSubnetCidrReservationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteTrafficMirrorFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTrafficMirrorFilterResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTrafficMirrorFilterRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTrafficMirrorFilterRuleResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTrafficMirrorSessionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTrafficMirrorSessionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTrafficMirrorTargetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTrafficMirrorTargetResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayConnectCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayConnectResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayConnectPeerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayConnectPeerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayMulticastDomainCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayMulticastDomainResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayPeeringAttachmentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayPeeringAttachmentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayPolicyTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayPolicyTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayPrefixListReferenceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayPrefixListReferenceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayRouteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayRouteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayRouteTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayRouteTableAnnouncementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayRouteTableAnnouncementResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteTransitGatewayVpcAttachmentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTransitGatewayVpcAttachmentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVerifiedAccessEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteVerifiedAccessEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVerifiedAccessGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteVerifiedAccessGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVerifiedAccessInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteVerifiedAccessInstanceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVerifiedAccessTrustProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteVerifiedAccessTrustProviderResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVolumeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteVpcCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteVpcBlockPublicAccessExclusionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteVpcBlockPublicAccessExclusionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVpcEndpointConnectionNotificationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteVpcEndpointConnectionNotificationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVpcEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteVpcEndpointsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVpcEndpointServiceConfigurationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteVpcEndpointServiceConfigurationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVpcPeeringConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteVpcPeeringConnectionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVpnConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteVpnConnectionRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteVpnGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeprovisionByoipCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeprovisionByoipCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeprovisionIpamByoasnCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeprovisionIpamByoasnResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeprovisionIpamPoolCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeprovisionIpamPoolCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeprovisionPublicIpv4PoolCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeprovisionPublicIpv4PoolCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeregisterImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeregisterInstanceEventNotificationAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterInstanceEventNotificationAttributesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeregisterTransitGatewayMulticastGroupMembersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterTransitGatewayMulticastGroupMembersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeregisterTransitGatewayMulticastGroupSourcesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterTransitGatewayMulticastGroupSourcesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAccountAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAccountAttributesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAddressesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAddressesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAddressesAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAddressesAttributeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAddressTransfersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAddressTransfersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAggregateIdFormatCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAggregateIdFormatResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAvailabilityZonesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAvailabilityZonesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAwsNetworkPerformanceMetricSubscriptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAwsNetworkPerformanceMetricSubscriptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeBundleTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeBundleTasksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeByoipCidrsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeByoipCidrsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCapacityBlockExtensionHistoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCapacityBlockExtensionHistoryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCapacityBlockExtensionOfferingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCapacityBlockExtensionOfferingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCapacityBlockOfferingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCapacityBlockOfferingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCapacityReservationBillingRequestsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCapacityReservationBillingRequestsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCapacityReservationFleetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCapacityReservationFleetsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCapacityReservationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCapacityReservationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCarrierGatewaysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCarrierGatewaysResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClassicLinkInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeClassicLinkInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClientVpnAuthorizationRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeClientVpnAuthorizationRulesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClientVpnConnectionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeClientVpnConnectionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClientVpnEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeClientVpnEndpointsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClientVpnRoutesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeClientVpnRoutesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClientVpnTargetNetworksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeClientVpnTargetNetworksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCoipPoolsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCoipPoolsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeConversionTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeConversionTasksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCustomerGatewaysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeCustomerGatewaysResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDeclarativePoliciesReportsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDeclarativePoliciesReportsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDhcpOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDhcpOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEgressOnlyInternetGatewaysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeEgressOnlyInternetGatewaysResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeElasticGpusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeElasticGpusResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeExportImageTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeExportImageTasksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeExportTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeExportTasksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFastLaunchImagesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeFastLaunchImagesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFastSnapshotRestoresCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeFastSnapshotRestoresResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFleetHistoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeFleetHistoryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFleetInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeFleetInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFleetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeFleetsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFlowLogsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeFlowLogsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFpgaImageAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeFpgaImageAttributeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFpgaImagesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeFpgaImagesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeHostReservationOfferingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeHostReservationOfferingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeHostReservationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeHostReservationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeHostsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeHostsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIamInstanceProfileAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIamInstanceProfileAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIdentityIdFormatCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIdentityIdFormatResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIdFormatCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIdFormatResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeImageAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ImageAttribute(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeImagesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeImagesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeImportImageTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeImportImageTasksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeImportSnapshotTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeImportSnapshotTasksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_InstanceAttribute(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceConnectEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceConnectEndpointsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceCreditSpecificationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceCreditSpecificationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceEventNotificationAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceEventNotificationAttributesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceEventWindowsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceEventWindowsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceImageMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceImageMetadataResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceStatusResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceTopologyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceTopologyResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceTypeOfferingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceTypeOfferingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceTypesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInternetGatewaysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInternetGatewaysResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIpamByoasnCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIpamByoasnResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIpamExternalResourceVerificationTokensCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIpamExternalResourceVerificationTokensResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIpamPoolsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIpamPoolsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIpamResourceDiscoveriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIpamResourceDiscoveriesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIpamResourceDiscoveryAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIpamResourceDiscoveryAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIpamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIpamsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIpamScopesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIpamScopesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIpv6PoolsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIpv6PoolsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeKeyPairsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeKeyPairsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLaunchTemplatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLaunchTemplatesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLaunchTemplateVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLaunchTemplateVersionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocalGatewayRouteTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocalGatewayRouteTablesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocalGatewayRouteTableVpcAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocalGatewayRouteTableVpcAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocalGatewaysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocalGatewaysResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocalGatewayVirtualInterfaceGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocalGatewayVirtualInterfaceGroupsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLocalGatewayVirtualInterfacesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLocalGatewayVirtualInterfacesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLockedSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLockedSnapshotsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeMacHostsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMacHostsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeManagedPrefixListsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeManagedPrefixListsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeMovingAddressesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMovingAddressesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNatGatewaysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNatGatewaysResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNetworkAclsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNetworkAclsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNetworkInsightsAccessScopeAnalysesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNetworkInsightsAccessScopeAnalysesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNetworkInsightsAccessScopesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNetworkInsightsAccessScopesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNetworkInsightsAnalysesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNetworkInsightsAnalysesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNetworkInsightsPathsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNetworkInsightsPathsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNetworkInterfaceAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNetworkInterfaceAttributeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNetworkInterfacePermissionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNetworkInterfacePermissionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNetworkInterfacesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNetworkInterfacesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribePlacementGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribePlacementGroupsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribePrefixListsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribePrefixListsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribePrincipalIdFormatCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribePrincipalIdFormatResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribePublicIpv4PoolsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribePublicIpv4PoolsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeRegionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeRegionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReplaceRootVolumeTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeReplaceRootVolumeTasksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeReservedInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedInstancesListingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeReservedInstancesListingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedInstancesModificationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeReservedInstancesModificationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedInstancesOfferingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeReservedInstancesOfferingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeRouteServerEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeRouteServerEndpointsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeRouteServerPeersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeRouteServerPeersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeRouteServersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeRouteServersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeRouteTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeRouteTablesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeScheduledInstanceAvailabilityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeScheduledInstanceAvailabilityResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeScheduledInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeScheduledInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSecurityGroupReferencesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSecurityGroupReferencesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSecurityGroupRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSecurityGroupRulesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSecurityGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSecurityGroupsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSecurityGroupVpcAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSecurityGroupVpcAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSnapshotAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSnapshotAttributeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSnapshotsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSnapshotTierStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSnapshotTierStatusResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSpotDatafeedSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSpotDatafeedSubscriptionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSpotFleetInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSpotFleetInstancesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSpotFleetRequestHistoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSpotFleetRequestHistoryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSpotFleetRequestsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSpotFleetRequestsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSpotInstanceRequestsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSpotInstanceRequestsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSpotPriceHistoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSpotPriceHistoryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeStaleSecurityGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeStaleSecurityGroupsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeStoreImageTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeStoreImageTasksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSubnetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSubnetsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTagsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTrafficMirrorFilterRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTrafficMirrorFilterRulesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTrafficMirrorFiltersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTrafficMirrorFiltersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTrafficMirrorSessionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTrafficMirrorSessionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTrafficMirrorTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTrafficMirrorTargetsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTransitGatewayAttachmentsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTransitGatewayAttachmentsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTransitGatewayConnectPeersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTransitGatewayConnectPeersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTransitGatewayConnectsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTransitGatewayConnectsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTransitGatewayMulticastDomainsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTransitGatewayMulticastDomainsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTransitGatewayPeeringAttachmentsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTransitGatewayPeeringAttachmentsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTransitGatewayPolicyTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTransitGatewayPolicyTablesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTransitGatewayRouteTableAnnouncementsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTransitGatewayRouteTableAnnouncementsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTransitGatewayRouteTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTransitGatewayRouteTablesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTransitGatewaysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTransitGatewaysResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTransitGatewayVpcAttachmentsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTransitGatewayVpcAttachmentsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTrunkInterfaceAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTrunkInterfaceAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVerifiedAccessEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVerifiedAccessEndpointsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVerifiedAccessGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVerifiedAccessGroupsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVerifiedAccessInstanceLoggingConfigurationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVerifiedAccessInstanceLoggingConfigurationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVerifiedAccessInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVerifiedAccessInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVerifiedAccessTrustProvidersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVerifiedAccessTrustProvidersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVolumeAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVolumeAttributeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVolumesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVolumesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVolumesModificationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVolumesModificationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVolumeStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVolumeStatusResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcAttributeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcBlockPublicAccessExclusionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcBlockPublicAccessExclusionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcBlockPublicAccessOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcBlockPublicAccessOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcClassicLinkCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcClassicLinkResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcClassicLinkDnsSupportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcClassicLinkDnsSupportResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcEndpointAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcEndpointAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcEndpointConnectionNotificationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcEndpointConnectionNotificationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcEndpointConnectionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcEndpointConnectionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcEndpointsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcEndpointServiceConfigurationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcEndpointServiceConfigurationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcEndpointServicePermissionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcEndpointServicePermissionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcEndpointServicesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcEndpointServicesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcPeeringConnectionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcPeeringConnectionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpcsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpcsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpnConnectionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpnConnectionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVpnGatewaysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVpnGatewaysResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DetachClassicLinkVpcCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachClassicLinkVpcResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DetachInternetGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DetachNetworkInterfaceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DetachVerifiedAccessTrustProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachVerifiedAccessTrustProviderResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DetachVolumeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_VolumeAttachment(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DetachVpnGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DisableAddressTransferCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableAddressTransferResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableAllowedImagesSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableAllowedImagesSettingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableAwsNetworkPerformanceMetricSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableAwsNetworkPerformanceMetricSubscriptionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableEbsEncryptionByDefaultCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableEbsEncryptionByDefaultResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableFastLaunchCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableFastLaunchResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableFastSnapshotRestoresCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableFastSnapshotRestoresResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableImageBlockPublicAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableImageBlockPublicAccessResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableImageDeprecationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableImageDeprecationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableImageDeregistrationProtectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableImageDeregistrationProtectionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableIpamOrganizationAdminAccountCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableIpamOrganizationAdminAccountResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableRouteServerPropagationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableRouteServerPropagationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableSerialConsoleAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableSerialConsoleAccessResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableSnapshotBlockPublicAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableSnapshotBlockPublicAccessResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableTransitGatewayRouteTablePropagationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableTransitGatewayRouteTablePropagationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableVgwRoutePropagationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DisableVpcClassicLinkCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableVpcClassicLinkResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableVpcClassicLinkDnsSupportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableVpcClassicLinkDnsSupportResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateAddressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DisassociateCapacityReservationBillingOwnerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateCapacityReservationBillingOwnerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateClientVpnTargetNetworkCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateClientVpnTargetNetworkResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateEnclaveCertificateIamRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateEnclaveCertificateIamRoleResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateIamInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateIamInstanceProfileResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateInstanceEventWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateInstanceEventWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateIpamByoasnCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateIpamByoasnResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateIpamResourceDiscoveryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateIpamResourceDiscoveryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateNatGatewayAddressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateNatGatewayAddressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateRouteServerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateRouteServerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateRouteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DisassociateSecurityGroupVpcCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateSecurityGroupVpcResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateSubnetCidrBlockCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateSubnetCidrBlockResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateTransitGatewayMulticastDomainCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateTransitGatewayMulticastDomainResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateTransitGatewayPolicyTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateTransitGatewayPolicyTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateTransitGatewayRouteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateTransitGatewayRouteTableResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateTrunkInterfaceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateTrunkInterfaceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateVpcCidrBlockCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateVpcCidrBlockResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableAddressTransferCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableAddressTransferResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableAllowedImagesSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableAllowedImagesSettingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableAwsNetworkPerformanceMetricSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableAwsNetworkPerformanceMetricSubscriptionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableEbsEncryptionByDefaultCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableEbsEncryptionByDefaultResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableFastLaunchCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableFastLaunchResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableFastSnapshotRestoresCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableFastSnapshotRestoresResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableImageBlockPublicAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableImageBlockPublicAccessResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableImageDeprecationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableImageDeprecationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableImageDeregistrationProtectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableImageDeregistrationProtectionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableIpamOrganizationAdminAccountCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableIpamOrganizationAdminAccountResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableReachabilityAnalyzerOrganizationSharingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableReachabilityAnalyzerOrganizationSharingResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableRouteServerPropagationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableRouteServerPropagationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableSerialConsoleAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableSerialConsoleAccessResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableSnapshotBlockPublicAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableSnapshotBlockPublicAccessResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableTransitGatewayRouteTablePropagationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableTransitGatewayRouteTablePropagationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableVgwRoutePropagationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_EnableVolumeIOCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_EnableVpcClassicLinkCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableVpcClassicLinkResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableVpcClassicLinkDnsSupportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableVpcClassicLinkDnsSupportResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ExportClientVpnClientCertificateRevocationListCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExportClientVpnClientCertificateRevocationListResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ExportClientVpnClientConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExportClientVpnClientConfigurationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ExportImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExportImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ExportTransitGatewayRoutesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExportTransitGatewayRoutesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ExportVerifiedAccessInstanceClientConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExportVerifiedAccessInstanceClientConfigurationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetAllowedImagesSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAllowedImagesSettingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetAssociatedEnclaveCertificateIamRolesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAssociatedEnclaveCertificateIamRolesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetAssociatedIpv6PoolCidrsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAssociatedIpv6PoolCidrsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetAwsNetworkPerformanceDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAwsNetworkPerformanceDataResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetCapacityReservationUsageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCapacityReservationUsageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetCoipPoolUsageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCoipPoolUsageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetConsoleOutputCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetConsoleOutputResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetConsoleScreenshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetConsoleScreenshotResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetDeclarativePoliciesReportSummaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDeclarativePoliciesReportSummaryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetDefaultCreditSpecificationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDefaultCreditSpecificationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetEbsDefaultKmsKeyIdCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetEbsDefaultKmsKeyIdResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetEbsEncryptionByDefaultCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetEbsEncryptionByDefaultResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetFlowLogsIntegrationTemplateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetFlowLogsIntegrationTemplateResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetGroupsForCapacityReservationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetGroupsForCapacityReservationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetHostReservationPurchasePreviewCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetHostReservationPurchasePreviewResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetImageBlockPublicAccessStateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetImageBlockPublicAccessStateResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetInstanceMetadataDefaultsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInstanceMetadataDefaultsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetInstanceTpmEkPubCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInstanceTpmEkPubResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetInstanceTypesFromInstanceRequirementsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInstanceTypesFromInstanceRequirementsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetInstanceUefiDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInstanceUefiDataResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetIpamAddressHistoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetIpamAddressHistoryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetIpamDiscoveredAccountsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetIpamDiscoveredAccountsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetIpamDiscoveredPublicAddressesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetIpamDiscoveredPublicAddressesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetIpamDiscoveredResourceCidrsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetIpamDiscoveredResourceCidrsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetIpamPoolAllocationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetIpamPoolAllocationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetIpamPoolCidrsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetIpamPoolCidrsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetIpamResourceCidrsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetIpamResourceCidrsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetLaunchTemplateDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetLaunchTemplateDataResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetManagedPrefixListAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetManagedPrefixListAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetManagedPrefixListEntriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetManagedPrefixListEntriesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetNetworkInsightsAccessScopeAnalysisFindingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetNetworkInsightsAccessScopeAnalysisFindingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetNetworkInsightsAccessScopeContentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetNetworkInsightsAccessScopeContentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetPasswordDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPasswordDataResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetReservedInstancesExchangeQuoteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetReservedInstancesExchangeQuoteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetRouteServerAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetRouteServerAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetRouteServerPropagationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetRouteServerPropagationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetRouteServerRoutingDatabaseCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetRouteServerRoutingDatabaseResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetSecurityGroupsForVpcCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSecurityGroupsForVpcResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetSerialConsoleAccessStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSerialConsoleAccessStatusResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetSnapshotBlockPublicAccessStateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSnapshotBlockPublicAccessStateResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetSpotPlacementScoresCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSpotPlacementScoresResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetSubnetCidrReservationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSubnetCidrReservationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetTransitGatewayAttachmentPropagationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetTransitGatewayAttachmentPropagationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetTransitGatewayMulticastDomainAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetTransitGatewayMulticastDomainAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetTransitGatewayPolicyTableAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetTransitGatewayPolicyTableAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetTransitGatewayPolicyTableEntriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetTransitGatewayPolicyTableEntriesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetTransitGatewayPrefixListReferencesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetTransitGatewayPrefixListReferencesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetTransitGatewayRouteTableAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetTransitGatewayRouteTableAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetTransitGatewayRouteTablePropagationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetTransitGatewayRouteTablePropagationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetVerifiedAccessEndpointPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetVerifiedAccessEndpointPolicyResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetVerifiedAccessEndpointTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetVerifiedAccessEndpointTargetsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetVerifiedAccessGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetVerifiedAccessGroupPolicyResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetVpnConnectionDeviceSampleConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetVpnConnectionDeviceSampleConfigurationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetVpnConnectionDeviceTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetVpnConnectionDeviceTypesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetVpnTunnelReplacementStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetVpnTunnelReplacementStatusResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ImportClientVpnClientCertificateRevocationListCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ImportClientVpnClientCertificateRevocationListResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ImportImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ImportImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ImportInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ImportInstanceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ImportKeyPairCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ImportKeyPairResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ImportSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ImportSnapshotResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ImportVolumeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ImportVolumeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListImagesInRecycleBinCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListImagesInRecycleBinResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListSnapshotsInRecycleBinCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSnapshotsInRecycleBinResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_LockSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_LockSnapshotResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyAddressAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyAddressAttributeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyAvailabilityZoneGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyAvailabilityZoneGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyCapacityReservationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyCapacityReservationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyCapacityReservationFleetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyCapacityReservationFleetResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyClientVpnEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyClientVpnEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyDefaultCreditSpecificationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyDefaultCreditSpecificationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyEbsDefaultKmsKeyIdCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyEbsDefaultKmsKeyIdResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyFleetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyFleetResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyFpgaImageAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyFpgaImageAttributeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyHostsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyHostsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyIdentityIdFormatCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ModifyIdFormatCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ModifyImageAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ModifyInstanceAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ModifyInstanceCapacityReservationAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyInstanceCapacityReservationAttributesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyInstanceCpuOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyInstanceCpuOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyInstanceCreditSpecificationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyInstanceCreditSpecificationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyInstanceEventStartTimeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyInstanceEventStartTimeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyInstanceEventWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyInstanceEventWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyInstanceMaintenanceOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyInstanceMaintenanceOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyInstanceMetadataDefaultsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyInstanceMetadataDefaultsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyInstanceMetadataOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyInstanceMetadataOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyInstanceNetworkPerformanceOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyInstanceNetworkPerformanceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyInstancePlacementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyInstancePlacementResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyIpamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyIpamResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyIpamPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyIpamPoolResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyIpamResourceCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyIpamResourceCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyIpamResourceDiscoveryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyIpamResourceDiscoveryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyIpamScopeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyIpamScopeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyLaunchTemplateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyLaunchTemplateResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyLocalGatewayRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyLocalGatewayRouteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyManagedPrefixListCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyManagedPrefixListResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyNetworkInterfaceAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ModifyPrivateDnsNameOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyPrivateDnsNameOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyReservedInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyReservedInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyRouteServerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyRouteServerResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifySecurityGroupRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifySecurityGroupRulesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifySnapshotAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ModifySnapshotTierCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifySnapshotTierResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifySpotFleetRequestCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifySpotFleetRequestResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifySubnetAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ModifyTrafficMirrorFilterNetworkServicesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTrafficMirrorFilterNetworkServicesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyTrafficMirrorFilterRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTrafficMirrorFilterRuleResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyTrafficMirrorSessionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTrafficMirrorSessionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyTransitGatewayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTransitGatewayResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyTransitGatewayPrefixListReferenceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTransitGatewayPrefixListReferenceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyTransitGatewayVpcAttachmentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTransitGatewayVpcAttachmentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVerifiedAccessEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVerifiedAccessEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVerifiedAccessEndpointPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVerifiedAccessEndpointPolicyResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVerifiedAccessGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVerifiedAccessGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVerifiedAccessGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVerifiedAccessGroupPolicyResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVerifiedAccessInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVerifiedAccessInstanceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVerifiedAccessInstanceLoggingConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVerifiedAccessInstanceLoggingConfigurationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVerifiedAccessTrustProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVerifiedAccessTrustProviderResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVolumeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVolumeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVolumeAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ModifyVpcAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ModifyVpcBlockPublicAccessExclusionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpcBlockPublicAccessExclusionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpcBlockPublicAccessOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpcBlockPublicAccessOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpcEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpcEndpointResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpcEndpointConnectionNotificationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpcEndpointConnectionNotificationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpcEndpointServiceConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpcEndpointServiceConfigurationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpcEndpointServicePayerResponsibilityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpcEndpointServicePayerResponsibilityResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpcEndpointServicePermissionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpcEndpointServicePermissionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpcPeeringConnectionOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpcPeeringConnectionOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpcTenancyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpcTenancyResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpnConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpnConnectionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpnConnectionOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpnConnectionOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpnTunnelCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpnTunnelCertificateResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyVpnTunnelOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyVpnTunnelOptionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_MonitorInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_MonitorInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_MoveAddressToVpcCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_MoveAddressToVpcResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_MoveByoipCidrToIpamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_MoveByoipCidrToIpamResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_MoveCapacityReservationInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_MoveCapacityReservationInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ProvisionByoipCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ProvisionByoipCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ProvisionIpamByoasnCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ProvisionIpamByoasnResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ProvisionIpamPoolCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ProvisionIpamPoolCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ProvisionPublicIpv4PoolCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ProvisionPublicIpv4PoolCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PurchaseCapacityBlockCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PurchaseCapacityBlockResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PurchaseCapacityBlockExtensionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PurchaseCapacityBlockExtensionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PurchaseHostReservationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PurchaseHostReservationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PurchaseReservedInstancesOfferingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PurchaseReservedInstancesOfferingResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PurchaseScheduledInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PurchaseScheduledInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RebootInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_RegisterImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterImageResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RegisterInstanceEventNotificationAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterInstanceEventNotificationAttributesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RegisterTransitGatewayMulticastGroupMembersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterTransitGatewayMulticastGroupMembersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RegisterTransitGatewayMulticastGroupSourcesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterTransitGatewayMulticastGroupSourcesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RejectCapacityReservationBillingOwnershipCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RejectCapacityReservationBillingOwnershipResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RejectTransitGatewayMulticastDomainAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RejectTransitGatewayMulticastDomainAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RejectTransitGatewayPeeringAttachmentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RejectTransitGatewayPeeringAttachmentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RejectTransitGatewayVpcAttachmentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RejectTransitGatewayVpcAttachmentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RejectVpcEndpointConnectionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RejectVpcEndpointConnectionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RejectVpcPeeringConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RejectVpcPeeringConnectionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ReleaseAddressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ReleaseHostsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReleaseHostsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ReleaseIpamPoolAllocationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReleaseIpamPoolAllocationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ReplaceIamInstanceProfileAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReplaceIamInstanceProfileAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ReplaceImageCriteriaInAllowedImagesSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReplaceImageCriteriaInAllowedImagesSettingsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ReplaceNetworkAclAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReplaceNetworkAclAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ReplaceNetworkAclEntryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ReplaceRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ReplaceRouteTableAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReplaceRouteTableAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ReplaceTransitGatewayRouteCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReplaceTransitGatewayRouteResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ReplaceVpnTunnelCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReplaceVpnTunnelResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ReportInstanceStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_RequestSpotFleetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RequestSpotFleetResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RequestSpotInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RequestSpotInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ResetAddressAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResetAddressAttributeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ResetEbsDefaultKmsKeyIdCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResetEbsDefaultKmsKeyIdResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ResetFpgaImageAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResetFpgaImageAttributeResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ResetImageAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ResetInstanceAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ResetNetworkInterfaceAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ResetSnapshotAttributeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_RestoreAddressToClassicCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreAddressToClassicResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RestoreImageFromRecycleBinCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreImageFromRecycleBinResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RestoreManagedPrefixListVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreManagedPrefixListVersionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RestoreSnapshotFromRecycleBinCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreSnapshotFromRecycleBinResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RestoreSnapshotTierCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreSnapshotTierResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RevokeClientVpnIngressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RevokeClientVpnIngressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RevokeSecurityGroupEgressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RevokeSecurityGroupEgressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RevokeSecurityGroupIngressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RevokeSecurityGroupIngressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RunInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_Reservation(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RunScheduledInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RunScheduledInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SearchLocalGatewayRoutesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SearchLocalGatewayRoutesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SearchTransitGatewayMulticastGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SearchTransitGatewayMulticastGroupsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SearchTransitGatewayRoutesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SearchTransitGatewayRoutesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SendDiagnosticInterruptCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_StartDeclarativePoliciesReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartDeclarativePoliciesReportResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StartInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StartNetworkInsightsAccessScopeAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartNetworkInsightsAccessScopeAnalysisResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StartNetworkInsightsAnalysisCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartNetworkInsightsAnalysisResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StartVpcEndpointServicePrivateDnsVerificationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartVpcEndpointServicePrivateDnsVerificationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StopInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StopInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_TerminateClientVpnConnectionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TerminateClientVpnConnectionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_TerminateInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TerminateInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UnassignIpv6AddressesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UnassignIpv6AddressesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UnassignPrivateIpAddressesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_UnassignPrivateNatGatewayAddressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UnassignPrivateNatGatewayAddressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UnlockSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UnlockSnapshotResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UnmonitorInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UnmonitorInstancesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateSecurityGroupRuleDescriptionsEgressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateSecurityGroupRuleDescriptionsEgressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateSecurityGroupRuleDescriptionsIngressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateSecurityGroupRuleDescriptionsIngressResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_WithdrawByoipCidrCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_WithdrawByoipCidrResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Errors.Error,
        errorCode,
    });
};
const se_AcceleratorCount = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_AcceleratorCountRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_AcceleratorManufacturerSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AcceleratorNameSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AcceleratorTotalMemoryMiB = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_AcceleratorTotalMemoryMiBRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_AcceleratorTypeSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AcceptAddressTransferRequest = (input, context) => {
    const entries = {};
    if (input[_Ad] != null) {
        entries[_Ad] = input[_Ad];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AcceptCapacityReservationBillingOwnershipRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    return entries;
};
const se_AcceptReservedInstancesExchangeQuoteRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RII] != null) {
        const memberEntries = se_ReservedInstanceIdSet(input[_RII], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReservedInstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TC] != null) {
        const memberEntries = se_TargetConfigurationRequestSet(input[_TC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetConfiguration.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AcceptTransitGatewayMulticastDomainAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_ValueStringList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AcceptTransitGatewayPeeringAttachmentRequest = (input, context) => {
    const entries = {};
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AcceptTransitGatewayVpcAttachmentRequest = (input, context) => {
    const entries = {};
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AcceptVpcEndpointConnectionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIe] != null) {
        entries[_SIe] = input[_SIe];
    }
    if (input[_VEI] != null) {
        const memberEntries = se_VpcEndpointIdList(input[_VEI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AcceptVpcPeeringConnectionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VPCI] != null) {
        entries[_VPCI] = input[_VPCI];
    }
    return entries;
};
const se_AccessScopePathListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_AccessScopePathRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AccessScopePathRequest = (input, context) => {
    const entries = {};
    if (input[_S] != null) {
        const memberEntries = se_PathStatementRequest(input[_S], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Source.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_D] != null) {
        const memberEntries = se_PathStatementRequest(input[_D], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Destination.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TR] != null) {
        const memberEntries = se_ThroughResourcesStatementRequestList(input[_TR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ThroughResource.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AccountAttributeNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`AttributeName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AddIpamOperatingRegion = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    return entries;
};
const se_AddIpamOperatingRegionSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_AddIpamOperatingRegion(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AddIpamOrganizationalUnitExclusion = (input, context) => {
    const entries = {};
    if (input[_OEP] != null) {
        entries[_OEP] = input[_OEP];
    }
    return entries;
};
const se_AddIpamOrganizationalUnitExclusionSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_AddIpamOrganizationalUnitExclusion(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AddPrefixListEntries = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_AddPrefixListEntry(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AddPrefixListEntry = (input, context) => {
    const entries = {};
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    return entries;
};
const se_AdvertiseByoipCidrRequest = (input, context) => {
    const entries = {};
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_As] != null) {
        entries[_As] = input[_As];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NBG] != null) {
        entries[_NBG] = input[_NBG];
    }
    return entries;
};
const se_AllocateAddressRequest = (input, context) => {
    const entries = {};
    if (input[_Do] != null) {
        entries[_Do] = input[_Do];
    }
    if (input[_Ad] != null) {
        entries[_Ad] = input[_Ad];
    }
    if (input[_PIP] != null) {
        entries[_PIP] = input[_PIP];
    }
    if (input[_NBG] != null) {
        entries[_NBG] = input[_NBG];
    }
    if (input[_COIP] != null) {
        entries[_COIP] = input[_COIP];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AllocateHostsRequest = (input, context) => {
    const entries = {};
    if (input[_IF] != null) {
        entries[_IF] = input[_IF];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_HR] != null) {
        entries[_HR] = input[_HR];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_HM] != null) {
        entries[_HM] = input[_HM];
    }
    if (input[_AI] != null) {
        const memberEntries = se_AssetIdList(input[_AI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AssetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AP] != null) {
        entries[_AP] = input[_AP];
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_Q] != null) {
        entries[_Q] = input[_Q];
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    return entries;
};
const se_AllocateIpamPoolCidrRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_NL] != null) {
        entries[_NL] = input[_NL];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_PNC] != null) {
        entries[_PNC] = input[_PNC];
    }
    if (input[_AC] != null) {
        const memberEntries = se_IpamPoolAllocationAllowedCidrs(input[_AC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AllowedCidr.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DC] != null) {
        const memberEntries = se_IpamPoolAllocationDisallowedCidrs(input[_DC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DisallowedCidr.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AllocationIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`AllocationId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AllocationIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AllowedInstanceTypeSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ApplySecurityGroupsToClientVpnTargetNetworkRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_SGI] != null) {
        const memberEntries = se_ClientVpnSecurityGroupIdSet(input[_SGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ArchitectureTypeSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ArnList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AsnAuthorizationContext = (input, context) => {
    const entries = {};
    if (input[_Me] != null) {
        entries[_Me] = input[_Me];
    }
    if (input[_Si] != null) {
        entries[_Si] = input[_Si];
    }
    return entries;
};
const se_AssetIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AssignIpv6AddressesRequest = (input, context) => {
    const entries = {};
    if (input[_IPC] != null) {
        entries[_IPC] = input[_IPC];
    }
    if (input[_IP] != null) {
        const memberEntries = se_IpPrefixList(input[_IP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Prefix.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_IA] != null) {
        const memberEntries = se_Ipv6AddressList(input[_IA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IAC] != null) {
        entries[_IAC] = input[_IAC];
    }
    return entries;
};
const se_AssignPrivateIpAddressesRequest = (input, context) => {
    const entries = {};
    if (input[_IPp] != null) {
        const memberEntries = se_IpPrefixList(input[_IPp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv4Prefix.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPCp] != null) {
        entries[_IPCp] = input[_IPCp];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_PIA] != null) {
        const memberEntries = se_PrivateIpAddressStringList(input[_PIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateIpAddress.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SPIAC] != null) {
        entries[_SPIAC] = input[_SPIAC];
    }
    if (input[_AR] != null) {
        entries[_AR] = input[_AR];
    }
    return entries;
};
const se_AssignPrivateNatGatewayAddressRequest = (input, context) => {
    const entries = {};
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    if (input[_PIA] != null) {
        const memberEntries = se_IpList(input[_PIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateIpAddress.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PIAC] != null) {
        entries[_PIAC] = input[_PIAC];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateAddressRequest = (input, context) => {
    const entries = {};
    if (input[_AIl] != null) {
        entries[_AIl] = input[_AIl];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_PI] != null) {
        entries[_PI] = input[_PI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_PIAr] != null) {
        entries[_PIAr] = input[_PIAr];
    }
    if (input[_ARl] != null) {
        entries[_ARl] = input[_ARl];
    }
    return entries;
};
const se_AssociateCapacityReservationBillingOwnerRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    if (input[_URBOI] != null) {
        entries[_URBOI] = input[_URBOI];
    }
    return entries;
};
const se_AssociateClientVpnTargetNetworkRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateDhcpOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DOI] != null) {
        entries[_DOI] = input[_DOI];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateEnclaveCertificateIamRoleRequest = (input, context) => {
    const entries = {};
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    if (input[_RAo] != null) {
        entries[_RAo] = input[_RAo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateIamInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input[_IIP] != null) {
        const memberEntries = se_IamInstanceProfileSpecification(input[_IIP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    return entries;
};
const se_AssociateInstanceEventWindowRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IEWI] != null) {
        entries[_IEWI] = input[_IEWI];
    }
    if (input[_AT] != null) {
        const memberEntries = se_InstanceEventWindowAssociationRequest(input[_AT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AssociationTarget.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AssociateIpamByoasnRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_As] != null) {
        entries[_As] = input[_As];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    return entries;
};
const se_AssociateIpamResourceDiscoveryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIp] != null) {
        entries[_IIp] = input[_IIp];
    }
    if (input[_IRDI] != null) {
        entries[_IRDI] = input[_IRDI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_AssociateNatGatewayAddressRequest = (input, context) => {
    const entries = {};
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    if (input[_AIll] != null) {
        const memberEntries = se_AllocationIdList(input[_AIll], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AllocationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PIA] != null) {
        const memberEntries = se_IpList(input[_PIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateIpAddress.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateRouteServerRequest = (input, context) => {
    const entries = {};
    if (input[_RSIo] != null) {
        entries[_RSIo] = input[_RSIo];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateRouteTableRequest = (input, context) => {
    const entries = {};
    if (input[_GI] != null) {
        entries[_GI] = input[_GI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    return entries;
};
const se_AssociateSecurityGroupVpcRequest = (input, context) => {
    const entries = {};
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateSubnetCidrBlockRequest = (input, context) => {
    const entries = {};
    if (input[_IIPI] != null) {
        entries[_IIPI] = input[_IIPI];
    }
    if (input[_INL] != null) {
        entries[_INL] = input[_INL];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_ICB] != null) {
        entries[_ICB] = input[_ICB];
    }
    return entries;
};
const se_AssociateTransitGatewayMulticastDomainRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_TransitGatewaySubnetIdList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateTransitGatewayPolicyTableRequest = (input, context) => {
    const entries = {};
    if (input[_TGPTI] != null) {
        entries[_TGPTI] = input[_TGPTI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateTransitGatewayRouteTableRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateTrunkInterfaceRequest = (input, context) => {
    const entries = {};
    if (input[_BII] != null) {
        entries[_BII] = input[_BII];
    }
    if (input[_TII] != null) {
        entries[_TII] = input[_TII];
    }
    if (input[_VIl] != null) {
        entries[_VIl] = input[_VIl];
    }
    if (input[_GK] != null) {
        entries[_GK] = input[_GK];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AssociateVpcCidrBlockRequest = (input, context) => {
    const entries = {};
    if (input[_CB] != null) {
        entries[_CB] = input[_CB];
    }
    if (input[_ICBNBG] != null) {
        entries[_ICBNBG] = input[_ICBNBG];
    }
    if (input[_IPpv] != null) {
        entries[_IPpv] = input[_IPpv];
    }
    if (input[_ICB] != null) {
        entries[_ICB] = input[_ICB];
    }
    if (input[_IIPIp] != null) {
        entries[_IIPIp] = input[_IIPIp];
    }
    if (input[_INLp] != null) {
        entries[_INLp] = input[_INLp];
    }
    if (input[_IIPI] != null) {
        entries[_IIPI] = input[_IIPI];
    }
    if (input[_INL] != null) {
        entries[_INL] = input[_INL];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_APICB] != null) {
        entries[_APICB] = input[_APICB];
    }
    return entries;
};
const se_AssociationIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`AssociationId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AthenaIntegration = (input, context) => {
    const entries = {};
    if (input[_IRSDA] != null) {
        entries[_IRSDA] = input[_IRSDA];
    }
    if (input[_PLF] != null) {
        entries[_PLF] = input[_PLF];
    }
    if (input[_PSD] != null) {
        entries[_PSD] = __serializeDateTime(input[_PSD]);
    }
    if (input[_PED] != null) {
        entries[_PED] = __serializeDateTime(input[_PED]);
    }
    return entries;
};
const se_AthenaIntegrationsSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_AthenaIntegration(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AttachClassicLinkVpcRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_G] != null) {
        const memberEntries = se_GroupIdStringList(input[_G], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AttachInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IGI] != null) {
        entries[_IGI] = input[_IGI];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_AttachNetworkInterfaceRequest = (input, context) => {
    const entries = {};
    if (input[_NCI] != null) {
        entries[_NCI] = input[_NCI];
    }
    if (input[_ESS] != null) {
        const memberEntries = se_EnaSrdSpecification(input[_ESS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnaSrdSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_DIev] != null) {
        entries[_DIev] = input[_DIev];
    }
    return entries;
};
const se_AttachVerifiedAccessTrustProviderRequest = (input, context) => {
    const entries = {};
    if (input[_VAII] != null) {
        entries[_VAII] = input[_VAII];
    }
    if (input[_VATPI] != null) {
        entries[_VATPI] = input[_VATPI];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AttachVolumeRequest = (input, context) => {
    const entries = {};
    if (input[_Dev] != null) {
        entries[_Dev] = input[_Dev];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_VIo] != null) {
        entries[_VIo] = input[_VIo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AttachVpnGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_VGI] != null) {
        entries[_VGI] = input[_VGI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AttributeBooleanValue = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_AttributeValue = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_AuthorizeClientVpnIngressRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_TNC] != null) {
        entries[_TNC] = input[_TNC];
    }
    if (input[_AGI] != null) {
        entries[_AGI] = input[_AGI];
    }
    if (input[_AAG] != null) {
        entries[_AAG] = input[_AAG];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AuthorizeSecurityGroupEgressRequest = (input, context) => {
    const entries = {};
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_SSGN] != null) {
        entries[_SSGN] = input[_SSGN];
    }
    if (input[_SSGOI] != null) {
        entries[_SSGOI] = input[_SSGOI];
    }
    if (input[_IPpr] != null) {
        entries[_IPpr] = input[_IPpr];
    }
    if (input[_FP] != null) {
        entries[_FP] = input[_FP];
    }
    if (input[_TP] != null) {
        entries[_TP] = input[_TP];
    }
    if (input[_CIi] != null) {
        entries[_CIi] = input[_CIi];
    }
    if (input[_IPpe] != null) {
        const memberEntries = se_IpPermissionList(input[_IPpe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AuthorizeSecurityGroupIngressRequest = (input, context) => {
    const entries = {};
    if (input[_CIi] != null) {
        entries[_CIi] = input[_CIi];
    }
    if (input[_FP] != null) {
        entries[_FP] = input[_FP];
    }
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_IPpe] != null) {
        const memberEntries = se_IpPermissionList(input[_IPpe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPpr] != null) {
        entries[_IPpr] = input[_IPpr];
    }
    if (input[_SSGN] != null) {
        entries[_SSGN] = input[_SSGN];
    }
    if (input[_SSGOI] != null) {
        entries[_SSGOI] = input[_SSGOI];
    }
    if (input[_TP] != null) {
        entries[_TP] = input[_TP];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_AvailabilityZoneStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`AvailabilityZone.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_BaselineEbsBandwidthMbps = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_BaselineEbsBandwidthMbpsRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_BaselinePerformanceFactors = (input, context) => {
    const entries = {};
    if (input[_Cp] != null) {
        const memberEntries = se_CpuPerformanceFactor(input[_Cp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Cpu.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_BaselinePerformanceFactorsRequest = (input, context) => {
    const entries = {};
    if (input[_Cp] != null) {
        const memberEntries = se_CpuPerformanceFactorRequest(input[_Cp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Cpu.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_BillingProductList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_BlobAttributeValue = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        entries[_Va] = context.base64Encoder(input[_Va]);
    }
    return entries;
};
const se_BlockDeviceMapping = (input, context) => {
    const entries = {};
    if (input[_E] != null) {
        const memberEntries = se_EbsBlockDevice(input[_E], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ebs.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ND] != null) {
        entries[_ND] = input[_ND];
    }
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_VN] != null) {
        entries[_VN] = input[_VN];
    }
    return entries;
};
const se_BlockDeviceMappingList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_BlockDeviceMapping(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_BlockDeviceMappingRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_BlockDeviceMapping(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`BlockDeviceMapping.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_BundleIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`BundleId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_BundleInstanceRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_St] != null) {
        const memberEntries = se_Storage(input[_St], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Storage.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CancelBundleTaskRequest = (input, context) => {
    const entries = {};
    if (input[_BIu] != null) {
        entries[_BIu] = input[_BIu];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CancelCapacityReservationFleetsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CRFI] != null) {
        const memberEntries = se_CapacityReservationFleetIdSet(input[_CRFI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationFleetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CancelCapacityReservationRequest = (input, context) => {
    const entries = {};
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CancelConversionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTI] != null) {
        entries[_CTI] = input[_CTI];
    }
    if (input[_RM] != null) {
        entries[_RM] = input[_RM];
    }
    return entries;
};
const se_CancelDeclarativePoliciesReportRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RIep] != null) {
        entries[_RIep] = input[_RIep];
    }
    return entries;
};
const se_CancelExportTaskRequest = (input, context) => {
    const entries = {};
    if (input[_ETI] != null) {
        entries[_ETI] = input[_ETI];
    }
    return entries;
};
const se_CancelImageLaunchPermissionRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CancelImportTaskRequest = (input, context) => {
    const entries = {};
    if (input[_CRa] != null) {
        entries[_CRa] = input[_CRa];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ITI] != null) {
        entries[_ITI] = input[_ITI];
    }
    return entries;
};
const se_CancelReservedInstancesListingRequest = (input, context) => {
    const entries = {};
    if (input[_RILI] != null) {
        entries[_RILI] = input[_RILI];
    }
    return entries;
};
const se_CancelSpotFleetRequestsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SFRI] != null) {
        const memberEntries = se_SpotFleetRequestIdList(input[_SFRI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SpotFleetRequestId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TI] != null) {
        entries[_TI] = input[_TI];
    }
    return entries;
};
const se_CancelSpotInstanceRequestsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIRI] != null) {
        const memberEntries = se_SpotInstanceRequestIdList(input[_SIRI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SpotInstanceRequestId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CapacityReservationFleetIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CapacityReservationIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CapacityReservationOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_USs] != null) {
        entries[_USs] = input[_USs];
    }
    return entries;
};
const se_CapacityReservationSpecification = (input, context) => {
    const entries = {};
    if (input[_CRP] != null) {
        entries[_CRP] = input[_CRP];
    }
    if (input[_CRTa] != null) {
        const memberEntries = se_CapacityReservationTarget(input[_CRTa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationTarget.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CapacityReservationTarget = (input, context) => {
    const entries = {};
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    if (input[_CRRGA] != null) {
        entries[_CRRGA] = input[_CRRGA];
    }
    return entries;
};
const se_CarrierGatewayIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CertificateAuthenticationRequest = (input, context) => {
    const entries = {};
    if (input[_CRCCA] != null) {
        entries[_CRCCA] = input[_CRCCA];
    }
    return entries;
};
const se_CidrAuthorizationContext = (input, context) => {
    const entries = {};
    if (input[_Me] != null) {
        entries[_Me] = input[_Me];
    }
    if (input[_Si] != null) {
        entries[_Si] = input[_Si];
    }
    return entries;
};
const se_ClassicLoadBalancer = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    return entries;
};
const se_ClassicLoadBalancers = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ClassicLoadBalancer(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ClassicLoadBalancersConfig = (input, context) => {
    const entries = {};
    if (input[_CLB] != null) {
        const memberEntries = se_ClassicLoadBalancers(input[_CLB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClassicLoadBalancers.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ClientConnectOptions = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    if (input[_LFA] != null) {
        entries[_LFA] = input[_LFA];
    }
    return entries;
};
const se_ClientData = (input, context) => {
    const entries = {};
    if (input[_Co] != null) {
        entries[_Co] = input[_Co];
    }
    if (input[_UE] != null) {
        entries[_UE] = __serializeDateTime(input[_UE]);
    }
    if (input[_USp] != null) {
        entries[_USp] = __serializeFloat(input[_USp]);
    }
    if (input[_USpl] != null) {
        entries[_USpl] = __serializeDateTime(input[_USpl]);
    }
    return entries;
};
const se_ClientLoginBannerOptions = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    if (input[_BT] != null) {
        entries[_BT] = input[_BT];
    }
    return entries;
};
const se_ClientVpnAuthenticationRequest = (input, context) => {
    const entries = {};
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_AD] != null) {
        const memberEntries = se_DirectoryServiceAuthenticationRequest(input[_AD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ActiveDirectory.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MA] != null) {
        const memberEntries = se_CertificateAuthenticationRequest(input[_MA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MutualAuthentication.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_FA] != null) {
        const memberEntries = se_FederatedAuthenticationRequest(input[_FA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FederatedAuthentication.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ClientVpnAuthenticationRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ClientVpnAuthenticationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ClientVpnEndpointIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ClientVpnSecurityGroupIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CloudWatchLogOptionsSpecification = (input, context) => {
    const entries = {};
    if (input[_LE] != null) {
        entries[_LE] = input[_LE];
    }
    if (input[_LGA] != null) {
        entries[_LGA] = input[_LGA];
    }
    if (input[_LOF] != null) {
        entries[_LOF] = input[_LOF];
    }
    return entries;
};
const se_CoipPoolIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ConfirmProductInstanceRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_PC] != null) {
        entries[_PC] = input[_PC];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ConnectionLogOptions = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    if (input[_CLG] != null) {
        entries[_CLG] = input[_CLG];
    }
    if (input[_CLS] != null) {
        entries[_CLS] = input[_CLS];
    }
    return entries;
};
const se_ConnectionNotificationIdsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ConnectionTrackingSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_TET] != null) {
        entries[_TET] = input[_TET];
    }
    if (input[_UST] != null) {
        entries[_UST] = input[_UST];
    }
    if (input[_UT] != null) {
        entries[_UT] = input[_UT];
    }
    return entries;
};
const se_ConversionIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CopyFpgaImageRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SFII] != null) {
        entries[_SFII] = input[_SFII];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_SR] != null) {
        entries[_SR] = input[_SR];
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_CopyImageRequest = (input, context) => {
    const entries = {};
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_Enc] != null) {
        entries[_Enc] = input[_Enc];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_SII] != null) {
        entries[_SII] = input[_SII];
    }
    if (input[_SR] != null) {
        entries[_SR] = input[_SR];
    }
    if (input[_DOA] != null) {
        entries[_DOA] = input[_DOA];
    }
    if (input[_CITo] != null) {
        entries[_CITo] = input[_CITo];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SCCDM] != null) {
        entries[_SCCDM] = input[_SCCDM];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CopySnapshotRequest = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DOA] != null) {
        entries[_DOA] = input[_DOA];
    }
    if (input[_DRes] != null) {
        entries[_DRes] = input[_DRes];
    }
    if (input[_Enc] != null) {
        entries[_Enc] = input[_Enc];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_PU] != null) {
        entries[_PU] = input[_PU];
    }
    if (input[_SR] != null) {
        entries[_SR] = input[_SR];
    }
    if (input[_SSI] != null) {
        entries[_SSI] = input[_SSI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CDM] != null) {
        entries[_CDM] = input[_CDM];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CpuManufacturerSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CpuOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_CC] != null) {
        entries[_CC] = input[_CC];
    }
    if (input[_TPC] != null) {
        entries[_TPC] = input[_TPC];
    }
    if (input[_ASS] != null) {
        entries[_ASS] = input[_ASS];
    }
    return entries;
};
const se_CpuPerformanceFactor = (input, context) => {
    const entries = {};
    if (input[_R] != null) {
        const memberEntries = se_PerformanceFactorReferenceSet(input[_R], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReferenceSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CpuPerformanceFactorRequest = (input, context) => {
    const entries = {};
    if (input[_R] != null) {
        const memberEntries = se_PerformanceFactorReferenceSetRequest(input[_R], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Reference.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateCapacityReservationBySplittingRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_SCRI] != null) {
        entries[_SCRI] = input[_SCRI];
    }
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateCapacityReservationFleetRequest = (input, context) => {
    const entries = {};
    if (input[_AS] != null) {
        entries[_AS] = input[_AS];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_ITS] != null) {
        const memberEntries = se_ReservationFleetInstanceSpecificationList(input[_ITS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceTypeSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Te] != null) {
        entries[_Te] = input[_Te];
    }
    if (input[_TTC] != null) {
        entries[_TTC] = input[_TTC];
    }
    if (input[_ED] != null) {
        entries[_ED] = __serializeDateTime(input[_ED]);
    }
    if (input[_IMC] != null) {
        entries[_IMC] = input[_IMC];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateCapacityReservationRequest = (input, context) => {
    const entries = {};
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_IPn] != null) {
        entries[_IPn] = input[_IPn];
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_AZI] != null) {
        entries[_AZI] = input[_AZI];
    }
    if (input[_Te] != null) {
        entries[_Te] = input[_Te];
    }
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_EO] != null) {
        entries[_EO] = input[_EO];
    }
    if (input[_ES] != null) {
        entries[_ES] = input[_ES];
    }
    if (input[_ED] != null) {
        entries[_ED] = __serializeDateTime(input[_ED]);
    }
    if (input[_EDT] != null) {
        entries[_EDT] = input[_EDT];
    }
    if (input[_IMC] != null) {
        entries[_IMC] = input[_IMC];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_PGA] != null) {
        entries[_PGA] = input[_PGA];
    }
    if (input[_SD] != null) {
        entries[_SD] = __serializeDateTime(input[_SD]);
    }
    if (input[_CD] != null) {
        entries[_CD] = input[_CD];
    }
    if (input[_DP] != null) {
        entries[_DP] = input[_DP];
    }
    return entries;
};
const se_CreateCarrierGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_CreateClientVpnEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_CCB] != null) {
        entries[_CCB] = input[_CCB];
    }
    if (input[_SCA] != null) {
        entries[_SCA] = input[_SCA];
    }
    if (input[_AO] != null) {
        const memberEntries = se_ClientVpnAuthenticationRequestList(input[_AO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Authentication.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CLO] != null) {
        const memberEntries = se_ConnectionLogOptions(input[_CLO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionLogOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DSn] != null) {
        const memberEntries = se_ValueStringList(input[_DSn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DnsServers.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TPr] != null) {
        entries[_TPr] = input[_TPr];
    }
    if (input[_VP] != null) {
        entries[_VP] = input[_VP];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SGI] != null) {
        const memberEntries = se_ClientVpnSecurityGroupIdSet(input[_SGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_SSP] != null) {
        entries[_SSP] = input[_SSP];
    }
    if (input[_CCO] != null) {
        const memberEntries = se_ClientConnectOptions(input[_CCO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClientConnectOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_STH] != null) {
        entries[_STH] = input[_STH];
    }
    if (input[_CLBO] != null) {
        const memberEntries = se_ClientLoginBannerOptions(input[_CLBO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClientLoginBannerOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DOST] != null) {
        entries[_DOST] = input[_DOST];
    }
    return entries;
};
const se_CreateClientVpnRouteRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_TVSI] != null) {
        entries[_TVSI] = input[_TVSI];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateCoipCidrRequest = (input, context) => {
    const entries = {};
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_CPIo] != null) {
        entries[_CPIo] = input[_CPIo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateCoipPoolRequest = (input, context) => {
    const entries = {};
    if (input[_LGRTI] != null) {
        entries[_LGRTI] = input[_LGRTI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateCustomerGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_BA] != null) {
        entries[_BA] = input[_BA];
    }
    if (input[_PI] != null) {
        entries[_PI] = input[_PI];
    }
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_IAp] != null) {
        entries[_IAp] = input[_IAp];
    }
    if (input[_BAE] != null) {
        entries[_BAE] = input[_BAE];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateDefaultSubnetRequest = (input, context) => {
    const entries = {};
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IN] != null) {
        entries[_IN] = input[_IN];
    }
    return entries;
};
const se_CreateDefaultVpcRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateDhcpOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DCh] != null) {
        const memberEntries = se_NewDhcpConfigurationList(input[_DCh], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DhcpConfiguration.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateEgressOnlyInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateFleetRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_SO] != null) {
        const memberEntries = se_SpotOptionsRequest(input[_SO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SpotOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ODO] != null) {
        const memberEntries = se_OnDemandOptionsRequest(input[_ODO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OnDemandOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ECTP] != null) {
        entries[_ECTP] = input[_ECTP];
    }
    if (input[_LTC] != null) {
        const memberEntries = se_FleetLaunchTemplateConfigListRequest(input[_LTC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateConfigs.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TCS] != null) {
        const memberEntries = se_TargetCapacitySpecificationRequest(input[_TCS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetCapacitySpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TIWE] != null) {
        entries[_TIWE] = input[_TIWE];
    }
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_VF] != null) {
        entries[_VF] = __serializeDateTime(input[_VF]);
    }
    if (input[_VU] != null) {
        entries[_VU] = __serializeDateTime(input[_VU]);
    }
    if (input[_RUI] != null) {
        entries[_RUI] = input[_RUI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Con] != null) {
        entries[_Con] = input[_Con];
    }
    return entries;
};
const se_CreateFlowLogsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DLPA] != null) {
        entries[_DLPA] = input[_DLPA];
    }
    if (input[_DCAR] != null) {
        entries[_DCAR] = input[_DCAR];
    }
    if (input[_LGN] != null) {
        entries[_LGN] = input[_LGN];
    }
    if (input[_RIes] != null) {
        const memberEntries = se_FlowLogResourceIds(input[_RIes], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RT] != null) {
        entries[_RT] = input[_RT];
    }
    if (input[_TT] != null) {
        entries[_TT] = input[_TT];
    }
    if (input[_LDT] != null) {
        entries[_LDT] = input[_LDT];
    }
    if (input[_LD] != null) {
        entries[_LD] = input[_LD];
    }
    if (input[_LF] != null) {
        entries[_LF] = input[_LF];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MAI] != null) {
        entries[_MAI] = input[_MAI];
    }
    if (input[_DO] != null) {
        const memberEntries = se_DestinationOptionsRequest(input[_DO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DestinationOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateFpgaImageRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ISL] != null) {
        const memberEntries = se_StorageLocation(input[_ISL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InputStorageLocation.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LSL] != null) {
        const memberEntries = se_StorageLocation(input[_LSL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LogsStorageLocation.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateImageRequest = (input, context) => {
    const entries = {};
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_NR] != null) {
        entries[_NR] = input[_NR];
    }
    if (input[_BDM] != null) {
        const memberEntries = se_BlockDeviceMappingRequestList(input[_BDM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateInstanceConnectEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_SGI] != null) {
        const memberEntries = se_SecurityGroupIdStringListRequest(input[_SGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PCI] != null) {
        entries[_PCI] = input[_PCI];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateInstanceEventWindowRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_TRi] != null) {
        const memberEntries = se_InstanceEventWindowTimeRangeRequestSet(input[_TRi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TimeRange.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CE] != null) {
        entries[_CE] = input[_CE];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateInstanceExportTaskRequest = (input, context) => {
    const entries = {};
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_TE] != null) {
        entries[_TE] = input[_TE];
    }
    if (input[_ETST] != null) {
        const memberEntries = se_ExportToS3TaskSpecification(input[_ETST], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExportToS3.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateIpamExternalResourceVerificationTokenRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIp] != null) {
        entries[_IIp] = input[_IIp];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_CreateIpamPoolRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ISI] != null) {
        entries[_ISI] = input[_ISI];
    }
    if (input[_L] != null) {
        entries[_L] = input[_L];
    }
    if (input[_SIPI] != null) {
        entries[_SIPI] = input[_SIPI];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_AF] != null) {
        entries[_AF] = input[_AF];
    }
    if (input[_AIu] != null) {
        entries[_AIu] = input[_AIu];
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_AMNL] != null) {
        entries[_AMNL] = input[_AMNL];
    }
    if (input[_AMNLl] != null) {
        entries[_AMNLl] = input[_AMNLl];
    }
    if (input[_ADNL] != null) {
        entries[_ADNL] = input[_ADNL];
    }
    if (input[_ARTl] != null) {
        const memberEntries = se_RequestIpamResourceTagList(input[_ARTl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AllocationResourceTag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_ASw] != null) {
        entries[_ASw] = input[_ASw];
    }
    if (input[_PIS] != null) {
        entries[_PIS] = input[_PIS];
    }
    if (input[_SRo] != null) {
        const memberEntries = se_IpamPoolSourceResourceRequest(input[_SRo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceResource.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateIpamRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_OR] != null) {
        const memberEntries = se_AddIpamOperatingRegionSet(input[_OR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OperatingRegion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_Ti] != null) {
        entries[_Ti] = input[_Ti];
    }
    if (input[_EPG] != null) {
        entries[_EPG] = input[_EPG];
    }
    return entries;
};
const se_CreateIpamResourceDiscoveryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_OR] != null) {
        const memberEntries = se_AddIpamOperatingRegionSet(input[_OR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OperatingRegion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_CreateIpamScopeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIp] != null) {
        entries[_IIp] = input[_IIp];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_CreateKeyPairRequest = (input, context) => {
    const entries = {};
    if (input[_KN] != null) {
        entries[_KN] = input[_KN];
    }
    if (input[_KT] != null) {
        entries[_KT] = input[_KT];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_KF] != null) {
        entries[_KF] = input[_KF];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateLaunchTemplateRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    if (input[_VD] != null) {
        entries[_VD] = input[_VD];
    }
    if (input[_LTD] != null) {
        const memberEntries = se_RequestLaunchTemplateData(input[_LTD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateData.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_O] != null) {
        const memberEntries = se_OperatorRequest(input[_O], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Operator.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateLaunchTemplateVersionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_LTI] != null) {
        entries[_LTI] = input[_LTI];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    if (input[_SV] != null) {
        entries[_SV] = input[_SV];
    }
    if (input[_VD] != null) {
        entries[_VD] = input[_VD];
    }
    if (input[_LTD] != null) {
        const memberEntries = se_RequestLaunchTemplateData(input[_LTD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateData.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RAe] != null) {
        entries[_RAe] = input[_RAe];
    }
    return entries;
};
const se_CreateLocalGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_LGRTI] != null) {
        entries[_LGRTI] = input[_LGRTI];
    }
    if (input[_LGVIGI] != null) {
        entries[_LGVIGI] = input[_LGVIGI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_DPLI] != null) {
        entries[_DPLI] = input[_DPLI];
    }
    return entries;
};
const se_CreateLocalGatewayRouteTableRequest = (input, context) => {
    const entries = {};
    if (input[_LGI] != null) {
        entries[_LGI] = input[_LGI];
    }
    if (input[_Mo] != null) {
        entries[_Mo] = input[_Mo];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest = (input, context) => {
    const entries = {};
    if (input[_LGRTI] != null) {
        entries[_LGRTI] = input[_LGRTI];
    }
    if (input[_LGVIGI] != null) {
        entries[_LGVIGI] = input[_LGVIGI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateLocalGatewayRouteTableVpcAssociationRequest = (input, context) => {
    const entries = {};
    if (input[_LGRTI] != null) {
        entries[_LGRTI] = input[_LGRTI];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateManagedPrefixListRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PLN] != null) {
        entries[_PLN] = input[_PLN];
    }
    if (input[_Ent] != null) {
        const memberEntries = se_AddPrefixListEntries(input[_Ent], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Entry.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ME] != null) {
        entries[_ME] = input[_ME];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AF] != null) {
        entries[_AF] = input[_AF];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_CreateNatGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_AIl] != null) {
        entries[_AIl] = input[_AIl];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTo] != null) {
        entries[_CTo] = input[_CTo];
    }
    if (input[_PIAr] != null) {
        entries[_PIAr] = input[_PIAr];
    }
    if (input[_SAI] != null) {
        const memberEntries = se_AllocationIdList(input[_SAI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecondaryAllocationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SPIA] != null) {
        const memberEntries = se_IpList(input[_SPIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecondaryPrivateIpAddress.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SPIAC] != null) {
        entries[_SPIAC] = input[_SPIAC];
    }
    return entries;
};
const se_CreateNetworkAclEntryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NAI] != null) {
        entries[_NAI] = input[_NAI];
    }
    if (input[_RNu] != null) {
        entries[_RNu] = input[_RNu];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_RAu] != null) {
        entries[_RAu] = input[_RAu];
    }
    if (input[_Eg] != null) {
        entries[_Eg] = input[_Eg];
    }
    if (input[_CB] != null) {
        entries[_CB] = input[_CB];
    }
    if (input[_ICB] != null) {
        entries[_ICB] = input[_ICB];
    }
    if (input[_ITC] != null) {
        const memberEntries = se_IcmpTypeCode(input[_ITC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Icmp.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PR] != null) {
        const memberEntries = se_PortRange(input[_PR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PortRange.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateNetworkAclRequest = (input, context) => {
    const entries = {};
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_CreateNetworkInsightsAccessScopeRequest = (input, context) => {
    const entries = {};
    if (input[_MP] != null) {
        const memberEntries = se_AccessScopePathListRequest(input[_MP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MatchPath.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_EP] != null) {
        const memberEntries = se_AccessScopePathListRequest(input[_EP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludePath.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateNetworkInsightsPathRequest = (input, context) => {
    const entries = {};
    if (input[_SIo] != null) {
        entries[_SIo] = input[_SIo];
    }
    if (input[_DIest] != null) {
        entries[_DIest] = input[_DIest];
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DPe] != null) {
        entries[_DPe] = input[_DPe];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_FAS] != null) {
        const memberEntries = se_PathRequestFilter(input[_FAS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FilterAtSource.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_FAD] != null) {
        const memberEntries = se_PathRequestFilter(input[_FAD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FilterAtDestination.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateNetworkInterfacePermissionRequest = (input, context) => {
    const entries = {};
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_AAI] != null) {
        entries[_AAI] = input[_AAI];
    }
    if (input[_ASw] != null) {
        entries[_ASw] = input[_ASw];
    }
    if (input[_Pe] != null) {
        entries[_Pe] = input[_Pe];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateNetworkInterfaceRequest = (input, context) => {
    const entries = {};
    if (input[_IPp] != null) {
        const memberEntries = se_Ipv4PrefixList(input[_IPp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv4Prefix.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPCp] != null) {
        entries[_IPCp] = input[_IPCp];
    }
    if (input[_IP] != null) {
        const memberEntries = se_Ipv6PrefixList(input[_IP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Prefix.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPC] != null) {
        entries[_IPC] = input[_IPC];
    }
    if (input[_ITn] != null) {
        entries[_ITn] = input[_ITn];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_EPI] != null) {
        entries[_EPI] = input[_EPI];
    }
    if (input[_CTS] != null) {
        const memberEntries = se_ConnectionTrackingSpecificationRequest(input[_CTS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionTrackingSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_O] != null) {
        const memberEntries = se_OperatorRequest(input[_O], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Operator.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_PIAr] != null) {
        entries[_PIAr] = input[_PIAr];
    }
    if (input[_G] != null) {
        const memberEntries = se_SecurityGroupIdStringList(input[_G], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PIA] != null) {
        const memberEntries = se_PrivateIpAddressSpecificationList(input[_PIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateIpAddresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SPIAC] != null) {
        entries[_SPIAC] = input[_SPIAC];
    }
    if (input[_IA] != null) {
        const memberEntries = se_InstanceIpv6AddressList(input[_IA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IAC] != null) {
        entries[_IAC] = input[_IAC];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreatePlacementGroupRequest = (input, context) => {
    const entries = {};
    if (input[_PCa] != null) {
        entries[_PCa] = input[_PCa];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SL] != null) {
        entries[_SL] = input[_SL];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_Str] != null) {
        entries[_Str] = input[_Str];
    }
    return entries;
};
const se_CreatePublicIpv4PoolRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NBG] != null) {
        entries[_NBG] = input[_NBG];
    }
    return entries;
};
const se_CreateReplaceRootVolumeTaskRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DRRV] != null) {
        entries[_DRRV] = input[_DRRV];
    }
    return entries;
};
const se_CreateReservedInstancesListingRequest = (input, context) => {
    const entries = {};
    if (input[_RIIe] != null) {
        entries[_RIIe] = input[_RIIe];
    }
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_PS] != null) {
        const memberEntries = se_PriceScheduleSpecificationList(input[_PS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PriceSchedules.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_CreateRestoreImageTaskRequest = (input, context) => {
    const entries = {};
    if (input[_B] != null) {
        entries[_B] = input[_B];
    }
    if (input[_OK] != null) {
        entries[_OK] = input[_OK];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateRouteRequest = (input, context) => {
    const entries = {};
    if (input[_DPLI] != null) {
        entries[_DPLI] = input[_DPLI];
    }
    if (input[_VEIp] != null) {
        entries[_VEIp] = input[_VEIp];
    }
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_LGI] != null) {
        entries[_LGI] = input[_LGI];
    }
    if (input[_CGI] != null) {
        entries[_CGI] = input[_CGI];
    }
    if (input[_CNAo] != null) {
        entries[_CNAo] = input[_CNAo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_GI] != null) {
        entries[_GI] = input[_GI];
    }
    if (input[_DICB] != null) {
        entries[_DICB] = input[_DICB];
    }
    if (input[_EOIGI] != null) {
        entries[_EOIGI] = input[_EOIGI];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_VPCI] != null) {
        entries[_VPCI] = input[_VPCI];
    }
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    return entries;
};
const se_CreateRouteServerEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_RSIo] != null) {
        entries[_RSIo] = input[_RSIo];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateRouteServerPeerRequest = (input, context) => {
    const entries = {};
    if (input[_RSEI] != null) {
        entries[_RSEI] = input[_RSEI];
    }
    if (input[_PAe] != null) {
        entries[_PAe] = input[_PAe];
    }
    if (input[_BO] != null) {
        const memberEntries = se_RouteServerBgpOptionsRequest(input[_BO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BgpOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateRouteServerRequest = (input, context) => {
    const entries = {};
    if (input[_ASA] != null) {
        entries[_ASA] = input[_ASA];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PRe] != null) {
        entries[_PRe] = input[_PRe];
    }
    if (input[_PRD] != null) {
        entries[_PRD] = input[_PRD];
    }
    if (input[_SNE] != null) {
        entries[_SNE] = input[_SNE];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateRouteTableRequest = (input, context) => {
    const entries = {};
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_CreateSecurityGroupRequest = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_GD] = input[_De];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateSnapshotRequest = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_VIo] != null) {
        entries[_VIo] = input[_VIo];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Lo] != null) {
        entries[_Lo] = input[_Lo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateSnapshotsRequest = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_ISn] != null) {
        const memberEntries = se_InstanceSpecification(input[_ISn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTFS] != null) {
        entries[_CTFS] = input[_CTFS];
    }
    if (input[_Lo] != null) {
        entries[_Lo] = input[_Lo];
    }
    return entries;
};
const se_CreateSpotDatafeedSubscriptionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_B] != null) {
        entries[_B] = input[_B];
    }
    if (input[_Pr] != null) {
        entries[_Pr] = input[_Pr];
    }
    return entries;
};
const se_CreateStoreImageTaskRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_B] != null) {
        entries[_B] = input[_B];
    }
    if (input[_SOT] != null) {
        const memberEntries = se_S3ObjectTagList(input[_SOT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `S3ObjectTag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateSubnetCidrReservationRequest = (input, context) => {
    const entries = {};
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_RTe] != null) {
        entries[_RTe] = input[_RTe];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateSubnetRequest = (input, context) => {
    const entries = {};
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_AZI] != null) {
        entries[_AZI] = input[_AZI];
    }
    if (input[_CB] != null) {
        entries[_CB] = input[_CB];
    }
    if (input[_ICB] != null) {
        entries[_ICB] = input[_ICB];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_IN] != null) {
        entries[_IN] = input[_IN];
    }
    if (input[_IIPIp] != null) {
        entries[_IIPIp] = input[_IIPIp];
    }
    if (input[_INLp] != null) {
        entries[_INLp] = input[_INLp];
    }
    if (input[_IIPI] != null) {
        entries[_IIPI] = input[_IIPI];
    }
    if (input[_INL] != null) {
        entries[_INL] = input[_INL];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTagsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Re] != null) {
        const memberEntries = se_ResourceIdList(input[_Re], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateTrafficMirrorFilterRequest = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_CreateTrafficMirrorFilterRuleRequest = (input, context) => {
    const entries = {};
    if (input[_TMFI] != null) {
        entries[_TMFI] = input[_TMFI];
    }
    if (input[_TD] != null) {
        entries[_TD] = input[_TD];
    }
    if (input[_RNu] != null) {
        entries[_RNu] = input[_RNu];
    }
    if (input[_RAu] != null) {
        entries[_RAu] = input[_RAu];
    }
    if (input[_DPR] != null) {
        const memberEntries = se_TrafficMirrorPortRangeRequest(input[_DPR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DestinationPortRange.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SPR] != null) {
        const memberEntries = se_TrafficMirrorPortRangeRequest(input[_SPR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourcePortRange.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_SCB] != null) {
        entries[_SCB] = input[_SCB];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateTrafficMirrorSessionRequest = (input, context) => {
    const entries = {};
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_TMTI] != null) {
        entries[_TMTI] = input[_TMTI];
    }
    if (input[_TMFI] != null) {
        entries[_TMFI] = input[_TMFI];
    }
    if (input[_PL] != null) {
        entries[_PL] = input[_PL];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_VNI] != null) {
        entries[_VNI] = input[_VNI];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_CreateTrafficMirrorTargetRequest = (input, context) => {
    const entries = {};
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_NLBA] != null) {
        entries[_NLBA] = input[_NLBA];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_GLBEI] != null) {
        entries[_GLBEI] = input[_GLBEI];
    }
    return entries;
};
const se_CreateTransitGatewayConnectPeerRequest = (input, context) => {
    const entries = {};
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_TGA] != null) {
        entries[_TGA] = input[_TGA];
    }
    if (input[_PAe] != null) {
        entries[_PAe] = input[_PAe];
    }
    if (input[_BO] != null) {
        const memberEntries = se_TransitGatewayConnectRequestBgpOptions(input[_BO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BgpOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ICBn] != null) {
        const memberEntries = se_InsideCidrBlocksStringList(input[_ICBn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InsideCidrBlocks.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayConnectRequest = (input, context) => {
    const entries = {};
    if (input[_TTGAI] != null) {
        entries[_TTGAI] = input[_TTGAI];
    }
    if (input[_Op] != null) {
        const memberEntries = se_CreateTransitGatewayConnectRequestOptions(input[_Op], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Options.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayConnectRequestOptions = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    return entries;
};
const se_CreateTransitGatewayMulticastDomainRequest = (input, context) => {
    const entries = {};
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_Op] != null) {
        const memberEntries = se_CreateTransitGatewayMulticastDomainRequestOptions(input[_Op], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Options.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayMulticastDomainRequestOptions = (input, context) => {
    const entries = {};
    if (input[_ISg] != null) {
        entries[_ISg] = input[_ISg];
    }
    if (input[_SSS] != null) {
        entries[_SSS] = input[_SSS];
    }
    if (input[_AASA] != null) {
        entries[_AASA] = input[_AASA];
    }
    return entries;
};
const se_CreateTransitGatewayPeeringAttachmentRequest = (input, context) => {
    const entries = {};
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_PTGI] != null) {
        entries[_PTGI] = input[_PTGI];
    }
    if (input[_PAI] != null) {
        entries[_PAI] = input[_PAI];
    }
    if (input[_PRee] != null) {
        entries[_PRee] = input[_PRee];
    }
    if (input[_Op] != null) {
        const memberEntries = se_CreateTransitGatewayPeeringAttachmentRequestOptions(input[_Op], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Options.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayPeeringAttachmentRequestOptions = (input, context) => {
    const entries = {};
    if (input[_DRy] != null) {
        entries[_DRy] = input[_DRy];
    }
    return entries;
};
const se_CreateTransitGatewayPolicyTableRequest = (input, context) => {
    const entries = {};
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayPrefixListReferenceRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_PLI] != null) {
        entries[_PLI] = input[_PLI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_Bl] != null) {
        entries[_Bl] = input[_Bl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_Op] != null) {
        const memberEntries = se_TransitGatewayRequestOptions(input[_Op], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Options.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_Bl] != null) {
        entries[_Bl] = input[_Bl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayRouteTableAnnouncementRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_PAIe] != null) {
        entries[_PAIe] = input[_PAIe];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayRouteTableRequest = (input, context) => {
    const entries = {};
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayVpcAttachmentRequest = (input, context) => {
    const entries = {};
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_TransitGatewaySubnetIdList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Op] != null) {
        const memberEntries = se_CreateTransitGatewayVpcAttachmentRequestOptions(input[_Op], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Options.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateTransitGatewayVpcAttachmentRequestOptions = (input, context) => {
    const entries = {};
    if (input[_DSns] != null) {
        entries[_DSns] = input[_DSns];
    }
    if (input[_SGRS] != null) {
        entries[_SGRS] = input[_SGRS];
    }
    if (input[_ISp] != null) {
        entries[_ISp] = input[_ISp];
    }
    if (input[_AMS] != null) {
        entries[_AMS] = input[_AMS];
    }
    return entries;
};
const se_CreateVerifiedAccessEndpointCidrOptions = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_CreateVerifiedAccessEndpointSubnetIdList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_PRo] != null) {
        const memberEntries = se_CreateVerifiedAccessEndpointPortRangeList(input[_PRo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PortRange.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVerifiedAccessEndpointEniOptions = (input, context) => {
    const entries = {};
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_PRo] != null) {
        const memberEntries = se_CreateVerifiedAccessEndpointPortRangeList(input[_PRo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PortRange.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVerifiedAccessEndpointLoadBalancerOptions = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_LBA] != null) {
        entries[_LBA] = input[_LBA];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_CreateVerifiedAccessEndpointSubnetIdList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PRo] != null) {
        const memberEntries = se_CreateVerifiedAccessEndpointPortRangeList(input[_PRo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PortRange.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVerifiedAccessEndpointPortRange = (input, context) => {
    const entries = {};
    if (input[_FP] != null) {
        entries[_FP] = input[_FP];
    }
    if (input[_TP] != null) {
        entries[_TP] = input[_TP];
    }
    return entries;
};
const se_CreateVerifiedAccessEndpointPortRangeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_CreateVerifiedAccessEndpointPortRange(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_CreateVerifiedAccessEndpointRdsOptions = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_RDIA] != null) {
        entries[_RDIA] = input[_RDIA];
    }
    if (input[_RDCA] != null) {
        entries[_RDCA] = input[_RDCA];
    }
    if (input[_RDPA] != null) {
        entries[_RDPA] = input[_RDPA];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_CreateVerifiedAccessEndpointSubnetIdList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVerifiedAccessEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_VAGI] != null) {
        entries[_VAGI] = input[_VAGI];
    }
    if (input[_ET] != null) {
        entries[_ET] = input[_ET];
    }
    if (input[_ATt] != null) {
        entries[_ATt] = input[_ATt];
    }
    if (input[_DCA] != null) {
        entries[_DCA] = input[_DCA];
    }
    if (input[_ADp] != null) {
        entries[_ADp] = input[_ADp];
    }
    if (input[_EDP] != null) {
        entries[_EDP] = input[_EDP];
    }
    if (input[_SGI] != null) {
        const memberEntries = se_SecurityGroupIdList(input[_SGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_LBO] != null) {
        const memberEntries = se_CreateVerifiedAccessEndpointLoadBalancerOptions(input[_LBO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NIO] != null) {
        const memberEntries = se_CreateVerifiedAccessEndpointEniOptions(input[_NIO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SS] != null) {
        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SseSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RO] != null) {
        const memberEntries = se_CreateVerifiedAccessEndpointRdsOptions(input[_RO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RdsOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CO] != null) {
        const memberEntries = se_CreateVerifiedAccessEndpointCidrOptions(input[_CO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CidrOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVerifiedAccessEndpointSubnetIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CreateVerifiedAccessGroupRequest = (input, context) => {
    const entries = {};
    if (input[_VAII] != null) {
        entries[_VAII] = input[_VAII];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SS] != null) {
        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SseSpecification.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVerifiedAccessInstanceRequest = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_FIPSE] != null) {
        entries[_FIPSE] = input[_FIPSE];
    }
    if (input[_CECSD] != null) {
        entries[_CECSD] = input[_CECSD];
    }
    return entries;
};
const se_CreateVerifiedAccessNativeApplicationOidcOptions = (input, context) => {
    const entries = {};
    if (input[_PSKE] != null) {
        entries[_PSKE] = input[_PSKE];
    }
    if (input[_I] != null) {
        entries[_I] = input[_I];
    }
    if (input[_AE] != null) {
        entries[_AE] = input[_AE];
    }
    if (input[_TEo] != null) {
        entries[_TEo] = input[_TEo];
    }
    if (input[_UIE] != null) {
        entries[_UIE] = input[_UIE];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_CSl] != null) {
        entries[_CSl] = input[_CSl];
    }
    if (input[_Sc] != null) {
        entries[_Sc] = input[_Sc];
    }
    return entries;
};
const se_CreateVerifiedAccessTrustProviderDeviceOptions = (input, context) => {
    const entries = {};
    if (input[_TIe] != null) {
        entries[_TIe] = input[_TIe];
    }
    if (input[_PSKU] != null) {
        entries[_PSKU] = input[_PSKU];
    }
    return entries;
};
const se_CreateVerifiedAccessTrustProviderOidcOptions = (input, context) => {
    const entries = {};
    if (input[_I] != null) {
        entries[_I] = input[_I];
    }
    if (input[_AE] != null) {
        entries[_AE] = input[_AE];
    }
    if (input[_TEo] != null) {
        entries[_TEo] = input[_TEo];
    }
    if (input[_UIE] != null) {
        entries[_UIE] = input[_UIE];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_CSl] != null) {
        entries[_CSl] = input[_CSl];
    }
    if (input[_Sc] != null) {
        entries[_Sc] = input[_Sc];
    }
    return entries;
};
const se_CreateVerifiedAccessTrustProviderRequest = (input, context) => {
    const entries = {};
    if (input[_TPT] != null) {
        entries[_TPT] = input[_TPT];
    }
    if (input[_UTPT] != null) {
        entries[_UTPT] = input[_UTPT];
    }
    if (input[_DTPT] != null) {
        entries[_DTPT] = input[_DTPT];
    }
    if (input[_OO] != null) {
        const memberEntries = se_CreateVerifiedAccessTrustProviderOidcOptions(input[_OO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OidcOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DOe] != null) {
        const memberEntries = se_CreateVerifiedAccessTrustProviderDeviceOptions(input[_DOe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DeviceOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PRN] != null) {
        entries[_PRN] = input[_PRN];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SS] != null) {
        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SseSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NAOO] != null) {
        const memberEntries = se_CreateVerifiedAccessNativeApplicationOidcOptions(input[_NAOO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NativeApplicationOidcOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVolumePermission = (input, context) => {
    const entries = {};
    if (input[_UIs] != null) {
        entries[_UIs] = input[_UIs];
    }
    if (input[_Gr] != null) {
        entries[_Gr] = input[_Gr];
    }
    return entries;
};
const se_CreateVolumePermissionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_CreateVolumePermission(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_CreateVolumePermissionModifications = (input, context) => {
    const entries = {};
    if (input[_Add] != null) {
        const memberEntries = se_CreateVolumePermissionList(input[_Add], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Add.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Rem] != null) {
        const memberEntries = se_CreateVolumePermissionList(input[_Rem], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Remove.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVolumeRequest = (input, context) => {
    const entries = {};
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_Enc] != null) {
        entries[_Enc] = input[_Enc];
    }
    if (input[_Io] != null) {
        entries[_Io] = input[_Io];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_Siz] != null) {
        entries[_Siz] = input[_Siz];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_VT] != null) {
        entries[_VT] = input[_VT];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MAE] != null) {
        entries[_MAE] = input[_MAE];
    }
    if (input[_Th] != null) {
        entries[_Th] = input[_Th];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_O] != null) {
        const memberEntries = se_OperatorRequest(input[_O], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Operator.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreateVpcBlockPublicAccessExclusionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_IGEM] != null) {
        entries[_IGEM] = input[_IGEM];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVpcEndpointConnectionNotificationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIe] != null) {
        entries[_SIe] = input[_SIe];
    }
    if (input[_VEIp] != null) {
        entries[_VEIp] = input[_VEIp];
    }
    if (input[_CNAon] != null) {
        entries[_CNAon] = input[_CNAon];
    }
    if (input[_CEo] != null) {
        const memberEntries = se_ValueStringList(input[_CEo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionEvents.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_CreateVpcEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VET] != null) {
        entries[_VET] = input[_VET];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_SNe] != null) {
        entries[_SNe] = input[_SNe];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    if (input[_RTIo] != null) {
        const memberEntries = se_VpcEndpointRouteTableIdList(input[_RTIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RouteTableId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SIu] != null) {
        const memberEntries = se_VpcEndpointSubnetIdList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SGI] != null) {
        const memberEntries = se_VpcEndpointSecurityGroupIdList(input[_SGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IAT] != null) {
        entries[_IAT] = input[_IAT];
    }
    if (input[_DOn] != null) {
        const memberEntries = se_DnsOptionsSpecification(input[_DOn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DnsOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_PDE] != null) {
        entries[_PDE] = input[_PDE];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SC] != null) {
        const memberEntries = se_SubnetConfigurationsList(input[_SC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetConfiguration.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SNA] != null) {
        entries[_SNA] = input[_SNA];
    }
    if (input[_RCA] != null) {
        entries[_RCA] = input[_RCA];
    }
    if (input[_SRe] != null) {
        entries[_SRe] = input[_SRe];
    }
    return entries;
};
const se_CreateVpcEndpointServiceConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ARc] != null) {
        entries[_ARc] = input[_ARc];
    }
    if (input[_PDN] != null) {
        entries[_PDN] = input[_PDN];
    }
    if (input[_NLBAe] != null) {
        const memberEntries = se_ValueStringList(input[_NLBAe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkLoadBalancerArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_GLBA] != null) {
        const memberEntries = se_ValueStringList(input[_GLBA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GatewayLoadBalancerArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SIAT] != null) {
        const memberEntries = se_ValueStringList(input[_SIAT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SupportedIpAddressType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SRu] != null) {
        const memberEntries = se_ValueStringList(input[_SRu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SupportedRegion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVpcPeeringConnectionRequest = (input, context) => {
    const entries = {};
    if (input[_PRee] != null) {
        entries[_PRee] = input[_PRee];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_PVI] != null) {
        entries[_PVI] = input[_PVI];
    }
    if (input[_POI] != null) {
        entries[_POI] = input[_POI];
    }
    return entries;
};
const se_CreateVpcRequest = (input, context) => {
    const entries = {};
    if (input[_CB] != null) {
        entries[_CB] = input[_CB];
    }
    if (input[_IPpv] != null) {
        entries[_IPpv] = input[_IPpv];
    }
    if (input[_ICB] != null) {
        entries[_ICB] = input[_ICB];
    }
    if (input[_IIPIp] != null) {
        entries[_IIPIp] = input[_IIPIp];
    }
    if (input[_INLp] != null) {
        entries[_INLp] = input[_INLp];
    }
    if (input[_IIPI] != null) {
        entries[_IIPI] = input[_IIPI];
    }
    if (input[_INL] != null) {
        entries[_INL] = input[_INL];
    }
    if (input[_ICBNBG] != null) {
        entries[_ICBNBG] = input[_ICBNBG];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ITns] != null) {
        entries[_ITns] = input[_ITns];
    }
    if (input[_APICB] != null) {
        entries[_APICB] = input[_APICB];
    }
    return entries;
};
const se_CreateVpnConnectionRequest = (input, context) => {
    const entries = {};
    if (input[_CGIu] != null) {
        entries[_CGIu] = input[_CGIu];
    }
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_VGI] != null) {
        entries[_VGI] = input[_VGI];
    }
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Op] != null) {
        const memberEntries = se_VpnConnectionOptionsSpecification(input[_Op], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Options.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVpnConnectionRouteRequest = (input, context) => {
    const entries = {};
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_VCI] != null) {
        entries[_VCI] = input[_VCI];
    }
    return entries;
};
const se_CreateVpnGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ASA] != null) {
        entries[_ASA] = input[_ASA];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_CreditSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_CCp] != null) {
        entries[_CCp] = input[_CCp];
    }
    return entries;
};
const se_CustomerGatewayIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`CustomerGatewayId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DataQueries = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_DataQuery(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_DataQuery = (input, context) => {
    const entries = {};
    if (input[_Id] != null) {
        entries[_Id] = input[_Id];
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_Met] != null) {
        entries[_Met] = input[_Met];
    }
    if (input[_Sta] != null) {
        entries[_Sta] = input[_Sta];
    }
    if (input[_Per] != null) {
        entries[_Per] = input[_Per];
    }
    return entries;
};
const se_DedicatedHostIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DeleteCarrierGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_CGI] != null) {
        entries[_CGI] = input[_CGI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteClientVpnEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteClientVpnRouteRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_TVSI] != null) {
        entries[_TVSI] = input[_TVSI];
    }
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteCoipCidrRequest = (input, context) => {
    const entries = {};
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_CPIo] != null) {
        entries[_CPIo] = input[_CPIo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteCoipPoolRequest = (input, context) => {
    const entries = {};
    if (input[_CPIo] != null) {
        entries[_CPIo] = input[_CPIo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteCustomerGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_CGIu] != null) {
        entries[_CGIu] = input[_CGIu];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteDhcpOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DOI] != null) {
        entries[_DOI] = input[_DOI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteEgressOnlyInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_EOIGI] != null) {
        entries[_EOIGI] = input[_EOIGI];
    }
    return entries;
};
const se_DeleteFleetsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_FI] != null) {
        const memberEntries = se_FleetIdSet(input[_FI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FleetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TI] != null) {
        entries[_TI] = input[_TI];
    }
    return entries;
};
const se_DeleteFlowLogsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_FLI] != null) {
        const memberEntries = se_FlowLogIdList(input[_FLI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FlowLogId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteFpgaImageRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_FII] != null) {
        entries[_FII] = input[_FII];
    }
    return entries;
};
const se_DeleteInstanceConnectEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ICEI] != null) {
        entries[_ICEI] = input[_ICEI];
    }
    return entries;
};
const se_DeleteInstanceEventWindowRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_FD] != null) {
        entries[_FD] = input[_FD];
    }
    if (input[_IEWI] != null) {
        entries[_IEWI] = input[_IEWI];
    }
    return entries;
};
const se_DeleteInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IGI] != null) {
        entries[_IGI] = input[_IGI];
    }
    return entries;
};
const se_DeleteIpamExternalResourceVerificationTokenRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IERVTI] != null) {
        entries[_IERVTI] = input[_IERVTI];
    }
    return entries;
};
const se_DeleteIpamPoolRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_Ca] != null) {
        entries[_Ca] = input[_Ca];
    }
    return entries;
};
const se_DeleteIpamRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIp] != null) {
        entries[_IIp] = input[_IIp];
    }
    if (input[_Ca] != null) {
        entries[_Ca] = input[_Ca];
    }
    return entries;
};
const se_DeleteIpamResourceDiscoveryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IRDI] != null) {
        entries[_IRDI] = input[_IRDI];
    }
    return entries;
};
const se_DeleteIpamScopeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ISI] != null) {
        entries[_ISI] = input[_ISI];
    }
    return entries;
};
const se_DeleteKeyPairRequest = (input, context) => {
    const entries = {};
    if (input[_KN] != null) {
        entries[_KN] = input[_KN];
    }
    if (input[_KPI] != null) {
        entries[_KPI] = input[_KPI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteLaunchTemplateRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_LTI] != null) {
        entries[_LTI] = input[_LTI];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    return entries;
};
const se_DeleteLaunchTemplateVersionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_LTI] != null) {
        entries[_LTI] = input[_LTI];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    if (input[_Ve] != null) {
        const memberEntries = se_VersionStringList(input[_Ve], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateVersion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteLocalGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_LGRTI] != null) {
        entries[_LGRTI] = input[_LGRTI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_DPLI] != null) {
        entries[_DPLI] = input[_DPLI];
    }
    return entries;
};
const se_DeleteLocalGatewayRouteTableRequest = (input, context) => {
    const entries = {};
    if (input[_LGRTI] != null) {
        entries[_LGRTI] = input[_LGRTI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationRequest = (input, context) => {
    const entries = {};
    if (input[_LGRTVIGAI] != null) {
        entries[_LGRTVIGAI] = input[_LGRTVIGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteLocalGatewayRouteTableVpcAssociationRequest = (input, context) => {
    const entries = {};
    if (input[_LGRTVAI] != null) {
        entries[_LGRTVAI] = input[_LGRTVAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteManagedPrefixListRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PLI] != null) {
        entries[_PLI] = input[_PLI];
    }
    return entries;
};
const se_DeleteNatGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    return entries;
};
const se_DeleteNetworkAclEntryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NAI] != null) {
        entries[_NAI] = input[_NAI];
    }
    if (input[_RNu] != null) {
        entries[_RNu] = input[_RNu];
    }
    if (input[_Eg] != null) {
        entries[_Eg] = input[_Eg];
    }
    return entries;
};
const se_DeleteNetworkAclRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NAI] != null) {
        entries[_NAI] = input[_NAI];
    }
    return entries;
};
const se_DeleteNetworkInsightsAccessScopeAnalysisRequest = (input, context) => {
    const entries = {};
    if (input[_NIASAI] != null) {
        entries[_NIASAI] = input[_NIASAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteNetworkInsightsAccessScopeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NIASI] != null) {
        entries[_NIASI] = input[_NIASI];
    }
    return entries;
};
const se_DeleteNetworkInsightsAnalysisRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NIAI] != null) {
        entries[_NIAI] = input[_NIAI];
    }
    return entries;
};
const se_DeleteNetworkInsightsPathRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NIPI] != null) {
        entries[_NIPI] = input[_NIPI];
    }
    return entries;
};
const se_DeleteNetworkInterfacePermissionRequest = (input, context) => {
    const entries = {};
    if (input[_NIPIe] != null) {
        entries[_NIPIe] = input[_NIPIe];
    }
    if (input[_F] != null) {
        entries[_F] = input[_F];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteNetworkInterfaceRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    return entries;
};
const se_DeletePlacementGroupRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    return entries;
};
const se_DeletePublicIpv4PoolRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PIo] != null) {
        entries[_PIo] = input[_PIo];
    }
    if (input[_NBG] != null) {
        entries[_NBG] = input[_NBG];
    }
    return entries;
};
const se_DeleteQueuedReservedInstancesIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DeleteQueuedReservedInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RIIes] != null) {
        const memberEntries = se_DeleteQueuedReservedInstancesIdList(input[_RIIes], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReservedInstancesId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteRouteRequest = (input, context) => {
    const entries = {};
    if (input[_DPLI] != null) {
        entries[_DPLI] = input[_DPLI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_DICB] != null) {
        entries[_DICB] = input[_DICB];
    }
    return entries;
};
const se_DeleteRouteServerEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_RSEI] != null) {
        entries[_RSEI] = input[_RSEI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteRouteServerPeerRequest = (input, context) => {
    const entries = {};
    if (input[_RSPI] != null) {
        entries[_RSPI] = input[_RSPI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteRouteServerRequest = (input, context) => {
    const entries = {};
    if (input[_RSIo] != null) {
        entries[_RSIo] = input[_RSIo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteRouteTableRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    return entries;
};
const se_DeleteSecurityGroupRequest = (input, context) => {
    const entries = {};
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteSnapshotRequest = (input, context) => {
    const entries = {};
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteSpotDatafeedSubscriptionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteSubnetCidrReservationRequest = (input, context) => {
    const entries = {};
    if (input[_SCRIu] != null) {
        entries[_SCRIu] = input[_SCRIu];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteSubnetRequest = (input, context) => {
    const entries = {};
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTagsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Re] != null) {
        const memberEntries = se_ResourceIdList(input[_Re], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteTrafficMirrorFilterRequest = (input, context) => {
    const entries = {};
    if (input[_TMFI] != null) {
        entries[_TMFI] = input[_TMFI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTrafficMirrorFilterRuleRequest = (input, context) => {
    const entries = {};
    if (input[_TMFRI] != null) {
        entries[_TMFRI] = input[_TMFRI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTrafficMirrorSessionRequest = (input, context) => {
    const entries = {};
    if (input[_TMSI] != null) {
        entries[_TMSI] = input[_TMSI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTrafficMirrorTargetRequest = (input, context) => {
    const entries = {};
    if (input[_TMTI] != null) {
        entries[_TMTI] = input[_TMTI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayConnectPeerRequest = (input, context) => {
    const entries = {};
    if (input[_TGCPI] != null) {
        entries[_TGCPI] = input[_TGCPI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayConnectRequest = (input, context) => {
    const entries = {};
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayMulticastDomainRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayPeeringAttachmentRequest = (input, context) => {
    const entries = {};
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayPolicyTableRequest = (input, context) => {
    const entries = {};
    if (input[_TGPTI] != null) {
        entries[_TGPTI] = input[_TGPTI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayPrefixListReferenceRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_PLI] != null) {
        entries[_PLI] = input[_PLI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayRouteTableAnnouncementRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTAI] != null) {
        entries[_TGRTAI] = input[_TGRTAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayRouteTableRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteTransitGatewayVpcAttachmentRequest = (input, context) => {
    const entries = {};
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteVerifiedAccessEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_VAEI] != null) {
        entries[_VAEI] = input[_VAEI];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteVerifiedAccessGroupRequest = (input, context) => {
    const entries = {};
    if (input[_VAGI] != null) {
        entries[_VAGI] = input[_VAGI];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteVerifiedAccessInstanceRequest = (input, context) => {
    const entries = {};
    if (input[_VAII] != null) {
        entries[_VAII] = input[_VAII];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_DeleteVerifiedAccessTrustProviderRequest = (input, context) => {
    const entries = {};
    if (input[_VATPI] != null) {
        entries[_VATPI] = input[_VATPI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_DeleteVolumeRequest = (input, context) => {
    const entries = {};
    if (input[_VIo] != null) {
        entries[_VIo] = input[_VIo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteVpcBlockPublicAccessExclusionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_EIxc] != null) {
        entries[_EIxc] = input[_EIxc];
    }
    return entries;
};
const se_DeleteVpcEndpointConnectionNotificationsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CNIo] != null) {
        const memberEntries = se_ConnectionNotificationIdsList(input[_CNIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionNotificationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteVpcEndpointServiceConfigurationsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIer] != null) {
        const memberEntries = se_VpcEndpointServiceIdList(input[_SIer], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteVpcEndpointsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VEI] != null) {
        const memberEntries = se_VpcEndpointIdList(input[_VEI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteVpcPeeringConnectionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VPCI] != null) {
        entries[_VPCI] = input[_VPCI];
    }
    return entries;
};
const se_DeleteVpcRequest = (input, context) => {
    const entries = {};
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteVpnConnectionRequest = (input, context) => {
    const entries = {};
    if (input[_VCI] != null) {
        entries[_VCI] = input[_VCI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeleteVpnConnectionRouteRequest = (input, context) => {
    const entries = {};
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_VCI] != null) {
        entries[_VCI] = input[_VCI];
    }
    return entries;
};
const se_DeleteVpnGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_VGI] != null) {
        entries[_VGI] = input[_VGI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeprovisionByoipCidrRequest = (input, context) => {
    const entries = {};
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeprovisionIpamByoasnRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIp] != null) {
        entries[_IIp] = input[_IIp];
    }
    if (input[_As] != null) {
        entries[_As] = input[_As];
    }
    return entries;
};
const se_DeprovisionIpamPoolCidrRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    return entries;
};
const se_DeprovisionPublicIpv4PoolCidrRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PIo] != null) {
        entries[_PIo] = input[_PIo];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    return entries;
};
const se_DeregisterImageRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeregisterInstanceEventNotificationAttributesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ITA] != null) {
        const memberEntries = se_DeregisterInstanceTagAttributeRequest(input[_ITA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceTagAttribute.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeregisterInstanceTagAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_IATOI] != null) {
        entries[_IATOI] = input[_IATOI];
    }
    if (input[_ITK] != null) {
        const memberEntries = se_InstanceTagKeySet(input[_ITK], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceTagKey.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeregisterTransitGatewayMulticastGroupMembersRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_GIA] != null) {
        entries[_GIA] = input[_GIA];
    }
    if (input[_NIIe] != null) {
        const memberEntries = se_TransitGatewayNetworkInterfaceIdList(input[_NIIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DeregisterTransitGatewayMulticastGroupSourcesRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_GIA] != null) {
        entries[_GIA] = input[_GIA];
    }
    if (input[_NIIe] != null) {
        const memberEntries = se_TransitGatewayNetworkInterfaceIdList(input[_NIIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeAccountAttributesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_AN] != null) {
        const memberEntries = se_AccountAttributeNameStringList(input[_AN], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AttributeName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeAddressesAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_AIll] != null) {
        const memberEntries = se_AllocationIds(input[_AIll], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AllocationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeAddressesRequest = (input, context) => {
    const entries = {};
    if (input[_PIu] != null) {
        const memberEntries = se_PublicIpStringList(input[_PIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PublicIp.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AIll] != null) {
        const memberEntries = se_AllocationIdList(input[_AIll], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AllocationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeAddressTransfersRequest = (input, context) => {
    const entries = {};
    if (input[_AIll] != null) {
        const memberEntries = se_AllocationIdList(input[_AIll], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AllocationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeAggregateIdFormatRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeAvailabilityZonesRequest = (input, context) => {
    const entries = {};
    if (input[_ZN] != null) {
        const memberEntries = se_ZoneNameStringList(input[_ZN], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ZoneName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ZI] != null) {
        const memberEntries = se_ZoneIdStringList(input[_ZI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ZoneId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AAZ] != null) {
        entries[_AAZ] = input[_AAZ];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeAwsNetworkPerformanceMetricSubscriptionsRequest = (input, context) => {
    const entries = {};
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeBundleTasksRequest = (input, context) => {
    const entries = {};
    if (input[_BIun] != null) {
        const memberEntries = se_BundleIdStringList(input[_BIun], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BundleId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeByoipCidrsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeCapacityBlockExtensionHistoryRequest = (input, context) => {
    const entries = {};
    if (input[_CRIa] != null) {
        const memberEntries = se_CapacityReservationIdSet(input[_CRIa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeCapacityBlockExtensionOfferingsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CBEDH] != null) {
        entries[_CBEDH] = input[_CBEDH];
    }
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeCapacityBlockOfferingsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_SDR] != null) {
        entries[_SDR] = __serializeDateTime(input[_SDR]);
    }
    if (input[_EDR] != null) {
        entries[_EDR] = __serializeDateTime(input[_EDR]);
    }
    if (input[_CDH] != null) {
        entries[_CDH] = input[_CDH];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeCapacityReservationBillingRequestsRequest = (input, context) => {
    const entries = {};
    if (input[_CRIa] != null) {
        const memberEntries = se_CapacityReservationIdSet(input[_CRIa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Ro] != null) {
        entries[_Ro] = input[_Ro];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeCapacityReservationFleetsRequest = (input, context) => {
    const entries = {};
    if (input[_CRFI] != null) {
        const memberEntries = se_CapacityReservationFleetIdSet(input[_CRFI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationFleetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeCapacityReservationsRequest = (input, context) => {
    const entries = {};
    if (input[_CRIa] != null) {
        const memberEntries = se_CapacityReservationIdSet(input[_CRIa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeCarrierGatewaysRequest = (input, context) => {
    const entries = {};
    if (input[_CGIa] != null) {
        const memberEntries = se_CarrierGatewayIdSet(input[_CGIa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CarrierGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeClassicLinkInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeClientVpnAuthorizationRulesRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeClientVpnConnectionsRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeClientVpnEndpointsRequest = (input, context) => {
    const entries = {};
    if (input[_CVEIl] != null) {
        const memberEntries = se_ClientVpnEndpointIdList(input[_CVEIl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClientVpnEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeClientVpnRoutesRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeClientVpnTargetNetworksRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_AIs] != null) {
        const memberEntries = se_ValueStringList(input[_AIs], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AssociationIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeCoipPoolsRequest = (input, context) => {
    const entries = {};
    if (input[_PIoo] != null) {
        const memberEntries = se_CoipPoolIdSet(input[_PIoo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PoolId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeConversionTasksRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTIo] != null) {
        const memberEntries = se_ConversionIdStringList(input[_CTIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConversionTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeCustomerGatewaysRequest = (input, context) => {
    const entries = {};
    if (input[_CGIus] != null) {
        const memberEntries = se_CustomerGatewayIdStringList(input[_CGIus], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomerGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeDeclarativePoliciesReportsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_RIepo] != null) {
        const memberEntries = se_ValueStringList(input[_RIepo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReportId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeDhcpOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DOIh] != null) {
        const memberEntries = se_DhcpOptionsIdStringList(input[_DOIh], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DhcpOptionsId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeEgressOnlyInternetGatewaysRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_EOIGIg] != null) {
        const memberEntries = se_EgressOnlyInternetGatewayIdList(input[_EOIGIg], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EgressOnlyInternetGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeElasticGpusRequest = (input, context) => {
    const entries = {};
    if (input[_EGI] != null) {
        const memberEntries = se_ElasticGpuIdSet(input[_EGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ElasticGpuId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeExportImageTasksRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_EITI] != null) {
        const memberEntries = se_ExportImageTaskIdList(input[_EITI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExportImageTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeExportTasksRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ETIx] != null) {
        const memberEntries = se_ExportTaskIdStringList(input[_ETIx], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExportTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeFastLaunchImagesRequest = (input, context) => {
    const entries = {};
    if (input[_IImag] != null) {
        const memberEntries = se_FastLaunchImageIdList(input[_IImag], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ImageId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeFastSnapshotRestoresRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeFleetHistoryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ETv] != null) {
        entries[_ETv] = input[_ETv];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_FIl] != null) {
        entries[_FIl] = input[_FIl];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    return entries;
};
const se_DescribeFleetInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_FIl] != null) {
        entries[_FIl] = input[_FIl];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeFleetsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_FI] != null) {
        const memberEntries = se_FleetIdSet(input[_FI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FleetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeFlowLogsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fil] != null) {
        const memberEntries = se_FilterList(input[_Fil], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_FLI] != null) {
        const memberEntries = se_FlowLogIdList(input[_FLI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FlowLogId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeFpgaImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_FII] != null) {
        entries[_FII] = input[_FII];
    }
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    return entries;
};
const se_DescribeFpgaImagesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_FIIp] != null) {
        const memberEntries = se_FpgaImageIdList(input[_FIIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FpgaImageId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Ow] != null) {
        const memberEntries = se_OwnerStringList(input[_Ow], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Owner.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeHostReservationOfferingsRequest = (input, context) => {
    const entries = {};
    if (input[_Fil] != null) {
        const memberEntries = se_FilterList(input[_Fil], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MD] != null) {
        entries[_MD] = input[_MD];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_MDi] != null) {
        entries[_MDi] = input[_MDi];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_OI] != null) {
        entries[_OI] = input[_OI];
    }
    return entries;
};
const se_DescribeHostReservationsRequest = (input, context) => {
    const entries = {};
    if (input[_Fil] != null) {
        const memberEntries = se_FilterList(input[_Fil], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_HRIS] != null) {
        const memberEntries = se_HostReservationIdSet(input[_HRIS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HostReservationIdSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeHostsRequest = (input, context) => {
    const entries = {};
    if (input[_HI] != null) {
        const memberEntries = se_RequestHostIdList(input[_HI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HostId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fil] != null) {
        const memberEntries = se_FilterList(input[_Fil], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeIamInstanceProfileAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_AIs] != null) {
        const memberEntries = se_AssociationIdList(input[_AIs], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AssociationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeIdentityIdFormatRequest = (input, context) => {
    const entries = {};
    if (input[_Res] != null) {
        entries[_Res] = input[_Res];
    }
    if (input[_PAr] != null) {
        entries[_PAr] = input[_PAr];
    }
    return entries;
};
const se_DescribeIdFormatRequest = (input, context) => {
    const entries = {};
    if (input[_Res] != null) {
        entries[_Res] = input[_Res];
    }
    return entries;
};
const se_DescribeImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeImagesRequest = (input, context) => {
    const entries = {};
    if (input[_EU] != null) {
        const memberEntries = se_ExecutableByStringList(input[_EU], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExecutableBy.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IImag] != null) {
        const memberEntries = se_ImageIdStringList(input[_IImag], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ImageId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Ow] != null) {
        const memberEntries = se_OwnerStringList(input[_Ow], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Owner.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ID] != null) {
        entries[_ID] = input[_ID];
    }
    if (input[_IDn] != null) {
        entries[_IDn] = input[_IDn];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeImportImageTasksRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ITIm] != null) {
        const memberEntries = se_ImportTaskIdList(input[_ITIm], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ImportTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeImportSnapshotTasksRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ITIm] != null) {
        const memberEntries = se_ImportSnapshotTaskIdList(input[_ITIm], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ImportTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeInstanceAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    return entries;
};
const se_DescribeInstanceConnectEndpointsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ICEIn] != null) {
        const memberEntries = se_ValueStringList(input[_ICEIn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceConnectEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeInstanceCreditSpecificationsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeInstanceEventNotificationAttributesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeInstanceEventWindowsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IEWIn] != null) {
        const memberEntries = se_InstanceEventWindowIdSet(input[_IEWIn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceEventWindowId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeInstanceImageMetadataRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeInstanceStatusRequest = (input, context) => {
    const entries = {};
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IAI] != null) {
        entries[_IAI] = input[_IAI];
    }
    return entries;
};
const se_DescribeInstanceTopologyGroupNameSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DescribeInstanceTopologyInstanceIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DescribeInstanceTopologyRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_IIns] != null) {
        const memberEntries = se_DescribeInstanceTopologyInstanceIdSet(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_GNr] != null) {
        const memberEntries = se_DescribeInstanceTopologyGroupNameSet(input[_GNr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GroupName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeInstanceTypeOfferingsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_LT] != null) {
        entries[_LT] = input[_LT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeInstanceTypesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ITnst] != null) {
        const memberEntries = se_RequestInstanceTypeList(input[_ITnst], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeInternetGatewaysRequest = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IGIn] != null) {
        const memberEntries = se_InternetGatewayIdList(input[_IGIn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InternetGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeIpamByoasnRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeIpamExternalResourceVerificationTokensRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_IERVTIp] != null) {
        const memberEntries = se_ValueStringList(input[_IERVTIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpamExternalResourceVerificationTokenId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeIpamPoolsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_IPIp] != null) {
        const memberEntries = se_ValueStringList(input[_IPIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpamPoolId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeIpamResourceDiscoveriesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IRDIp] != null) {
        const memberEntries = se_ValueStringList(input[_IRDIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpamResourceDiscoveryId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeIpamResourceDiscoveryAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IRDAI] != null) {
        const memberEntries = se_ValueStringList(input[_IRDAI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpamResourceDiscoveryAssociationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeIpamScopesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_ISIp] != null) {
        const memberEntries = se_ValueStringList(input[_ISIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpamScopeId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeIpamsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_IIpa] != null) {
        const memberEntries = se_ValueStringList(input[_IIpa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpamId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeIpv6PoolsRequest = (input, context) => {
    const entries = {};
    if (input[_PIoo] != null) {
        const memberEntries = se_Ipv6PoolIdList(input[_PIoo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PoolId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeKeyPairsRequest = (input, context) => {
    const entries = {};
    if (input[_KNe] != null) {
        const memberEntries = se_KeyNameStringList(input[_KNe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `KeyName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_KPIe] != null) {
        const memberEntries = se_KeyPairIdStringList(input[_KPIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `KeyPairId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPK] != null) {
        entries[_IPK] = input[_IPK];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeLaunchTemplatesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_LTIa] != null) {
        const memberEntries = se_LaunchTemplateIdStringList(input[_LTIa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_LTNa] != null) {
        const memberEntries = se_LaunchTemplateNameStringList(input[_LTNa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeLaunchTemplateVersionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_LTI] != null) {
        entries[_LTI] = input[_LTI];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    if (input[_Ve] != null) {
        const memberEntries = se_VersionStringList(input[_Ve], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateVersion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MVi] != null) {
        entries[_MVi] = input[_MVi];
    }
    if (input[_MVa] != null) {
        entries[_MVa] = input[_MVa];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RAe] != null) {
        entries[_RAe] = input[_RAe];
    }
    return entries;
};
const se_DescribeLocalGatewayRouteTablesRequest = (input, context) => {
    const entries = {};
    if (input[_LGRTIo] != null) {
        const memberEntries = se_LocalGatewayRouteTableIdSet(input[_LGRTIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LocalGatewayRouteTableId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_LGRTVIGAIo] != null) {
        const memberEntries = se_LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet(input[_LGRTVIGAIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LocalGatewayRouteTableVirtualInterfaceGroupAssociationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeLocalGatewayRouteTableVpcAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_LGRTVAIo] != null) {
        const memberEntries = se_LocalGatewayRouteTableVpcAssociationIdSet(input[_LGRTVAIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LocalGatewayRouteTableVpcAssociationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeLocalGatewaysRequest = (input, context) => {
    const entries = {};
    if (input[_LGIo] != null) {
        const memberEntries = se_LocalGatewayIdSet(input[_LGIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LocalGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeLocalGatewayVirtualInterfaceGroupsRequest = (input, context) => {
    const entries = {};
    if (input[_LGVIGIo] != null) {
        const memberEntries = se_LocalGatewayVirtualInterfaceGroupIdSet(input[_LGVIGIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LocalGatewayVirtualInterfaceGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeLocalGatewayVirtualInterfacesRequest = (input, context) => {
    const entries = {};
    if (input[_LGVII] != null) {
        const memberEntries = se_LocalGatewayVirtualInterfaceIdSet(input[_LGVII], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LocalGatewayVirtualInterfaceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeLockedSnapshotsRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_SIna] != null) {
        const memberEntries = se_SnapshotIdStringList(input[_SIna], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SnapshotId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeMacHostsRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_HI] != null) {
        const memberEntries = se_RequestHostIdList(input[_HI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HostId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeManagedPrefixListsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_PLIr] != null) {
        const memberEntries = se_ValueStringList(input[_PLIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrefixListId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeMovingAddressesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PIu] != null) {
        const memberEntries = se_ValueStringList(input[_PIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PublicIp.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeNatGatewaysRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fil] != null) {
        const memberEntries = se_FilterList(input[_Fil], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NGIa] != null) {
        const memberEntries = se_NatGatewayIdStringList(input[_NGIa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NatGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeNetworkAclsRequest = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NAIe] != null) {
        const memberEntries = se_NetworkAclIdStringList(input[_NAIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkAclId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeNetworkInsightsAccessScopeAnalysesRequest = (input, context) => {
    const entries = {};
    if (input[_NIASAIe] != null) {
        const memberEntries = se_NetworkInsightsAccessScopeAnalysisIdList(input[_NIASAIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInsightsAccessScopeAnalysisId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NIASI] != null) {
        entries[_NIASI] = input[_NIASI];
    }
    if (input[_ASTB] != null) {
        entries[_ASTB] = __serializeDateTime(input[_ASTB]);
    }
    if (input[_ASTE] != null) {
        entries[_ASTE] = __serializeDateTime(input[_ASTE]);
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeNetworkInsightsAccessScopesRequest = (input, context) => {
    const entries = {};
    if (input[_NIASIe] != null) {
        const memberEntries = se_NetworkInsightsAccessScopeIdList(input[_NIASIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInsightsAccessScopeId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeNetworkInsightsAnalysesRequest = (input, context) => {
    const entries = {};
    if (input[_NIAIe] != null) {
        const memberEntries = se_NetworkInsightsAnalysisIdList(input[_NIAIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInsightsAnalysisId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NIPI] != null) {
        entries[_NIPI] = input[_NIPI];
    }
    if (input[_AST] != null) {
        entries[_AST] = __serializeDateTime(input[_AST]);
    }
    if (input[_AET] != null) {
        entries[_AET] = __serializeDateTime(input[_AET]);
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeNetworkInsightsPathsRequest = (input, context) => {
    const entries = {};
    if (input[_NIPIet] != null) {
        const memberEntries = se_NetworkInsightsPathIdList(input[_NIPIet], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInsightsPathId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeNetworkInterfaceAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    return entries;
};
const se_DescribeNetworkInterfacePermissionsRequest = (input, context) => {
    const entries = {};
    if (input[_NIPIetw] != null) {
        const memberEntries = se_NetworkInterfacePermissionIdList(input[_NIPIetw], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfacePermissionId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeNetworkInterfacesRequest = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NIIe] != null) {
        const memberEntries = se_NetworkInterfaceIdList(input[_NIIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribePlacementGroupsRequest = (input, context) => {
    const entries = {};
    if (input[_GIro] != null) {
        const memberEntries = se_PlacementGroupIdStringList(input[_GIro], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_GNr] != null) {
        const memberEntries = se_PlacementGroupStringList(input[_GNr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GroupName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribePrefixListsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_PLIr] != null) {
        const memberEntries = se_PrefixListResourceIdStringList(input[_PLIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrefixListId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribePrincipalIdFormatRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Re] != null) {
        const memberEntries = se_ResourceList(input[_Re], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Resource.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribePublicIpv4PoolsRequest = (input, context) => {
    const entries = {};
    if (input[_PIoo] != null) {
        const memberEntries = se_PublicIpv4PoolIdStringList(input[_PIoo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PoolId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeRegionsRequest = (input, context) => {
    const entries = {};
    if (input[_RNe] != null) {
        const memberEntries = se_RegionNameStringList(input[_RNe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RegionName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ARll] != null) {
        entries[_ARll] = input[_ARll];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeReplaceRootVolumeTasksRequest = (input, context) => {
    const entries = {};
    if (input[_RRVTI] != null) {
        const memberEntries = se_ReplaceRootVolumeTaskIds(input[_RRVTI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReplaceRootVolumeTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeReservedInstancesListingsRequest = (input, context) => {
    const entries = {};
    if (input[_RIIe] != null) {
        entries[_RIIe] = input[_RIIe];
    }
    if (input[_RILI] != null) {
        entries[_RILI] = input[_RILI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeReservedInstancesModificationsRequest = (input, context) => {
    const entries = {};
    if (input[_RIMI] != null) {
        const memberEntries = se_ReservedInstancesModificationIdStringList(input[_RIMI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReservedInstancesModificationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeReservedInstancesOfferingsRequest = (input, context) => {
    const entries = {};
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_IM] != null) {
        entries[_IM] = input[_IM];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_MD] != null) {
        entries[_MD] = input[_MD];
    }
    if (input[_MIC] != null) {
        entries[_MIC] = input[_MIC];
    }
    if (input[_MDi] != null) {
        entries[_MDi] = input[_MDi];
    }
    if (input[_OC] != null) {
        entries[_OC] = input[_OC];
    }
    if (input[_PDr] != null) {
        entries[_PDr] = input[_PDr];
    }
    if (input[_RIOI] != null) {
        const memberEntries = se_ReservedInstancesOfferingIdStringList(input[_RIOI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReservedInstancesOfferingId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ITns] != null) {
        entries[_ITns] = input[_ITns];
    }
    if (input[_OT] != null) {
        entries[_OT] = input[_OT];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeReservedInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_OC] != null) {
        entries[_OC] = input[_OC];
    }
    if (input[_RIIes] != null) {
        const memberEntries = se_ReservedInstancesIdStringList(input[_RIIes], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReservedInstancesId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_OT] != null) {
        entries[_OT] = input[_OT];
    }
    return entries;
};
const se_DescribeRouteServerEndpointsRequest = (input, context) => {
    const entries = {};
    if (input[_RSEIo] != null) {
        const memberEntries = se_RouteServerEndpointIdsList(input[_RSEIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RouteServerEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeRouteServerPeersRequest = (input, context) => {
    const entries = {};
    if (input[_RSPIo] != null) {
        const memberEntries = se_RouteServerPeerIdsList(input[_RSPIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RouteServerPeerId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeRouteServersRequest = (input, context) => {
    const entries = {};
    if (input[_RSIou] != null) {
        const memberEntries = se_RouteServerIdsList(input[_RSIou], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RouteServerId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeRouteTablesRequest = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RTIo] != null) {
        const memberEntries = se_RouteTableIdStringList(input[_RTIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RouteTableId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeScheduledInstanceAvailabilityRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_FSSTR] != null) {
        const memberEntries = se_SlotDateTimeRangeRequest(input[_FSSTR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FirstSlotStartTimeRange.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_MSDIH] != null) {
        entries[_MSDIH] = input[_MSDIH];
    }
    if (input[_MSDIHi] != null) {
        entries[_MSDIHi] = input[_MSDIHi];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Rec] != null) {
        const memberEntries = se_ScheduledInstanceRecurrenceRequest(input[_Rec], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Recurrence.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeScheduledInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_SIIc] != null) {
        const memberEntries = se_ScheduledInstanceIdRequestSet(input[_SIIc], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScheduledInstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SSTR] != null) {
        const memberEntries = se_SlotStartTimeRangeRequest(input[_SSTR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SlotStartTimeRange.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeSecurityGroupReferencesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_GIr] != null) {
        const memberEntries = se_GroupIds(input[_GIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeSecurityGroupRulesRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SGRI] != null) {
        const memberEntries = se_SecurityGroupRuleIdList(input[_SGRI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupRuleId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeSecurityGroupsRequest = (input, context) => {
    const entries = {};
    if (input[_GIro] != null) {
        const memberEntries = se_GroupIdStringList(input[_GIro], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_GNr] != null) {
        const memberEntries = se_GroupNameStringList(input[_GNr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GroupName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeSecurityGroupVpcAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeSnapshotAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeSnapshotsRequest = (input, context) => {
    const entries = {};
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_OIw] != null) {
        const memberEntries = se_OwnerStringList(input[_OIw], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Owner.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RBUI] != null) {
        const memberEntries = se_RestorableByStringList(input[_RBUI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RestorableBy.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SIna] != null) {
        const memberEntries = se_SnapshotIdStringList(input[_SIna], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SnapshotId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeSnapshotTierStatusRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeSpotDatafeedSubscriptionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeSpotFleetInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SFRIp] != null) {
        entries[_SFRIp] = input[_SFRIp];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeSpotFleetRequestHistoryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SFRIp] != null) {
        entries[_SFRIp] = input[_SFRIp];
    }
    if (input[_ETv] != null) {
        entries[_ETv] = input[_ETv];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeSpotFleetRequestsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SFRI] != null) {
        const memberEntries = se_SpotFleetRequestIdList(input[_SFRI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SpotFleetRequestId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeSpotInstanceRequestsRequest = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIRI] != null) {
        const memberEntries = se_SpotInstanceRequestIdList(input[_SIRI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SpotInstanceRequestId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeSpotPriceHistoryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ETn] != null) {
        entries[_ETn] = __serializeDateTime(input[_ETn]);
    }
    if (input[_ITnst] != null) {
        const memberEntries = se_InstanceTypeList(input[_ITnst], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PDro] != null) {
        const memberEntries = se_ProductDescriptionList(input[_PDro], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ProductDescription.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeStaleSecurityGroupsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_DescribeStoreImageTasksRequest = (input, context) => {
    const entries = {};
    if (input[_IImag] != null) {
        const memberEntries = se_ImageIdList(input[_IImag], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ImageId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeSubnetsRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SIu] != null) {
        const memberEntries = se_SubnetIdStringList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTagsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeTrafficMirrorFilterRulesRequest = (input, context) => {
    const entries = {};
    if (input[_TMFRIr] != null) {
        const memberEntries = se_TrafficMirrorFilterRuleIdList(input[_TMFRIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrafficMirrorFilterRuleId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TMFI] != null) {
        entries[_TMFI] = input[_TMFI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeTrafficMirrorFiltersRequest = (input, context) => {
    const entries = {};
    if (input[_TMFIr] != null) {
        const memberEntries = se_TrafficMirrorFilterIdList(input[_TMFIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrafficMirrorFilterId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeTrafficMirrorSessionsRequest = (input, context) => {
    const entries = {};
    if (input[_TMSIr] != null) {
        const memberEntries = se_TrafficMirrorSessionIdList(input[_TMSIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrafficMirrorSessionId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeTrafficMirrorTargetsRequest = (input, context) => {
    const entries = {};
    if (input[_TMTIr] != null) {
        const memberEntries = se_TrafficMirrorTargetIdList(input[_TMTIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrafficMirrorTargetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeTransitGatewayAttachmentsRequest = (input, context) => {
    const entries = {};
    if (input[_TGAIr] != null) {
        const memberEntries = se_TransitGatewayAttachmentIdStringList(input[_TGAIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTransitGatewayConnectPeersRequest = (input, context) => {
    const entries = {};
    if (input[_TGCPIr] != null) {
        const memberEntries = se_TransitGatewayConnectPeerIdStringList(input[_TGCPIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayConnectPeerIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTransitGatewayConnectsRequest = (input, context) => {
    const entries = {};
    if (input[_TGAIr] != null) {
        const memberEntries = se_TransitGatewayAttachmentIdStringList(input[_TGAIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTransitGatewayMulticastDomainsRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDIr] != null) {
        const memberEntries = se_TransitGatewayMulticastDomainIdStringList(input[_TGMDIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayMulticastDomainIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTransitGatewayPeeringAttachmentsRequest = (input, context) => {
    const entries = {};
    if (input[_TGAIr] != null) {
        const memberEntries = se_TransitGatewayAttachmentIdStringList(input[_TGAIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTransitGatewayPolicyTablesRequest = (input, context) => {
    const entries = {};
    if (input[_TGPTIr] != null) {
        const memberEntries = se_TransitGatewayPolicyTableIdStringList(input[_TGPTIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayPolicyTableIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTransitGatewayRouteTableAnnouncementsRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTAIr] != null) {
        const memberEntries = se_TransitGatewayRouteTableAnnouncementIdStringList(input[_TGRTAIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayRouteTableAnnouncementIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTransitGatewayRouteTablesRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTIr] != null) {
        const memberEntries = se_TransitGatewayRouteTableIdStringList(input[_TGRTIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayRouteTableIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTransitGatewaysRequest = (input, context) => {
    const entries = {};
    if (input[_TGIr] != null) {
        const memberEntries = se_TransitGatewayIdStringList(input[_TGIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTransitGatewayVpcAttachmentsRequest = (input, context) => {
    const entries = {};
    if (input[_TGAIr] != null) {
        const memberEntries = se_TransitGatewayAttachmentIdStringList(input[_TGAIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeTrunkInterfaceAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_AIs] != null) {
        const memberEntries = se_TrunkInterfaceAssociationIdList(input[_AIs], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AssociationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeVerifiedAccessEndpointsRequest = (input, context) => {
    const entries = {};
    if (input[_VAEIe] != null) {
        const memberEntries = se_VerifiedAccessEndpointIdList(input[_VAEIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VerifiedAccessEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VAII] != null) {
        entries[_VAII] = input[_VAII];
    }
    if (input[_VAGI] != null) {
        entries[_VAGI] = input[_VAGI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeVerifiedAccessGroupsRequest = (input, context) => {
    const entries = {};
    if (input[_VAGIe] != null) {
        const memberEntries = se_VerifiedAccessGroupIdList(input[_VAGIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VerifiedAccessGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VAII] != null) {
        entries[_VAII] = input[_VAII];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeVerifiedAccessInstanceLoggingConfigurationsRequest = (input, context) => {
    const entries = {};
    if (input[_VAIIe] != null) {
        const memberEntries = se_VerifiedAccessInstanceIdList(input[_VAIIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VerifiedAccessInstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeVerifiedAccessInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_VAIIe] != null) {
        const memberEntries = se_VerifiedAccessInstanceIdList(input[_VAIIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VerifiedAccessInstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeVerifiedAccessTrustProvidersRequest = (input, context) => {
    const entries = {};
    if (input[_VATPIe] != null) {
        const memberEntries = se_VerifiedAccessTrustProviderIdList(input[_VATPIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VerifiedAccessTrustProviderId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeVolumeAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_VIo] != null) {
        entries[_VIo] = input[_VIo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeVolumesModificationsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VIol] != null) {
        const memberEntries = se_VolumeIdStringList(input[_VIol], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VolumeId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeVolumesRequest = (input, context) => {
    const entries = {};
    if (input[_VIol] != null) {
        const memberEntries = se_VolumeIdStringList(input[_VIol], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VolumeId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeVolumeStatusRequest = (input, context) => {
    const entries = {};
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_VIol] != null) {
        const memberEntries = se_VolumeIdStringList(input[_VIol], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VolumeId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeVpcAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeVpcBlockPublicAccessExclusionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_EIxcl] != null) {
        const memberEntries = se_VpcBlockPublicAccessExclusionIdList(input[_EIxcl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExclusionId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeVpcBlockPublicAccessOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeVpcClassicLinkDnsSupportRequest = (input, context) => {
    const entries = {};
    if (input[_VIp] != null) {
        const memberEntries = se_VpcClassicLinkIdList(input[_VIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeVpcClassicLinkRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VIp] != null) {
        const memberEntries = se_VpcClassicLinkIdList(input[_VIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeVpcEndpointAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VEI] != null) {
        const memberEntries = se_VpcEndpointIdList(input[_VEI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeVpcEndpointConnectionNotificationsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CNIon] != null) {
        entries[_CNIon] = input[_CNIon];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeVpcEndpointConnectionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeVpcEndpointServiceConfigurationsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIer] != null) {
        const memberEntries = se_VpcEndpointServiceIdList(input[_SIer], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeVpcEndpointServicePermissionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIe] != null) {
        entries[_SIe] = input[_SIe];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeVpcEndpointServicesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SNer] != null) {
        const memberEntries = se_ValueStringList(input[_SNer], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_SRer] != null) {
        const memberEntries = se_ValueStringList(input[_SRer], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceRegion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeVpcEndpointsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VEI] != null) {
        const memberEntries = se_VpcEndpointIdList(input[_VEI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeVpcPeeringConnectionsRequest = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VPCIp] != null) {
        const memberEntries = se_VpcPeeringConnectionIdList(input[_VPCIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcPeeringConnectionId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeVpcsRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VIp] != null) {
        const memberEntries = se_VpcIdStringList(input[_VIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeVpnConnectionsRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VCIp] != null) {
        const memberEntries = se_VpnConnectionIdStringList(input[_VCIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpnConnectionId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DescribeVpnGatewaysRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VGIp] != null) {
        const memberEntries = se_VpnGatewayIdStringList(input[_VGIp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpnGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DestinationOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_FF] != null) {
        entries[_FF] = input[_FF];
    }
    if (input[_HCP] != null) {
        entries[_HCP] = input[_HCP];
    }
    if (input[_PHP] != null) {
        entries[_PHP] = input[_PHP];
    }
    return entries;
};
const se_DetachClassicLinkVpcRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_DetachInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IGI] != null) {
        entries[_IGI] = input[_IGI];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_DetachNetworkInterfaceRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_AIt] != null) {
        entries[_AIt] = input[_AIt];
    }
    if (input[_F] != null) {
        entries[_F] = input[_F];
    }
    return entries;
};
const se_DetachVerifiedAccessTrustProviderRequest = (input, context) => {
    const entries = {};
    if (input[_VAII] != null) {
        entries[_VAII] = input[_VAII];
    }
    if (input[_VATPI] != null) {
        entries[_VATPI] = input[_VATPI];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DetachVolumeRequest = (input, context) => {
    const entries = {};
    if (input[_Dev] != null) {
        entries[_Dev] = input[_Dev];
    }
    if (input[_F] != null) {
        entries[_F] = input[_F];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_VIo] != null) {
        entries[_VIo] = input[_VIo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DetachVpnGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_VGI] != null) {
        entries[_VGI] = input[_VGI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DhcpOptionsIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`DhcpOptionsId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DirectoryServiceAuthenticationRequest = (input, context) => {
    const entries = {};
    if (input[_DIir] != null) {
        entries[_DIir] = input[_DIir];
    }
    return entries;
};
const se_DisableAddressTransferRequest = (input, context) => {
    const entries = {};
    if (input[_AIl] != null) {
        entries[_AIl] = input[_AIl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableAllowedImagesSettingsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableAwsNetworkPerformanceMetricSubscriptionRequest = (input, context) => {
    const entries = {};
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_Met] != null) {
        entries[_Met] = input[_Met];
    }
    if (input[_Sta] != null) {
        entries[_Sta] = input[_Sta];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableEbsEncryptionByDefaultRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableFastLaunchRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_F] != null) {
        entries[_F] = input[_F];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableFastSnapshotRestoresRequest = (input, context) => {
    const entries = {};
    if (input[_AZv] != null) {
        const memberEntries = se_AvailabilityZoneStringList(input[_AZv], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZone.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SSIo] != null) {
        const memberEntries = se_SnapshotIdStringList(input[_SSIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceSnapshotId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableImageBlockPublicAccessRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableImageDeprecationRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableImageDeregistrationProtectionRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableImageRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableIpamOrganizationAdminAccountRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_DAAI] != null) {
        entries[_DAAI] = input[_DAAI];
    }
    return entries;
};
const se_DisableRouteServerPropagationRequest = (input, context) => {
    const entries = {};
    if (input[_RSIo] != null) {
        entries[_RSIo] = input[_RSIo];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableSerialConsoleAccessRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableSnapshotBlockPublicAccessRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableTransitGatewayRouteTablePropagationRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_TGRTAI] != null) {
        entries[_TGRTAI] = input[_TGRTAI];
    }
    return entries;
};
const se_DisableVgwRoutePropagationRequest = (input, context) => {
    const entries = {};
    if (input[_GI] != null) {
        entries[_GI] = input[_GI];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisableVpcClassicLinkDnsSupportRequest = (input, context) => {
    const entries = {};
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_DisableVpcClassicLinkRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_DisassociateAddressRequest = (input, context) => {
    const entries = {};
    if (input[_AIss] != null) {
        entries[_AIss] = input[_AIss];
    }
    if (input[_PI] != null) {
        entries[_PI] = input[_PI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisassociateCapacityReservationBillingOwnerRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    if (input[_URBOI] != null) {
        entries[_URBOI] = input[_URBOI];
    }
    return entries;
};
const se_DisassociateClientVpnTargetNetworkRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_AIss] != null) {
        entries[_AIss] = input[_AIss];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisassociateEnclaveCertificateIamRoleRequest = (input, context) => {
    const entries = {};
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    if (input[_RAo] != null) {
        entries[_RAo] = input[_RAo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisassociateIamInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input[_AIss] != null) {
        entries[_AIss] = input[_AIss];
    }
    return entries;
};
const se_DisassociateInstanceEventWindowRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IEWI] != null) {
        entries[_IEWI] = input[_IEWI];
    }
    if (input[_AT] != null) {
        const memberEntries = se_InstanceEventWindowDisassociationRequest(input[_AT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AssociationTarget.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DisassociateIpamByoasnRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_As] != null) {
        entries[_As] = input[_As];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    return entries;
};
const se_DisassociateIpamResourceDiscoveryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IRDAIp] != null) {
        entries[_IRDAIp] = input[_IRDAIp];
    }
    return entries;
};
const se_DisassociateNatGatewayAddressRequest = (input, context) => {
    const entries = {};
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    if (input[_AIs] != null) {
        const memberEntries = se_EipAssociationIdList(input[_AIs], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AssociationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MDDS] != null) {
        entries[_MDDS] = input[_MDDS];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisassociateRouteServerRequest = (input, context) => {
    const entries = {};
    if (input[_RSIo] != null) {
        entries[_RSIo] = input[_RSIo];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisassociateRouteTableRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_AIss] != null) {
        entries[_AIss] = input[_AIss];
    }
    return entries;
};
const se_DisassociateSecurityGroupVpcRequest = (input, context) => {
    const entries = {};
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisassociateSubnetCidrBlockRequest = (input, context) => {
    const entries = {};
    if (input[_AIss] != null) {
        entries[_AIss] = input[_AIss];
    }
    return entries;
};
const se_DisassociateTransitGatewayMulticastDomainRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_TransitGatewaySubnetIdList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisassociateTransitGatewayPolicyTableRequest = (input, context) => {
    const entries = {};
    if (input[_TGPTI] != null) {
        entries[_TGPTI] = input[_TGPTI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisassociateTransitGatewayRouteTableRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisassociateTrunkInterfaceRequest = (input, context) => {
    const entries = {};
    if (input[_AIss] != null) {
        entries[_AIss] = input[_AIss];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_DisassociateVpcCidrBlockRequest = (input, context) => {
    const entries = {};
    if (input[_AIss] != null) {
        entries[_AIss] = input[_AIss];
    }
    return entries;
};
const se_DiskImage = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_Im] != null) {
        const memberEntries = se_DiskImageDetail(input[_Im], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Image.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Vo] != null) {
        const memberEntries = se_VolumeDetail(input[_Vo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Volume.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DiskImageDetail = (input, context) => {
    const entries = {};
    if (input[_Fo] != null) {
        entries[_Fo] = input[_Fo];
    }
    if (input[_By] != null) {
        entries[_By] = input[_By];
    }
    if (input[_IMU] != null) {
        entries[_IMU] = input[_IMU];
    }
    return entries;
};
const se_DiskImageList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_DiskImage(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_DnsOptionsSpecification = (input, context) => {
    const entries = {};
    if (input[_DRIT] != null) {
        entries[_DRIT] = input[_DRIT];
    }
    if (input[_PDOFIRE] != null) {
        entries[_PDOFIRE] = input[_PDOFIRE];
    }
    return entries;
};
const se_DnsServersOptionsModifyStructure = (input, context) => {
    const entries = {};
    if (input[_CDSu] != null) {
        const memberEntries = se_ValueStringList(input[_CDSu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomDnsServers.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    return entries;
};
const se_EbsBlockDevice = (input, context) => {
    const entries = {};
    if (input[_DOT] != null) {
        entries[_DOT] = input[_DOT];
    }
    if (input[_Io] != null) {
        entries[_Io] = input[_Io];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_VS] != null) {
        entries[_VS] = input[_VS];
    }
    if (input[_VT] != null) {
        entries[_VT] = input[_VT];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_Th] != null) {
        entries[_Th] = input[_Th];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_Enc] != null) {
        entries[_Enc] = input[_Enc];
    }
    return entries;
};
const se_EbsInstanceBlockDeviceSpecification = (input, context) => {
    const entries = {};
    if (input[_VIo] != null) {
        entries[_VIo] = input[_VIo];
    }
    if (input[_DOT] != null) {
        entries[_DOT] = input[_DOT];
    }
    return entries;
};
const se_EgressOnlyInternetGatewayIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_EipAssociationIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ElasticGpuIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ElasticGpuSpecification = (input, context) => {
    const entries = {};
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    return entries;
};
const se_ElasticGpuSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ElasticGpuSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`ElasticGpuSpecification.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ElasticGpuSpecifications = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ElasticGpuSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ElasticInferenceAccelerator = (input, context) => {
    const entries = {};
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_Cou] != null) {
        entries[_Cou] = input[_Cou];
    }
    return entries;
};
const se_ElasticInferenceAccelerators = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ElasticInferenceAccelerator(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_EnableAddressTransferRequest = (input, context) => {
    const entries = {};
    if (input[_AIl] != null) {
        entries[_AIl] = input[_AIl];
    }
    if (input[_TAI] != null) {
        entries[_TAI] = input[_TAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableAllowedImagesSettingsRequest = (input, context) => {
    const entries = {};
    if (input[_AISS] != null) {
        entries[_AISS] = input[_AISS];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableAwsNetworkPerformanceMetricSubscriptionRequest = (input, context) => {
    const entries = {};
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_Met] != null) {
        entries[_Met] = input[_Met];
    }
    if (input[_Sta] != null) {
        entries[_Sta] = input[_Sta];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableEbsEncryptionByDefaultRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableFastLaunchRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_RT] != null) {
        entries[_RT] = input[_RT];
    }
    if (input[_SCn] != null) {
        const memberEntries = se_FastLaunchSnapshotConfigurationRequest(input[_SCn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SnapshotConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LTa] != null) {
        const memberEntries = se_FastLaunchLaunchTemplateSpecificationRequest(input[_LTa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MPL] != null) {
        entries[_MPL] = input[_MPL];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableFastSnapshotRestoresRequest = (input, context) => {
    const entries = {};
    if (input[_AZv] != null) {
        const memberEntries = se_AvailabilityZoneStringList(input[_AZv], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZone.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SSIo] != null) {
        const memberEntries = se_SnapshotIdStringList(input[_SSIo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceSnapshotId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableImageBlockPublicAccessRequest = (input, context) => {
    const entries = {};
    if (input[_IBPAS] != null) {
        entries[_IBPAS] = input[_IBPAS];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableImageDeprecationRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DAe] != null) {
        entries[_DAe] = __serializeDateTime(input[_DAe]);
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableImageDeregistrationProtectionRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_WC] != null) {
        entries[_WC] = input[_WC];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableImageRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableIpamOrganizationAdminAccountRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_DAAI] != null) {
        entries[_DAAI] = input[_DAAI];
    }
    return entries;
};
const se_EnableReachabilityAnalyzerOrganizationSharingRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableRouteServerPropagationRequest = (input, context) => {
    const entries = {};
    if (input[_RSIo] != null) {
        entries[_RSIo] = input[_RSIo];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableSerialConsoleAccessRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableSnapshotBlockPublicAccessRequest = (input, context) => {
    const entries = {};
    if (input[_Stat] != null) {
        entries[_Stat] = input[_Stat];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableTransitGatewayRouteTablePropagationRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_TGRTAI] != null) {
        entries[_TGRTAI] = input[_TGRTAI];
    }
    return entries;
};
const se_EnableVgwRoutePropagationRequest = (input, context) => {
    const entries = {};
    if (input[_GI] != null) {
        entries[_GI] = input[_GI];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_EnableVolumeIORequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VIo] != null) {
        entries[_VIo] = input[_VIo];
    }
    return entries;
};
const se_EnableVpcClassicLinkDnsSupportRequest = (input, context) => {
    const entries = {};
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_EnableVpcClassicLinkRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    return entries;
};
const se_EnaSrdSpecification = (input, context) => {
    const entries = {};
    if (input[_ESE] != null) {
        entries[_ESE] = input[_ESE];
    }
    if (input[_ESUS] != null) {
        const memberEntries = se_EnaSrdUdpSpecification(input[_ESUS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnaSrdUdpSpecification.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EnaSrdSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_ESE] != null) {
        entries[_ESE] = input[_ESE];
    }
    if (input[_ESUS] != null) {
        const memberEntries = se_EnaSrdUdpSpecificationRequest(input[_ESUS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnaSrdUdpSpecification.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EnaSrdUdpSpecification = (input, context) => {
    const entries = {};
    if (input[_ESUE] != null) {
        entries[_ESUE] = input[_ESUE];
    }
    return entries;
};
const se_EnaSrdUdpSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_ESUE] != null) {
        entries[_ESUE] = input[_ESUE];
    }
    return entries;
};
const se_EnclaveOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    return entries;
};
const se_ExcludedInstanceTypeSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ExecutableByStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ExecutableBy.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ExportClientVpnClientCertificateRevocationListRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ExportClientVpnClientConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ExportImageRequest = (input, context) => {
    const entries = {};
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DIFi] != null) {
        entries[_DIFi] = input[_DIFi];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_SEL] != null) {
        const memberEntries = se_ExportTaskS3LocationRequest(input[_SEL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `S3ExportLocation.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RNo] != null) {
        entries[_RNo] = input[_RNo];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ExportImageTaskIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ExportImageTaskId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ExportTaskIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ExportTaskId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ExportTaskS3LocationRequest = (input, context) => {
    const entries = {};
    if (input[_SB] != null) {
        entries[_SB] = input[_SB];
    }
    if (input[_SP] != null) {
        entries[_SP] = input[_SP];
    }
    return entries;
};
const se_ExportToS3TaskSpecification = (input, context) => {
    const entries = {};
    if (input[_DIFi] != null) {
        entries[_DIFi] = input[_DIFi];
    }
    if (input[_CFo] != null) {
        entries[_CFo] = input[_CFo];
    }
    if (input[_SB] != null) {
        entries[_SB] = input[_SB];
    }
    if (input[_SP] != null) {
        entries[_SP] = input[_SP];
    }
    return entries;
};
const se_ExportTransitGatewayRoutesRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SB] != null) {
        entries[_SB] = input[_SB];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ExportVerifiedAccessInstanceClientConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_VAII] != null) {
        entries[_VAII] = input[_VAII];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_FastLaunchImageIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ImageId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_FastLaunchLaunchTemplateSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_LTI] != null) {
        entries[_LTI] = input[_LTI];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    if (input[_V] != null) {
        entries[_V] = input[_V];
    }
    return entries;
};
const se_FastLaunchSnapshotConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_TRC] != null) {
        entries[_TRC] = input[_TRC];
    }
    return entries;
};
const se_FederatedAuthenticationRequest = (input, context) => {
    const entries = {};
    if (input[_SAMLPA] != null) {
        entries[_SAMLPA] = input[_SAMLPA];
    }
    if (input[_SSSAMLPA] != null) {
        entries[_SSSAMLPA] = input[_SSSAMLPA];
    }
    return entries;
};
const se_Filter = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_Val] != null) {
        const memberEntries = se_ValueStringList(input[_Val], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Value.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_FilterList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Filter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Filter.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_FleetBlockDeviceMappingRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_VN] != null) {
        entries[_VN] = input[_VN];
    }
    if (input[_E] != null) {
        const memberEntries = se_FleetEbsBlockDeviceRequest(input[_E], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ebs.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ND] != null) {
        entries[_ND] = input[_ND];
    }
    return entries;
};
const se_FleetBlockDeviceMappingRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_FleetBlockDeviceMappingRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`BlockDeviceMapping.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_FleetEbsBlockDeviceRequest = (input, context) => {
    const entries = {};
    if (input[_Enc] != null) {
        entries[_Enc] = input[_Enc];
    }
    if (input[_DOT] != null) {
        entries[_DOT] = input[_DOT];
    }
    if (input[_Io] != null) {
        entries[_Io] = input[_Io];
    }
    if (input[_Th] != null) {
        entries[_Th] = input[_Th];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_VS] != null) {
        entries[_VS] = input[_VS];
    }
    if (input[_VT] != null) {
        entries[_VT] = input[_VT];
    }
    return entries;
};
const se_FleetIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_FleetLaunchTemplateConfigListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_FleetLaunchTemplateConfigRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_FleetLaunchTemplateConfigRequest = (input, context) => {
    const entries = {};
    if (input[_LTS] != null) {
        const memberEntries = se_FleetLaunchTemplateSpecificationRequest(input[_LTS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ov] != null) {
        const memberEntries = se_FleetLaunchTemplateOverridesListRequest(input[_Ov], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Overrides.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_FleetLaunchTemplateOverridesListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_FleetLaunchTemplateOverridesRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_FleetLaunchTemplateOverridesRequest = (input, context) => {
    const entries = {};
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_MPa] != null) {
        entries[_MPa] = input[_MPa];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_WCe] != null) {
        entries[_WCe] = __serializeFloat(input[_WCe]);
    }
    if (input[_Pri] != null) {
        entries[_Pri] = __serializeFloat(input[_Pri]);
    }
    if (input[_Pl] != null) {
        const memberEntries = se_Placement(input[_Pl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Placement.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_BDM] != null) {
        const memberEntries = se_FleetBlockDeviceMappingRequestList(input[_BDM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IR] != null) {
        const memberEntries = se_InstanceRequirementsRequest(input[_IR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRequirements.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    return entries;
};
const se_FleetLaunchTemplateSpecification = (input, context) => {
    const entries = {};
    if (input[_LTI] != null) {
        entries[_LTI] = input[_LTI];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    if (input[_V] != null) {
        entries[_V] = input[_V];
    }
    return entries;
};
const se_FleetLaunchTemplateSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_LTI] != null) {
        entries[_LTI] = input[_LTI];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    if (input[_V] != null) {
        entries[_V] = input[_V];
    }
    return entries;
};
const se_FleetSpotCapacityRebalanceRequest = (input, context) => {
    const entries = {};
    if (input[_RS] != null) {
        entries[_RS] = input[_RS];
    }
    if (input[_TDe] != null) {
        entries[_TDe] = input[_TDe];
    }
    return entries;
};
const se_FleetSpotMaintenanceStrategiesRequest = (input, context) => {
    const entries = {};
    if (input[_CRap] != null) {
        const memberEntries = se_FleetSpotCapacityRebalanceRequest(input[_CRap], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityRebalance.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_FlowLogIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_FlowLogResourceIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_FpgaImageIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_GetAllowedImagesSettingsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetAssociatedEnclaveCertificateIamRolesRequest = (input, context) => {
    const entries = {};
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetAssociatedIpv6PoolCidrsRequest = (input, context) => {
    const entries = {};
    if (input[_PIo] != null) {
        entries[_PIo] = input[_PIo];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetAwsNetworkPerformanceDataRequest = (input, context) => {
    const entries = {};
    if (input[_DQ] != null) {
        const memberEntries = se_DataQueries(input[_DQ], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DataQuery.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ETn] != null) {
        entries[_ETn] = __serializeDateTime(input[_ETn]);
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetCapacityReservationUsageRequest = (input, context) => {
    const entries = {};
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetCoipPoolUsageRequest = (input, context) => {
    const entries = {};
    if (input[_PIo] != null) {
        entries[_PIo] = input[_PIo];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetConsoleOutputRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_La] != null) {
        entries[_La] = input[_La];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetConsoleScreenshotRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_WU] != null) {
        entries[_WU] = input[_WU];
    }
    return entries;
};
const se_GetDeclarativePoliciesReportSummaryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RIep] != null) {
        entries[_RIep] = input[_RIep];
    }
    return entries;
};
const se_GetDefaultCreditSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IF] != null) {
        entries[_IF] = input[_IF];
    }
    return entries;
};
const se_GetEbsDefaultKmsKeyIdRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetEbsEncryptionByDefaultRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetFlowLogsIntegrationTemplateRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_FLIl] != null) {
        entries[_FLIl] = input[_FLIl];
    }
    if (input[_CDSDA] != null) {
        entries[_CDSDA] = input[_CDSDA];
    }
    if (input[_ISnt] != null) {
        const memberEntries = se_IntegrateServices(input[_ISnt], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IntegrateService.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetGroupsForCapacityReservationRequest = (input, context) => {
    const entries = {};
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetHostReservationPurchasePreviewRequest = (input, context) => {
    const entries = {};
    if (input[_HIS] != null) {
        const memberEntries = se_RequestHostIdSet(input[_HIS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HostIdSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_OI] != null) {
        entries[_OI] = input[_OI];
    }
    return entries;
};
const se_GetImageBlockPublicAccessStateRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetInstanceMetadataDefaultsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetInstanceTpmEkPubRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_KT] != null) {
        entries[_KT] = input[_KT];
    }
    if (input[_KF] != null) {
        entries[_KF] = input[_KF];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetInstanceTypesFromInstanceRequirementsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ATr] != null) {
        const memberEntries = se_ArchitectureTypeSet(input[_ATr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ArchitectureType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VTi] != null) {
        const memberEntries = se_VirtualizationTypeSet(input[_VTi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VirtualizationType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IR] != null) {
        const memberEntries = se_InstanceRequirementsRequest(input[_IR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRequirements.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_GetInstanceUefiDataRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetIpamAddressHistoryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_ISI] != null) {
        entries[_ISI] = input[_ISI];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ETn] != null) {
        entries[_ETn] = __serializeDateTime(input[_ETn]);
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_GetIpamDiscoveredAccountsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IRDI] != null) {
        entries[_IRDI] = input[_IRDI];
    }
    if (input[_DRi] != null) {
        entries[_DRi] = input[_DRi];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_GetIpamDiscoveredPublicAddressesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IRDI] != null) {
        entries[_IRDI] = input[_IRDI];
    }
    if (input[_ARd] != null) {
        entries[_ARd] = input[_ARd];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_GetIpamDiscoveredResourceCidrsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IRDI] != null) {
        entries[_IRDI] = input[_IRDI];
    }
    if (input[_RRe] != null) {
        entries[_RRe] = input[_RRe];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_GetIpamPoolAllocationsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_IPAI] != null) {
        entries[_IPAI] = input[_IPAI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_GetIpamPoolCidrsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_GetIpamResourceCidrsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_ISI] != null) {
        entries[_ISI] = input[_ISI];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_RIeso] != null) {
        entries[_RIeso] = input[_RIeso];
    }
    if (input[_RT] != null) {
        entries[_RT] = input[_RT];
    }
    if (input[_RTes] != null) {
        const memberEntries = se_RequestIpamResourceTag(input[_RTes], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceTag.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ROe] != null) {
        entries[_ROe] = input[_ROe];
    }
    return entries;
};
const se_GetLaunchTemplateDataRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    return entries;
};
const se_GetManagedPrefixListAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PLI] != null) {
        entries[_PLI] = input[_PLI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_GetManagedPrefixListEntriesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PLI] != null) {
        entries[_PLI] = input[_PLI];
    }
    if (input[_TV] != null) {
        entries[_TV] = input[_TV];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_GetNetworkInsightsAccessScopeAnalysisFindingsRequest = (input, context) => {
    const entries = {};
    if (input[_NIASAI] != null) {
        entries[_NIASAI] = input[_NIASAI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetNetworkInsightsAccessScopeContentRequest = (input, context) => {
    const entries = {};
    if (input[_NIASI] != null) {
        entries[_NIASI] = input[_NIASI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetPasswordDataRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetReservedInstancesExchangeQuoteRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RII] != null) {
        const memberEntries = se_ReservedInstanceIdSet(input[_RII], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReservedInstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TC] != null) {
        const memberEntries = se_TargetConfigurationRequestSet(input[_TC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetConfiguration.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetRouteServerAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_RSIo] != null) {
        entries[_RSIo] = input[_RSIo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetRouteServerPropagationsRequest = (input, context) => {
    const entries = {};
    if (input[_RSIo] != null) {
        entries[_RSIo] = input[_RSIo];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetRouteServerRoutingDatabaseRequest = (input, context) => {
    const entries = {};
    if (input[_RSIo] != null) {
        entries[_RSIo] = input[_RSIo];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetSecurityGroupsForVpcRequest = (input, context) => {
    const entries = {};
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetSerialConsoleAccessStatusRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetSnapshotBlockPublicAccessStateRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetSpotPlacementScoresRequest = (input, context) => {
    const entries = {};
    if (input[_ITnst] != null) {
        const memberEntries = se_InstanceTypes(input[_ITnst], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TCa] != null) {
        entries[_TCa] = input[_TCa];
    }
    if (input[_TCUT] != null) {
        entries[_TCUT] = input[_TCUT];
    }
    if (input[_SAZ] != null) {
        entries[_SAZ] = input[_SAZ];
    }
    if (input[_RNe] != null) {
        const memberEntries = se_RegionNames(input[_RNe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RegionName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IRWM] != null) {
        const memberEntries = se_InstanceRequirementsWithMetadataRequest(input[_IRWM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRequirementsWithMetadata.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_GetSubnetCidrReservationsRequest = (input, context) => {
    const entries = {};
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_GetTransitGatewayAttachmentPropagationsRequest = (input, context) => {
    const entries = {};
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetTransitGatewayMulticastDomainAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetTransitGatewayPolicyTableAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_TGPTI] != null) {
        entries[_TGPTI] = input[_TGPTI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetTransitGatewayPolicyTableEntriesRequest = (input, context) => {
    const entries = {};
    if (input[_TGPTI] != null) {
        entries[_TGPTI] = input[_TGPTI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetTransitGatewayPrefixListReferencesRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetTransitGatewayRouteTableAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetTransitGatewayRouteTablePropagationsRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetVerifiedAccessEndpointPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_VAEI] != null) {
        entries[_VAEI] = input[_VAEI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetVerifiedAccessEndpointTargetsRequest = (input, context) => {
    const entries = {};
    if (input[_VAEI] != null) {
        entries[_VAEI] = input[_VAEI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetVerifiedAccessGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_VAGI] != null) {
        entries[_VAGI] = input[_VAGI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetVpnConnectionDeviceSampleConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_VCI] != null) {
        entries[_VCI] = input[_VCI];
    }
    if (input[_VCDTI] != null) {
        entries[_VCDTI] = input[_VCDTI];
    }
    if (input[_IKEV] != null) {
        entries[_IKEV] = input[_IKEV];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetVpnConnectionDeviceTypesRequest = (input, context) => {
    const entries = {};
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GetVpnTunnelReplacementStatusRequest = (input, context) => {
    const entries = {};
    if (input[_VCI] != null) {
        entries[_VCI] = input[_VCI];
    }
    if (input[_VTOIA] != null) {
        entries[_VTOIA] = input[_VTOIA];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_GroupIdentifier = (input, context) => {
    const entries = {};
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    return entries;
};
const se_GroupIdentifierList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_GroupIdentifier(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_GroupIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_GroupIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`GroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_GroupNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`GroupName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_HibernationOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_Conf] != null) {
        entries[_Conf] = input[_Conf];
    }
    return entries;
};
const se_HostReservationIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_IamInstanceProfileSpecification = (input, context) => {
    const entries = {};
    if (input[_Ar] != null) {
        entries[_Ar] = input[_Ar];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    return entries;
};
const se_IcmpTypeCode = (input, context) => {
    const entries = {};
    if (input[_Cod] != null) {
        entries[_Cod] = input[_Cod];
    }
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    return entries;
};
const se_IKEVersionsRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_IKEVersionsRequestListValue(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_IKEVersionsRequestListValue = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_ImageCriterionRequest = (input, context) => {
    const entries = {};
    if (input[_IPm] != null) {
        const memberEntries = se_ImageProviderRequestList(input[_IPm], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ImageProvider.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ImageCriterionRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ImageCriterionRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`ImageCriterion.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ImageDiskContainer = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_Fo] != null) {
        entries[_Fo] = input[_Fo];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    if (input[_UB] != null) {
        const memberEntries = se_UserBucket(input[_UB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserBucket.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ImageDiskContainerList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ImageDiskContainer(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ImageIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ImageIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ImageId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ImageProviderRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ImportClientVpnClientCertificateRevocationListRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_CRL] != null) {
        entries[_CRL] = input[_CRL];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ImportImageLicenseConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_LCA] != null) {
        entries[_LCA] = input[_LCA];
    }
    return entries;
};
const se_ImportImageLicenseSpecificationListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ImportImageLicenseConfigurationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ImportImageRequest = (input, context) => {
    const entries = {};
    if (input[_Arc] != null) {
        entries[_Arc] = input[_Arc];
    }
    if (input[_CDl] != null) {
        const memberEntries = se_ClientData(input[_CDl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClientData.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DCi] != null) {
        const memberEntries = se_ImageDiskContainerList(input[_DCi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DiskContainer.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Enc] != null) {
        entries[_Enc] = input[_Enc];
    }
    if (input[_H] != null) {
        entries[_H] = input[_H];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_LTi] != null) {
        entries[_LTi] = input[_LTi];
    }
    if (input[_Pla] != null) {
        entries[_Pla] = input[_Pla];
    }
    if (input[_RNo] != null) {
        entries[_RNo] = input[_RNo];
    }
    if (input[_LSi] != null) {
        const memberEntries = se_ImportImageLicenseSpecificationListRequest(input[_LSi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LicenseSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_UO] != null) {
        entries[_UO] = input[_UO];
    }
    if (input[_BM] != null) {
        entries[_BM] = input[_BM];
    }
    return entries;
};
const se_ImportInstanceLaunchSpecification = (input, context) => {
    const entries = {};
    if (input[_Arc] != null) {
        entries[_Arc] = input[_Arc];
    }
    if (input[_GNr] != null) {
        const memberEntries = se_SecurityGroupStringList(input[_GNr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GroupName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_GIro] != null) {
        const memberEntries = se_SecurityGroupIdStringList(input[_GIro], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AId] != null) {
        entries[_AId] = input[_AId];
    }
    if (input[_UD] != null) {
        const memberEntries = se_UserData(input[_UD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserData.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_Pl] != null) {
        const memberEntries = se_Placement(input[_Pl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Placement.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Mon] != null) {
        entries[_Mon] = input[_Mon];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_IISB] != null) {
        entries[_IISB] = input[_IISB];
    }
    if (input[_PIAr] != null) {
        entries[_PIAr] = input[_PIAr];
    }
    return entries;
};
const se_ImportInstanceRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_LSa] != null) {
        const memberEntries = se_ImportInstanceLaunchSpecification(input[_LSa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DIis] != null) {
        const memberEntries = se_DiskImageList(input[_DIis], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DiskImage.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Pla] != null) {
        entries[_Pla] = input[_Pla];
    }
    return entries;
};
const se_ImportKeyPairRequest = (input, context) => {
    const entries = {};
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_KN] != null) {
        entries[_KN] = input[_KN];
    }
    if (input[_PKM] != null) {
        entries[_PKM] = context.base64Encoder(input[_PKM]);
    }
    return entries;
};
const se_ImportSnapshotRequest = (input, context) => {
    const entries = {};
    if (input[_CDl] != null) {
        const memberEntries = se_ClientData(input[_CDl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClientData.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DCis] != null) {
        const memberEntries = se_SnapshotDiskContainer(input[_DCis], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DiskContainer.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_Enc] != null) {
        entries[_Enc] = input[_Enc];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_RNo] != null) {
        entries[_RNo] = input[_RNo];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ImportSnapshotTaskIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ImportTaskId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ImportTaskIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ImportTaskId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ImportVolumeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_Im] != null) {
        const memberEntries = se_DiskImageDetail(input[_Im], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Image.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_Vo] != null) {
        const memberEntries = se_VolumeDetail(input[_Vo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Volume.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InsideCidrBlocksStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceBlockDeviceMappingSpecification = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_E] != null) {
        const memberEntries = se_EbsInstanceBlockDeviceSpecification(input[_E], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ebs.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_VN] != null) {
        entries[_VN] = input[_VN];
    }
    if (input[_ND] != null) {
        entries[_ND] = input[_ND];
    }
    return entries;
};
const se_InstanceBlockDeviceMappingSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_InstanceBlockDeviceMappingSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_InstanceCreditSpecificationListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_InstanceCreditSpecificationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_InstanceCreditSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_CCp] != null) {
        entries[_CCp] = input[_CCp];
    }
    return entries;
};
const se_InstanceEventWindowAssociationRequest = (input, context) => {
    const entries = {};
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ITnsta] != null) {
        const memberEntries = se_TagList(input[_ITnsta], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceTag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DHI] != null) {
        const memberEntries = se_DedicatedHostIdList(input[_DHI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DedicatedHostId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InstanceEventWindowDisassociationRequest = (input, context) => {
    const entries = {};
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ITnsta] != null) {
        const memberEntries = se_TagList(input[_ITnsta], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceTag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DHI] != null) {
        const memberEntries = se_DedicatedHostIdList(input[_DHI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DedicatedHostId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InstanceEventWindowIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`InstanceEventWindowId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceEventWindowTimeRangeRequest = (input, context) => {
    const entries = {};
    if (input[_SWD] != null) {
        entries[_SWD] = input[_SWD];
    }
    if (input[_SH] != null) {
        entries[_SH] = input[_SH];
    }
    if (input[_EWD] != null) {
        entries[_EWD] = input[_EWD];
    }
    if (input[_EH] != null) {
        entries[_EH] = input[_EH];
    }
    return entries;
};
const se_InstanceEventWindowTimeRangeRequestSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_InstanceEventWindowTimeRangeRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_InstanceGenerationSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`InstanceId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceIpv6Address = (input, context) => {
    const entries = {};
    if (input[_IApv] != null) {
        entries[_IApv] = input[_IApv];
    }
    if (input[_IPIs] != null) {
        entries[_IPIs] = input[_IPIs];
    }
    return entries;
};
const se_InstanceIpv6AddressList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_InstanceIpv6Address(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_InstanceIpv6AddressListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_InstanceIpv6AddressRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`InstanceIpv6Address.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_InstanceIpv6AddressRequest = (input, context) => {
    const entries = {};
    if (input[_IApv] != null) {
        entries[_IApv] = input[_IApv];
    }
    return entries;
};
const se_InstanceMaintenanceOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_ARu] != null) {
        entries[_ARu] = input[_ARu];
    }
    return entries;
};
const se_InstanceMarketOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_MT] != null) {
        entries[_MT] = input[_MT];
    }
    if (input[_SO] != null) {
        const memberEntries = se_SpotMarketOptions(input[_SO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SpotOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InstanceMetadataOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_HT] != null) {
        entries[_HT] = input[_HT];
    }
    if (input[_HPRHL] != null) {
        entries[_HPRHL] = input[_HPRHL];
    }
    if (input[_HE] != null) {
        entries[_HE] = input[_HE];
    }
    if (input[_HPI] != null) {
        entries[_HPI] = input[_HPI];
    }
    if (input[_IMT] != null) {
        entries[_IMT] = input[_IMT];
    }
    return entries;
};
const se_InstanceNetworkInterfaceSpecification = (input, context) => {
    const entries = {};
    if (input[_APIAs] != null) {
        entries[_APIAs] = input[_APIAs];
    }
    if (input[_DOT] != null) {
        entries[_DOT] = input[_DOT];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DIev] != null) {
        entries[_DIev] = input[_DIev];
    }
    if (input[_G] != null) {
        const memberEntries = se_SecurityGroupIdStringList(input[_G], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IAC] != null) {
        entries[_IAC] = input[_IAC];
    }
    if (input[_IA] != null) {
        const memberEntries = se_InstanceIpv6AddressList(input[_IA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_PIAr] != null) {
        entries[_PIAr] = input[_PIAr];
    }
    if (input[_PIA] != null) {
        const memberEntries = se_PrivateIpAddressSpecificationList(input[_PIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateIpAddresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SPIAC] != null) {
        entries[_SPIAC] = input[_SPIAC];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_ACIA] != null) {
        entries[_ACIA] = input[_ACIA];
    }
    if (input[_ITn] != null) {
        entries[_ITn] = input[_ITn];
    }
    if (input[_NCI] != null) {
        entries[_NCI] = input[_NCI];
    }
    if (input[_IPp] != null) {
        const memberEntries = se_Ipv4PrefixList(input[_IPp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv4Prefix.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPCp] != null) {
        entries[_IPCp] = input[_IPCp];
    }
    if (input[_IP] != null) {
        const memberEntries = se_Ipv6PrefixList(input[_IP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Prefix.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPC] != null) {
        entries[_IPC] = input[_IPC];
    }
    if (input[_PIr] != null) {
        entries[_PIr] = input[_PIr];
    }
    if (input[_ESS] != null) {
        const memberEntries = se_EnaSrdSpecificationRequest(input[_ESS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnaSrdSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CTS] != null) {
        const memberEntries = se_ConnectionTrackingSpecificationRequest(input[_CTS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionTrackingSpecification.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InstanceNetworkInterfaceSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_InstanceNetworkInterfaceSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_InstanceNetworkPerformanceOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_BW] != null) {
        entries[_BW] = input[_BW];
    }
    return entries;
};
const se_InstanceRequirements = (input, context) => {
    const entries = {};
    if (input[_VCC] != null) {
        const memberEntries = se_VCpuCountRange(input[_VCC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VCpuCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MMB] != null) {
        const memberEntries = se_MemoryMiB(input[_MMB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MemoryMiB.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CM] != null) {
        const memberEntries = se_CpuManufacturerSet(input[_CM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CpuManufacturerSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MGBPVC] != null) {
        const memberEntries = se_MemoryGiBPerVCpu(input[_MGBPVC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MemoryGiBPerVCpu.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EIT] != null) {
        const memberEntries = se_ExcludedInstanceTypeSet(input[_EIT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludedInstanceTypeSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IG] != null) {
        const memberEntries = se_InstanceGenerationSet(input[_IG], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceGenerationSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SMPPOLP] != null) {
        entries[_SMPPOLP] = input[_SMPPOLP];
    }
    if (input[_ODMPPOLP] != null) {
        entries[_ODMPPOLP] = input[_ODMPPOLP];
    }
    if (input[_BMa] != null) {
        entries[_BMa] = input[_BMa];
    }
    if (input[_BP] != null) {
        entries[_BP] = input[_BP];
    }
    if (input[_RHS] != null) {
        entries[_RHS] = input[_RHS];
    }
    if (input[_NIC] != null) {
        const memberEntries = se_NetworkInterfaceCount(input[_NIC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LSo] != null) {
        entries[_LSo] = input[_LSo];
    }
    if (input[_LST] != null) {
        const memberEntries = se_LocalStorageTypeSet(input[_LST], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LocalStorageTypeSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TLSGB] != null) {
        const memberEntries = se_TotalLocalStorageGB(input[_TLSGB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TotalLocalStorageGB.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_BEBM] != null) {
        const memberEntries = se_BaselineEbsBandwidthMbps(input[_BEBM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BaselineEbsBandwidthMbps.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ATc] != null) {
        const memberEntries = se_AcceleratorTypeSet(input[_ATc], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorTypeSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ACc] != null) {
        const memberEntries = se_AcceleratorCount(input[_ACc], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AM] != null) {
        const memberEntries = se_AcceleratorManufacturerSet(input[_AM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorManufacturerSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ANc] != null) {
        const memberEntries = se_AcceleratorNameSet(input[_ANc], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorNameSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ATMMB] != null) {
        const memberEntries = se_AcceleratorTotalMemoryMiB(input[_ATMMB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorTotalMemoryMiB.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NBGe] != null) {
        const memberEntries = se_NetworkBandwidthGbps(input[_NBGe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkBandwidthGbps.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AIT] != null) {
        const memberEntries = se_AllowedInstanceTypeSet(input[_AIT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AllowedInstanceTypeSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MSPAPOOODP] != null) {
        entries[_MSPAPOOODP] = input[_MSPAPOOODP];
    }
    if (input[_BPF] != null) {
        const memberEntries = se_BaselinePerformanceFactors(input[_BPF], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BaselinePerformanceFactors.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InstanceRequirementsRequest = (input, context) => {
    const entries = {};
    if (input[_VCC] != null) {
        const memberEntries = se_VCpuCountRangeRequest(input[_VCC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VCpuCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MMB] != null) {
        const memberEntries = se_MemoryMiBRequest(input[_MMB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MemoryMiB.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CM] != null) {
        const memberEntries = se_CpuManufacturerSet(input[_CM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CpuManufacturer.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MGBPVC] != null) {
        const memberEntries = se_MemoryGiBPerVCpuRequest(input[_MGBPVC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MemoryGiBPerVCpu.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EIT] != null) {
        const memberEntries = se_ExcludedInstanceTypeSet(input[_EIT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludedInstanceType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IG] != null) {
        const memberEntries = se_InstanceGenerationSet(input[_IG], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceGeneration.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SMPPOLP] != null) {
        entries[_SMPPOLP] = input[_SMPPOLP];
    }
    if (input[_ODMPPOLP] != null) {
        entries[_ODMPPOLP] = input[_ODMPPOLP];
    }
    if (input[_BMa] != null) {
        entries[_BMa] = input[_BMa];
    }
    if (input[_BP] != null) {
        entries[_BP] = input[_BP];
    }
    if (input[_RHS] != null) {
        entries[_RHS] = input[_RHS];
    }
    if (input[_NIC] != null) {
        const memberEntries = se_NetworkInterfaceCountRequest(input[_NIC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LSo] != null) {
        entries[_LSo] = input[_LSo];
    }
    if (input[_LST] != null) {
        const memberEntries = se_LocalStorageTypeSet(input[_LST], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LocalStorageType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TLSGB] != null) {
        const memberEntries = se_TotalLocalStorageGBRequest(input[_TLSGB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TotalLocalStorageGB.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_BEBM] != null) {
        const memberEntries = se_BaselineEbsBandwidthMbpsRequest(input[_BEBM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BaselineEbsBandwidthMbps.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ATc] != null) {
        const memberEntries = se_AcceleratorTypeSet(input[_ATc], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ACc] != null) {
        const memberEntries = se_AcceleratorCountRequest(input[_ACc], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AM] != null) {
        const memberEntries = se_AcceleratorManufacturerSet(input[_AM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorManufacturer.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ANc] != null) {
        const memberEntries = se_AcceleratorNameSet(input[_ANc], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ATMMB] != null) {
        const memberEntries = se_AcceleratorTotalMemoryMiBRequest(input[_ATMMB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorTotalMemoryMiB.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NBGe] != null) {
        const memberEntries = se_NetworkBandwidthGbpsRequest(input[_NBGe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkBandwidthGbps.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AIT] != null) {
        const memberEntries = se_AllowedInstanceTypeSet(input[_AIT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AllowedInstanceType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MSPAPOOODP] != null) {
        entries[_MSPAPOOODP] = input[_MSPAPOOODP];
    }
    if (input[_BPF] != null) {
        const memberEntries = se_BaselinePerformanceFactorsRequest(input[_BPF], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BaselinePerformanceFactors.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InstanceRequirementsWithMetadataRequest = (input, context) => {
    const entries = {};
    if (input[_ATr] != null) {
        const memberEntries = se_ArchitectureTypeSet(input[_ATr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ArchitectureType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VTi] != null) {
        const memberEntries = se_VirtualizationTypeSet(input[_VTi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VirtualizationType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IR] != null) {
        const memberEntries = se_InstanceRequirementsRequest(input[_IR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRequirements.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InstanceSpecification = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_EBV] != null) {
        entries[_EBV] = input[_EBV];
    }
    if (input[_EDVI] != null) {
        const memberEntries = se_VolumeIdStringList(input[_EDVI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludeDataVolumeId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InstanceTagKeySet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceTypeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_IntegrateServices = (input, context) => {
    const entries = {};
    if (input[_AIth] != null) {
        const memberEntries = se_AthenaIntegrationsSet(input[_AIth], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AthenaIntegration.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InternetGatewayIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_IpamCidrAuthorizationContext = (input, context) => {
    const entries = {};
    if (input[_Me] != null) {
        entries[_Me] = input[_Me];
    }
    if (input[_Si] != null) {
        entries[_Si] = input[_Si];
    }
    return entries;
};
const se_IpamPoolAllocationAllowedCidrs = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_IpamPoolAllocationDisallowedCidrs = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_IpamPoolSourceResourceRequest = (input, context) => {
    const entries = {};
    if (input[_RIeso] != null) {
        entries[_RIeso] = input[_RIeso];
    }
    if (input[_RT] != null) {
        entries[_RT] = input[_RT];
    }
    if (input[_RRe] != null) {
        entries[_RRe] = input[_RRe];
    }
    if (input[_ROe] != null) {
        entries[_ROe] = input[_ROe];
    }
    return entries;
};
const se_IpList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_IpPermission = (input, context) => {
    const entries = {};
    if (input[_IPpr] != null) {
        entries[_IPpr] = input[_IPpr];
    }
    if (input[_FP] != null) {
        entries[_FP] = input[_FP];
    }
    if (input[_TP] != null) {
        entries[_TP] = input[_TP];
    }
    if (input[_UIGP] != null) {
        const memberEntries = se_UserIdGroupPairList(input[_UIGP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Groups.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IRp] != null) {
        const memberEntries = se_IpRangeList(input[_IRp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpRanges.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IRpv] != null) {
        const memberEntries = se_Ipv6RangeList(input[_IRpv], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Ranges.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PLIr] != null) {
        const memberEntries = se_PrefixListIdList(input[_PLIr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrefixListIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_IpPermissionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_IpPermission(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_IpPrefixList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_IpRange = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_CIi] != null) {
        entries[_CIi] = input[_CIi];
    }
    return entries;
};
const se_IpRangeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_IpRange(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Ipv4PrefixList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Ipv4PrefixSpecificationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Ipv4PrefixSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_IPpvr] != null) {
        entries[_IPpvr] = input[_IPpvr];
    }
    return entries;
};
const se_Ipv6AddressList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Ipv6PoolIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Ipv6PrefixList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Ipv6PrefixSpecificationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Ipv6PrefixSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_IPpvre] != null) {
        entries[_IPpvre] = input[_IPpvre];
    }
    return entries;
};
const se_Ipv6Range = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_CIid] != null) {
        entries[_CIid] = input[_CIid];
    }
    return entries;
};
const se_Ipv6RangeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Ipv6Range(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_KeyNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`KeyName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_KeyPairIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`KeyPairId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LaunchPermission = (input, context) => {
    const entries = {};
    if (input[_OAr] != null) {
        entries[_OAr] = input[_OAr];
    }
    if (input[_OUA] != null) {
        entries[_OUA] = input[_OUA];
    }
    if (input[_UIs] != null) {
        entries[_UIs] = input[_UIs];
    }
    if (input[_Gr] != null) {
        entries[_Gr] = input[_Gr];
    }
    return entries;
};
const se_LaunchPermissionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LaunchPermission(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LaunchPermissionModifications = (input, context) => {
    const entries = {};
    if (input[_Add] != null) {
        const memberEntries = se_LaunchPermissionList(input[_Add], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Add.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Rem] != null) {
        const memberEntries = se_LaunchPermissionList(input[_Rem], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Remove.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchSpecsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_SpotFleetLaunchSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LaunchTemplateBlockDeviceMappingRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_VN] != null) {
        entries[_VN] = input[_VN];
    }
    if (input[_E] != null) {
        const memberEntries = se_LaunchTemplateEbsBlockDeviceRequest(input[_E], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ebs.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ND] != null) {
        entries[_ND] = input[_ND];
    }
    return entries;
};
const se_LaunchTemplateBlockDeviceMappingRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LaunchTemplateBlockDeviceMappingRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`BlockDeviceMapping.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LaunchTemplateCapacityReservationSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_CRP] != null) {
        entries[_CRP] = input[_CRP];
    }
    if (input[_CRTa] != null) {
        const memberEntries = se_CapacityReservationTarget(input[_CRTa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationTarget.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchTemplateConfig = (input, context) => {
    const entries = {};
    if (input[_LTS] != null) {
        const memberEntries = se_FleetLaunchTemplateSpecification(input[_LTS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ov] != null) {
        const memberEntries = se_LaunchTemplateOverridesList(input[_Ov], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Overrides.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchTemplateConfigList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LaunchTemplateConfig(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LaunchTemplateCpuOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_CC] != null) {
        entries[_CC] = input[_CC];
    }
    if (input[_TPC] != null) {
        entries[_TPC] = input[_TPC];
    }
    if (input[_ASS] != null) {
        entries[_ASS] = input[_ASS];
    }
    return entries;
};
const se_LaunchTemplateEbsBlockDeviceRequest = (input, context) => {
    const entries = {};
    if (input[_Enc] != null) {
        entries[_Enc] = input[_Enc];
    }
    if (input[_DOT] != null) {
        entries[_DOT] = input[_DOT];
    }
    if (input[_Io] != null) {
        entries[_Io] = input[_Io];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_VS] != null) {
        entries[_VS] = input[_VS];
    }
    if (input[_VT] != null) {
        entries[_VT] = input[_VT];
    }
    if (input[_Th] != null) {
        entries[_Th] = input[_Th];
    }
    return entries;
};
const se_LaunchTemplateElasticInferenceAccelerator = (input, context) => {
    const entries = {};
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_Cou] != null) {
        entries[_Cou] = input[_Cou];
    }
    return entries;
};
const se_LaunchTemplateElasticInferenceAcceleratorList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LaunchTemplateElasticInferenceAccelerator(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LaunchTemplateEnclaveOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    return entries;
};
const se_LaunchTemplateHibernationOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_Conf] != null) {
        entries[_Conf] = input[_Conf];
    }
    return entries;
};
const se_LaunchTemplateIamInstanceProfileSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_Ar] != null) {
        entries[_Ar] = input[_Ar];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    return entries;
};
const se_LaunchTemplateIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LaunchTemplateInstanceMaintenanceOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_ARu] != null) {
        entries[_ARu] = input[_ARu];
    }
    return entries;
};
const se_LaunchTemplateInstanceMarketOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_MT] != null) {
        entries[_MT] = input[_MT];
    }
    if (input[_SO] != null) {
        const memberEntries = se_LaunchTemplateSpotMarketOptionsRequest(input[_SO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SpotOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchTemplateInstanceMetadataOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_HT] != null) {
        entries[_HT] = input[_HT];
    }
    if (input[_HPRHL] != null) {
        entries[_HPRHL] = input[_HPRHL];
    }
    if (input[_HE] != null) {
        entries[_HE] = input[_HE];
    }
    if (input[_HPI] != null) {
        entries[_HPI] = input[_HPI];
    }
    if (input[_IMT] != null) {
        entries[_IMT] = input[_IMT];
    }
    return entries;
};
const se_LaunchTemplateInstanceNetworkInterfaceSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_ACIA] != null) {
        entries[_ACIA] = input[_ACIA];
    }
    if (input[_APIAs] != null) {
        entries[_APIAs] = input[_APIAs];
    }
    if (input[_DOT] != null) {
        entries[_DOT] = input[_DOT];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DIev] != null) {
        entries[_DIev] = input[_DIev];
    }
    if (input[_G] != null) {
        const memberEntries = se_SecurityGroupIdStringList(input[_G], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ITn] != null) {
        entries[_ITn] = input[_ITn];
    }
    if (input[_IAC] != null) {
        entries[_IAC] = input[_IAC];
    }
    if (input[_IA] != null) {
        const memberEntries = se_InstanceIpv6AddressListRequest(input[_IA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_PIAr] != null) {
        entries[_PIAr] = input[_PIAr];
    }
    if (input[_PIA] != null) {
        const memberEntries = se_PrivateIpAddressSpecificationList(input[_PIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateIpAddresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SPIAC] != null) {
        entries[_SPIAC] = input[_SPIAC];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_NCI] != null) {
        entries[_NCI] = input[_NCI];
    }
    if (input[_IPp] != null) {
        const memberEntries = se_Ipv4PrefixList(input[_IPp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv4Prefix.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPCp] != null) {
        entries[_IPCp] = input[_IPCp];
    }
    if (input[_IP] != null) {
        const memberEntries = se_Ipv6PrefixList(input[_IP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Prefix.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPC] != null) {
        entries[_IPC] = input[_IPC];
    }
    if (input[_PIr] != null) {
        entries[_PIr] = input[_PIr];
    }
    if (input[_ESS] != null) {
        const memberEntries = se_EnaSrdSpecificationRequest(input[_ESS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnaSrdSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CTS] != null) {
        const memberEntries = se_ConnectionTrackingSpecificationRequest(input[_CTS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionTrackingSpecification.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LaunchTemplateInstanceNetworkInterfaceSpecificationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`InstanceNetworkInterfaceSpecification.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LaunchTemplateLicenseConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_LCA] != null) {
        entries[_LCA] = input[_LCA];
    }
    return entries;
};
const se_LaunchTemplateLicenseSpecificationListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LaunchTemplateLicenseConfigurationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LaunchTemplateNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LaunchTemplateNetworkPerformanceOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_BW] != null) {
        entries[_BW] = input[_BW];
    }
    return entries;
};
const se_LaunchTemplateOverrides = (input, context) => {
    const entries = {};
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_SPp] != null) {
        entries[_SPp] = input[_SPp];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_WCe] != null) {
        entries[_WCe] = __serializeFloat(input[_WCe]);
    }
    if (input[_Pri] != null) {
        entries[_Pri] = __serializeFloat(input[_Pri]);
    }
    if (input[_IR] != null) {
        const memberEntries = se_InstanceRequirements(input[_IR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRequirements.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchTemplateOverridesList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LaunchTemplateOverrides(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LaunchTemplatePlacementRequest = (input, context) => {
    const entries = {};
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_Af] != null) {
        entries[_Af] = input[_Af];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_HIo] != null) {
        entries[_HIo] = input[_HIo];
    }
    if (input[_Te] != null) {
        entries[_Te] = input[_Te];
    }
    if (input[_SDp] != null) {
        entries[_SDp] = input[_SDp];
    }
    if (input[_HRGA] != null) {
        entries[_HRGA] = input[_HRGA];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    return entries;
};
const se_LaunchTemplatePrivateDnsNameOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_HTo] != null) {
        entries[_HTo] = input[_HTo];
    }
    if (input[_ERNDAR] != null) {
        entries[_ERNDAR] = input[_ERNDAR];
    }
    if (input[_ERNDAAAAR] != null) {
        entries[_ERNDAAAAR] = input[_ERNDAAAAR];
    }
    return entries;
};
const se_LaunchTemplatesMonitoringRequest = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    return entries;
};
const se_LaunchTemplateSpecification = (input, context) => {
    const entries = {};
    if (input[_LTI] != null) {
        entries[_LTI] = input[_LTI];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    if (input[_V] != null) {
        entries[_V] = input[_V];
    }
    return entries;
};
const se_LaunchTemplateSpotMarketOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_MPa] != null) {
        entries[_MPa] = input[_MPa];
    }
    if (input[_SIT] != null) {
        entries[_SIT] = input[_SIT];
    }
    if (input[_BDMl] != null) {
        entries[_BDMl] = input[_BDMl];
    }
    if (input[_VU] != null) {
        entries[_VU] = __serializeDateTime(input[_VU]);
    }
    if (input[_IIB] != null) {
        entries[_IIB] = input[_IIB];
    }
    return entries;
};
const se_LaunchTemplateTagSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_RT] != null) {
        entries[_RT] = input[_RT];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchTemplateTagSpecificationRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LaunchTemplateTagSpecificationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`LaunchTemplateTagSpecificationRequest.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LicenseConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_LCA] != null) {
        entries[_LCA] = input[_LCA];
    }
    return entries;
};
const se_LicenseSpecificationListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LicenseConfigurationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ListImagesInRecycleBinRequest = (input, context) => {
    const entries = {};
    if (input[_IImag] != null) {
        const memberEntries = se_ImageIdStringList(input[_IImag], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ImageId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ListSnapshotsInRecycleBinRequest = (input, context) => {
    const entries = {};
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_SIna] != null) {
        const memberEntries = se_SnapshotIdStringList(input[_SIna], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SnapshotId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_LoadBalancersConfig = (input, context) => {
    const entries = {};
    if (input[_CLBC] != null) {
        const memberEntries = se_ClassicLoadBalancersConfig(input[_CLBC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClassicLoadBalancersConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TGC] != null) {
        const memberEntries = se_TargetGroupsConfig(input[_TGC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupsConfig.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LoadPermissionListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LoadPermissionRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LoadPermissionModifications = (input, context) => {
    const entries = {};
    if (input[_Add] != null) {
        const memberEntries = se_LoadPermissionListRequest(input[_Add], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Add.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Rem] != null) {
        const memberEntries = se_LoadPermissionListRequest(input[_Rem], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Remove.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LoadPermissionRequest = (input, context) => {
    const entries = {};
    if (input[_Gr] != null) {
        entries[_Gr] = input[_Gr];
    }
    if (input[_UIs] != null) {
        entries[_UIs] = input[_UIs];
    }
    return entries;
};
const se_LocalGatewayIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LocalGatewayRouteTableIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LocalGatewayRouteTableVpcAssociationIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LocalGatewayVirtualInterfaceGroupIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LocalGatewayVirtualInterfaceIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LocalStorageTypeSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LockSnapshotRequest = (input, context) => {
    const entries = {};
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_LM] != null) {
        entries[_LM] = input[_LM];
    }
    if (input[_COP] != null) {
        entries[_COP] = input[_COP];
    }
    if (input[_LDo] != null) {
        entries[_LDo] = input[_LDo];
    }
    if (input[_EDx] != null) {
        entries[_EDx] = __serializeDateTime(input[_EDx]);
    }
    return entries;
};
const se_MemoryGiBPerVCpu = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = __serializeFloat(input[_M]);
    }
    if (input[_Ma] != null) {
        entries[_Ma] = __serializeFloat(input[_Ma]);
    }
    return entries;
};
const se_MemoryGiBPerVCpuRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = __serializeFloat(input[_M]);
    }
    if (input[_Ma] != null) {
        entries[_Ma] = __serializeFloat(input[_Ma]);
    }
    return entries;
};
const se_MemoryMiB = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_MemoryMiBRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_ModifyAddressAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_AIl] != null) {
        entries[_AIl] = input[_AIl];
    }
    if (input[_DNo] != null) {
        entries[_DNo] = input[_DNo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyAvailabilityZoneGroupRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_OIS] != null) {
        entries[_OIS] = input[_OIS];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyCapacityReservationFleetRequest = (input, context) => {
    const entries = {};
    if (input[_CRFIa] != null) {
        entries[_CRFIa] = input[_CRFIa];
    }
    if (input[_TTC] != null) {
        entries[_TTC] = input[_TTC];
    }
    if (input[_ED] != null) {
        entries[_ED] = __serializeDateTime(input[_ED]);
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RED] != null) {
        entries[_RED] = input[_RED];
    }
    return entries;
};
const se_ModifyCapacityReservationRequest = (input, context) => {
    const entries = {};
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_ED] != null) {
        entries[_ED] = __serializeDateTime(input[_ED]);
    }
    if (input[_EDT] != null) {
        entries[_EDT] = input[_EDT];
    }
    if (input[_Ac] != null) {
        entries[_Ac] = input[_Ac];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_AId] != null) {
        entries[_AId] = input[_AId];
    }
    if (input[_IMC] != null) {
        entries[_IMC] = input[_IMC];
    }
    return entries;
};
const se_ModifyClientVpnEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_SCA] != null) {
        entries[_SCA] = input[_SCA];
    }
    if (input[_CLO] != null) {
        const memberEntries = se_ConnectionLogOptions(input[_CLO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionLogOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DSn] != null) {
        const memberEntries = se_DnsServersOptionsModifyStructure(input[_DSn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DnsServers.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_VP] != null) {
        entries[_VP] = input[_VP];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SGI] != null) {
        const memberEntries = se_ClientVpnSecurityGroupIdSet(input[_SGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_SSP] != null) {
        entries[_SSP] = input[_SSP];
    }
    if (input[_CCO] != null) {
        const memberEntries = se_ClientConnectOptions(input[_CCO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClientConnectOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_STH] != null) {
        entries[_STH] = input[_STH];
    }
    if (input[_CLBO] != null) {
        const memberEntries = se_ClientLoginBannerOptions(input[_CLBO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClientLoginBannerOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DOST] != null) {
        entries[_DOST] = input[_DOST];
    }
    return entries;
};
const se_ModifyDefaultCreditSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IF] != null) {
        entries[_IF] = input[_IF];
    }
    if (input[_CCp] != null) {
        entries[_CCp] = input[_CCp];
    }
    return entries;
};
const se_ModifyEbsDefaultKmsKeyIdRequest = (input, context) => {
    const entries = {};
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyFleetRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ECTP] != null) {
        entries[_ECTP] = input[_ECTP];
    }
    if (input[_LTC] != null) {
        const memberEntries = se_FleetLaunchTemplateConfigListRequest(input[_LTC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateConfig.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_FIl] != null) {
        entries[_FIl] = input[_FIl];
    }
    if (input[_TCS] != null) {
        const memberEntries = se_TargetCapacitySpecificationRequest(input[_TCS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetCapacitySpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Con] != null) {
        entries[_Con] = input[_Con];
    }
    return entries;
};
const se_ModifyFpgaImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_FII] != null) {
        entries[_FII] = input[_FII];
    }
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_OTp] != null) {
        entries[_OTp] = input[_OTp];
    }
    if (input[_UIse] != null) {
        const memberEntries = se_UserIdStringList(input[_UIse], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_UG] != null) {
        const memberEntries = se_UserGroupStringList(input[_UG], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PCr] != null) {
        const memberEntries = se_ProductCodeStringList(input[_PCr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ProductCode.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_LP] != null) {
        const memberEntries = se_LoadPermissionModifications(input[_LP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadPermission.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    return entries;
};
const se_ModifyHostsRequest = (input, context) => {
    const entries = {};
    if (input[_HR] != null) {
        entries[_HR] = input[_HR];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_IF] != null) {
        entries[_IF] = input[_IF];
    }
    if (input[_HM] != null) {
        entries[_HM] = input[_HM];
    }
    if (input[_HI] != null) {
        const memberEntries = se_RequestHostIdList(input[_HI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HostId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AP] != null) {
        entries[_AP] = input[_AP];
    }
    return entries;
};
const se_ModifyIdentityIdFormatRequest = (input, context) => {
    const entries = {};
    if (input[_Res] != null) {
        entries[_Res] = input[_Res];
    }
    if (input[_ULI] != null) {
        entries[_ULI] = input[_ULI];
    }
    if (input[_PAr] != null) {
        entries[_PAr] = input[_PAr];
    }
    return entries;
};
const se_ModifyIdFormatRequest = (input, context) => {
    const entries = {};
    if (input[_Res] != null) {
        entries[_Res] = input[_Res];
    }
    if (input[_ULI] != null) {
        entries[_ULI] = input[_ULI];
    }
    return entries;
};
const se_ModifyImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_De] != null) {
        const memberEntries = se_AttributeValue(input[_De], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Description.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_LPa] != null) {
        const memberEntries = se_LaunchPermissionModifications(input[_LPa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchPermission.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_OTp] != null) {
        entries[_OTp] = input[_OTp];
    }
    if (input[_PCr] != null) {
        const memberEntries = se_ProductCodeStringList(input[_PCr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ProductCode.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_UG] != null) {
        const memberEntries = se_UserGroupStringList(input[_UG], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_UIse] != null) {
        const memberEntries = se_UserIdStringList(input[_UIse], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    if (input[_OArg] != null) {
        const memberEntries = se_OrganizationArnStringList(input[_OArg], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OrganizationArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_OUAr] != null) {
        const memberEntries = se_OrganizationalUnitArnStringList(input[_OUAr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OrganizationalUnitArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ISm] != null) {
        const memberEntries = se_AttributeValue(input[_ISm], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ImdsSupport.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyInstanceAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_SDC] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_SDC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceDestCheck.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DAS] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_DAS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DisableApiStop.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    if (input[_BDM] != null) {
        const memberEntries = se_InstanceBlockDeviceMappingSpecificationList(input[_BDM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DATis] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_DATis], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DisableApiTermination.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IT] != null) {
        const memberEntries = se_AttributeValue(input[_IT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceType.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_K] != null) {
        const memberEntries = se_AttributeValue(input[_K], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Kernel.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ra] != null) {
        const memberEntries = se_AttributeValue(input[_Ra], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ramdisk.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_UD] != null) {
        const memberEntries = se_BlobAttributeValue(input[_UD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserData.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IISB] != null) {
        const memberEntries = se_AttributeValue(input[_IISB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceInitiatedShutdownBehavior.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_G] != null) {
        const memberEntries = se_GroupIdStringList(input[_G], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_EO] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_EO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EbsOptimized.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SNS] != null) {
        const memberEntries = se_AttributeValue(input[_SNS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SriovNetSupport.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ESn] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_ESn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnaSupport.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyInstanceCapacityReservationAttributesRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_CRSa] != null) {
        const memberEntries = se_CapacityReservationSpecification(input[_CRSa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyInstanceCpuOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_CC] != null) {
        entries[_CC] = input[_CC];
    }
    if (input[_TPC] != null) {
        entries[_TPC] = input[_TPC];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyInstanceCreditSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_ICS] != null) {
        const memberEntries = se_InstanceCreditSpecificationListRequest(input[_ICS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceCreditSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyInstanceEventStartTimeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_IEI] != null) {
        entries[_IEI] = input[_IEI];
    }
    if (input[_NB] != null) {
        entries[_NB] = __serializeDateTime(input[_NB]);
    }
    return entries;
};
const se_ModifyInstanceEventWindowRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_IEWI] != null) {
        entries[_IEWI] = input[_IEWI];
    }
    if (input[_TRi] != null) {
        const memberEntries = se_InstanceEventWindowTimeRangeRequestSet(input[_TRi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TimeRange.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CE] != null) {
        entries[_CE] = input[_CE];
    }
    return entries;
};
const se_ModifyInstanceMaintenanceOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_ARu] != null) {
        entries[_ARu] = input[_ARu];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyInstanceMetadataDefaultsRequest = (input, context) => {
    const entries = {};
    if (input[_HT] != null) {
        entries[_HT] = input[_HT];
    }
    if (input[_HPRHL] != null) {
        entries[_HPRHL] = input[_HPRHL];
    }
    if (input[_HE] != null) {
        entries[_HE] = input[_HE];
    }
    if (input[_IMT] != null) {
        entries[_IMT] = input[_IMT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyInstanceMetadataOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_HT] != null) {
        entries[_HT] = input[_HT];
    }
    if (input[_HPRHL] != null) {
        entries[_HPRHL] = input[_HPRHL];
    }
    if (input[_HE] != null) {
        entries[_HE] = input[_HE];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_HPI] != null) {
        entries[_HPI] = input[_HPI];
    }
    if (input[_IMT] != null) {
        entries[_IMT] = input[_IMT];
    }
    return entries;
};
const se_ModifyInstanceNetworkPerformanceRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_BW] != null) {
        entries[_BW] = input[_BW];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyInstancePlacementRequest = (input, context) => {
    const entries = {};
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_HRGA] != null) {
        entries[_HRGA] = input[_HRGA];
    }
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_Te] != null) {
        entries[_Te] = input[_Te];
    }
    if (input[_Af] != null) {
        entries[_Af] = input[_Af];
    }
    if (input[_HIo] != null) {
        entries[_HIo] = input[_HIo];
    }
    return entries;
};
const se_ModifyIpamPoolRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_AIu] != null) {
        entries[_AIu] = input[_AIu];
    }
    if (input[_AMNL] != null) {
        entries[_AMNL] = input[_AMNL];
    }
    if (input[_AMNLl] != null) {
        entries[_AMNLl] = input[_AMNLl];
    }
    if (input[_ADNL] != null) {
        entries[_ADNL] = input[_ADNL];
    }
    if (input[_CADNL] != null) {
        entries[_CADNL] = input[_CADNL];
    }
    if (input[_AART] != null) {
        const memberEntries = se_RequestIpamResourceTagList(input[_AART], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddAllocationResourceTag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RART] != null) {
        const memberEntries = se_RequestIpamResourceTagList(input[_RART], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveAllocationResourceTag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyIpamRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIp] != null) {
        entries[_IIp] = input[_IIp];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_AOR] != null) {
        const memberEntries = se_AddIpamOperatingRegionSet(input[_AOR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddOperatingRegion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ROR] != null) {
        const memberEntries = se_RemoveIpamOperatingRegionSet(input[_ROR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveOperatingRegion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Ti] != null) {
        entries[_Ti] = input[_Ti];
    }
    if (input[_EPG] != null) {
        entries[_EPG] = input[_EPG];
    }
    return entries;
};
const se_ModifyIpamResourceCidrRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RIeso] != null) {
        entries[_RIeso] = input[_RIeso];
    }
    if (input[_RC] != null) {
        entries[_RC] = input[_RC];
    }
    if (input[_RRe] != null) {
        entries[_RRe] = input[_RRe];
    }
    if (input[_CISI] != null) {
        entries[_CISI] = input[_CISI];
    }
    if (input[_DISI] != null) {
        entries[_DISI] = input[_DISI];
    }
    if (input[_Moni] != null) {
        entries[_Moni] = input[_Moni];
    }
    return entries;
};
const se_ModifyIpamResourceDiscoveryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IRDI] != null) {
        entries[_IRDI] = input[_IRDI];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_AOR] != null) {
        const memberEntries = se_AddIpamOperatingRegionSet(input[_AOR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddOperatingRegion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ROR] != null) {
        const memberEntries = se_RemoveIpamOperatingRegionSet(input[_ROR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveOperatingRegion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AOUE] != null) {
        const memberEntries = se_AddIpamOrganizationalUnitExclusionSet(input[_AOUE], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddOrganizationalUnitExclusion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ROUE] != null) {
        const memberEntries = se_RemoveIpamOrganizationalUnitExclusionSet(input[_ROUE], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveOrganizationalUnitExclusion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyIpamScopeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ISI] != null) {
        entries[_ISI] = input[_ISI];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    return entries;
};
const se_ModifyLaunchTemplateRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_LTI] != null) {
        entries[_LTI] = input[_LTI];
    }
    if (input[_LTN] != null) {
        entries[_LTN] = input[_LTN];
    }
    if (input[_DVef] != null) {
        entries[_SDV] = input[_DVef];
    }
    return entries;
};
const se_ModifyLocalGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_LGRTI] != null) {
        entries[_LGRTI] = input[_LGRTI];
    }
    if (input[_LGVIGI] != null) {
        entries[_LGVIGI] = input[_LGVIGI];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_DPLI] != null) {
        entries[_DPLI] = input[_DPLI];
    }
    return entries;
};
const se_ModifyManagedPrefixListRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PLI] != null) {
        entries[_PLI] = input[_PLI];
    }
    if (input[_CVu] != null) {
        entries[_CVu] = input[_CVu];
    }
    if (input[_PLN] != null) {
        entries[_PLN] = input[_PLN];
    }
    if (input[_AEd] != null) {
        const memberEntries = se_AddPrefixListEntries(input[_AEd], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddEntry.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_REe] != null) {
        const memberEntries = se_RemovePrefixListEntries(input[_REe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveEntry.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ME] != null) {
        entries[_ME] = input[_ME];
    }
    return entries;
};
const se_ModifyNetworkInterfaceAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_ESS] != null) {
        const memberEntries = se_EnaSrdSpecification(input[_ESS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnaSrdSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EPI] != null) {
        entries[_EPI] = input[_EPI];
    }
    if (input[_CTS] != null) {
        const memberEntries = se_ConnectionTrackingSpecificationRequest(input[_CTS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionTrackingSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_APIAs] != null) {
        entries[_APIAs] = input[_APIAs];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_De] != null) {
        const memberEntries = se_AttributeValue(input[_De], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Description.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SDC] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_SDC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceDestCheck.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_G] != null) {
        const memberEntries = se_SecurityGroupIdStringList(input[_G], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Att] != null) {
        const memberEntries = se_NetworkInterfaceAttachmentChanges(input[_Att], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Attachment.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyPrivateDnsNameOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_PDHT] != null) {
        entries[_PDHT] = input[_PDHT];
    }
    if (input[_ERNDAR] != null) {
        entries[_ERNDAR] = input[_ERNDAR];
    }
    if (input[_ERNDAAAAR] != null) {
        entries[_ERNDAAAAR] = input[_ERNDAAAAR];
    }
    return entries;
};
const se_ModifyReservedInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_RIIes] != null) {
        const memberEntries = se_ReservedInstancesIdStringList(input[_RIIes], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReservedInstancesId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_TC] != null) {
        const memberEntries = se_ReservedInstancesConfigurationList(input[_TC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReservedInstancesConfigurationSetItemType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyRouteServerRequest = (input, context) => {
    const entries = {};
    if (input[_RSIo] != null) {
        entries[_RSIo] = input[_RSIo];
    }
    if (input[_PRe] != null) {
        entries[_PRe] = input[_PRe];
    }
    if (input[_PRD] != null) {
        entries[_PRD] = input[_PRD];
    }
    if (input[_SNE] != null) {
        entries[_SNE] = input[_SNE];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifySecurityGroupRulesRequest = (input, context) => {
    const entries = {};
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_SGR] != null) {
        const memberEntries = se_SecurityGroupRuleUpdateList(input[_SGR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupRule.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifySnapshotAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_CVP] != null) {
        const memberEntries = se_CreateVolumePermissionModifications(input[_CVP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CreateVolumePermission.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_GNr] != null) {
        const memberEntries = se_GroupNameStringList(input[_GNr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_OTp] != null) {
        entries[_OTp] = input[_OTp];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_UIse] != null) {
        const memberEntries = se_UserIdStringList(input[_UIse], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifySnapshotTierRequest = (input, context) => {
    const entries = {};
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_STto] != null) {
        entries[_STto] = input[_STto];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifySpotFleetRequestRequest = (input, context) => {
    const entries = {};
    if (input[_LTC] != null) {
        const memberEntries = se_LaunchTemplateConfigList(input[_LTC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateConfig.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ODTC] != null) {
        entries[_ODTC] = input[_ODTC];
    }
    if (input[_Con] != null) {
        entries[_Con] = input[_Con];
    }
    if (input[_SFRIp] != null) {
        entries[_SFRIp] = input[_SFRIp];
    }
    if (input[_TCa] != null) {
        entries[_TCa] = input[_TCa];
    }
    if (input[_ECTP] != null) {
        entries[_ECTP] = input[_ECTP];
    }
    return entries;
};
const se_ModifySubnetAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_AIAOC] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_AIAOC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AssignIpv6AddressOnCreation.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MPIOL] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_MPIOL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MapPublicIpOnLaunch.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_MCOIOL] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_MCOIOL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MapCustomerOwnedIpOnLaunch.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_COIP] != null) {
        entries[_COIP] = input[_COIP];
    }
    if (input[_EDn] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_EDn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnableDns64.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PDHTOL] != null) {
        entries[_PDHTOL] = input[_PDHTOL];
    }
    if (input[_ERNDAROL] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_ERNDAROL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnableResourceNameDnsARecordOnLaunch.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ERNDAAAAROL] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_ERNDAAAAROL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnableResourceNameDnsAAAARecordOnLaunch.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ELADI] != null) {
        entries[_ELADI] = input[_ELADI];
    }
    if (input[_DLADI] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_DLADI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DisableLniAtDeviceIndex.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyTrafficMirrorFilterNetworkServicesRequest = (input, context) => {
    const entries = {};
    if (input[_TMFI] != null) {
        entries[_TMFI] = input[_TMFI];
    }
    if (input[_ANS] != null) {
        const memberEntries = se_TrafficMirrorNetworkServiceList(input[_ANS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddNetworkService.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RNS] != null) {
        const memberEntries = se_TrafficMirrorNetworkServiceList(input[_RNS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveNetworkService.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyTrafficMirrorFilterRuleRequest = (input, context) => {
    const entries = {};
    if (input[_TMFRI] != null) {
        entries[_TMFRI] = input[_TMFRI];
    }
    if (input[_TD] != null) {
        entries[_TD] = input[_TD];
    }
    if (input[_RNu] != null) {
        entries[_RNu] = input[_RNu];
    }
    if (input[_RAu] != null) {
        entries[_RAu] = input[_RAu];
    }
    if (input[_DPR] != null) {
        const memberEntries = se_TrafficMirrorPortRangeRequest(input[_DPR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DestinationPortRange.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SPR] != null) {
        const memberEntries = se_TrafficMirrorPortRangeRequest(input[_SPR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourcePortRange.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_SCB] != null) {
        entries[_SCB] = input[_SCB];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_RF] != null) {
        const memberEntries = se_TrafficMirrorFilterRuleFieldList(input[_RF], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveField.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyTrafficMirrorSessionRequest = (input, context) => {
    const entries = {};
    if (input[_TMSI] != null) {
        entries[_TMSI] = input[_TMSI];
    }
    if (input[_TMTI] != null) {
        entries[_TMTI] = input[_TMTI];
    }
    if (input[_TMFI] != null) {
        entries[_TMFI] = input[_TMFI];
    }
    if (input[_PL] != null) {
        entries[_PL] = input[_PL];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_VNI] != null) {
        entries[_VNI] = input[_VNI];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_RF] != null) {
        const memberEntries = se_TrafficMirrorSessionFieldList(input[_RF], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveField.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyTransitGatewayOptions = (input, context) => {
    const entries = {};
    if (input[_ATGCB] != null) {
        const memberEntries = se_TransitGatewayCidrBlockStringList(input[_ATGCB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddTransitGatewayCidrBlocks.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RTGCB] != null) {
        const memberEntries = se_TransitGatewayCidrBlockStringList(input[_RTGCB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveTransitGatewayCidrBlocks.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VES] != null) {
        entries[_VES] = input[_VES];
    }
    if (input[_DSns] != null) {
        entries[_DSns] = input[_DSns];
    }
    if (input[_SGRS] != null) {
        entries[_SGRS] = input[_SGRS];
    }
    if (input[_AASAu] != null) {
        entries[_AASAu] = input[_AASAu];
    }
    if (input[_DRTA] != null) {
        entries[_DRTA] = input[_DRTA];
    }
    if (input[_ADRTI] != null) {
        entries[_ADRTI] = input[_ADRTI];
    }
    if (input[_DRTP] != null) {
        entries[_DRTP] = input[_DRTP];
    }
    if (input[_PDRTI] != null) {
        entries[_PDRTI] = input[_PDRTI];
    }
    if (input[_ASA] != null) {
        entries[_ASA] = input[_ASA];
    }
    return entries;
};
const se_ModifyTransitGatewayPrefixListReferenceRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_PLI] != null) {
        entries[_PLI] = input[_PLI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_Bl] != null) {
        entries[_Bl] = input[_Bl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyTransitGatewayRequest = (input, context) => {
    const entries = {};
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_Op] != null) {
        const memberEntries = se_ModifyTransitGatewayOptions(input[_Op], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Options.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyTransitGatewayVpcAttachmentRequest = (input, context) => {
    const entries = {};
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_ASI] != null) {
        const memberEntries = se_TransitGatewaySubnetIdList(input[_ASI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddSubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RSIe] != null) {
        const memberEntries = se_TransitGatewaySubnetIdList(input[_RSIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveSubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Op] != null) {
        const memberEntries = se_ModifyTransitGatewayVpcAttachmentRequestOptions(input[_Op], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Options.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyTransitGatewayVpcAttachmentRequestOptions = (input, context) => {
    const entries = {};
    if (input[_DSns] != null) {
        entries[_DSns] = input[_DSns];
    }
    if (input[_SGRS] != null) {
        entries[_SGRS] = input[_SGRS];
    }
    if (input[_ISp] != null) {
        entries[_ISp] = input[_ISp];
    }
    if (input[_AMS] != null) {
        entries[_AMS] = input[_AMS];
    }
    return entries;
};
const se_ModifyVerifiedAccessEndpointCidrOptions = (input, context) => {
    const entries = {};
    if (input[_PRo] != null) {
        const memberEntries = se_ModifyVerifiedAccessEndpointPortRangeList(input[_PRo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PortRange.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVerifiedAccessEndpointEniOptions = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_PRo] != null) {
        const memberEntries = se_ModifyVerifiedAccessEndpointPortRangeList(input[_PRo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PortRange.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVerifiedAccessEndpointLoadBalancerOptions = (input, context) => {
    const entries = {};
    if (input[_SIu] != null) {
        const memberEntries = se_ModifyVerifiedAccessEndpointSubnetIdList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_PRo] != null) {
        const memberEntries = se_ModifyVerifiedAccessEndpointPortRangeList(input[_PRo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PortRange.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVerifiedAccessEndpointPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_VAEI] != null) {
        entries[_VAEI] = input[_VAEI];
    }
    if (input[_PE] != null) {
        entries[_PE] = input[_PE];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SS] != null) {
        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SseSpecification.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVerifiedAccessEndpointPortRange = (input, context) => {
    const entries = {};
    if (input[_FP] != null) {
        entries[_FP] = input[_FP];
    }
    if (input[_TP] != null) {
        entries[_TP] = input[_TP];
    }
    return entries;
};
const se_ModifyVerifiedAccessEndpointPortRangeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ModifyVerifiedAccessEndpointPortRange(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ModifyVerifiedAccessEndpointRdsOptions = (input, context) => {
    const entries = {};
    if (input[_SIu] != null) {
        const memberEntries = se_ModifyVerifiedAccessEndpointSubnetIdList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    return entries;
};
const se_ModifyVerifiedAccessEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_VAEI] != null) {
        entries[_VAEI] = input[_VAEI];
    }
    if (input[_VAGI] != null) {
        entries[_VAGI] = input[_VAGI];
    }
    if (input[_LBO] != null) {
        const memberEntries = se_ModifyVerifiedAccessEndpointLoadBalancerOptions(input[_LBO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NIO] != null) {
        const memberEntries = se_ModifyVerifiedAccessEndpointEniOptions(input[_NIO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RO] != null) {
        const memberEntries = se_ModifyVerifiedAccessEndpointRdsOptions(input[_RO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RdsOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CO] != null) {
        const memberEntries = se_ModifyVerifiedAccessEndpointCidrOptions(input[_CO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CidrOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVerifiedAccessEndpointSubnetIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ModifyVerifiedAccessGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input[_VAGI] != null) {
        entries[_VAGI] = input[_VAGI];
    }
    if (input[_PE] != null) {
        entries[_PE] = input[_PE];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SS] != null) {
        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SseSpecification.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVerifiedAccessGroupRequest = (input, context) => {
    const entries = {};
    if (input[_VAGI] != null) {
        entries[_VAGI] = input[_VAGI];
    }
    if (input[_VAII] != null) {
        entries[_VAII] = input[_VAII];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyVerifiedAccessInstanceLoggingConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_VAII] != null) {
        entries[_VAII] = input[_VAII];
    }
    if (input[_AL] != null) {
        const memberEntries = se_VerifiedAccessLogOptions(input[_AL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AccessLogs.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_ModifyVerifiedAccessInstanceRequest = (input, context) => {
    const entries = {};
    if (input[_VAII] != null) {
        entries[_VAII] = input[_VAII];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_CECSD] != null) {
        entries[_CECSD] = input[_CECSD];
    }
    return entries;
};
const se_ModifyVerifiedAccessNativeApplicationOidcOptions = (input, context) => {
    const entries = {};
    if (input[_PSKE] != null) {
        entries[_PSKE] = input[_PSKE];
    }
    if (input[_I] != null) {
        entries[_I] = input[_I];
    }
    if (input[_AE] != null) {
        entries[_AE] = input[_AE];
    }
    if (input[_TEo] != null) {
        entries[_TEo] = input[_TEo];
    }
    if (input[_UIE] != null) {
        entries[_UIE] = input[_UIE];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_CSl] != null) {
        entries[_CSl] = input[_CSl];
    }
    if (input[_Sc] != null) {
        entries[_Sc] = input[_Sc];
    }
    return entries;
};
const se_ModifyVerifiedAccessTrustProviderDeviceOptions = (input, context) => {
    const entries = {};
    if (input[_PSKU] != null) {
        entries[_PSKU] = input[_PSKU];
    }
    return entries;
};
const se_ModifyVerifiedAccessTrustProviderOidcOptions = (input, context) => {
    const entries = {};
    if (input[_I] != null) {
        entries[_I] = input[_I];
    }
    if (input[_AE] != null) {
        entries[_AE] = input[_AE];
    }
    if (input[_TEo] != null) {
        entries[_TEo] = input[_TEo];
    }
    if (input[_UIE] != null) {
        entries[_UIE] = input[_UIE];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_CSl] != null) {
        entries[_CSl] = input[_CSl];
    }
    if (input[_Sc] != null) {
        entries[_Sc] = input[_Sc];
    }
    return entries;
};
const se_ModifyVerifiedAccessTrustProviderRequest = (input, context) => {
    const entries = {};
    if (input[_VATPI] != null) {
        entries[_VATPI] = input[_VATPI];
    }
    if (input[_OO] != null) {
        const memberEntries = se_ModifyVerifiedAccessTrustProviderOidcOptions(input[_OO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OidcOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DOe] != null) {
        const memberEntries = se_ModifyVerifiedAccessTrustProviderDeviceOptions(input[_DOe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DeviceOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_SS] != null) {
        const memberEntries = se_VerifiedAccessSseSpecificationRequest(input[_SS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SseSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NAOO] != null) {
        const memberEntries = se_ModifyVerifiedAccessNativeApplicationOidcOptions(input[_NAOO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NativeApplicationOidcOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVolumeAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_AEIO] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_AEIO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AutoEnableIO.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_VIo] != null) {
        entries[_VIo] = input[_VIo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyVolumeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VIo] != null) {
        entries[_VIo] = input[_VIo];
    }
    if (input[_Siz] != null) {
        entries[_Siz] = input[_Siz];
    }
    if (input[_VT] != null) {
        entries[_VT] = input[_VT];
    }
    if (input[_Io] != null) {
        entries[_Io] = input[_Io];
    }
    if (input[_Th] != null) {
        entries[_Th] = input[_Th];
    }
    if (input[_MAE] != null) {
        entries[_MAE] = input[_MAE];
    }
    return entries;
};
const se_ModifyVpcAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_EDH] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_EDH], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnableDnsHostnames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EDS] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_EDS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnableDnsSupport.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_ENAUM] != null) {
        const memberEntries = se_AttributeBooleanValue(input[_ENAUM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnableNetworkAddressUsageMetrics.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVpcBlockPublicAccessExclusionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_EIxc] != null) {
        entries[_EIxc] = input[_EIxc];
    }
    if (input[_IGEM] != null) {
        entries[_IGEM] = input[_IGEM];
    }
    return entries;
};
const se_ModifyVpcBlockPublicAccessOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IGBM] != null) {
        entries[_IGBM] = input[_IGBM];
    }
    return entries;
};
const se_ModifyVpcEndpointConnectionNotificationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CNIon] != null) {
        entries[_CNIon] = input[_CNIon];
    }
    if (input[_CNAon] != null) {
        entries[_CNAon] = input[_CNAon];
    }
    if (input[_CEo] != null) {
        const memberEntries = se_ValueStringList(input[_CEo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionEvents.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVpcEndpointRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VEIp] != null) {
        entries[_VEIp] = input[_VEIp];
    }
    if (input[_RP] != null) {
        entries[_RP] = input[_RP];
    }
    if (input[_PD] != null) {
        entries[_PD] = input[_PD];
    }
    if (input[_ARTI] != null) {
        const memberEntries = se_VpcEndpointRouteTableIdList(input[_ARTI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddRouteTableId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RRTI] != null) {
        const memberEntries = se_VpcEndpointRouteTableIdList(input[_RRTI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveRouteTableId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ASI] != null) {
        const memberEntries = se_VpcEndpointSubnetIdList(input[_ASI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddSubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RSIe] != null) {
        const memberEntries = se_VpcEndpointSubnetIdList(input[_RSIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveSubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ASGId] != null) {
        const memberEntries = se_VpcEndpointSecurityGroupIdList(input[_ASGId], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddSecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RSGIe] != null) {
        const memberEntries = se_VpcEndpointSecurityGroupIdList(input[_RSGIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveSecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IAT] != null) {
        entries[_IAT] = input[_IAT];
    }
    if (input[_DOn] != null) {
        const memberEntries = se_DnsOptionsSpecification(input[_DOn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DnsOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PDE] != null) {
        entries[_PDE] = input[_PDE];
    }
    if (input[_SC] != null) {
        const memberEntries = se_SubnetConfigurationsList(input[_SC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetConfiguration.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVpcEndpointServiceConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIe] != null) {
        entries[_SIe] = input[_SIe];
    }
    if (input[_PDN] != null) {
        entries[_PDN] = input[_PDN];
    }
    if (input[_RPDN] != null) {
        entries[_RPDN] = input[_RPDN];
    }
    if (input[_ARc] != null) {
        entries[_ARc] = input[_ARc];
    }
    if (input[_ANLBA] != null) {
        const memberEntries = se_ValueStringList(input[_ANLBA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddNetworkLoadBalancerArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RNLBA] != null) {
        const memberEntries = se_ValueStringList(input[_RNLBA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveNetworkLoadBalancerArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AGLBA] != null) {
        const memberEntries = se_ValueStringList(input[_AGLBA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddGatewayLoadBalancerArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RGLBA] != null) {
        const memberEntries = se_ValueStringList(input[_RGLBA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveGatewayLoadBalancerArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ASIAT] != null) {
        const memberEntries = se_ValueStringList(input[_ASIAT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddSupportedIpAddressType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RSIAT] != null) {
        const memberEntries = se_ValueStringList(input[_RSIAT], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveSupportedIpAddressType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ASR] != null) {
        const memberEntries = se_ValueStringList(input[_ASR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddSupportedRegion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RSR] != null) {
        const memberEntries = se_ValueStringList(input[_RSR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveSupportedRegion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVpcEndpointServicePayerResponsibilityRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIe] != null) {
        entries[_SIe] = input[_SIe];
    }
    if (input[_PRa] != null) {
        entries[_PRa] = input[_PRa];
    }
    return entries;
};
const se_ModifyVpcEndpointServicePermissionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIe] != null) {
        entries[_SIe] = input[_SIe];
    }
    if (input[_AAP] != null) {
        const memberEntries = se_ValueStringList(input[_AAP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddAllowedPrincipals.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RAP] != null) {
        const memberEntries = se_ValueStringList(input[_RAP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveAllowedPrincipals.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyVpcPeeringConnectionOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_APCO] != null) {
        const memberEntries = se_PeeringConnectionOptionsRequest(input[_APCO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AccepterPeeringConnectionOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RPCO] != null) {
        const memberEntries = se_PeeringConnectionOptionsRequest(input[_RPCO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RequesterPeeringConnectionOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_VPCI] != null) {
        entries[_VPCI] = input[_VPCI];
    }
    return entries;
};
const se_ModifyVpcTenancyRequest = (input, context) => {
    const entries = {};
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_ITns] != null) {
        entries[_ITns] = input[_ITns];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyVpnConnectionOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_VCI] != null) {
        entries[_VCI] = input[_VCI];
    }
    if (input[_LINC] != null) {
        entries[_LINC] = input[_LINC];
    }
    if (input[_RINC] != null) {
        entries[_RINC] = input[_RINC];
    }
    if (input[_LINCo] != null) {
        entries[_LINCo] = input[_LINCo];
    }
    if (input[_RINCe] != null) {
        entries[_RINCe] = input[_RINCe];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyVpnConnectionRequest = (input, context) => {
    const entries = {};
    if (input[_VCI] != null) {
        entries[_VCI] = input[_VCI];
    }
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_CGIu] != null) {
        entries[_CGIu] = input[_CGIu];
    }
    if (input[_VGI] != null) {
        entries[_VGI] = input[_VGI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyVpnTunnelCertificateRequest = (input, context) => {
    const entries = {};
    if (input[_VCI] != null) {
        entries[_VCI] = input[_VCI];
    }
    if (input[_VTOIA] != null) {
        entries[_VTOIA] = input[_VTOIA];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ModifyVpnTunnelOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_VCI] != null) {
        entries[_VCI] = input[_VCI];
    }
    if (input[_VTOIA] != null) {
        entries[_VTOIA] = input[_VTOIA];
    }
    if (input[_TO] != null) {
        const memberEntries = se_ModifyVpnTunnelOptionsSpecification(input[_TO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TunnelOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_STR] != null) {
        entries[_STR] = input[_STR];
    }
    return entries;
};
const se_ModifyVpnTunnelOptionsSpecification = (input, context) => {
    const entries = {};
    if (input[_TIC] != null) {
        entries[_TIC] = input[_TIC];
    }
    if (input[_TIIC] != null) {
        entries[_TIIC] = input[_TIIC];
    }
    if (input[_PSK] != null) {
        entries[_PSK] = input[_PSK];
    }
    if (input[_PLS] != null) {
        entries[_PLS] = input[_PLS];
    }
    if (input[_PLSh] != null) {
        entries[_PLSh] = input[_PLSh];
    }
    if (input[_RMTS] != null) {
        entries[_RMTS] = input[_RMTS];
    }
    if (input[_RFP] != null) {
        entries[_RFP] = input[_RFP];
    }
    if (input[_RWS] != null) {
        entries[_RWS] = input[_RWS];
    }
    if (input[_DPDTS] != null) {
        entries[_DPDTS] = input[_DPDTS];
    }
    if (input[_DPDTA] != null) {
        entries[_DPDTA] = input[_DPDTA];
    }
    if (input[_PEA] != null) {
        const memberEntries = se_Phase1EncryptionAlgorithmsRequestList(input[_PEA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase1EncryptionAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PEAh] != null) {
        const memberEntries = se_Phase2EncryptionAlgorithmsRequestList(input[_PEAh], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase2EncryptionAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PIAh] != null) {
        const memberEntries = se_Phase1IntegrityAlgorithmsRequestList(input[_PIAh], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase1IntegrityAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PIAha] != null) {
        const memberEntries = se_Phase2IntegrityAlgorithmsRequestList(input[_PIAha], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase2IntegrityAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PDHGN] != null) {
        const memberEntries = se_Phase1DHGroupNumbersRequestList(input[_PDHGN], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase1DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PDHGNh] != null) {
        const memberEntries = se_Phase2DHGroupNumbersRequestList(input[_PDHGNh], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase2DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IKEVe] != null) {
        const memberEntries = se_IKEVersionsRequestList(input[_IKEVe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IKEVersion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SA] != null) {
        entries[_SA] = input[_SA];
    }
    if (input[_LO] != null) {
        const memberEntries = se_VpnTunnelLogOptionsSpecification(input[_LO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LogOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ETLC] != null) {
        entries[_ETLC] = input[_ETLC];
    }
    return entries;
};
const se_MonitorInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_MoveAddressToVpcRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PI] != null) {
        entries[_PI] = input[_PI];
    }
    return entries;
};
const se_MoveByoipCidrToIpamRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_IPO] != null) {
        entries[_IPO] = input[_IPO];
    }
    return entries;
};
const se_MoveCapacityReservationInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_SCRI] != null) {
        entries[_SCRI] = input[_SCRI];
    }
    if (input[_DCRI] != null) {
        entries[_DCRI] = input[_DCRI];
    }
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    return entries;
};
const se_NatGatewayIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_NetworkAclIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_NetworkBandwidthGbps = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = __serializeFloat(input[_M]);
    }
    if (input[_Ma] != null) {
        entries[_Ma] = __serializeFloat(input[_Ma]);
    }
    return entries;
};
const se_NetworkBandwidthGbpsRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = __serializeFloat(input[_M]);
    }
    if (input[_Ma] != null) {
        entries[_Ma] = __serializeFloat(input[_Ma]);
    }
    return entries;
};
const se_NetworkInsightsAccessScopeAnalysisIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_NetworkInsightsAccessScopeIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_NetworkInsightsAnalysisIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_NetworkInsightsPathIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_NetworkInterfaceAttachmentChanges = (input, context) => {
    const entries = {};
    if (input[_AIt] != null) {
        entries[_AIt] = input[_AIt];
    }
    if (input[_DOT] != null) {
        entries[_DOT] = input[_DOT];
    }
    return entries;
};
const se_NetworkInterfaceCount = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_NetworkInterfaceCountRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_NetworkInterfaceIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_NetworkInterfacePermissionIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_NewDhcpConfiguration = (input, context) => {
    const entries = {};
    if (input[_Ke] != null) {
        entries[_Ke] = input[_Ke];
    }
    if (input[_Val] != null) {
        const memberEntries = se_ValueStringList(input[_Val], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Value.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_NewDhcpConfigurationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_NewDhcpConfiguration(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_OccurrenceDayRequestSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`OccurenceDay.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_OnDemandOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_AS] != null) {
        entries[_AS] = input[_AS];
    }
    if (input[_CRO] != null) {
        const memberEntries = se_CapacityReservationOptionsRequest(input[_CRO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SITi] != null) {
        entries[_SITi] = input[_SITi];
    }
    if (input[_SAZ] != null) {
        entries[_SAZ] = input[_SAZ];
    }
    if (input[_MTC] != null) {
        entries[_MTC] = input[_MTC];
    }
    if (input[_MTP] != null) {
        entries[_MTP] = input[_MTP];
    }
    return entries;
};
const se_OperatorRequest = (input, context) => {
    const entries = {};
    if (input[_Prin] != null) {
        entries[_Prin] = input[_Prin];
    }
    return entries;
};
const se_OrganizationalUnitArnStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`OrganizationalUnitArn.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_OrganizationArnStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`OrganizationArn.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_OwnerStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Owner.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PacketHeaderStatementRequest = (input, context) => {
    const entries = {};
    if (input[_SAo] != null) {
        const memberEntries = se_ValueStringList(input[_SAo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceAddress.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DAes] != null) {
        const memberEntries = se_ValueStringList(input[_DAes], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DestinationAddress.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SPo] != null) {
        const memberEntries = se_ValueStringList(input[_SPo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourcePort.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DPes] != null) {
        const memberEntries = se_ValueStringList(input[_DPes], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DestinationPort.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SPL] != null) {
        const memberEntries = se_ValueStringList(input[_SPL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourcePrefixList.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DPLe] != null) {
        const memberEntries = se_ValueStringList(input[_DPLe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DestinationPrefixList.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Pro] != null) {
        const memberEntries = se_ProtocolList(input[_Pro], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Protocol.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PathRequestFilter = (input, context) => {
    const entries = {};
    if (input[_SAou] != null) {
        entries[_SAou] = input[_SAou];
    }
    if (input[_SPR] != null) {
        const memberEntries = se_RequestFilterPortRange(input[_SPR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourcePortRange.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DAest] != null) {
        entries[_DAest] = input[_DAest];
    }
    if (input[_DPR] != null) {
        const memberEntries = se_RequestFilterPortRange(input[_DPR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DestinationPortRange.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PathStatementRequest = (input, context) => {
    const entries = {};
    if (input[_PHS] != null) {
        const memberEntries = se_PacketHeaderStatementRequest(input[_PHS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PacketHeaderStatement.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RSe] != null) {
        const memberEntries = se_ResourceStatementRequest(input[_RSe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceStatement.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PeeringConnectionOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_ADRFRV] != null) {
        entries[_ADRFRV] = input[_ADRFRV];
    }
    if (input[_AEFLCLTRV] != null) {
        entries[_AEFLCLTRV] = input[_AEFLCLTRV];
    }
    if (input[_AEFLVTRCL] != null) {
        entries[_AEFLVTRCL] = input[_AEFLVTRCL];
    }
    return entries;
};
const se_PerformanceFactorReference = (input, context) => {
    const entries = {};
    if (input[_IF] != null) {
        entries[_IF] = input[_IF];
    }
    return entries;
};
const se_PerformanceFactorReferenceRequest = (input, context) => {
    const entries = {};
    if (input[_IF] != null) {
        entries[_IF] = input[_IF];
    }
    return entries;
};
const se_PerformanceFactorReferenceSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PerformanceFactorReference(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PerformanceFactorReferenceSetRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PerformanceFactorReferenceRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Phase1DHGroupNumbersRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Phase1DHGroupNumbersRequestListValue(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Phase1DHGroupNumbersRequestListValue = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_Phase1EncryptionAlgorithmsRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Phase1EncryptionAlgorithmsRequestListValue(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Phase1EncryptionAlgorithmsRequestListValue = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_Phase1IntegrityAlgorithmsRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Phase1IntegrityAlgorithmsRequestListValue(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Phase1IntegrityAlgorithmsRequestListValue = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_Phase2DHGroupNumbersRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Phase2DHGroupNumbersRequestListValue(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Phase2DHGroupNumbersRequestListValue = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_Phase2EncryptionAlgorithmsRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Phase2EncryptionAlgorithmsRequestListValue(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Phase2EncryptionAlgorithmsRequestListValue = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_Phase2IntegrityAlgorithmsRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Phase2IntegrityAlgorithmsRequestListValue(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Phase2IntegrityAlgorithmsRequestListValue = (input, context) => {
    const entries = {};
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_Placement = (input, context) => {
    const entries = {};
    if (input[_Af] != null) {
        entries[_Af] = input[_Af];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_HIo] != null) {
        entries[_HIo] = input[_HIo];
    }
    if (input[_Te] != null) {
        entries[_Te] = input[_Te];
    }
    if (input[_SDp] != null) {
        entries[_SDp] = input[_SDp];
    }
    if (input[_HRGA] != null) {
        entries[_HRGA] = input[_HRGA];
    }
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    return entries;
};
const se_PlacementGroupIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`GroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PlacementGroupStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PortRange = (input, context) => {
    const entries = {};
    if (input[_Fr] != null) {
        entries[_Fr] = input[_Fr];
    }
    if (input[_To] != null) {
        entries[_To] = input[_To];
    }
    return entries;
};
const se_PrefixListId = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_PLI] != null) {
        entries[_PLI] = input[_PLI];
    }
    return entries;
};
const se_PrefixListIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PrefixListId(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PrefixListResourceIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PriceScheduleSpecification = (input, context) => {
    const entries = {};
    if (input[_Ter] != null) {
        entries[_Ter] = input[_Ter];
    }
    if (input[_Pric] != null) {
        entries[_Pric] = __serializeFloat(input[_Pric]);
    }
    if (input[_CCu] != null) {
        entries[_CCu] = input[_CCu];
    }
    return entries;
};
const se_PriceScheduleSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PriceScheduleSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PrivateDnsNameOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_HTo] != null) {
        entries[_HTo] = input[_HTo];
    }
    if (input[_ERNDAR] != null) {
        entries[_ERNDAR] = input[_ERNDAR];
    }
    if (input[_ERNDAAAAR] != null) {
        entries[_ERNDAAAAR] = input[_ERNDAAAAR];
    }
    return entries;
};
const se_PrivateIpAddressConfigSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ScheduledInstancesPrivateIpAddressConfig(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`PrivateIpAddressConfigSet.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PrivateIpAddressSpecification = (input, context) => {
    const entries = {};
    if (input[_Prim] != null) {
        entries[_Prim] = input[_Prim];
    }
    if (input[_PIAr] != null) {
        entries[_PIAr] = input[_PIAr];
    }
    return entries;
};
const se_PrivateIpAddressSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PrivateIpAddressSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PrivateIpAddressStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`PrivateIpAddress.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ProductCodeStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ProductCode.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ProductDescriptionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ProtocolList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ProvisionByoipCidrRequest = (input, context) => {
    const entries = {};
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_CAC] != null) {
        const memberEntries = se_CidrAuthorizationContext(input[_CAC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CidrAuthorizationContext.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PTS] != null) {
        const memberEntries = se_TagSpecificationList(input[_PTS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PoolTagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MRu] != null) {
        entries[_MRu] = input[_MRu];
    }
    if (input[_NBG] != null) {
        entries[_NBG] = input[_NBG];
    }
    return entries;
};
const se_ProvisionIpamByoasnRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIp] != null) {
        entries[_IIp] = input[_IIp];
    }
    if (input[_As] != null) {
        entries[_As] = input[_As];
    }
    if (input[_AAC] != null) {
        const memberEntries = se_AsnAuthorizationContext(input[_AAC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AsnAuthorizationContext.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ProvisionIpamPoolCidrRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_CAC] != null) {
        const memberEntries = se_IpamCidrAuthorizationContext(input[_CAC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CidrAuthorizationContext.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NL] != null) {
        entries[_NL] = input[_NL];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_VM] != null) {
        entries[_VM] = input[_VM];
    }
    if (input[_IERVTI] != null) {
        entries[_IERVTI] = input[_IERVTI];
    }
    return entries;
};
const se_ProvisionPublicIpv4PoolCidrRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_PIo] != null) {
        entries[_PIo] = input[_PIo];
    }
    if (input[_NL] != null) {
        entries[_NL] = input[_NL];
    }
    if (input[_NBG] != null) {
        entries[_NBG] = input[_NBG];
    }
    return entries;
};
const se_PublicIpStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`PublicIp.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PublicIpv4PoolIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PurchaseCapacityBlockExtensionRequest = (input, context) => {
    const entries = {};
    if (input[_CBEOI] != null) {
        entries[_CBEOI] = input[_CBEOI];
    }
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_PurchaseCapacityBlockRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CBOI] != null) {
        entries[_CBOI] = input[_CBOI];
    }
    if (input[_IPn] != null) {
        entries[_IPn] = input[_IPn];
    }
    return entries;
};
const se_PurchaseHostReservationRequest = (input, context) => {
    const entries = {};
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_CCu] != null) {
        entries[_CCu] = input[_CCu];
    }
    if (input[_HIS] != null) {
        const memberEntries = se_RequestHostIdSet(input[_HIS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HostIdSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_LPi] != null) {
        entries[_LPi] = input[_LPi];
    }
    if (input[_OI] != null) {
        entries[_OI] = input[_OI];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PurchaseRequest = (input, context) => {
    const entries = {};
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_PT] != null) {
        entries[_PT] = input[_PT];
    }
    return entries;
};
const se_PurchaseRequestSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PurchaseRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`PurchaseRequest.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PurchaseReservedInstancesOfferingRequest = (input, context) => {
    const entries = {};
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_RIOIe] != null) {
        entries[_RIOIe] = input[_RIOIe];
    }
    if (input[_PTu] != null) {
        entries[_PTu] = __serializeDateTime(input[_PTu]);
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_LPi] != null) {
        const memberEntries = se_ReservedInstanceLimitPrice(input[_LPi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LimitPrice.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PurchaseScheduledInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PRu] != null) {
        const memberEntries = se_PurchaseRequestSet(input[_PRu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PurchaseRequest.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ReasonCodesList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RebootInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RegionNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RegionNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`RegionName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RegisterImageRequest = (input, context) => {
    const entries = {};
    if (input[_IL] != null) {
        entries[_IL] = input[_IL];
    }
    if (input[_BPi] != null) {
        const memberEntries = se_BillingProductList(input[_BPi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BillingProduct.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_BM] != null) {
        entries[_BM] = input[_BM];
    }
    if (input[_TSp] != null) {
        entries[_TSp] = input[_TSp];
    }
    if (input[_UDe] != null) {
        entries[_UDe] = input[_UDe];
    }
    if (input[_ISm] != null) {
        entries[_ISm] = input[_ISm];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_Arc] != null) {
        entries[_Arc] = input[_Arc];
    }
    if (input[_KI] != null) {
        entries[_KI] = input[_KI];
    }
    if (input[_RIa] != null) {
        entries[_RIa] = input[_RIa];
    }
    if (input[_RDN] != null) {
        entries[_RDN] = input[_RDN];
    }
    if (input[_BDM] != null) {
        const memberEntries = se_BlockDeviceMappingRequestList(input[_BDM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_VTir] != null) {
        entries[_VTir] = input[_VTir];
    }
    if (input[_SNS] != null) {
        entries[_SNS] = input[_SNS];
    }
    if (input[_ESn] != null) {
        entries[_ESn] = input[_ESn];
    }
    return entries;
};
const se_RegisterInstanceEventNotificationAttributesRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_ITA] != null) {
        const memberEntries = se_RegisterInstanceTagAttributeRequest(input[_ITA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceTagAttribute.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RegisterInstanceTagAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_IATOI] != null) {
        entries[_IATOI] = input[_IATOI];
    }
    if (input[_ITK] != null) {
        const memberEntries = se_InstanceTagKeySet(input[_ITK], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceTagKey.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RegisterTransitGatewayMulticastGroupMembersRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_GIA] != null) {
        entries[_GIA] = input[_GIA];
    }
    if (input[_NIIe] != null) {
        const memberEntries = se_TransitGatewayNetworkInterfaceIdList(input[_NIIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RegisterTransitGatewayMulticastGroupSourcesRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_GIA] != null) {
        entries[_GIA] = input[_GIA];
    }
    if (input[_NIIe] != null) {
        const memberEntries = se_TransitGatewayNetworkInterfaceIdList(input[_NIIe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RejectCapacityReservationBillingOwnershipRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_CRI] != null) {
        entries[_CRI] = input[_CRI];
    }
    return entries;
};
const se_RejectTransitGatewayMulticastDomainAssociationsRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_ValueStringList(input[_SIu], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RejectTransitGatewayPeeringAttachmentRequest = (input, context) => {
    const entries = {};
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RejectTransitGatewayVpcAttachmentRequest = (input, context) => {
    const entries = {};
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RejectVpcEndpointConnectionsRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIe] != null) {
        entries[_SIe] = input[_SIe];
    }
    if (input[_VEI] != null) {
        const memberEntries = se_VpcEndpointIdList(input[_VEI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RejectVpcPeeringConnectionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_VPCI] != null) {
        entries[_VPCI] = input[_VPCI];
    }
    return entries;
};
const se_ReleaseAddressRequest = (input, context) => {
    const entries = {};
    if (input[_AIl] != null) {
        entries[_AIl] = input[_AIl];
    }
    if (input[_PI] != null) {
        entries[_PI] = input[_PI];
    }
    if (input[_NBG] != null) {
        entries[_NBG] = input[_NBG];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ReleaseHostsRequest = (input, context) => {
    const entries = {};
    if (input[_HI] != null) {
        const memberEntries = se_RequestHostIdList(input[_HI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HostId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ReleaseIpamPoolAllocationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IPI] != null) {
        entries[_IPI] = input[_IPI];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_IPAI] != null) {
        entries[_IPAI] = input[_IPAI];
    }
    return entries;
};
const se_RemoveIpamOperatingRegion = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    return entries;
};
const se_RemoveIpamOperatingRegionSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_RemoveIpamOperatingRegion(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RemoveIpamOrganizationalUnitExclusion = (input, context) => {
    const entries = {};
    if (input[_OEP] != null) {
        entries[_OEP] = input[_OEP];
    }
    return entries;
};
const se_RemoveIpamOrganizationalUnitExclusionSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_RemoveIpamOrganizationalUnitExclusion(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RemovePrefixListEntries = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_RemovePrefixListEntry(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RemovePrefixListEntry = (input, context) => {
    const entries = {};
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    return entries;
};
const se_ReplaceIamInstanceProfileAssociationRequest = (input, context) => {
    const entries = {};
    if (input[_IIP] != null) {
        const memberEntries = se_IamInstanceProfileSpecification(input[_IIP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AIss] != null) {
        entries[_AIss] = input[_AIss];
    }
    return entries;
};
const se_ReplaceImageCriteriaInAllowedImagesSettingsRequest = (input, context) => {
    const entries = {};
    if (input[_ICm] != null) {
        const memberEntries = se_ImageCriterionRequestList(input[_ICm], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ImageCriterion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ReplaceNetworkAclAssociationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_AIss] != null) {
        entries[_AIss] = input[_AIss];
    }
    if (input[_NAI] != null) {
        entries[_NAI] = input[_NAI];
    }
    return entries;
};
const se_ReplaceNetworkAclEntryRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NAI] != null) {
        entries[_NAI] = input[_NAI];
    }
    if (input[_RNu] != null) {
        entries[_RNu] = input[_RNu];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_RAu] != null) {
        entries[_RAu] = input[_RAu];
    }
    if (input[_Eg] != null) {
        entries[_Eg] = input[_Eg];
    }
    if (input[_CB] != null) {
        entries[_CB] = input[_CB];
    }
    if (input[_ICB] != null) {
        entries[_ICB] = input[_ICB];
    }
    if (input[_ITC] != null) {
        const memberEntries = se_IcmpTypeCode(input[_ITC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Icmp.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PR] != null) {
        const memberEntries = se_PortRange(input[_PR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PortRange.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ReplaceRootVolumeTaskIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ReplaceRootVolumeTaskId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ReplaceRouteRequest = (input, context) => {
    const entries = {};
    if (input[_DPLI] != null) {
        entries[_DPLI] = input[_DPLI];
    }
    if (input[_VEIp] != null) {
        entries[_VEIp] = input[_VEIp];
    }
    if (input[_LTo] != null) {
        entries[_LTo] = input[_LTo];
    }
    if (input[_TGI] != null) {
        entries[_TGI] = input[_TGI];
    }
    if (input[_LGI] != null) {
        entries[_LGI] = input[_LGI];
    }
    if (input[_CGI] != null) {
        entries[_CGI] = input[_CGI];
    }
    if (input[_CNAo] != null) {
        entries[_CNAo] = input[_CNAo];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_GI] != null) {
        entries[_GI] = input[_GI];
    }
    if (input[_DICB] != null) {
        entries[_DICB] = input[_DICB];
    }
    if (input[_EOIGI] != null) {
        entries[_EOIGI] = input[_EOIGI];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_VPCI] != null) {
        entries[_VPCI] = input[_VPCI];
    }
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    return entries;
};
const se_ReplaceRouteTableAssociationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_AIss] != null) {
        entries[_AIss] = input[_AIss];
    }
    if (input[_RTI] != null) {
        entries[_RTI] = input[_RTI];
    }
    return entries;
};
const se_ReplaceTransitGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input[_DCB] != null) {
        entries[_DCB] = input[_DCB];
    }
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_TGAI] != null) {
        entries[_TGAI] = input[_TGAI];
    }
    if (input[_Bl] != null) {
        entries[_Bl] = input[_Bl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ReplaceVpnTunnelRequest = (input, context) => {
    const entries = {};
    if (input[_VCI] != null) {
        entries[_VCI] = input[_VCI];
    }
    if (input[_VTOIA] != null) {
        entries[_VTOIA] = input[_VTOIA];
    }
    if (input[_APM] != null) {
        entries[_APM] = input[_APM];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ReportInstanceStatusRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_In] != null) {
        const memberEntries = se_InstanceIdStringList(input[_In], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Statu] != null) {
        entries[_Statu] = input[_Statu];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ETn] != null) {
        entries[_ETn] = __serializeDateTime(input[_ETn]);
    }
    if (input[_RCe] != null) {
        const memberEntries = se_ReasonCodesList(input[_RCe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ReasonCode.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    return entries;
};
const se_RequestFilterPortRange = (input, context) => {
    const entries = {};
    if (input[_FP] != null) {
        entries[_FP] = input[_FP];
    }
    if (input[_TP] != null) {
        entries[_TP] = input[_TP];
    }
    return entries;
};
const se_RequestHostIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RequestHostIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RequestInstanceTypeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RequestIpamResourceTag = (input, context) => {
    const entries = {};
    if (input[_Ke] != null) {
        entries[_Ke] = input[_Ke];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_RequestIpamResourceTagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_RequestIpamResourceTag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RequestLaunchTemplateData = (input, context) => {
    const entries = {};
    if (input[_KI] != null) {
        entries[_KI] = input[_KI];
    }
    if (input[_EO] != null) {
        entries[_EO] = input[_EO];
    }
    if (input[_IIP] != null) {
        const memberEntries = se_LaunchTemplateIamInstanceProfileSpecificationRequest(input[_IIP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_BDM] != null) {
        const memberEntries = se_LaunchTemplateBlockDeviceMappingRequestList(input[_BDM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NI] != null) {
        const memberEntries = se_LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList(input[_NI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_KN] != null) {
        entries[_KN] = input[_KN];
    }
    if (input[_Mon] != null) {
        const memberEntries = se_LaunchTemplatesMonitoringRequest(input[_Mon], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Monitoring.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Pl] != null) {
        const memberEntries = se_LaunchTemplatePlacementRequest(input[_Pl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Placement.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RDI] != null) {
        entries[_RDI] = input[_RDI];
    }
    if (input[_DATis] != null) {
        entries[_DATis] = input[_DATis];
    }
    if (input[_IISB] != null) {
        entries[_IISB] = input[_IISB];
    }
    if (input[_UD] != null) {
        entries[_UD] = input[_UD];
    }
    if (input[_TS] != null) {
        const memberEntries = se_LaunchTemplateTagSpecificationRequestList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_EGS] != null) {
        const memberEntries = se_ElasticGpuSpecificationList(input[_EGS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ElasticGpuSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_EIA] != null) {
        const memberEntries = se_LaunchTemplateElasticInferenceAcceleratorList(input[_EIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ElasticInferenceAccelerator.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SGI] != null) {
        const memberEntries = se_SecurityGroupIdStringList(input[_SGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SG] != null) {
        const memberEntries = se_SecurityGroupStringList(input[_SG], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IMO] != null) {
        const memberEntries = se_LaunchTemplateInstanceMarketOptionsRequest(input[_IMO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceMarketOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CSred] != null) {
        const memberEntries = se_CreditSpecificationRequest(input[_CSred], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CreditSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_COp] != null) {
        const memberEntries = se_LaunchTemplateCpuOptionsRequest(input[_COp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CpuOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CRSa] != null) {
        const memberEntries = se_LaunchTemplateCapacityReservationSpecificationRequest(input[_CRSa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LSi] != null) {
        const memberEntries = se_LaunchTemplateLicenseSpecificationListRequest(input[_LSi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LicenseSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_HO] != null) {
        const memberEntries = se_LaunchTemplateHibernationOptionsRequest(input[_HO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HibernationOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MO] != null) {
        const memberEntries = se_LaunchTemplateInstanceMetadataOptionsRequest(input[_MO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetadataOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EOn] != null) {
        const memberEntries = se_LaunchTemplateEnclaveOptionsRequest(input[_EOn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnclaveOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IR] != null) {
        const memberEntries = se_InstanceRequirementsRequest(input[_IR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRequirements.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PDNO] != null) {
        const memberEntries = se_LaunchTemplatePrivateDnsNameOptionsRequest(input[_PDNO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateDnsNameOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MOa] != null) {
        const memberEntries = se_LaunchTemplateInstanceMaintenanceOptionsRequest(input[_MOa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MaintenanceOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DAS] != null) {
        entries[_DAS] = input[_DAS];
    }
    if (input[_O] != null) {
        const memberEntries = se_OperatorRequest(input[_O], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Operator.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NPO] != null) {
        const memberEntries = se_LaunchTemplateNetworkPerformanceOptionsRequest(input[_NPO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkPerformanceOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RequestSpotFleetRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SFRC] != null) {
        const memberEntries = se_SpotFleetRequestConfigData(input[_SFRC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SpotFleetRequestConfig.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RequestSpotInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_LSa] != null) {
        const memberEntries = se_RequestSpotLaunchSpecification(input[_LSa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IIB] != null) {
        entries[_IIB] = input[_IIB];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SPp] != null) {
        entries[_SPp] = input[_SPp];
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_VF] != null) {
        entries[_VF] = __serializeDateTime(input[_VF]);
    }
    if (input[_VU] != null) {
        entries[_VU] = __serializeDateTime(input[_VU]);
    }
    if (input[_LG] != null) {
        entries[_LG] = input[_LG];
    }
    if (input[_AZG] != null) {
        entries[_AZG] = input[_AZG];
    }
    if (input[_BDMl] != null) {
        entries[_BDMl] = input[_BDMl];
    }
    return entries;
};
const se_RequestSpotLaunchSpecification = (input, context) => {
    const entries = {};
    if (input[_SGI] != null) {
        const memberEntries = se_RequestSpotLaunchSpecificationSecurityGroupIdList(input[_SGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SG] != null) {
        const memberEntries = se_RequestSpotLaunchSpecificationSecurityGroupList(input[_SG], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ATd] != null) {
        entries[_ATd] = input[_ATd];
    }
    if (input[_BDM] != null) {
        const memberEntries = se_BlockDeviceMappingList(input[_BDM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_EO] != null) {
        entries[_EO] = input[_EO];
    }
    if (input[_IIP] != null) {
        const memberEntries = se_IamInstanceProfileSpecification(input[_IIP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_KI] != null) {
        entries[_KI] = input[_KI];
    }
    if (input[_KN] != null) {
        entries[_KN] = input[_KN];
    }
    if (input[_Mon] != null) {
        const memberEntries = se_RunInstancesMonitoringEnabled(input[_Mon], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Monitoring.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NI] != null) {
        const memberEntries = se_InstanceNetworkInterfaceSpecificationList(input[_NI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Pl] != null) {
        const memberEntries = se_SpotPlacement(input[_Pl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Placement.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RIa] != null) {
        entries[_RIa] = input[_RIa];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_UD] != null) {
        entries[_UD] = input[_UD];
    }
    return entries;
};
const se_RequestSpotLaunchSpecificationSecurityGroupIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RequestSpotLaunchSpecificationSecurityGroupList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ReservationFleetInstanceSpecification = (input, context) => {
    const entries = {};
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_IPn] != null) {
        entries[_IPn] = input[_IPn];
    }
    if (input[_W] != null) {
        entries[_W] = __serializeFloat(input[_W]);
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_AZI] != null) {
        entries[_AZI] = input[_AZI];
    }
    if (input[_EO] != null) {
        entries[_EO] = input[_EO];
    }
    if (input[_Pri] != null) {
        entries[_Pri] = input[_Pri];
    }
    return entries;
};
const se_ReservationFleetInstanceSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ReservationFleetInstanceSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ReservedInstanceIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ReservedInstanceId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ReservedInstanceLimitPrice = (input, context) => {
    const entries = {};
    if (input[_Am] != null) {
        entries[_Am] = __serializeFloat(input[_Am]);
    }
    if (input[_CCu] != null) {
        entries[_CCu] = input[_CCu];
    }
    return entries;
};
const se_ReservedInstancesConfiguration = (input, context) => {
    const entries = {};
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_Pla] != null) {
        entries[_Pla] = input[_Pla];
    }
    if (input[_Sc] != null) {
        entries[_Sc] = input[_Sc];
    }
    return entries;
};
const se_ReservedInstancesConfigurationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ReservedInstancesConfiguration(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ReservedInstancesIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ReservedInstancesId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ReservedInstancesModificationIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ReservedInstancesModificationId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ReservedInstancesOfferingIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ResetAddressAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_AIl] != null) {
        entries[_AIl] = input[_AIl];
    }
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ResetEbsDefaultKmsKeyIdRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ResetFpgaImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_FII] != null) {
        entries[_FII] = input[_FII];
    }
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    return entries;
};
const se_ResetImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ResetInstanceAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    return entries;
};
const se_ResetNetworkInterfaceAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_SDC] != null) {
        entries[_SDC] = input[_SDC];
    }
    return entries;
};
const se_ResetSnapshotAttributeRequest = (input, context) => {
    const entries = {};
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ResourceIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ResourceList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ResourceStatementRequest = (input, context) => {
    const entries = {};
    if (input[_Re] != null) {
        const memberEntries = se_ValueStringList(input[_Re], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Resource.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_RTeso] != null) {
        const memberEntries = se_ValueStringList(input[_RTeso], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RestorableByStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RestoreAddressToClassicRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PI] != null) {
        entries[_PI] = input[_PI];
    }
    return entries;
};
const se_RestoreImageFromRecycleBinRequest = (input, context) => {
    const entries = {};
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RestoreManagedPrefixListVersionRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_PLI] != null) {
        entries[_PLI] = input[_PLI];
    }
    if (input[_PV] != null) {
        entries[_PV] = input[_PV];
    }
    if (input[_CVu] != null) {
        entries[_CVu] = input[_CVu];
    }
    return entries;
};
const se_RestoreSnapshotFromRecycleBinRequest = (input, context) => {
    const entries = {};
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RestoreSnapshotTierRequest = (input, context) => {
    const entries = {};
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_TRD] != null) {
        entries[_TRD] = input[_TRD];
    }
    if (input[_PRer] != null) {
        entries[_PRer] = input[_PRer];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RevokeClientVpnIngressRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_TNC] != null) {
        entries[_TNC] = input[_TNC];
    }
    if (input[_AGI] != null) {
        entries[_AGI] = input[_AGI];
    }
    if (input[_RAG] != null) {
        entries[_RAG] = input[_RAG];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RevokeSecurityGroupEgressRequest = (input, context) => {
    const entries = {};
    if (input[_SGRI] != null) {
        const memberEntries = se_SecurityGroupRuleIdList(input[_SGRI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupRuleId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_SSGN] != null) {
        entries[_SSGN] = input[_SSGN];
    }
    if (input[_SSGOI] != null) {
        entries[_SSGOI] = input[_SSGOI];
    }
    if (input[_IPpr] != null) {
        entries[_IPpr] = input[_IPpr];
    }
    if (input[_FP] != null) {
        entries[_FP] = input[_FP];
    }
    if (input[_TP] != null) {
        entries[_TP] = input[_TP];
    }
    if (input[_CIi] != null) {
        entries[_CIi] = input[_CIi];
    }
    if (input[_IPpe] != null) {
        const memberEntries = se_IpPermissionList(input[_IPpe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RevokeSecurityGroupIngressRequest = (input, context) => {
    const entries = {};
    if (input[_CIi] != null) {
        entries[_CIi] = input[_CIi];
    }
    if (input[_FP] != null) {
        entries[_FP] = input[_FP];
    }
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_IPpe] != null) {
        const memberEntries = se_IpPermissionList(input[_IPpe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IPpr] != null) {
        entries[_IPpr] = input[_IPpr];
    }
    if (input[_SSGN] != null) {
        entries[_SSGN] = input[_SSGN];
    }
    if (input[_SSGOI] != null) {
        entries[_SSGOI] = input[_SSGOI];
    }
    if (input[_TP] != null) {
        entries[_TP] = input[_TP];
    }
    if (input[_SGRI] != null) {
        const memberEntries = se_SecurityGroupRuleIdList(input[_SGRI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupRuleId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_RouteServerBgpOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_PAee] != null) {
        entries[_PAee] = input[_PAee];
    }
    if (input[_PLD] != null) {
        entries[_PLD] = input[_PLD];
    }
    return entries;
};
const se_RouteServerEndpointIdsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RouteServerIdsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RouteServerPeerIdsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RouteTableIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RunInstancesMonitoringEnabled = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    return entries;
};
const se_RunInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_BDM] != null) {
        const memberEntries = se_BlockDeviceMappingRequestList(input[_BDM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_IAC] != null) {
        entries[_IAC] = input[_IAC];
    }
    if (input[_IA] != null) {
        const memberEntries = se_InstanceIpv6AddressList(input[_IA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Address.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_KI] != null) {
        entries[_KI] = input[_KI];
    }
    if (input[_KN] != null) {
        entries[_KN] = input[_KN];
    }
    if (input[_MC] != null) {
        entries[_MC] = input[_MC];
    }
    if (input[_MCi] != null) {
        entries[_MCi] = input[_MCi];
    }
    if (input[_Mon] != null) {
        const memberEntries = se_RunInstancesMonitoringEnabled(input[_Mon], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Monitoring.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Pl] != null) {
        const memberEntries = se_Placement(input[_Pl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Placement.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RIa] != null) {
        entries[_RIa] = input[_RIa];
    }
    if (input[_SGI] != null) {
        const memberEntries = se_SecurityGroupIdStringList(input[_SGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SG] != null) {
        const memberEntries = se_SecurityGroupStringList(input[_SG], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_UD] != null) {
        entries[_UD] = input[_UD];
    }
    if (input[_EGSl] != null) {
        const memberEntries = se_ElasticGpuSpecifications(input[_EGSl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ElasticGpuSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_EIA] != null) {
        const memberEntries = se_ElasticInferenceAccelerators(input[_EIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ElasticInferenceAccelerator.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_LTa] != null) {
        const memberEntries = se_LaunchTemplateSpecification(input[_LTa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IMO] != null) {
        const memberEntries = se_InstanceMarketOptionsRequest(input[_IMO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceMarketOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CSred] != null) {
        const memberEntries = se_CreditSpecificationRequest(input[_CSred], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CreditSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_COp] != null) {
        const memberEntries = se_CpuOptionsRequest(input[_COp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CpuOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CRSa] != null) {
        const memberEntries = se_CapacityReservationSpecification(input[_CRSa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityReservationSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_HO] != null) {
        const memberEntries = se_HibernationOptionsRequest(input[_HO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HibernationOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LSi] != null) {
        const memberEntries = se_LicenseSpecificationListRequest(input[_LSi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LicenseSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MO] != null) {
        const memberEntries = se_InstanceMetadataOptionsRequest(input[_MO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetadataOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EOn] != null) {
        const memberEntries = se_EnclaveOptionsRequest(input[_EOn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EnclaveOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PDNO] != null) {
        const memberEntries = se_PrivateDnsNameOptionsRequest(input[_PDNO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateDnsNameOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MOa] != null) {
        const memberEntries = se_InstanceMaintenanceOptionsRequest(input[_MOa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MaintenanceOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DAS] != null) {
        entries[_DAS] = input[_DAS];
    }
    if (input[_EPI] != null) {
        entries[_EPI] = input[_EPI];
    }
    if (input[_NPO] != null) {
        const memberEntries = se_InstanceNetworkPerformanceOptionsRequest(input[_NPO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkPerformanceOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_O] != null) {
        const memberEntries = se_OperatorRequest(input[_O], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Operator.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_DATis] != null) {
        entries[_DATis] = input[_DATis];
    }
    if (input[_IISB] != null) {
        entries[_IISB] = input[_IISB];
    }
    if (input[_PIAr] != null) {
        entries[_PIAr] = input[_PIAr];
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_AId] != null) {
        entries[_AId] = input[_AId];
    }
    if (input[_NI] != null) {
        const memberEntries = se_InstanceNetworkInterfaceSpecificationList(input[_NI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IIP] != null) {
        const memberEntries = se_IamInstanceProfileSpecification(input[_IIP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EO] != null) {
        entries[_EO] = input[_EO];
    }
    return entries;
};
const se_RunScheduledInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_LSa] != null) {
        const memberEntries = se_ScheduledInstancesLaunchSpecification(input[_LSa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SIIch] != null) {
        entries[_SIIch] = input[_SIIch];
    }
    return entries;
};
const se_S3ObjectTag = (input, context) => {
    const entries = {};
    if (input[_Ke] != null) {
        entries[_Ke] = input[_Ke];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_S3ObjectTagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_S3ObjectTag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_S3Storage = (input, context) => {
    const entries = {};
    if (input[_AWSAKI] != null) {
        entries[_AWSAKI] = input[_AWSAKI];
    }
    if (input[_B] != null) {
        entries[_B] = input[_B];
    }
    if (input[_Pr] != null) {
        entries[_Pr] = input[_Pr];
    }
    if (input[_UP] != null) {
        entries[_UP] = context.base64Encoder(input[_UP]);
    }
    if (input[_UPS] != null) {
        entries[_UPS] = input[_UPS];
    }
    return entries;
};
const se_ScheduledInstanceIdRequestSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ScheduledInstanceId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ScheduledInstanceRecurrenceRequest = (input, context) => {
    const entries = {};
    if (input[_Fre] != null) {
        entries[_Fre] = input[_Fre];
    }
    if (input[_Int] != null) {
        entries[_Int] = input[_Int];
    }
    if (input[_OD] != null) {
        const memberEntries = se_OccurrenceDayRequestSet(input[_OD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OccurrenceDay.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_ORTE] != null) {
        entries[_ORTE] = input[_ORTE];
    }
    if (input[_OU] != null) {
        entries[_OU] = input[_OU];
    }
    return entries;
};
const se_ScheduledInstancesBlockDeviceMapping = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_E] != null) {
        const memberEntries = se_ScheduledInstancesEbs(input[_E], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ebs.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ND] != null) {
        entries[_ND] = input[_ND];
    }
    if (input[_VN] != null) {
        entries[_VN] = input[_VN];
    }
    return entries;
};
const se_ScheduledInstancesBlockDeviceMappingSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ScheduledInstancesBlockDeviceMapping(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`BlockDeviceMapping.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ScheduledInstancesEbs = (input, context) => {
    const entries = {};
    if (input[_DOT] != null) {
        entries[_DOT] = input[_DOT];
    }
    if (input[_Enc] != null) {
        entries[_Enc] = input[_Enc];
    }
    if (input[_Io] != null) {
        entries[_Io] = input[_Io];
    }
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_VS] != null) {
        entries[_VS] = input[_VS];
    }
    if (input[_VT] != null) {
        entries[_VT] = input[_VT];
    }
    return entries;
};
const se_ScheduledInstancesIamInstanceProfile = (input, context) => {
    const entries = {};
    if (input[_Ar] != null) {
        entries[_Ar] = input[_Ar];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    return entries;
};
const se_ScheduledInstancesIpv6Address = (input, context) => {
    const entries = {};
    if (input[_IApv] != null) {
        entries[_IApv] = input[_IApv];
    }
    return entries;
};
const se_ScheduledInstancesIpv6AddressList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ScheduledInstancesIpv6Address(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Ipv6Address.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ScheduledInstancesLaunchSpecification = (input, context) => {
    const entries = {};
    if (input[_BDM] != null) {
        const memberEntries = se_ScheduledInstancesBlockDeviceMappingSet(input[_BDM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_EO] != null) {
        entries[_EO] = input[_EO];
    }
    if (input[_IIP] != null) {
        const memberEntries = se_ScheduledInstancesIamInstanceProfile(input[_IIP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_KI] != null) {
        entries[_KI] = input[_KI];
    }
    if (input[_KN] != null) {
        entries[_KN] = input[_KN];
    }
    if (input[_Mon] != null) {
        const memberEntries = se_ScheduledInstancesMonitoring(input[_Mon], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Monitoring.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NI] != null) {
        const memberEntries = se_ScheduledInstancesNetworkInterfaceSet(input[_NI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Pl] != null) {
        const memberEntries = se_ScheduledInstancesPlacement(input[_Pl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Placement.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RIa] != null) {
        entries[_RIa] = input[_RIa];
    }
    if (input[_SGI] != null) {
        const memberEntries = se_ScheduledInstancesSecurityGroupIdSet(input[_SGI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_UD] != null) {
        entries[_UD] = input[_UD];
    }
    return entries;
};
const se_ScheduledInstancesMonitoring = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    return entries;
};
const se_ScheduledInstancesNetworkInterface = (input, context) => {
    const entries = {};
    if (input[_APIAs] != null) {
        entries[_APIAs] = input[_APIAs];
    }
    if (input[_DOT] != null) {
        entries[_DOT] = input[_DOT];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_DIev] != null) {
        entries[_DIev] = input[_DIev];
    }
    if (input[_G] != null) {
        const memberEntries = se_ScheduledInstancesSecurityGroupIdSet(input[_G], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Group.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IAC] != null) {
        entries[_IAC] = input[_IAC];
    }
    if (input[_IA] != null) {
        const memberEntries = se_ScheduledInstancesIpv6AddressList(input[_IA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Address.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_PIAr] != null) {
        entries[_PIAr] = input[_PIAr];
    }
    if (input[_PIACr] != null) {
        const memberEntries = se_PrivateIpAddressConfigSet(input[_PIACr], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateIpAddressConfig.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SPIAC] != null) {
        entries[_SPIAC] = input[_SPIAC];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    return entries;
};
const se_ScheduledInstancesNetworkInterfaceSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ScheduledInstancesNetworkInterface(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`NetworkInterface.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ScheduledInstancesPlacement = (input, context) => {
    const entries = {};
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    return entries;
};
const se_ScheduledInstancesPrivateIpAddressConfig = (input, context) => {
    const entries = {};
    if (input[_Prim] != null) {
        entries[_Prim] = input[_Prim];
    }
    if (input[_PIAr] != null) {
        entries[_PIAr] = input[_PIAr];
    }
    return entries;
};
const se_ScheduledInstancesSecurityGroupIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SecurityGroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SearchLocalGatewayRoutesRequest = (input, context) => {
    const entries = {};
    if (input[_LGRTI] != null) {
        entries[_LGRTI] = input[_LGRTI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_SearchTransitGatewayMulticastGroupsRequest = (input, context) => {
    const entries = {};
    if (input[_TGMDI] != null) {
        entries[_TGMDI] = input[_TGMDI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_SearchTransitGatewayRoutesRequest = (input, context) => {
    const entries = {};
    if (input[_TGRTI] != null) {
        entries[_TGRTI] = input[_TGRTI];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_FilterList(input[_Fi], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_SecurityGroupIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SecurityGroupIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SecurityGroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SecurityGroupIdStringListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SecurityGroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SecurityGroupRuleDescription = (input, context) => {
    const entries = {};
    if (input[_SGRIe] != null) {
        entries[_SGRIe] = input[_SGRIe];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    return entries;
};
const se_SecurityGroupRuleDescriptionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_SecurityGroupRuleDescription(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_SecurityGroupRuleIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SecurityGroupRuleRequest = (input, context) => {
    const entries = {};
    if (input[_IPpr] != null) {
        entries[_IPpr] = input[_IPpr];
    }
    if (input[_FP] != null) {
        entries[_FP] = input[_FP];
    }
    if (input[_TP] != null) {
        entries[_TP] = input[_TP];
    }
    if (input[_CIidr] != null) {
        entries[_CIidr] = input[_CIidr];
    }
    if (input[_CIid] != null) {
        entries[_CIid] = input[_CIid];
    }
    if (input[_PLI] != null) {
        entries[_PLI] = input[_PLI];
    }
    if (input[_RGI] != null) {
        entries[_RGI] = input[_RGI];
    }
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    return entries;
};
const se_SecurityGroupRuleUpdate = (input, context) => {
    const entries = {};
    if (input[_SGRIe] != null) {
        entries[_SGRIe] = input[_SGRIe];
    }
    if (input[_SGRe] != null) {
        const memberEntries = se_SecurityGroupRuleRequest(input[_SGRe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupRule.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SecurityGroupRuleUpdateList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_SecurityGroupRuleUpdate(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_SecurityGroupStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SecurityGroup.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SendDiagnosticInterruptRequest = (input, context) => {
    const entries = {};
    if (input[_IIn] != null) {
        entries[_IIn] = input[_IIn];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_SlotDateTimeRangeRequest = (input, context) => {
    const entries = {};
    if (input[_ETa] != null) {
        entries[_ETa] = __serializeDateTime(input[_ETa]);
    }
    if (input[_LTat] != null) {
        entries[_LTat] = __serializeDateTime(input[_LTat]);
    }
    return entries;
};
const se_SlotStartTimeRangeRequest = (input, context) => {
    const entries = {};
    if (input[_ETa] != null) {
        entries[_ETa] = __serializeDateTime(input[_ETa]);
    }
    if (input[_LTat] != null) {
        entries[_LTat] = __serializeDateTime(input[_LTat]);
    }
    return entries;
};
const se_SnapshotDiskContainer = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_Fo] != null) {
        entries[_Fo] = input[_Fo];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    if (input[_UB] != null) {
        const memberEntries = se_UserBucket(input[_UB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `UserBucket.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SnapshotIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SnapshotId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SpotCapacityRebalance = (input, context) => {
    const entries = {};
    if (input[_RS] != null) {
        entries[_RS] = input[_RS];
    }
    if (input[_TDe] != null) {
        entries[_TDe] = input[_TDe];
    }
    return entries;
};
const se_SpotFleetLaunchSpecification = (input, context) => {
    const entries = {};
    if (input[_ATd] != null) {
        entries[_ATd] = input[_ATd];
    }
    if (input[_BDM] != null) {
        const memberEntries = se_BlockDeviceMappingList(input[_BDM], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_EO] != null) {
        entries[_EO] = input[_EO];
    }
    if (input[_IIP] != null) {
        const memberEntries = se_IamInstanceProfileSpecification(input[_IIP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IIma] != null) {
        entries[_IIma] = input[_IIma];
    }
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    if (input[_KI] != null) {
        entries[_KI] = input[_KI];
    }
    if (input[_KN] != null) {
        entries[_KN] = input[_KN];
    }
    if (input[_Mon] != null) {
        const memberEntries = se_SpotFleetMonitoring(input[_Mon], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Monitoring.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NI] != null) {
        const memberEntries = se_InstanceNetworkInterfaceSpecificationList(input[_NI], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Pl] != null) {
        const memberEntries = se_SpotPlacement(input[_Pl], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Placement.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RIa] != null) {
        entries[_RIa] = input[_RIa];
    }
    if (input[_SPp] != null) {
        entries[_SPp] = input[_SPp];
    }
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_UD] != null) {
        entries[_UD] = input[_UD];
    }
    if (input[_WCe] != null) {
        entries[_WCe] = __serializeFloat(input[_WCe]);
    }
    if (input[_TS] != null) {
        const memberEntries = se_SpotFleetTagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecificationSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IR] != null) {
        const memberEntries = se_InstanceRequirements(input[_IR], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRequirements.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SG] != null) {
        const memberEntries = se_GroupIdentifierList(input[_SG], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `GroupSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SpotFleetMonitoring = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    return entries;
};
const se_SpotFleetRequestConfigData = (input, context) => {
    const entries = {};
    if (input[_AS] != null) {
        entries[_AS] = input[_AS];
    }
    if (input[_ODAS] != null) {
        entries[_ODAS] = input[_ODAS];
    }
    if (input[_SMS] != null) {
        const memberEntries = se_SpotMaintenanceStrategies(input[_SMS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SpotMaintenanceStrategies.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_ECTP] != null) {
        entries[_ECTP] = input[_ECTP];
    }
    if (input[_FC] != null) {
        entries[_FC] = __serializeFloat(input[_FC]);
    }
    if (input[_ODFC] != null) {
        entries[_ODFC] = __serializeFloat(input[_ODFC]);
    }
    if (input[_IFR] != null) {
        entries[_IFR] = input[_IFR];
    }
    if (input[_LSau] != null) {
        const memberEntries = se_LaunchSpecsList(input[_LSau], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_LTC] != null) {
        const memberEntries = se_LaunchTemplateConfigList(input[_LTC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateConfigs.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SPp] != null) {
        entries[_SPp] = input[_SPp];
    }
    if (input[_TCa] != null) {
        entries[_TCa] = input[_TCa];
    }
    if (input[_ODTC] != null) {
        entries[_ODTC] = input[_ODTC];
    }
    if (input[_ODMTP] != null) {
        entries[_ODMTP] = input[_ODMTP];
    }
    if (input[_SMTP] != null) {
        entries[_SMTP] = input[_SMTP];
    }
    if (input[_TIWE] != null) {
        entries[_TIWE] = input[_TIWE];
    }
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    if (input[_VF] != null) {
        entries[_VF] = __serializeDateTime(input[_VF]);
    }
    if (input[_VU] != null) {
        entries[_VU] = __serializeDateTime(input[_VU]);
    }
    if (input[_RUI] != null) {
        entries[_RUI] = input[_RUI];
    }
    if (input[_IIB] != null) {
        entries[_IIB] = input[_IIB];
    }
    if (input[_LBC] != null) {
        const memberEntries = se_LoadBalancersConfig(input[_LBC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancersConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IPTUC] != null) {
        entries[_IPTUC] = input[_IPTUC];
    }
    if (input[_Con] != null) {
        entries[_Con] = input[_Con];
    }
    if (input[_TCUT] != null) {
        entries[_TCUT] = input[_TCUT];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SpotFleetRequestIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SpotFleetTagSpecification = (input, context) => {
    const entries = {};
    if (input[_RT] != null) {
        entries[_RT] = input[_RT];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SpotFleetTagSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_SpotFleetTagSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_SpotInstanceRequestIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SpotInstanceRequestId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SpotMaintenanceStrategies = (input, context) => {
    const entries = {};
    if (input[_CRap] != null) {
        const memberEntries = se_SpotCapacityRebalance(input[_CRap], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CapacityRebalance.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SpotMarketOptions = (input, context) => {
    const entries = {};
    if (input[_MPa] != null) {
        entries[_MPa] = input[_MPa];
    }
    if (input[_SIT] != null) {
        entries[_SIT] = input[_SIT];
    }
    if (input[_BDMl] != null) {
        entries[_BDMl] = input[_BDMl];
    }
    if (input[_VU] != null) {
        entries[_VU] = __serializeDateTime(input[_VU]);
    }
    if (input[_IIB] != null) {
        entries[_IIB] = input[_IIB];
    }
    return entries;
};
const se_SpotOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_AS] != null) {
        entries[_AS] = input[_AS];
    }
    if (input[_MS] != null) {
        const memberEntries = se_FleetSpotMaintenanceStrategiesRequest(input[_MS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MaintenanceStrategies.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IIB] != null) {
        entries[_IIB] = input[_IIB];
    }
    if (input[_IPTUC] != null) {
        entries[_IPTUC] = input[_IPTUC];
    }
    if (input[_SITi] != null) {
        entries[_SITi] = input[_SITi];
    }
    if (input[_SAZ] != null) {
        entries[_SAZ] = input[_SAZ];
    }
    if (input[_MTC] != null) {
        entries[_MTC] = input[_MTC];
    }
    if (input[_MTP] != null) {
        entries[_MTP] = input[_MTP];
    }
    return entries;
};
const se_SpotPlacement = (input, context) => {
    const entries = {};
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_Te] != null) {
        entries[_Te] = input[_Te];
    }
    return entries;
};
const se_StartDeclarativePoliciesReportRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SB] != null) {
        entries[_SB] = input[_SB];
    }
    if (input[_SP] != null) {
        entries[_SP] = input[_SP];
    }
    if (input[_TIa] != null) {
        entries[_TIa] = input[_TIa];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_StartInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_AId] != null) {
        entries[_AId] = input[_AId];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_StartNetworkInsightsAccessScopeAnalysisRequest = (input, context) => {
    const entries = {};
    if (input[_NIASI] != null) {
        entries[_NIASI] = input[_NIASI];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_StartNetworkInsightsAnalysisRequest = (input, context) => {
    const entries = {};
    if (input[_NIPI] != null) {
        entries[_NIPI] = input[_NIPI];
    }
    if (input[_AAd] != null) {
        const memberEntries = se_ValueStringList(input[_AAd], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AdditionalAccount.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_FIA] != null) {
        const memberEntries = se_ArnList(input[_FIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FilterInArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_TS] != null) {
        const memberEntries = se_TagSpecificationList(input[_TS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_CTl] === undefined) {
        input[_CTl] = generateIdempotencyToken();
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    return entries;
};
const se_StartVpcEndpointServicePrivateDnsVerificationRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_SIe] != null) {
        entries[_SIe] = input[_SIe];
    }
    return entries;
};
const se_StopInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_Hi] != null) {
        entries[_Hi] = input[_Hi];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_F] != null) {
        entries[_F] = input[_F];
    }
    return entries;
};
const se_Storage = (input, context) => {
    const entries = {};
    if (input[_S_] != null) {
        const memberEntries = se_S3Storage(input[_S_], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `S3.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_StorageLocation = (input, context) => {
    const entries = {};
    if (input[_B] != null) {
        entries[_B] = input[_B];
    }
    if (input[_Ke] != null) {
        entries[_Ke] = input[_Ke];
    }
    return entries;
};
const se_SubnetConfiguration = (input, context) => {
    const entries = {};
    if (input[_SIub] != null) {
        entries[_SIub] = input[_SIub];
    }
    if (input[_Ip] != null) {
        entries[_Ip] = input[_Ip];
    }
    if (input[_Ipv] != null) {
        entries[_Ipv] = input[_Ipv];
    }
    return entries;
};
const se_SubnetConfigurationsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_SubnetConfiguration(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_SubnetIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SubnetId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_Ke] != null) {
        entries[_Ke] = input[_Ke];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_TagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TagSpecification = (input, context) => {
    const entries = {};
    if (input[_RT] != null) {
        entries[_RT] = input[_RT];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TagSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetCapacitySpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_TTC] != null) {
        entries[_TTC] = input[_TTC];
    }
    if (input[_ODTC] != null) {
        entries[_ODTC] = input[_ODTC];
    }
    if (input[_STC] != null) {
        entries[_STC] = input[_STC];
    }
    if (input[_DTCT] != null) {
        entries[_DTCT] = input[_DTCT];
    }
    if (input[_TCUT] != null) {
        entries[_TCUT] = input[_TCUT];
    }
    return entries;
};
const se_TargetConfigurationRequest = (input, context) => {
    const entries = {};
    if (input[_IC] != null) {
        entries[_IC] = input[_IC];
    }
    if (input[_OI] != null) {
        entries[_OI] = input[_OI];
    }
    return entries;
};
const se_TargetConfigurationRequestSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TargetConfigurationRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`TargetConfigurationRequest.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetGroup = (input, context) => {
    const entries = {};
    if (input[_Ar] != null) {
        entries[_Ar] = input[_Ar];
    }
    return entries;
};
const se_TargetGroups = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TargetGroup(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetGroupsConfig = (input, context) => {
    const entries = {};
    if (input[_TG] != null) {
        const memberEntries = se_TargetGroups(input[_TG], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroups.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TerminateClientVpnConnectionsRequest = (input, context) => {
    const entries = {};
    if (input[_CVEI] != null) {
        entries[_CVEI] = input[_CVEI];
    }
    if (input[_CIo] != null) {
        entries[_CIo] = input[_CIo];
    }
    if (input[_Us] != null) {
        entries[_Us] = input[_Us];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_TerminateInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ThroughResourcesStatementRequest = (input, context) => {
    const entries = {};
    if (input[_RSe] != null) {
        const memberEntries = se_ResourceStatementRequest(input[_RSe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceStatement.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ThroughResourcesStatementRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ThroughResourcesStatementRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TotalLocalStorageGB = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = __serializeFloat(input[_M]);
    }
    if (input[_Ma] != null) {
        entries[_Ma] = __serializeFloat(input[_Ma]);
    }
    return entries;
};
const se_TotalLocalStorageGBRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = __serializeFloat(input[_M]);
    }
    if (input[_Ma] != null) {
        entries[_Ma] = __serializeFloat(input[_Ma]);
    }
    return entries;
};
const se_TrafficMirrorFilterIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TrafficMirrorFilterRuleFieldList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TrafficMirrorFilterRuleIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TrafficMirrorNetworkServiceList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TrafficMirrorPortRangeRequest = (input, context) => {
    const entries = {};
    if (input[_FP] != null) {
        entries[_FP] = input[_FP];
    }
    if (input[_TP] != null) {
        entries[_TP] = input[_TP];
    }
    return entries;
};
const se_TrafficMirrorSessionFieldList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TrafficMirrorSessionIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TrafficMirrorTargetIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TransitGatewayAttachmentIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TransitGatewayCidrBlockStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TransitGatewayConnectPeerIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TransitGatewayConnectRequestBgpOptions = (input, context) => {
    const entries = {};
    if (input[_PAee] != null) {
        entries[_PAee] = input[_PAee];
    }
    return entries;
};
const se_TransitGatewayIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TransitGatewayMulticastDomainIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TransitGatewayNetworkInterfaceIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TransitGatewayPolicyTableIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TransitGatewayRequestOptions = (input, context) => {
    const entries = {};
    if (input[_ASA] != null) {
        entries[_ASA] = input[_ASA];
    }
    if (input[_AASAu] != null) {
        entries[_AASAu] = input[_AASAu];
    }
    if (input[_DRTA] != null) {
        entries[_DRTA] = input[_DRTA];
    }
    if (input[_DRTP] != null) {
        entries[_DRTP] = input[_DRTP];
    }
    if (input[_VES] != null) {
        entries[_VES] = input[_VES];
    }
    if (input[_DSns] != null) {
        entries[_DSns] = input[_DSns];
    }
    if (input[_SGRS] != null) {
        entries[_SGRS] = input[_SGRS];
    }
    if (input[_MSu] != null) {
        entries[_MSu] = input[_MSu];
    }
    if (input[_TGCB] != null) {
        const memberEntries = se_TransitGatewayCidrBlockStringList(input[_TGCB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitGatewayCidrBlocks.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TransitGatewayRouteTableAnnouncementIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TransitGatewayRouteTableIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TransitGatewaySubnetIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TrunkInterfaceAssociationIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_UnassignIpv6AddressesRequest = (input, context) => {
    const entries = {};
    if (input[_IP] != null) {
        const memberEntries = se_IpPrefixList(input[_IP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Prefix.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_IA] != null) {
        const memberEntries = se_Ipv6AddressList(input[_IA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UnassignPrivateIpAddressesRequest = (input, context) => {
    const entries = {};
    if (input[_IPp] != null) {
        const memberEntries = se_IpPrefixList(input[_IPp], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ipv4Prefix.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_NII] != null) {
        entries[_NII] = input[_NII];
    }
    if (input[_PIA] != null) {
        const memberEntries = se_PrivateIpAddressStringList(input[_PIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateIpAddress.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UnassignPrivateNatGatewayAddressRequest = (input, context) => {
    const entries = {};
    if (input[_NGI] != null) {
        entries[_NGI] = input[_NGI];
    }
    if (input[_PIA] != null) {
        const memberEntries = se_IpList(input[_PIA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PrivateIpAddress.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_MDDS] != null) {
        entries[_MDDS] = input[_MDDS];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_UnlockSnapshotRequest = (input, context) => {
    const entries = {};
    if (input[_SIn] != null) {
        entries[_SIn] = input[_SIn];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_UnmonitorInstancesRequest = (input, context) => {
    const entries = {};
    if (input[_IIns] != null) {
        const memberEntries = se_InstanceIdStringList(input[_IIns], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_UpdateSecurityGroupRuleDescriptionsEgressRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_IPpe] != null) {
        const memberEntries = se_IpPermissionList(input[_IPpe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SGRD] != null) {
        const memberEntries = se_SecurityGroupRuleDescriptionList(input[_SGRD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupRuleDescription.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UpdateSecurityGroupRuleDescriptionsIngressRequest = (input, context) => {
    const entries = {};
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_IPpe] != null) {
        const memberEntries = se_IpPermissionList(input[_IPpe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SGRD] != null) {
        const memberEntries = se_SecurityGroupRuleDescriptionList(input[_SGRD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroupRuleDescription.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UserBucket = (input, context) => {
    const entries = {};
    if (input[_SB] != null) {
        entries[_SB] = input[_SB];
    }
    if (input[_SK] != null) {
        entries[_SK] = input[_SK];
    }
    return entries;
};
const se_UserData = (input, context) => {
    const entries = {};
    if (input[_Da] != null) {
        entries[_Da] = input[_Da];
    }
    return entries;
};
const se_UserGroupStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`UserGroup.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_UserIdGroupPair = (input, context) => {
    const entries = {};
    if (input[_De] != null) {
        entries[_De] = input[_De];
    }
    if (input[_UIs] != null) {
        entries[_UIs] = input[_UIs];
    }
    if (input[_GN] != null) {
        entries[_GN] = input[_GN];
    }
    if (input[_GIr] != null) {
        entries[_GIr] = input[_GIr];
    }
    if (input[_VI] != null) {
        entries[_VI] = input[_VI];
    }
    if (input[_VPCI] != null) {
        entries[_VPCI] = input[_VPCI];
    }
    if (input[_PSe] != null) {
        entries[_PSe] = input[_PSe];
    }
    return entries;
};
const se_UserIdGroupPairList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_UserIdGroupPair(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Item.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_UserIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`UserId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ValueStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VCpuCountRange = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_VCpuCountRangeRequest = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_VerifiedAccessEndpointIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VerifiedAccessGroupIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VerifiedAccessInstanceIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VerifiedAccessLogCloudWatchLogsDestinationOptions = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    if (input[_LGo] != null) {
        entries[_LGo] = input[_LGo];
    }
    return entries;
};
const se_VerifiedAccessLogKinesisDataFirehoseDestinationOptions = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    if (input[_DSel] != null) {
        entries[_DSel] = input[_DSel];
    }
    return entries;
};
const se_VerifiedAccessLogOptions = (input, context) => {
    const entries = {};
    if (input[_S_] != null) {
        const memberEntries = se_VerifiedAccessLogS3DestinationOptions(input[_S_], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `S3.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CWL] != null) {
        const memberEntries = se_VerifiedAccessLogCloudWatchLogsDestinationOptions(input[_CWL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CloudWatchLogs.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_KDF] != null) {
        const memberEntries = se_VerifiedAccessLogKinesisDataFirehoseDestinationOptions(input[_KDF], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `KinesisDataFirehose.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LV] != null) {
        entries[_LV] = input[_LV];
    }
    if (input[_ITCn] != null) {
        entries[_ITCn] = input[_ITCn];
    }
    return entries;
};
const se_VerifiedAccessLogS3DestinationOptions = (input, context) => {
    const entries = {};
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    if (input[_BN] != null) {
        entries[_BN] = input[_BN];
    }
    if (input[_Pr] != null) {
        entries[_Pr] = input[_Pr];
    }
    if (input[_BOu] != null) {
        entries[_BOu] = input[_BOu];
    }
    return entries;
};
const se_VerifiedAccessSseSpecificationRequest = (input, context) => {
    const entries = {};
    if (input[_CMKE] != null) {
        entries[_CMKE] = input[_CMKE];
    }
    if (input[_KKA] != null) {
        entries[_KKA] = input[_KKA];
    }
    return entries;
};
const se_VerifiedAccessTrustProviderIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VersionStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VirtualizationTypeSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VolumeDetail = (input, context) => {
    const entries = {};
    if (input[_Siz] != null) {
        entries[_Siz] = input[_Siz];
    }
    return entries;
};
const se_VolumeIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`VolumeId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcBlockPublicAccessExclusionIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcClassicLinkIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`VpcId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcEndpointIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcEndpointRouteTableIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcEndpointSecurityGroupIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcEndpointServiceIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcEndpointSubnetIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`VpcId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcPeeringConnectionIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpnConnectionIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`VpnConnectionId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpnConnectionOptionsSpecification = (input, context) => {
    const entries = {};
    if (input[_EA] != null) {
        entries[_EA] = input[_EA];
    }
    if (input[_TIIV] != null) {
        entries[_TIIV] = input[_TIIV];
    }
    if (input[_TO] != null) {
        const memberEntries = se_VpnTunnelOptionsSpecificationsList(input[_TO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TunnelOptions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_LINC] != null) {
        entries[_LINC] = input[_LINC];
    }
    if (input[_RINC] != null) {
        entries[_RINC] = input[_RINC];
    }
    if (input[_LINCo] != null) {
        entries[_LINCo] = input[_LINCo];
    }
    if (input[_RINCe] != null) {
        entries[_RINCe] = input[_RINCe];
    }
    if (input[_OIAT] != null) {
        entries[_OIAT] = input[_OIAT];
    }
    if (input[_TTGAI] != null) {
        entries[_TTGAI] = input[_TTGAI];
    }
    if (input[_SRO] != null) {
        entries[_SRO] = input[_SRO];
    }
    return entries;
};
const se_VpnGatewayIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`VpnGatewayId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpnTunnelLogOptionsSpecification = (input, context) => {
    const entries = {};
    if (input[_CWLO] != null) {
        const memberEntries = se_CloudWatchLogOptionsSpecification(input[_CWLO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CloudWatchLogOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_VpnTunnelOptionsSpecification = (input, context) => {
    const entries = {};
    if (input[_TIC] != null) {
        entries[_TIC] = input[_TIC];
    }
    if (input[_TIIC] != null) {
        entries[_TIIC] = input[_TIIC];
    }
    if (input[_PSK] != null) {
        entries[_PSK] = input[_PSK];
    }
    if (input[_PLS] != null) {
        entries[_PLS] = input[_PLS];
    }
    if (input[_PLSh] != null) {
        entries[_PLSh] = input[_PLSh];
    }
    if (input[_RMTS] != null) {
        entries[_RMTS] = input[_RMTS];
    }
    if (input[_RFP] != null) {
        entries[_RFP] = input[_RFP];
    }
    if (input[_RWS] != null) {
        entries[_RWS] = input[_RWS];
    }
    if (input[_DPDTS] != null) {
        entries[_DPDTS] = input[_DPDTS];
    }
    if (input[_DPDTA] != null) {
        entries[_DPDTA] = input[_DPDTA];
    }
    if (input[_PEA] != null) {
        const memberEntries = se_Phase1EncryptionAlgorithmsRequestList(input[_PEA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase1EncryptionAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PEAh] != null) {
        const memberEntries = se_Phase2EncryptionAlgorithmsRequestList(input[_PEAh], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase2EncryptionAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PIAh] != null) {
        const memberEntries = se_Phase1IntegrityAlgorithmsRequestList(input[_PIAh], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase1IntegrityAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PIAha] != null) {
        const memberEntries = se_Phase2IntegrityAlgorithmsRequestList(input[_PIAha], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase2IntegrityAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PDHGN] != null) {
        const memberEntries = se_Phase1DHGroupNumbersRequestList(input[_PDHGN], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase1DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_PDHGNh] != null) {
        const memberEntries = se_Phase2DHGroupNumbersRequestList(input[_PDHGNh], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Phase2DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_IKEVe] != null) {
        const memberEntries = se_IKEVersionsRequestList(input[_IKEVe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IKEVersion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = value;
        });
    }
    if (input[_SA] != null) {
        entries[_SA] = input[_SA];
    }
    if (input[_LO] != null) {
        const memberEntries = se_VpnTunnelLogOptionsSpecification(input[_LO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LogOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ETLC] != null) {
        entries[_ETLC] = input[_ETLC];
    }
    return entries;
};
const se_VpnTunnelOptionsSpecificationsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_VpnTunnelOptionsSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_WithdrawByoipCidrRequest = (input, context) => {
    const entries = {};
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    return entries;
};
const se_ZoneIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ZoneId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ZoneNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ZoneName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const de_AcceleratorCount = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_M] = __strictParseInt32(output[_m]);
    }
    if (output[_ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_ma]);
    }
    return contents;
};
const de_AcceleratorManufacturerSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AcceleratorNameSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AcceleratorTotalMemoryMiB = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_M] = __strictParseInt32(output[_m]);
    }
    if (output[_ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_ma]);
    }
    return contents;
};
const de_AcceleratorTypeSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AcceptAddressTransferResult = (output, context) => {
    const contents = {};
    if (output[_aT] != null) {
        contents[_ATdd] = de_AddressTransfer(output[_aT], context);
    }
    return contents;
};
const de_AcceptCapacityReservationBillingOwnershipResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_AcceptReservedInstancesExchangeQuoteResult = (output, context) => {
    const contents = {};
    if (output[_eI] != null) {
        contents[_EIxch] = __expectString(output[_eI]);
    }
    return contents;
};
const de_AcceptTransitGatewayMulticastDomainAssociationsResult = (output, context) => {
    const contents = {};
    if (output[_a] != null) {
        contents[_Ass] = de_TransitGatewayMulticastDomainAssociations(output[_a], context);
    }
    return contents;
};
const de_AcceptTransitGatewayPeeringAttachmentResult = (output, context) => {
    const contents = {};
    if (output[_tGPA] != null) {
        contents[_TGPA] = de_TransitGatewayPeeringAttachment(output[_tGPA], context);
    }
    return contents;
};
const de_AcceptTransitGatewayVpcAttachmentResult = (output, context) => {
    const contents = {};
    if (output[_tGVA] != null) {
        contents[_TGVA] = de_TransitGatewayVpcAttachment(output[_tGVA], context);
    }
    return contents;
};
const de_AcceptVpcEndpointConnectionsResult = (output, context) => {
    const contents = {};
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_AcceptVpcPeeringConnectionResult = (output, context) => {
    const contents = {};
    if (output[_vPC] != null) {
        contents[_VPC] = de_VpcPeeringConnection(output[_vPC], context);
    }
    return contents;
};
const de_AccessScopeAnalysisFinding = (output, context) => {
    const contents = {};
    if (output[_nIASAI] != null) {
        contents[_NIASAI] = __expectString(output[_nIASAI]);
    }
    if (output[_nIASI] != null) {
        contents[_NIASI] = __expectString(output[_nIASI]);
    }
    if (output[_fI] != null) {
        contents[_FIi] = __expectString(output[_fI]);
    }
    if (output.findingComponentSet === "") {
        contents[_FCi] = [];
    }
    else if (output[_fCS] != null && output[_fCS][_i] != null) {
        contents[_FCi] = de_PathComponentList(__getArrayIfSingleItem(output[_fCS][_i]), context);
    }
    return contents;
};
const de_AccessScopeAnalysisFindingList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessScopeAnalysisFinding(entry, context);
    });
};
const de_AccessScopePath = (output, context) => {
    const contents = {};
    if (output[_s] != null) {
        contents[_S] = de_PathStatement(output[_s], context);
    }
    if (output[_d] != null) {
        contents[_D] = de_PathStatement(output[_d], context);
    }
    if (output.throughResourceSet === "") {
        contents[_TR] = [];
    }
    else if (output[_tRS] != null && output[_tRS][_i] != null) {
        contents[_TR] = de_ThroughResourcesStatementList(__getArrayIfSingleItem(output[_tRS][_i]), context);
    }
    return contents;
};
const de_AccessScopePathList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessScopePath(entry, context);
    });
};
const de_AccountAttribute = (output, context) => {
    const contents = {};
    if (output[_aN] != null) {
        contents[_ANt] = __expectString(output[_aN]);
    }
    if (output.attributeValueSet === "") {
        contents[_AVt] = [];
    }
    else if (output[_aVS] != null && output[_aVS][_i] != null) {
        contents[_AVt] = de_AccountAttributeValueList(__getArrayIfSingleItem(output[_aVS][_i]), context);
    }
    return contents;
};
const de_AccountAttributeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccountAttribute(entry, context);
    });
};
const de_AccountAttributeValue = (output, context) => {
    const contents = {};
    if (output[_aV] != null) {
        contents[_AVtt] = __expectString(output[_aV]);
    }
    return contents;
};
const de_AccountAttributeValueList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccountAttributeValue(entry, context);
    });
};
const de_ActiveInstance = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_sIRI] != null) {
        contents[_SIRIp] = __expectString(output[_sIRI]);
    }
    if (output[_iH] != null) {
        contents[_IH] = __expectString(output[_iH]);
    }
    return contents;
};
const de_ActiveInstanceSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ActiveInstance(entry, context);
    });
};
const de_AddedPrincipal = (output, context) => {
    const contents = {};
    if (output[_pT] != null) {
        contents[_PTr] = __expectString(output[_pT]);
    }
    if (output[_p] != null) {
        contents[_Prin] = __expectString(output[_p]);
    }
    if (output[_sPI] != null) {
        contents[_SPI] = __expectString(output[_sPI]);
    }
    if (output[_sI] != null) {
        contents[_SIe] = __expectString(output[_sI]);
    }
    return contents;
};
const de_AddedPrincipalSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AddedPrincipal(entry, context);
    });
};
const de_AdditionalDetail = (output, context) => {
    const contents = {};
    if (output[_aDT] != null) {
        contents[_ADT] = __expectString(output[_aDT]);
    }
    if (output[_c] != null) {
        contents[_Com] = de_AnalysisComponent(output[_c], context);
    }
    if (output[_vES] != null) {
        contents[_VESp] = de_AnalysisComponent(output[_vES], context);
    }
    if (output.ruleOptionSet === "") {
        contents[_ROu] = [];
    }
    else if (output[_rOS] != null && output[_rOS][_i] != null) {
        contents[_ROu] = de_RuleOptionList(__getArrayIfSingleItem(output[_rOS][_i]), context);
    }
    if (output.ruleGroupTypePairSet === "") {
        contents[_RGTP] = [];
    }
    else if (output[_rGTPS] != null && output[_rGTPS][_i] != null) {
        contents[_RGTP] = de_RuleGroupTypePairList(__getArrayIfSingleItem(output[_rGTPS][_i]), context);
    }
    if (output.ruleGroupRuleOptionsPairSet === "") {
        contents[_RGROP] = [];
    }
    else if (output[_rGROPS] != null && output[_rGROPS][_i] != null) {
        contents[_RGROP] = de_RuleGroupRuleOptionsPairList(__getArrayIfSingleItem(output[_rGROPS][_i]), context);
    }
    if (output[_sN] != null) {
        contents[_SNe] = __expectString(output[_sN]);
    }
    if (output.loadBalancerSet === "") {
        contents[_LB] = [];
    }
    else if (output[_lBS] != null && output[_lBS][_i] != null) {
        contents[_LB] = de_AnalysisComponentList(__getArrayIfSingleItem(output[_lBS][_i]), context);
    }
    return contents;
};
const de_AdditionalDetailList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdditionalDetail(entry, context);
    });
};
const de_Address = (output, context) => {
    const contents = {};
    if (output[_aI] != null) {
        contents[_AIl] = __expectString(output[_aI]);
    }
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_do] != null) {
        contents[_Do] = __expectString(output[_do]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_nIOI] != null) {
        contents[_NIOI] = __expectString(output[_nIOI]);
    }
    if (output[_pIA] != null) {
        contents[_PIAr] = __expectString(output[_pIA]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_pIP] != null) {
        contents[_PIP] = __expectString(output[_pIP]);
    }
    if (output[_nBG] != null) {
        contents[_NBG] = __expectString(output[_nBG]);
    }
    if (output[_cOI] != null) {
        contents[_COI] = __expectString(output[_cOI]);
    }
    if (output[_cOIP] != null) {
        contents[_COIP] = __expectString(output[_cOIP]);
    }
    if (output[_cI] != null) {
        contents[_CIa] = __expectString(output[_cI]);
    }
    if (output[_sM] != null) {
        contents[_SM] = __expectString(output[_sM]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_pI] != null) {
        contents[_PI] = __expectString(output[_pI]);
    }
    return contents;
};
const de_AddressAttribute = (output, context) => {
    const contents = {};
    if (output[_pI] != null) {
        contents[_PI] = __expectString(output[_pI]);
    }
    if (output[_aI] != null) {
        contents[_AIl] = __expectString(output[_aI]);
    }
    if (output[_pR] != null) {
        contents[_PRt] = __expectString(output[_pR]);
    }
    if (output[_pRU] != null) {
        contents[_PRU] = de_PtrUpdateStatus(output[_pRU], context);
    }
    return contents;
};
const de_AddressList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Address(entry, context);
    });
};
const de_AddressSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AddressAttribute(entry, context);
    });
};
const de_AddressTransfer = (output, context) => {
    const contents = {};
    if (output[_pI] != null) {
        contents[_PI] = __expectString(output[_pI]);
    }
    if (output[_aI] != null) {
        contents[_AIl] = __expectString(output[_aI]);
    }
    if (output[_tAI] != null) {
        contents[_TAI] = __expectString(output[_tAI]);
    }
    if (output[_tOET] != null) {
        contents[_TOET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tOET]));
    }
    if (output[_tOAT] != null) {
        contents[_TOAT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tOAT]));
    }
    if (output[_aTS] != null) {
        contents[_ATS] = __expectString(output[_aTS]);
    }
    return contents;
};
const de_AddressTransferList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AddressTransfer(entry, context);
    });
};
const de_AdvertiseByoipCidrResult = (output, context) => {
    const contents = {};
    if (output[_bC] != null) {
        contents[_BC] = de_ByoipCidr(output[_bC], context);
    }
    return contents;
};
const de_AllocateAddressResult = (output, context) => {
    const contents = {};
    if (output[_aI] != null) {
        contents[_AIl] = __expectString(output[_aI]);
    }
    if (output[_pIP] != null) {
        contents[_PIP] = __expectString(output[_pIP]);
    }
    if (output[_nBG] != null) {
        contents[_NBG] = __expectString(output[_nBG]);
    }
    if (output[_do] != null) {
        contents[_Do] = __expectString(output[_do]);
    }
    if (output[_cOI] != null) {
        contents[_COI] = __expectString(output[_cOI]);
    }
    if (output[_cOIP] != null) {
        contents[_COIP] = __expectString(output[_cOIP]);
    }
    if (output[_cI] != null) {
        contents[_CIa] = __expectString(output[_cI]);
    }
    if (output[_pI] != null) {
        contents[_PI] = __expectString(output[_pI]);
    }
    return contents;
};
const de_AllocateHostsResult = (output, context) => {
    const contents = {};
    if (output.hostIdSet === "") {
        contents[_HI] = [];
    }
    else if (output[_hIS] != null && output[_hIS][_i] != null) {
        contents[_HI] = de_ResponseHostIdList(__getArrayIfSingleItem(output[_hIS][_i]), context);
    }
    return contents;
};
const de_AllocateIpamPoolCidrResult = (output, context) => {
    const contents = {};
    if (output[_iPA] != null) {
        contents[_IPA] = de_IpamPoolAllocation(output[_iPA], context);
    }
    return contents;
};
const de_AllowedInstanceTypeSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AllowedPrincipal = (output, context) => {
    const contents = {};
    if (output[_pT] != null) {
        contents[_PTr] = __expectString(output[_pT]);
    }
    if (output[_p] != null) {
        contents[_Prin] = __expectString(output[_p]);
    }
    if (output[_sPI] != null) {
        contents[_SPI] = __expectString(output[_sPI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_sI] != null) {
        contents[_SIe] = __expectString(output[_sI]);
    }
    return contents;
};
const de_AllowedPrincipalSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AllowedPrincipal(entry, context);
    });
};
const de_AlternatePathHint = (output, context) => {
    const contents = {};
    if (output[_cIo] != null) {
        contents[_CIom] = __expectString(output[_cIo]);
    }
    if (output[_cA] != null) {
        contents[_CAo] = __expectString(output[_cA]);
    }
    return contents;
};
const de_AlternatePathHintList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AlternatePathHint(entry, context);
    });
};
const de_AnalysisAclRule = (output, context) => {
    const contents = {};
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    if (output[_e] != null) {
        contents[_Eg] = __parseBoolean(output[_e]);
    }
    if (output[_pRo] != null) {
        contents[_PR] = de_PortRange(output[_pRo], context);
    }
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output[_rA] != null) {
        contents[_RAu] = __expectString(output[_rA]);
    }
    if (output[_rN] != null) {
        contents[_RNu] = __strictParseInt32(output[_rN]);
    }
    return contents;
};
const de_AnalysisComponent = (output, context) => {
    const contents = {};
    if (output[_id] != null) {
        contents[_Id] = __expectString(output[_id]);
    }
    if (output[_ar] != null) {
        contents[_Ar] = __expectString(output[_ar]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    return contents;
};
const de_AnalysisComponentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalysisComponent(entry, context);
    });
};
const de_AnalysisLoadBalancerListener = (output, context) => {
    const contents = {};
    if (output[_lBP] != null) {
        contents[_LBP] = __strictParseInt32(output[_lBP]);
    }
    if (output[_iP] != null) {
        contents[_IPns] = __strictParseInt32(output[_iP]);
    }
    return contents;
};
const de_AnalysisLoadBalancerTarget = (output, context) => {
    const contents = {};
    if (output[_ad] != null) {
        contents[_Ad] = __expectString(output[_ad]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_in] != null) {
        contents[_Ins] = de_AnalysisComponent(output[_in], context);
    }
    if (output[_po] != null) {
        contents[_Po] = __strictParseInt32(output[_po]);
    }
    return contents;
};
const de_AnalysisPacketHeader = (output, context) => {
    const contents = {};
    if (output.destinationAddressSet === "") {
        contents[_DAes] = [];
    }
    else if (output[_dAS] != null && output[_dAS][_i] != null) {
        contents[_DAes] = de_IpAddressList(__getArrayIfSingleItem(output[_dAS][_i]), context);
    }
    if (output.destinationPortRangeSet === "") {
        contents[_DPRe] = [];
    }
    else if (output[_dPRS] != null && output[_dPRS][_i] != null) {
        contents[_DPRe] = de_PortRangeList(__getArrayIfSingleItem(output[_dPRS][_i]), context);
    }
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output.sourceAddressSet === "") {
        contents[_SAo] = [];
    }
    else if (output[_sAS] != null && output[_sAS][_i] != null) {
        contents[_SAo] = de_IpAddressList(__getArrayIfSingleItem(output[_sAS][_i]), context);
    }
    if (output.sourcePortRangeSet === "") {
        contents[_SPRo] = [];
    }
    else if (output[_sPRS] != null && output[_sPRS][_i] != null) {
        contents[_SPRo] = de_PortRangeList(__getArrayIfSingleItem(output[_sPRS][_i]), context);
    }
    return contents;
};
const de_AnalysisRouteTableRoute = (output, context) => {
    const contents = {};
    if (output[_dC] != null) {
        contents[_DCe] = __expectString(output[_dC]);
    }
    if (output[_dPLI] != null) {
        contents[_DPLI] = __expectString(output[_dPLI]);
    }
    if (output[_eOIGI] != null) {
        contents[_EOIGI] = __expectString(output[_eOIGI]);
    }
    if (output[_gI] != null) {
        contents[_GI] = __expectString(output[_gI]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_nGI] != null) {
        contents[_NGI] = __expectString(output[_nGI]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_o] != null) {
        contents[_Or] = __expectString(output[_o]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_vPCI] != null) {
        contents[_VPCI] = __expectString(output[_vPCI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_cGI] != null) {
        contents[_CGI] = __expectString(output[_cGI]);
    }
    if (output[_cNA] != null) {
        contents[_CNAo] = __expectString(output[_cNA]);
    }
    if (output[_lGI] != null) {
        contents[_LGI] = __expectString(output[_lGI]);
    }
    return contents;
};
const de_AnalysisSecurityGroupRule = (output, context) => {
    const contents = {};
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    if (output[_di] != null) {
        contents[_Di] = __expectString(output[_di]);
    }
    if (output[_sGI] != null) {
        contents[_SGIe] = __expectString(output[_sGI]);
    }
    if (output[_pRo] != null) {
        contents[_PR] = de_PortRange(output[_pRo], context);
    }
    if (output[_pLI] != null) {
        contents[_PLI] = __expectString(output[_pLI]);
    }
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    return contents;
};
const de_ApplySecurityGroupsToClientVpnTargetNetworkResult = (output, context) => {
    const contents = {};
    if (output.securityGroupIds === "") {
        contents[_SGI] = [];
    }
    else if (output[_sGIe] != null && output[_sGIe][_i] != null) {
        contents[_SGI] = de_ClientVpnSecurityGroupIdSet(__getArrayIfSingleItem(output[_sGIe][_i]), context);
    }
    return contents;
};
const de_ArchitectureTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ArnList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AsnAssociation = (output, context) => {
    const contents = {};
    if (output[_as] != null) {
        contents[_As] = __expectString(output[_as]);
    }
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_AsnAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AsnAssociation(entry, context);
    });
};
const de_AsPath = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AssignedPrivateIpAddress = (output, context) => {
    const contents = {};
    if (output[_pIA] != null) {
        contents[_PIAr] = __expectString(output[_pIA]);
    }
    return contents;
};
const de_AssignedPrivateIpAddressList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AssignedPrivateIpAddress(entry, context);
    });
};
const de_AssignIpv6AddressesResult = (output, context) => {
    const contents = {};
    if (output.assignedIpv6Addresses === "") {
        contents[_AIAs] = [];
    }
    else if (output[_aIA] != null && output[_aIA][_i] != null) {
        contents[_AIAs] = de_Ipv6AddressList(__getArrayIfSingleItem(output[_aIA][_i]), context);
    }
    if (output.assignedIpv6PrefixSet === "") {
        contents[_AIP] = [];
    }
    else if (output[_aIPS] != null && output[_aIPS][_i] != null) {
        contents[_AIP] = de_IpPrefixList(__getArrayIfSingleItem(output[_aIPS][_i]), context);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    return contents;
};
const de_AssignPrivateIpAddressesResult = (output, context) => {
    const contents = {};
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output.assignedPrivateIpAddressesSet === "") {
        contents[_APIAss] = [];
    }
    else if (output[_aPIAS] != null && output[_aPIAS][_i] != null) {
        contents[_APIAss] = de_AssignedPrivateIpAddressList(__getArrayIfSingleItem(output[_aPIAS][_i]), context);
    }
    if (output.assignedIpv4PrefixSet === "") {
        contents[_AIPs] = [];
    }
    else if (output[_aIPSs] != null && output[_aIPSs][_i] != null) {
        contents[_AIPs] = de_Ipv4PrefixesList(__getArrayIfSingleItem(output[_aIPSs][_i]), context);
    }
    return contents;
};
const de_AssignPrivateNatGatewayAddressResult = (output, context) => {
    const contents = {};
    if (output[_nGI] != null) {
        contents[_NGI] = __expectString(output[_nGI]);
    }
    if (output.natGatewayAddressSet === "") {
        contents[_NGA] = [];
    }
    else if (output[_nGAS] != null && output[_nGAS][_i] != null) {
        contents[_NGA] = de_NatGatewayAddressList(__getArrayIfSingleItem(output[_nGAS][_i]), context);
    }
    return contents;
};
const de_AssociateAddressResult = (output, context) => {
    const contents = {};
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    return contents;
};
const de_AssociateCapacityReservationBillingOwnerResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_AssociateClientVpnTargetNetworkResult = (output, context) => {
    const contents = {};
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_AssociationStatus(output[_sta], context);
    }
    return contents;
};
const de_AssociatedRole = (output, context) => {
    const contents = {};
    if (output[_aRA] != null) {
        contents[_ARA] = __expectString(output[_aRA]);
    }
    if (output[_cSBN] != null) {
        contents[_CSBN] = __expectString(output[_cSBN]);
    }
    if (output[_cSOK] != null) {
        contents[_CSOK] = __expectString(output[_cSOK]);
    }
    if (output[_eKKI] != null) {
        contents[_EKKI] = __expectString(output[_eKKI]);
    }
    return contents;
};
const de_AssociatedRolesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AssociatedRole(entry, context);
    });
};
const de_AssociatedTargetNetwork = (output, context) => {
    const contents = {};
    if (output[_nI] != null) {
        contents[_NIe] = __expectString(output[_nI]);
    }
    if (output[_nT] != null) {
        contents[_NTe] = __expectString(output[_nT]);
    }
    return contents;
};
const de_AssociatedTargetNetworkSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AssociatedTargetNetwork(entry, context);
    });
};
const de_AssociateEnclaveCertificateIamRoleResult = (output, context) => {
    const contents = {};
    if (output[_cSBN] != null) {
        contents[_CSBN] = __expectString(output[_cSBN]);
    }
    if (output[_cSOK] != null) {
        contents[_CSOK] = __expectString(output[_cSOK]);
    }
    if (output[_eKKI] != null) {
        contents[_EKKI] = __expectString(output[_eKKI]);
    }
    return contents;
};
const de_AssociateIamInstanceProfileResult = (output, context) => {
    const contents = {};
    if (output[_iIPA] != null) {
        contents[_IIPA] = de_IamInstanceProfileAssociation(output[_iIPA], context);
    }
    return contents;
};
const de_AssociateInstanceEventWindowResult = (output, context) => {
    const contents = {};
    if (output[_iEW] != null) {
        contents[_IEW] = de_InstanceEventWindow(output[_iEW], context);
    }
    return contents;
};
const de_AssociateIpamByoasnResult = (output, context) => {
    const contents = {};
    if (output[_aA] != null) {
        contents[_AAsn] = de_AsnAssociation(output[_aA], context);
    }
    return contents;
};
const de_AssociateIpamResourceDiscoveryResult = (output, context) => {
    const contents = {};
    if (output[_iRDA] != null) {
        contents[_IRDA] = de_IpamResourceDiscoveryAssociation(output[_iRDA], context);
    }
    return contents;
};
const de_AssociateNatGatewayAddressResult = (output, context) => {
    const contents = {};
    if (output[_nGI] != null) {
        contents[_NGI] = __expectString(output[_nGI]);
    }
    if (output.natGatewayAddressSet === "") {
        contents[_NGA] = [];
    }
    else if (output[_nGAS] != null && output[_nGAS][_i] != null) {
        contents[_NGA] = de_NatGatewayAddressList(__getArrayIfSingleItem(output[_nGAS][_i]), context);
    }
    return contents;
};
const de_AssociateRouteServerResult = (output, context) => {
    const contents = {};
    if (output[_rSA] != null) {
        contents[_RSAo] = de_RouteServerAssociation(output[_rSA], context);
    }
    return contents;
};
const de_AssociateRouteTableResult = (output, context) => {
    const contents = {};
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_aS] != null) {
        contents[_ASs] = de_RouteTableAssociationState(output[_aS], context);
    }
    return contents;
};
const de_AssociateSecurityGroupVpcResult = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_AssociateSubnetCidrBlockResult = (output, context) => {
    const contents = {};
    if (output[_iCBA] != null) {
        contents[_ICBA] = de_SubnetIpv6CidrBlockAssociation(output[_iCBA], context);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    return contents;
};
const de_AssociateTransitGatewayMulticastDomainResult = (output, context) => {
    const contents = {};
    if (output[_a] != null) {
        contents[_Ass] = de_TransitGatewayMulticastDomainAssociations(output[_a], context);
    }
    return contents;
};
const de_AssociateTransitGatewayPolicyTableResult = (output, context) => {
    const contents = {};
    if (output[_ass] != null) {
        contents[_Asso] = de_TransitGatewayPolicyTableAssociation(output[_ass], context);
    }
    return contents;
};
const de_AssociateTransitGatewayRouteTableResult = (output, context) => {
    const contents = {};
    if (output[_ass] != null) {
        contents[_Asso] = de_TransitGatewayAssociation(output[_ass], context);
    }
    return contents;
};
const de_AssociateTrunkInterfaceResult = (output, context) => {
    const contents = {};
    if (output[_iA] != null) {
        contents[_IAn] = de_TrunkInterfaceAssociation(output[_iA], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_AssociateVpcCidrBlockResult = (output, context) => {
    const contents = {};
    if (output[_iCBA] != null) {
        contents[_ICBA] = de_VpcIpv6CidrBlockAssociation(output[_iCBA], context);
    }
    if (output[_cBA] != null) {
        contents[_CBA] = de_VpcCidrBlockAssociation(output[_cBA], context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    return contents;
};
const de_AssociationStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_AttachClassicLinkVpcResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_AttachmentEnaSrdSpecification = (output, context) => {
    const contents = {};
    if (output[_eSE] != null) {
        contents[_ESE] = __parseBoolean(output[_eSE]);
    }
    if (output[_eSUS] != null) {
        contents[_ESUS] = de_AttachmentEnaSrdUdpSpecification(output[_eSUS], context);
    }
    return contents;
};
const de_AttachmentEnaSrdUdpSpecification = (output, context) => {
    const contents = {};
    if (output[_eSUE] != null) {
        contents[_ESUE] = __parseBoolean(output[_eSUE]);
    }
    return contents;
};
const de_AttachNetworkInterfaceResult = (output, context) => {
    const contents = {};
    if (output[_aIt] != null) {
        contents[_AIt] = __expectString(output[_aIt]);
    }
    if (output[_nCI] != null) {
        contents[_NCI] = __strictParseInt32(output[_nCI]);
    }
    return contents;
};
const de_AttachVerifiedAccessTrustProviderResult = (output, context) => {
    const contents = {};
    if (output[_vATP] != null) {
        contents[_VATP] = de_VerifiedAccessTrustProvider(output[_vATP], context);
    }
    if (output[_vAI] != null) {
        contents[_VAI] = de_VerifiedAccessInstance(output[_vAI], context);
    }
    return contents;
};
const de_AttachVpnGatewayResult = (output, context) => {
    const contents = {};
    if (output[_at] != null) {
        contents[_VA] = de_VpcAttachment(output[_at], context);
    }
    return contents;
};
const de_AttributeBooleanValue = (output, context) => {
    const contents = {};
    if (output[_v] != null) {
        contents[_Va] = __parseBoolean(output[_v]);
    }
    return contents;
};
const de_AttributeSummary = (output, context) => {
    const contents = {};
    if (output[_aN] != null) {
        contents[_ANt] = __expectString(output[_aN]);
    }
    if (output[_mFV] != null) {
        contents[_MFV] = __expectString(output[_mFV]);
    }
    if (output[_nOMA] != null) {
        contents[_NOMA] = __strictParseInt32(output[_nOMA]);
    }
    if (output[_nOUA] != null) {
        contents[_NOUA] = __strictParseInt32(output[_nOUA]);
    }
    if (output.regionalSummarySet === "") {
        contents[_RSeg] = [];
    }
    else if (output[_rSS] != null && output[_rSS][_i] != null) {
        contents[_RSeg] = de_RegionalSummaryList(__getArrayIfSingleItem(output[_rSS][_i]), context);
    }
    return contents;
};
const de_AttributeSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AttributeSummary(entry, context);
    });
};
const de_AttributeValue = (output, context) => {
    const contents = {};
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    return contents;
};
const de_AuthorizationRule = (output, context) => {
    const contents = {};
    if (output[_cVEI] != null) {
        contents[_CVEI] = __expectString(output[_cVEI]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_aAc] != null) {
        contents[_AAc] = __parseBoolean(output[_aAc]);
    }
    if (output[_dC] != null) {
        contents[_DCe] = __expectString(output[_dC]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnAuthorizationRuleStatus(output[_sta], context);
    }
    return contents;
};
const de_AuthorizationRuleSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuthorizationRule(entry, context);
    });
};
const de_AuthorizeClientVpnIngressResult = (output, context) => {
    const contents = {};
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnAuthorizationRuleStatus(output[_sta], context);
    }
    return contents;
};
const de_AuthorizeSecurityGroupEgressResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    if (output.securityGroupRuleSet === "") {
        contents[_SGR] = [];
    }
    else if (output[_sGRS] != null && output[_sGRS][_i] != null) {
        contents[_SGR] = de_SecurityGroupRuleList(__getArrayIfSingleItem(output[_sGRS][_i]), context);
    }
    return contents;
};
const de_AuthorizeSecurityGroupIngressResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    if (output.securityGroupRuleSet === "") {
        contents[_SGR] = [];
    }
    else if (output[_sGRS] != null && output[_sGRS][_i] != null) {
        contents[_SGR] = de_SecurityGroupRuleList(__getArrayIfSingleItem(output[_sGRS][_i]), context);
    }
    return contents;
};
const de_AvailabilityZone = (output, context) => {
    const contents = {};
    if (output[_oIS] != null) {
        contents[_OIS] = __expectString(output[_oIS]);
    }
    if (output.messageSet === "") {
        contents[_Mes] = [];
    }
    else if (output[_mS] != null && output[_mS][_i] != null) {
        contents[_Mes] = de_AvailabilityZoneMessageList(__getArrayIfSingleItem(output[_mS][_i]), context);
    }
    if (output[_rNe] != null) {
        contents[_RN] = __expectString(output[_rNe]);
    }
    if (output[_zN] != null) {
        contents[_ZNo] = __expectString(output[_zN]);
    }
    if (output[_zI] != null) {
        contents[_ZIo] = __expectString(output[_zI]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output[_nBG] != null) {
        contents[_NBG] = __expectString(output[_nBG]);
    }
    if (output[_zT] != null) {
        contents[_ZT] = __expectString(output[_zT]);
    }
    if (output[_pZN] != null) {
        contents[_PZN] = __expectString(output[_pZN]);
    }
    if (output[_pZI] != null) {
        contents[_PZI] = __expectString(output[_pZI]);
    }
    if (output[_gLN] != null) {
        contents[_GLN] = __expectString(output[_gLN]);
    }
    if (output[_zS] != null) {
        contents[_Stat] = __expectString(output[_zS]);
    }
    return contents;
};
const de_AvailabilityZoneList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AvailabilityZone(entry, context);
    });
};
const de_AvailabilityZoneMessage = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_AvailabilityZoneMessageList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AvailabilityZoneMessage(entry, context);
    });
};
const de_AvailableCapacity = (output, context) => {
    const contents = {};
    if (output.availableInstanceCapacity === "") {
        contents[_AIC] = [];
    }
    else if (output[_aIC] != null && output[_aIC][_i] != null) {
        contents[_AIC] = de_AvailableInstanceCapacityList(__getArrayIfSingleItem(output[_aIC][_i]), context);
    }
    if (output[_aVC] != null) {
        contents[_AVC] = __strictParseInt32(output[_aVC]);
    }
    return contents;
};
const de_AvailableInstanceCapacityList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceCapacity(entry, context);
    });
};
const de_BandwidthWeightingTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_BaselineEbsBandwidthMbps = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_M] = __strictParseInt32(output[_m]);
    }
    if (output[_ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_ma]);
    }
    return contents;
};
const de_BaselinePerformanceFactors = (output, context) => {
    const contents = {};
    if (output[_cp] != null) {
        contents[_Cp] = de_CpuPerformanceFactor(output[_cp], context);
    }
    return contents;
};
const de_BlockDeviceMapping = (output, context) => {
    const contents = {};
    if (output[_eb] != null) {
        contents[_E] = de_EbsBlockDevice(output[_eb], context);
    }
    if (output[_nD] != null) {
        contents[_ND] = __expectString(output[_nD]);
    }
    if (output[_dN] != null) {
        contents[_DN] = __expectString(output[_dN]);
    }
    if (output[_vN] != null) {
        contents[_VN] = __expectString(output[_vN]);
    }
    return contents;
};
const de_BlockDeviceMappingList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BlockDeviceMapping(entry, context);
    });
};
const de_BlockDeviceMappingResponse = (output, context) => {
    const contents = {};
    if (output[_dN] != null) {
        contents[_DN] = __expectString(output[_dN]);
    }
    if (output[_vN] != null) {
        contents[_VN] = __expectString(output[_vN]);
    }
    if (output[_eb] != null) {
        contents[_E] = de_EbsBlockDeviceResponse(output[_eb], context);
    }
    if (output[_nD] != null) {
        contents[_ND] = __expectString(output[_nD]);
    }
    return contents;
};
const de_BlockDeviceMappingResponseList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BlockDeviceMappingResponse(entry, context);
    });
};
const de_BlockPublicAccessStates = (output, context) => {
    const contents = {};
    if (output[_iGBM] != null) {
        contents[_IGBM] = __expectString(output[_iGBM]);
    }
    return contents;
};
const de_BootModeTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_BundleInstanceResult = (output, context) => {
    const contents = {};
    if (output[_bIT] != null) {
        contents[_BTu] = de_BundleTask(output[_bIT], context);
    }
    return contents;
};
const de_BundleTask = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_bI] != null) {
        contents[_BIu] = __expectString(output[_bI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sT] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));
    }
    if (output[_uT] != null) {
        contents[_UTp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uT]));
    }
    if (output[_sto] != null) {
        contents[_St] = de_Storage(output[_sto], context);
    }
    if (output[_pro] != null) {
        contents[_Prog] = __expectString(output[_pro]);
    }
    if (output[_er] != null) {
        contents[_BTE] = de_BundleTaskError(output[_er], context);
    }
    return contents;
};
const de_BundleTaskError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_BundleTaskList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BundleTask(entry, context);
    });
};
const de_Byoasn = (output, context) => {
    const contents = {};
    if (output[_as] != null) {
        contents[_As] = __expectString(output[_as]);
    }
    if (output[_iIp] != null) {
        contents[_IIp] = __expectString(output[_iIp]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_ByoasnSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Byoasn(entry, context);
    });
};
const de_ByoipCidr = (output, context) => {
    const contents = {};
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.asnAssociationSet === "") {
        contents[_AAsns] = [];
    }
    else if (output[_aAS] != null && output[_aAS][_i] != null) {
        contents[_AAsns] = de_AsnAssociationSet(__getArrayIfSingleItem(output[_aAS][_i]), context);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_nBG] != null) {
        contents[_NBG] = __expectString(output[_nBG]);
    }
    return contents;
};
const de_ByoipCidrSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ByoipCidr(entry, context);
    });
};
const de_CancelBundleTaskResult = (output, context) => {
    const contents = {};
    if (output[_bIT] != null) {
        contents[_BTu] = de_BundleTask(output[_bIT], context);
    }
    return contents;
};
const de_CancelCapacityReservationFleetError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CancelCapacityReservationFleetsResult = (output, context) => {
    const contents = {};
    if (output.successfulFleetCancellationSet === "") {
        contents[_SFC] = [];
    }
    else if (output[_sFCS] != null && output[_sFCS][_i] != null) {
        contents[_SFC] = de_CapacityReservationFleetCancellationStateSet(__getArrayIfSingleItem(output[_sFCS][_i]), context);
    }
    if (output.failedFleetCancellationSet === "") {
        contents[_FFC] = [];
    }
    else if (output[_fFCS] != null && output[_fFCS][_i] != null) {
        contents[_FFC] = de_FailedCapacityReservationFleetCancellationResultSet(__getArrayIfSingleItem(output[_fFCS][_i]), context);
    }
    return contents;
};
const de_CancelCapacityReservationResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_CancelDeclarativePoliciesReportResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_CancelImageLaunchPermissionResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_CancelImportTaskResult = (output, context) => {
    const contents = {};
    if (output[_iTI] != null) {
        contents[_ITI] = __expectString(output[_iTI]);
    }
    if (output[_pS] != null) {
        contents[_PSr] = __expectString(output[_pS]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_CancelledSpotInstanceRequest = (output, context) => {
    const contents = {};
    if (output[_sIRI] != null) {
        contents[_SIRIp] = __expectString(output[_sIRI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_CancelledSpotInstanceRequestList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CancelledSpotInstanceRequest(entry, context);
    });
};
const de_CancelReservedInstancesListingResult = (output, context) => {
    const contents = {};
    if (output.reservedInstancesListingsSet === "") {
        contents[_RIL] = [];
    }
    else if (output[_rILS] != null && output[_rILS][_i] != null) {
        contents[_RIL] = de_ReservedInstancesListingList(__getArrayIfSingleItem(output[_rILS][_i]), context);
    }
    return contents;
};
const de_CancelSpotFleetRequestsError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_CancelSpotFleetRequestsErrorItem = (output, context) => {
    const contents = {};
    if (output[_er] != null) {
        contents[_Er] = de_CancelSpotFleetRequestsError(output[_er], context);
    }
    if (output[_sFRI] != null) {
        contents[_SFRIp] = __expectString(output[_sFRI]);
    }
    return contents;
};
const de_CancelSpotFleetRequestsErrorSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CancelSpotFleetRequestsErrorItem(entry, context);
    });
};
const de_CancelSpotFleetRequestsResponse = (output, context) => {
    const contents = {};
    if (output.successfulFleetRequestSet === "") {
        contents[_SFR] = [];
    }
    else if (output[_sFRS] != null && output[_sFRS][_i] != null) {
        contents[_SFR] = de_CancelSpotFleetRequestsSuccessSet(__getArrayIfSingleItem(output[_sFRS][_i]), context);
    }
    if (output.unsuccessfulFleetRequestSet === "") {
        contents[_UFR] = [];
    }
    else if (output[_uFRS] != null && output[_uFRS][_i] != null) {
        contents[_UFR] = de_CancelSpotFleetRequestsErrorSet(__getArrayIfSingleItem(output[_uFRS][_i]), context);
    }
    return contents;
};
const de_CancelSpotFleetRequestsSuccessItem = (output, context) => {
    const contents = {};
    if (output[_cSFRS] != null) {
        contents[_CSFRS] = __expectString(output[_cSFRS]);
    }
    if (output[_pSFRS] != null) {
        contents[_PSFRS] = __expectString(output[_pSFRS]);
    }
    if (output[_sFRI] != null) {
        contents[_SFRIp] = __expectString(output[_sFRI]);
    }
    return contents;
};
const de_CancelSpotFleetRequestsSuccessSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CancelSpotFleetRequestsSuccessItem(entry, context);
    });
};
const de_CancelSpotInstanceRequestsResult = (output, context) => {
    const contents = {};
    if (output.spotInstanceRequestSet === "") {
        contents[_CSIRa] = [];
    }
    else if (output[_sIRS] != null && output[_sIRS][_i] != null) {
        contents[_CSIRa] = de_CancelledSpotInstanceRequestList(__getArrayIfSingleItem(output[_sIRS][_i]), context);
    }
    return contents;
};
const de_CapacityAllocation = (output, context) => {
    const contents = {};
    if (output[_aTl] != null) {
        contents[_ATl] = __expectString(output[_aTl]);
    }
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    return contents;
};
const de_CapacityAllocations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CapacityAllocation(entry, context);
    });
};
const de_CapacityBlockExtension = (output, context) => {
    const contents = {};
    if (output[_cRI] != null) {
        contents[_CRI] = __expectString(output[_cRI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_iC] != null) {
        contents[_IC] = __strictParseInt32(output[_iC]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_aZI] != null) {
        contents[_AZI] = __expectString(output[_aZI]);
    }
    if (output[_cBEOI] != null) {
        contents[_CBEOI] = __expectString(output[_cBEOI]);
    }
    if (output[_cBEDH] != null) {
        contents[_CBEDH] = __strictParseInt32(output[_cBEDH]);
    }
    if (output[_cBES] != null) {
        contents[_CBES] = __expectString(output[_cBES]);
    }
    if (output[_cBEPD] != null) {
        contents[_CBEPD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cBEPD]));
    }
    if (output[_cBESD] != null) {
        contents[_CBESD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cBESD]));
    }
    if (output[_cBEED] != null) {
        contents[_CBEED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cBEED]));
    }
    if (output[_uF] != null) {
        contents[_UF] = __expectString(output[_uF]);
    }
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    return contents;
};
const de_CapacityBlockExtensionOffering = (output, context) => {
    const contents = {};
    if (output[_cBEOI] != null) {
        contents[_CBEOI] = __expectString(output[_cBEOI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_iC] != null) {
        contents[_IC] = __strictParseInt32(output[_iC]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_aZI] != null) {
        contents[_AZI] = __expectString(output[_aZI]);
    }
    if (output[_sD] != null) {
        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));
    }
    if (output[_cBESD] != null) {
        contents[_CBESD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cBESD]));
    }
    if (output[_cBEED] != null) {
        contents[_CBEED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cBEED]));
    }
    if (output[_cBEDH] != null) {
        contents[_CBEDH] = __strictParseInt32(output[_cBEDH]);
    }
    if (output[_uF] != null) {
        contents[_UF] = __expectString(output[_uF]);
    }
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output[_t] != null) {
        contents[_Te] = __expectString(output[_t]);
    }
    return contents;
};
const de_CapacityBlockExtensionOfferingSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CapacityBlockExtensionOffering(entry, context);
    });
};
const de_CapacityBlockExtensionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CapacityBlockExtension(entry, context);
    });
};
const de_CapacityBlockOffering = (output, context) => {
    const contents = {};
    if (output[_cBOI] != null) {
        contents[_CBOI] = __expectString(output[_cBOI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_iC] != null) {
        contents[_IC] = __strictParseInt32(output[_iC]);
    }
    if (output[_sD] != null) {
        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));
    }
    if (output[_eD] != null) {
        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));
    }
    if (output[_cBDH] != null) {
        contents[_CBDH] = __strictParseInt32(output[_cBDH]);
    }
    if (output[_uF] != null) {
        contents[_UF] = __expectString(output[_uF]);
    }
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output[_t] != null) {
        contents[_Te] = __expectString(output[_t]);
    }
    if (output[_cBDM] != null) {
        contents[_CBDM] = __strictParseInt32(output[_cBDM]);
    }
    return contents;
};
const de_CapacityBlockOfferingSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CapacityBlockOffering(entry, context);
    });
};
const de_CapacityReservation = (output, context) => {
    const contents = {};
    if (output[_cRI] != null) {
        contents[_CRI] = __expectString(output[_cRI]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_cRA] != null) {
        contents[_CRA] = __expectString(output[_cRA]);
    }
    if (output[_aZI] != null) {
        contents[_AZI] = __expectString(output[_aZI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_iPn] != null) {
        contents[_IPn] = __expectString(output[_iPn]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_t] != null) {
        contents[_Te] = __expectString(output[_t]);
    }
    if (output[_tIC] != null) {
        contents[_TICo] = __strictParseInt32(output[_tIC]);
    }
    if (output[_aICv] != null) {
        contents[_AICv] = __strictParseInt32(output[_aICv]);
    }
    if (output[_eO] != null) {
        contents[_EO] = __parseBoolean(output[_eO]);
    }
    if (output[_eS] != null) {
        contents[_ES] = __parseBoolean(output[_eS]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sD] != null) {
        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));
    }
    if (output[_eD] != null) {
        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));
    }
    if (output[_eDT] != null) {
        contents[_EDT] = __expectString(output[_eDT]);
    }
    if (output[_iMC] != null) {
        contents[_IMC] = __expectString(output[_iMC]);
    }
    if (output[_cD] != null) {
        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cD]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_cRFI] != null) {
        contents[_CRFIa] = __expectString(output[_cRFI]);
    }
    if (output[_pGA] != null) {
        contents[_PGA] = __expectString(output[_pGA]);
    }
    if (output.capacityAllocationSet === "") {
        contents[_CAa] = [];
    }
    else if (output[_cAS] != null && output[_cAS][_i] != null) {
        contents[_CAa] = de_CapacityAllocations(__getArrayIfSingleItem(output[_cAS][_i]), context);
    }
    if (output[_rT] != null) {
        contents[_RTe] = __expectString(output[_rT]);
    }
    if (output[_uRBOI] != null) {
        contents[_URBOI] = __expectString(output[_uRBOI]);
    }
    if (output[_cIom] != null) {
        contents[_CIomm] = de_CapacityReservationCommitmentInfo(output[_cIom], context);
    }
    if (output[_dP] != null) {
        contents[_DP] = __expectString(output[_dP]);
    }
    return contents;
};
const de_CapacityReservationBillingRequest = (output, context) => {
    const contents = {};
    if (output[_cRI] != null) {
        contents[_CRI] = __expectString(output[_cRI]);
    }
    if (output[_rB] != null) {
        contents[_RB] = __expectString(output[_rB]);
    }
    if (output[_uRBOI] != null) {
        contents[_URBOI] = __expectString(output[_uRBOI]);
    }
    if (output[_lUT] != null) {
        contents[_LUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lUT]));
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_cRIa] != null) {
        contents[_CRIap] = de_CapacityReservationInfo(output[_cRIa], context);
    }
    return contents;
};
const de_CapacityReservationBillingRequestSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CapacityReservationBillingRequest(entry, context);
    });
};
const de_CapacityReservationCommitmentInfo = (output, context) => {
    const contents = {};
    if (output[_cIC] != null) {
        contents[_CIC] = __strictParseInt32(output[_cIC]);
    }
    if (output[_cED] != null) {
        contents[_CED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cED]));
    }
    return contents;
};
const de_CapacityReservationFleet = (output, context) => {
    const contents = {};
    if (output[_cRFI] != null) {
        contents[_CRFIa] = __expectString(output[_cRFI]);
    }
    if (output[_cRFA] != null) {
        contents[_CRFA] = __expectString(output[_cRFA]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_tTC] != null) {
        contents[_TTC] = __strictParseInt32(output[_tTC]);
    }
    if (output[_tFC] != null) {
        contents[_TFC] = __strictParseFloat(output[_tFC]);
    }
    if (output[_t] != null) {
        contents[_Te] = __expectString(output[_t]);
    }
    if (output[_eD] != null) {
        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));
    }
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output[_iMC] != null) {
        contents[_IMC] = __expectString(output[_iMC]);
    }
    if (output[_aSl] != null) {
        contents[_AS] = __expectString(output[_aSl]);
    }
    if (output.instanceTypeSpecificationSet === "") {
        contents[_ITS] = [];
    }
    else if (output[_iTSS] != null && output[_iTSS][_i] != null) {
        contents[_ITS] = de_FleetCapacityReservationSet(__getArrayIfSingleItem(output[_iTSS][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_CapacityReservationFleetCancellationState = (output, context) => {
    const contents = {};
    if (output[_cFS] != null) {
        contents[_CFS] = __expectString(output[_cFS]);
    }
    if (output[_pFS] != null) {
        contents[_PFS] = __expectString(output[_pFS]);
    }
    if (output[_cRFI] != null) {
        contents[_CRFIa] = __expectString(output[_cRFI]);
    }
    return contents;
};
const de_CapacityReservationFleetCancellationStateSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CapacityReservationFleetCancellationState(entry, context);
    });
};
const de_CapacityReservationFleetSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CapacityReservationFleet(entry, context);
    });
};
const de_CapacityReservationGroup = (output, context) => {
    const contents = {};
    if (output[_gA] != null) {
        contents[_GA] = __expectString(output[_gA]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    return contents;
};
const de_CapacityReservationGroupSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CapacityReservationGroup(entry, context);
    });
};
const de_CapacityReservationInfo = (output, context) => {
    const contents = {};
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_t] != null) {
        contents[_Te] = __expectString(output[_t]);
    }
    return contents;
};
const de_CapacityReservationOptions = (output, context) => {
    const contents = {};
    if (output[_uS] != null) {
        contents[_USs] = __expectString(output[_uS]);
    }
    return contents;
};
const de_CapacityReservationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CapacityReservation(entry, context);
    });
};
const de_CapacityReservationSpecificationResponse = (output, context) => {
    const contents = {};
    if (output[_cRP] != null) {
        contents[_CRP] = __expectString(output[_cRP]);
    }
    if (output[_cRT] != null) {
        contents[_CRTa] = de_CapacityReservationTargetResponse(output[_cRT], context);
    }
    return contents;
};
const de_CapacityReservationTargetResponse = (output, context) => {
    const contents = {};
    if (output[_cRI] != null) {
        contents[_CRI] = __expectString(output[_cRI]);
    }
    if (output[_cRRGA] != null) {
        contents[_CRRGA] = __expectString(output[_cRRGA]);
    }
    return contents;
};
const de_CarrierGateway = (output, context) => {
    const contents = {};
    if (output[_cGI] != null) {
        contents[_CGI] = __expectString(output[_cGI]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_CarrierGatewaySet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CarrierGateway(entry, context);
    });
};
const de_CertificateAuthentication = (output, context) => {
    const contents = {};
    if (output[_cRCC] != null) {
        contents[_CRCC] = __expectString(output[_cRCC]);
    }
    return contents;
};
const de_CidrBlock = (output, context) => {
    const contents = {};
    if (output[_cB] != null) {
        contents[_CB] = __expectString(output[_cB]);
    }
    return contents;
};
const de_CidrBlockSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CidrBlock(entry, context);
    });
};
const de_ClassicLinkDnsSupport = (output, context) => {
    const contents = {};
    if (output[_cLDS] != null) {
        contents[_CLDS] = __parseBoolean(output[_cLDS]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    return contents;
};
const de_ClassicLinkDnsSupportList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClassicLinkDnsSupport(entry, context);
    });
};
const de_ClassicLinkInstance = (output, context) => {
    const contents = {};
    if (output.groupSet === "") {
        contents[_G] = [];
    }
    else if (output[_gS] != null && output[_gS][_i] != null) {
        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    return contents;
};
const de_ClassicLinkInstanceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClassicLinkInstance(entry, context);
    });
};
const de_ClassicLoadBalancer = (output, context) => {
    const contents = {};
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    return contents;
};
const de_ClassicLoadBalancers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClassicLoadBalancer(entry, context);
    });
};
const de_ClassicLoadBalancersConfig = (output, context) => {
    const contents = {};
    if (output.classicLoadBalancers === "") {
        contents[_CLB] = [];
    }
    else if (output[_cLB] != null && output[_cLB][_i] != null) {
        contents[_CLB] = de_ClassicLoadBalancers(__getArrayIfSingleItem(output[_cLB][_i]), context);
    }
    return contents;
};
const de_ClientCertificateRevocationListStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ClientConnectResponseOptions = (output, context) => {
    const contents = {};
    if (output[_en] != null) {
        contents[_En] = __parseBoolean(output[_en]);
    }
    if (output[_lFA] != null) {
        contents[_LFA] = __expectString(output[_lFA]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnEndpointAttributeStatus(output[_sta], context);
    }
    return contents;
};
const de_ClientLoginBannerResponseOptions = (output, context) => {
    const contents = {};
    if (output[_en] != null) {
        contents[_En] = __parseBoolean(output[_en]);
    }
    if (output[_bT] != null) {
        contents[_BT] = __expectString(output[_bT]);
    }
    return contents;
};
const de_ClientVpnAuthentication = (output, context) => {
    const contents = {};
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_aD] != null) {
        contents[_AD] = de_DirectoryServiceAuthentication(output[_aD], context);
    }
    if (output[_mA] != null) {
        contents[_MA] = de_CertificateAuthentication(output[_mA], context);
    }
    if (output[_fA] != null) {
        contents[_FA] = de_FederatedAuthentication(output[_fA], context);
    }
    return contents;
};
const de_ClientVpnAuthenticationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClientVpnAuthentication(entry, context);
    });
};
const de_ClientVpnAuthorizationRuleStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ClientVpnConnection = (output, context) => {
    const contents = {};
    if (output[_cVEI] != null) {
        contents[_CVEI] = __expectString(output[_cVEI]);
    }
    if (output[_ti] != null) {
        contents[_Tim] = __expectString(output[_ti]);
    }
    if (output[_cIon] != null) {
        contents[_CIo] = __expectString(output[_cIon]);
    }
    if (output[_us] != null) {
        contents[_Us] = __expectString(output[_us]);
    }
    if (output[_cET] != null) {
        contents[_CETo] = __expectString(output[_cET]);
    }
    if (output[_iB] != null) {
        contents[_IB] = __expectString(output[_iB]);
    }
    if (output[_eB] != null) {
        contents[_EB] = __expectString(output[_eB]);
    }
    if (output[_iPng] != null) {
        contents[_IPng] = __expectString(output[_iPng]);
    }
    if (output[_eP] != null) {
        contents[_EPg] = __expectString(output[_eP]);
    }
    if (output[_cIl] != null) {
        contents[_CIli] = __expectString(output[_cIl]);
    }
    if (output[_cN] != null) {
        contents[_CN] = __expectString(output[_cN]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnConnectionStatus(output[_sta], context);
    }
    if (output[_cETo] != null) {
        contents[_CETon] = __expectString(output[_cETo]);
    }
    if (output.postureComplianceStatusSet === "") {
        contents[_PCS] = [];
    }
    else if (output[_pCSS] != null && output[_pCSS][_i] != null) {
        contents[_PCS] = de_ValueStringList(__getArrayIfSingleItem(output[_pCSS][_i]), context);
    }
    return contents;
};
const de_ClientVpnConnectionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClientVpnConnection(entry, context);
    });
};
const de_ClientVpnConnectionStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ClientVpnEndpoint = (output, context) => {
    const contents = {};
    if (output[_cVEI] != null) {
        contents[_CVEI] = __expectString(output[_cVEI]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnEndpointStatus(output[_sta], context);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectString(output[_cTre]);
    }
    if (output[_dT] != null) {
        contents[_DTel] = __expectString(output[_dT]);
    }
    if (output[_dNn] != null) {
        contents[_DNn] = __expectString(output[_dNn]);
    }
    if (output[_cCB] != null) {
        contents[_CCB] = __expectString(output[_cCB]);
    }
    if (output.dnsServer === "") {
        contents[_DSn] = [];
    }
    else if (output[_dS] != null && output[_dS][_i] != null) {
        contents[_DSn] = de_ValueStringList(__getArrayIfSingleItem(output[_dS][_i]), context);
    }
    if (output[_sTp] != null) {
        contents[_ST] = __parseBoolean(output[_sTp]);
    }
    if (output[_vP] != null) {
        contents[_VPp] = __expectString(output[_vP]);
    }
    if (output[_tP] != null) {
        contents[_TPr] = __expectString(output[_tP]);
    }
    if (output[_vPp] != null) {
        contents[_VP] = __strictParseInt32(output[_vPp]);
    }
    if (output.associatedTargetNetwork === "") {
        contents[_ATN] = [];
    }
    else if (output[_aTN] != null && output[_aTN][_i] != null) {
        contents[_ATN] = de_AssociatedTargetNetworkSet(__getArrayIfSingleItem(output[_aTN][_i]), context);
    }
    if (output[_sCA] != null) {
        contents[_SCA] = __expectString(output[_sCA]);
    }
    if (output.authenticationOptions === "") {
        contents[_AO] = [];
    }
    else if (output[_aO] != null && output[_aO][_i] != null) {
        contents[_AO] = de_ClientVpnAuthenticationList(__getArrayIfSingleItem(output[_aO][_i]), context);
    }
    if (output[_cLO] != null) {
        contents[_CLO] = de_ConnectionLogResponseOptions(output[_cLO], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output.securityGroupIdSet === "") {
        contents[_SGI] = [];
    }
    else if (output[_sGIS] != null && output[_sGIS][_i] != null) {
        contents[_SGI] = de_ClientVpnSecurityGroupIdSet(__getArrayIfSingleItem(output[_sGIS][_i]), context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_sSPU] != null) {
        contents[_SSPU] = __expectString(output[_sSPU]);
    }
    if (output[_cCO] != null) {
        contents[_CCO] = de_ClientConnectResponseOptions(output[_cCO], context);
    }
    if (output[_sTH] != null) {
        contents[_STH] = __strictParseInt32(output[_sTH]);
    }
    if (output[_cLBO] != null) {
        contents[_CLBO] = de_ClientLoginBannerResponseOptions(output[_cLBO], context);
    }
    if (output[_dOST] != null) {
        contents[_DOST] = __parseBoolean(output[_dOST]);
    }
    return contents;
};
const de_ClientVpnEndpointAttributeStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ClientVpnEndpointStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ClientVpnRoute = (output, context) => {
    const contents = {};
    if (output[_cVEI] != null) {
        contents[_CVEI] = __expectString(output[_cVEI]);
    }
    if (output[_dC] != null) {
        contents[_DCe] = __expectString(output[_dC]);
    }
    if (output[_tSa] != null) {
        contents[_TSa] = __expectString(output[_tSa]);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_o] != null) {
        contents[_Or] = __expectString(output[_o]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnRouteStatus(output[_sta], context);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    return contents;
};
const de_ClientVpnRouteSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClientVpnRoute(entry, context);
    });
};
const de_ClientVpnRouteStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ClientVpnSecurityGroupIdSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CloudWatchLogOptions = (output, context) => {
    const contents = {};
    if (output[_lE] != null) {
        contents[_LE] = __parseBoolean(output[_lE]);
    }
    if (output[_lGA] != null) {
        contents[_LGA] = __expectString(output[_lGA]);
    }
    if (output[_lOF] != null) {
        contents[_LOF] = __expectString(output[_lOF]);
    }
    return contents;
};
const de_CoipAddressUsage = (output, context) => {
    const contents = {};
    if (output[_aI] != null) {
        contents[_AIl] = __expectString(output[_aI]);
    }
    if (output[_aAI] != null) {
        contents[_AAI] = __expectString(output[_aAI]);
    }
    if (output[_aSw] != null) {
        contents[_ASw] = __expectString(output[_aSw]);
    }
    if (output[_cIop] != null) {
        contents[_CIop] = __expectString(output[_cIop]);
    }
    return contents;
};
const de_CoipAddressUsageSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CoipAddressUsage(entry, context);
    });
};
const de_CoipCidr = (output, context) => {
    const contents = {};
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    if (output[_cPI] != null) {
        contents[_CPIo] = __expectString(output[_cPI]);
    }
    if (output[_lGRTI] != null) {
        contents[_LGRTI] = __expectString(output[_lGRTI]);
    }
    return contents;
};
const de_CoipPool = (output, context) => {
    const contents = {};
    if (output[_pIo] != null) {
        contents[_PIo] = __expectString(output[_pIo]);
    }
    if (output.poolCidrSet === "") {
        contents[_PCo] = [];
    }
    else if (output[_pCS] != null && output[_pCS][_i] != null) {
        contents[_PCo] = de_ValueStringList(__getArrayIfSingleItem(output[_pCS][_i]), context);
    }
    if (output[_lGRTI] != null) {
        contents[_LGRTI] = __expectString(output[_lGRTI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_pA] != null) {
        contents[_PAo] = __expectString(output[_pA]);
    }
    return contents;
};
const de_CoipPoolSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CoipPool(entry, context);
    });
};
const de_ConfirmProductInstanceResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    return contents;
};
const de_ConnectionLogResponseOptions = (output, context) => {
    const contents = {};
    if (output[_En] != null) {
        contents[_En] = __parseBoolean(output[_En]);
    }
    if (output[_CLG] != null) {
        contents[_CLG] = __expectString(output[_CLG]);
    }
    if (output[_CLS] != null) {
        contents[_CLS] = __expectString(output[_CLS]);
    }
    return contents;
};
const de_ConnectionNotification = (output, context) => {
    const contents = {};
    if (output[_cNI] != null) {
        contents[_CNIon] = __expectString(output[_cNI]);
    }
    if (output[_sI] != null) {
        contents[_SIe] = __expectString(output[_sI]);
    }
    if (output[_vEI] != null) {
        contents[_VEIp] = __expectString(output[_vEI]);
    }
    if (output[_cNT] != null) {
        contents[_CNT] = __expectString(output[_cNT]);
    }
    if (output[_cNAo] != null) {
        contents[_CNAon] = __expectString(output[_cNAo]);
    }
    if (output.connectionEvents === "") {
        contents[_CEo] = [];
    }
    else if (output[_cE] != null && output[_cE][_i] != null) {
        contents[_CEo] = de_ValueStringList(__getArrayIfSingleItem(output[_cE][_i]), context);
    }
    if (output[_cNS] != null) {
        contents[_CNS] = __expectString(output[_cNS]);
    }
    if (output[_sR] != null) {
        contents[_SRe] = __expectString(output[_sR]);
    }
    return contents;
};
const de_ConnectionNotificationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ConnectionNotification(entry, context);
    });
};
const de_ConnectionTrackingConfiguration = (output, context) => {
    const contents = {};
    if (output[_tET] != null) {
        contents[_TET] = __strictParseInt32(output[_tET]);
    }
    if (output[_uST] != null) {
        contents[_UST] = __strictParseInt32(output[_uST]);
    }
    if (output[_uTd] != null) {
        contents[_UT] = __strictParseInt32(output[_uTd]);
    }
    return contents;
};
const de_ConnectionTrackingSpecification = (output, context) => {
    const contents = {};
    if (output[_tET] != null) {
        contents[_TET] = __strictParseInt32(output[_tET]);
    }
    if (output[_uTd] != null) {
        contents[_UT] = __strictParseInt32(output[_uTd]);
    }
    if (output[_uST] != null) {
        contents[_UST] = __strictParseInt32(output[_uST]);
    }
    return contents;
};
const de_ConnectionTrackingSpecificationRequest = (output, context) => {
    const contents = {};
    if (output[_TET] != null) {
        contents[_TET] = __strictParseInt32(output[_TET]);
    }
    if (output[_UST] != null) {
        contents[_UST] = __strictParseInt32(output[_UST]);
    }
    if (output[_UT] != null) {
        contents[_UT] = __strictParseInt32(output[_UT]);
    }
    return contents;
};
const de_ConnectionTrackingSpecificationResponse = (output, context) => {
    const contents = {};
    if (output[_tET] != null) {
        contents[_TET] = __strictParseInt32(output[_tET]);
    }
    if (output[_uST] != null) {
        contents[_UST] = __strictParseInt32(output[_uST]);
    }
    if (output[_uTd] != null) {
        contents[_UT] = __strictParseInt32(output[_uTd]);
    }
    return contents;
};
const de_ConversionTask = (output, context) => {
    const contents = {};
    if (output[_cTI] != null) {
        contents[_CTI] = __expectString(output[_cTI]);
    }
    if (output[_eT] != null) {
        contents[_ETx] = __expectString(output[_eT]);
    }
    if (output[_iIm] != null) {
        contents[_IIm] = de_ImportInstanceTaskDetails(output[_iIm], context);
    }
    if (output[_iV] != null) {
        contents[_IV] = de_ImportVolumeTaskDetails(output[_iV], context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_CopyFpgaImageResult = (output, context) => {
    const contents = {};
    if (output[_fII] != null) {
        contents[_FII] = __expectString(output[_fII]);
    }
    return contents;
};
const de_CopyImageResult = (output, context) => {
    const contents = {};
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    return contents;
};
const de_CopySnapshotResult = (output, context) => {
    const contents = {};
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    return contents;
};
const de_CoreCountList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __strictParseInt32(entry);
    });
};
const de_CpuManufacturerSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CpuOptions = (output, context) => {
    const contents = {};
    if (output[_cCo] != null) {
        contents[_CC] = __strictParseInt32(output[_cCo]);
    }
    if (output[_tPC] != null) {
        contents[_TPC] = __strictParseInt32(output[_tPC]);
    }
    if (output[_aSS] != null) {
        contents[_ASS] = __expectString(output[_aSS]);
    }
    return contents;
};
const de_CpuPerformanceFactor = (output, context) => {
    const contents = {};
    if (output.referenceSet === "") {
        contents[_R] = [];
    }
    else if (output[_rS] != null && output[_rS][_i] != null) {
        contents[_R] = de_PerformanceFactorReferenceSet(__getArrayIfSingleItem(output[_rS][_i]), context);
    }
    return contents;
};
const de_CreateCapacityReservationBySplittingResult = (output, context) => {
    const contents = {};
    if (output[_sCR] != null) {
        contents[_SCR] = de_CapacityReservation(output[_sCR], context);
    }
    if (output[_dCR] != null) {
        contents[_DCRe] = de_CapacityReservation(output[_dCR], context);
    }
    if (output[_iC] != null) {
        contents[_IC] = __strictParseInt32(output[_iC]);
    }
    return contents;
};
const de_CreateCapacityReservationFleetResult = (output, context) => {
    const contents = {};
    if (output[_cRFI] != null) {
        contents[_CRFIa] = __expectString(output[_cRFI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_tTC] != null) {
        contents[_TTC] = __strictParseInt32(output[_tTC]);
    }
    if (output[_tFC] != null) {
        contents[_TFC] = __strictParseFloat(output[_tFC]);
    }
    if (output[_iMC] != null) {
        contents[_IMC] = __expectString(output[_iMC]);
    }
    if (output[_aSl] != null) {
        contents[_AS] = __expectString(output[_aSl]);
    }
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output[_eD] != null) {
        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));
    }
    if (output[_t] != null) {
        contents[_Te] = __expectString(output[_t]);
    }
    if (output.fleetCapacityReservationSet === "") {
        contents[_FCR] = [];
    }
    else if (output[_fCRS] != null && output[_fCRS][_i] != null) {
        contents[_FCR] = de_FleetCapacityReservationSet(__getArrayIfSingleItem(output[_fCRS][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_CreateCapacityReservationResult = (output, context) => {
    const contents = {};
    if (output[_cR] != null) {
        contents[_CRapa] = de_CapacityReservation(output[_cR], context);
    }
    return contents;
};
const de_CreateCarrierGatewayResult = (output, context) => {
    const contents = {};
    if (output[_cG] != null) {
        contents[_CG] = de_CarrierGateway(output[_cG], context);
    }
    return contents;
};
const de_CreateClientVpnEndpointResult = (output, context) => {
    const contents = {};
    if (output[_cVEI] != null) {
        contents[_CVEI] = __expectString(output[_cVEI]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnEndpointStatus(output[_sta], context);
    }
    if (output[_dNn] != null) {
        contents[_DNn] = __expectString(output[_dNn]);
    }
    return contents;
};
const de_CreateClientVpnRouteResult = (output, context) => {
    const contents = {};
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnRouteStatus(output[_sta], context);
    }
    return contents;
};
const de_CreateCoipCidrResult = (output, context) => {
    const contents = {};
    if (output[_cCoi] != null) {
        contents[_CCo] = de_CoipCidr(output[_cCoi], context);
    }
    return contents;
};
const de_CreateCoipPoolResult = (output, context) => {
    const contents = {};
    if (output[_cP] != null) {
        contents[_CP] = de_CoipPool(output[_cP], context);
    }
    return contents;
};
const de_CreateCustomerGatewayResult = (output, context) => {
    const contents = {};
    if (output[_cGu] != null) {
        contents[_CGu] = de_CustomerGateway(output[_cGu], context);
    }
    return contents;
};
const de_CreateDefaultSubnetResult = (output, context) => {
    const contents = {};
    if (output[_su] != null) {
        contents[_Su] = de_Subnet(output[_su], context);
    }
    return contents;
};
const de_CreateDefaultVpcResult = (output, context) => {
    const contents = {};
    if (output[_vp] != null) {
        contents[_Vp] = de_Vpc(output[_vp], context);
    }
    return contents;
};
const de_CreateDhcpOptionsResult = (output, context) => {
    const contents = {};
    if (output[_dO] != null) {
        contents[_DOh] = de_DhcpOptions(output[_dO], context);
    }
    return contents;
};
const de_CreateEgressOnlyInternetGatewayResult = (output, context) => {
    const contents = {};
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    if (output[_eOIG] != null) {
        contents[_EOIG] = de_EgressOnlyInternetGateway(output[_eOIG], context);
    }
    return contents;
};
const de_CreateFleetError = (output, context) => {
    const contents = {};
    if (output[_lTAO] != null) {
        contents[_LTAO] = de_LaunchTemplateAndOverridesResponse(output[_lTAO], context);
    }
    if (output[_l] != null) {
        contents[_Li] = __expectString(output[_l]);
    }
    if (output[_eC] != null) {
        contents[_EC] = __expectString(output[_eC]);
    }
    if (output[_eM] != null) {
        contents[_EM] = __expectString(output[_eM]);
    }
    return contents;
};
const de_CreateFleetErrorsSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CreateFleetError(entry, context);
    });
};
const de_CreateFleetInstance = (output, context) => {
    const contents = {};
    if (output[_lTAO] != null) {
        contents[_LTAO] = de_LaunchTemplateAndOverridesResponse(output[_lTAO], context);
    }
    if (output[_l] != null) {
        contents[_Li] = __expectString(output[_l]);
    }
    if (output.instanceIds === "") {
        contents[_IIns] = [];
    }
    else if (output[_iIn] != null && output[_iIn][_i] != null) {
        contents[_IIns] = de_InstanceIdsSet(__getArrayIfSingleItem(output[_iIn][_i]), context);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    return contents;
};
const de_CreateFleetInstancesSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CreateFleetInstance(entry, context);
    });
};
const de_CreateFleetResult = (output, context) => {
    const contents = {};
    if (output[_fIl] != null) {
        contents[_FIl] = __expectString(output[_fIl]);
    }
    if (output.errorSet === "") {
        contents[_Err] = [];
    }
    else if (output[_eSr] != null && output[_eSr][_i] != null) {
        contents[_Err] = de_CreateFleetErrorsSet(__getArrayIfSingleItem(output[_eSr][_i]), context);
    }
    if (output.fleetInstanceSet === "") {
        contents[_In] = [];
    }
    else if (output[_fIS] != null && output[_fIS][_i] != null) {
        contents[_In] = de_CreateFleetInstancesSet(__getArrayIfSingleItem(output[_fIS][_i]), context);
    }
    return contents;
};
const de_CreateFlowLogsResult = (output, context) => {
    const contents = {};
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    if (output.flowLogIdSet === "") {
        contents[_FLI] = [];
    }
    else if (output[_fLIS] != null && output[_fLIS][_i] != null) {
        contents[_FLI] = de_ValueStringList(__getArrayIfSingleItem(output[_fLIS][_i]), context);
    }
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_CreateFpgaImageResult = (output, context) => {
    const contents = {};
    if (output[_fII] != null) {
        contents[_FII] = __expectString(output[_fII]);
    }
    if (output[_fIGI] != null) {
        contents[_FIGI] = __expectString(output[_fIGI]);
    }
    return contents;
};
const de_CreateImageResult = (output, context) => {
    const contents = {};
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    return contents;
};
const de_CreateInstanceConnectEndpointResult = (output, context) => {
    const contents = {};
    if (output[_iCE] != null) {
        contents[_ICE] = de_Ec2InstanceConnectEndpoint(output[_iCE], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreateInstanceEventWindowResult = (output, context) => {
    const contents = {};
    if (output[_iEW] != null) {
        contents[_IEW] = de_InstanceEventWindow(output[_iEW], context);
    }
    return contents;
};
const de_CreateInstanceExportTaskResult = (output, context) => {
    const contents = {};
    if (output[_eTx] != null) {
        contents[_ETxp] = de_ExportTask(output[_eTx], context);
    }
    return contents;
};
const de_CreateInternetGatewayResult = (output, context) => {
    const contents = {};
    if (output[_iG] != null) {
        contents[_IGn] = de_InternetGateway(output[_iG], context);
    }
    return contents;
};
const de_CreateIpamExternalResourceVerificationTokenResult = (output, context) => {
    const contents = {};
    if (output[_iERVT] != null) {
        contents[_IERVT] = de_IpamExternalResourceVerificationToken(output[_iERVT], context);
    }
    return contents;
};
const de_CreateIpamPoolResult = (output, context) => {
    const contents = {};
    if (output[_iPp] != null) {
        contents[_IPpa] = de_IpamPool(output[_iPp], context);
    }
    return contents;
};
const de_CreateIpamResourceDiscoveryResult = (output, context) => {
    const contents = {};
    if (output[_iRD] != null) {
        contents[_IRD] = de_IpamResourceDiscovery(output[_iRD], context);
    }
    return contents;
};
const de_CreateIpamResult = (output, context) => {
    const contents = {};
    if (output[_ip] != null) {
        contents[_Ipa] = de_Ipam(output[_ip], context);
    }
    return contents;
};
const de_CreateIpamScopeResult = (output, context) => {
    const contents = {};
    if (output[_iS] != null) {
        contents[_ISpa] = de_IpamScope(output[_iS], context);
    }
    return contents;
};
const de_CreateLaunchTemplateResult = (output, context) => {
    const contents = {};
    if (output[_lT] != null) {
        contents[_LTa] = de_LaunchTemplate(output[_lT], context);
    }
    if (output[_w] != null) {
        contents[_Wa] = de_ValidationWarning(output[_w], context);
    }
    return contents;
};
const de_CreateLaunchTemplateVersionResult = (output, context) => {
    const contents = {};
    if (output[_lTV] != null) {
        contents[_LTV] = de_LaunchTemplateVersion(output[_lTV], context);
    }
    if (output[_w] != null) {
        contents[_Wa] = de_ValidationWarning(output[_w], context);
    }
    return contents;
};
const de_CreateLocalGatewayRouteResult = (output, context) => {
    const contents = {};
    if (output[_ro] != null) {
        contents[_Rou] = de_LocalGatewayRoute(output[_ro], context);
    }
    return contents;
};
const de_CreateLocalGatewayRouteTableResult = (output, context) => {
    const contents = {};
    if (output[_lGRT] != null) {
        contents[_LGRT] = de_LocalGatewayRouteTable(output[_lGRT], context);
    }
    return contents;
};
const de_CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult = (output, context) => {
    const contents = {};
    if (output[_lGRTVIGA] != null) {
        contents[_LGRTVIGA] = de_LocalGatewayRouteTableVirtualInterfaceGroupAssociation(output[_lGRTVIGA], context);
    }
    return contents;
};
const de_CreateLocalGatewayRouteTableVpcAssociationResult = (output, context) => {
    const contents = {};
    if (output[_lGRTVA] != null) {
        contents[_LGRTVA] = de_LocalGatewayRouteTableVpcAssociation(output[_lGRTVA], context);
    }
    return contents;
};
const de_CreateManagedPrefixListResult = (output, context) => {
    const contents = {};
    if (output[_pL] != null) {
        contents[_PLr] = de_ManagedPrefixList(output[_pL], context);
    }
    return contents;
};
const de_CreateNatGatewayResult = (output, context) => {
    const contents = {};
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    if (output[_nG] != null) {
        contents[_NG] = de_NatGateway(output[_nG], context);
    }
    return contents;
};
const de_CreateNetworkAclResult = (output, context) => {
    const contents = {};
    if (output[_nA] != null) {
        contents[_NA] = de_NetworkAcl(output[_nA], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreateNetworkInsightsAccessScopeResult = (output, context) => {
    const contents = {};
    if (output[_nIAS] != null) {
        contents[_NIAS] = de_NetworkInsightsAccessScope(output[_nIAS], context);
    }
    if (output[_nIASC] != null) {
        contents[_NIASC] = de_NetworkInsightsAccessScopeContent(output[_nIASC], context);
    }
    return contents;
};
const de_CreateNetworkInsightsPathResult = (output, context) => {
    const contents = {};
    if (output[_nIP] != null) {
        contents[_NIP] = de_NetworkInsightsPath(output[_nIP], context);
    }
    return contents;
};
const de_CreateNetworkInterfacePermissionResult = (output, context) => {
    const contents = {};
    if (output[_iPnt] != null) {
        contents[_IPnt] = de_NetworkInterfacePermission(output[_iPnt], context);
    }
    return contents;
};
const de_CreateNetworkInterfaceResult = (output, context) => {
    const contents = {};
    if (output[_nIe] != null) {
        contents[_NIet] = de_NetworkInterface(output[_nIe], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreatePlacementGroupResult = (output, context) => {
    const contents = {};
    if (output[_pG] != null) {
        contents[_PG] = de_PlacementGroup(output[_pG], context);
    }
    return contents;
};
const de_CreatePublicIpv4PoolResult = (output, context) => {
    const contents = {};
    if (output[_pIo] != null) {
        contents[_PIo] = __expectString(output[_pIo]);
    }
    return contents;
};
const de_CreateReplaceRootVolumeTaskResult = (output, context) => {
    const contents = {};
    if (output[_rRVT] != null) {
        contents[_RRVT] = de_ReplaceRootVolumeTask(output[_rRVT], context);
    }
    return contents;
};
const de_CreateReservedInstancesListingResult = (output, context) => {
    const contents = {};
    if (output.reservedInstancesListingsSet === "") {
        contents[_RIL] = [];
    }
    else if (output[_rILS] != null && output[_rILS][_i] != null) {
        contents[_RIL] = de_ReservedInstancesListingList(__getArrayIfSingleItem(output[_rILS][_i]), context);
    }
    return contents;
};
const de_CreateRestoreImageTaskResult = (output, context) => {
    const contents = {};
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    return contents;
};
const de_CreateRouteResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_CreateRouteServerEndpointResult = (output, context) => {
    const contents = {};
    if (output[_rSE] != null) {
        contents[_RSE] = de_RouteServerEndpoint(output[_rSE], context);
    }
    return contents;
};
const de_CreateRouteServerPeerResult = (output, context) => {
    const contents = {};
    if (output[_rSP] != null) {
        contents[_RSP] = de_RouteServerPeer(output[_rSP], context);
    }
    return contents;
};
const de_CreateRouteServerResult = (output, context) => {
    const contents = {};
    if (output[_rSo] != null) {
        contents[_RSo] = de_RouteServer(output[_rSo], context);
    }
    return contents;
};
const de_CreateRouteTableResult = (output, context) => {
    const contents = {};
    if (output[_rTo] != null) {
        contents[_RTo] = de_RouteTable(output[_rTo], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreateSecurityGroupResult = (output, context) => {
    const contents = {};
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_sGA] != null) {
        contents[_SGA] = __expectString(output[_sGA]);
    }
    return contents;
};
const de_CreateSnapshotsResult = (output, context) => {
    const contents = {};
    if (output.snapshotSet === "") {
        contents[_Sn] = [];
    }
    else if (output[_sS] != null && output[_sS][_i] != null) {
        contents[_Sn] = de_SnapshotSet(__getArrayIfSingleItem(output[_sS][_i]), context);
    }
    return contents;
};
const de_CreateSpotDatafeedSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_sDS] != null) {
        contents[_SDS] = de_SpotDatafeedSubscription(output[_sDS], context);
    }
    return contents;
};
const de_CreateStoreImageTaskResult = (output, context) => {
    const contents = {};
    if (output[_oK] != null) {
        contents[_OK] = __expectString(output[_oK]);
    }
    return contents;
};
const de_CreateSubnetCidrReservationResult = (output, context) => {
    const contents = {};
    if (output[_sCRu] != null) {
        contents[_SCRu] = de_SubnetCidrReservation(output[_sCRu], context);
    }
    return contents;
};
const de_CreateSubnetResult = (output, context) => {
    const contents = {};
    if (output[_su] != null) {
        contents[_Su] = de_Subnet(output[_su], context);
    }
    return contents;
};
const de_CreateTrafficMirrorFilterResult = (output, context) => {
    const contents = {};
    if (output[_tMF] != null) {
        contents[_TMF] = de_TrafficMirrorFilter(output[_tMF], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreateTrafficMirrorFilterRuleResult = (output, context) => {
    const contents = {};
    if (output[_tMFR] != null) {
        contents[_TMFR] = de_TrafficMirrorFilterRule(output[_tMFR], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreateTrafficMirrorSessionResult = (output, context) => {
    const contents = {};
    if (output[_tMS] != null) {
        contents[_TMS] = de_TrafficMirrorSession(output[_tMS], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreateTrafficMirrorTargetResult = (output, context) => {
    const contents = {};
    if (output[_tMT] != null) {
        contents[_TMT] = de_TrafficMirrorTarget(output[_tMT], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreateTransitGatewayConnectPeerResult = (output, context) => {
    const contents = {};
    if (output[_tGCP] != null) {
        contents[_TGCP] = de_TransitGatewayConnectPeer(output[_tGCP], context);
    }
    return contents;
};
const de_CreateTransitGatewayConnectResult = (output, context) => {
    const contents = {};
    if (output[_tGC] != null) {
        contents[_TGCr] = de_TransitGatewayConnect(output[_tGC], context);
    }
    return contents;
};
const de_CreateTransitGatewayMulticastDomainResult = (output, context) => {
    const contents = {};
    if (output[_tGMD] != null) {
        contents[_TGMD] = de_TransitGatewayMulticastDomain(output[_tGMD], context);
    }
    return contents;
};
const de_CreateTransitGatewayPeeringAttachmentResult = (output, context) => {
    const contents = {};
    if (output[_tGPA] != null) {
        contents[_TGPA] = de_TransitGatewayPeeringAttachment(output[_tGPA], context);
    }
    return contents;
};
const de_CreateTransitGatewayPolicyTableResult = (output, context) => {
    const contents = {};
    if (output[_tGPT] != null) {
        contents[_TGPT] = de_TransitGatewayPolicyTable(output[_tGPT], context);
    }
    return contents;
};
const de_CreateTransitGatewayPrefixListReferenceResult = (output, context) => {
    const contents = {};
    if (output[_tGPLR] != null) {
        contents[_TGPLR] = de_TransitGatewayPrefixListReference(output[_tGPLR], context);
    }
    return contents;
};
const de_CreateTransitGatewayResult = (output, context) => {
    const contents = {};
    if (output[_tG] != null) {
        contents[_TGr] = de_TransitGateway(output[_tG], context);
    }
    return contents;
};
const de_CreateTransitGatewayRouteResult = (output, context) => {
    const contents = {};
    if (output[_ro] != null) {
        contents[_Rou] = de_TransitGatewayRoute(output[_ro], context);
    }
    return contents;
};
const de_CreateTransitGatewayRouteTableAnnouncementResult = (output, context) => {
    const contents = {};
    if (output[_tGRTA] != null) {
        contents[_TGRTA] = de_TransitGatewayRouteTableAnnouncement(output[_tGRTA], context);
    }
    return contents;
};
const de_CreateTransitGatewayRouteTableResult = (output, context) => {
    const contents = {};
    if (output[_tGRT] != null) {
        contents[_TGRT] = de_TransitGatewayRouteTable(output[_tGRT], context);
    }
    return contents;
};
const de_CreateTransitGatewayVpcAttachmentResult = (output, context) => {
    const contents = {};
    if (output[_tGVA] != null) {
        contents[_TGVA] = de_TransitGatewayVpcAttachment(output[_tGVA], context);
    }
    return contents;
};
const de_CreateVerifiedAccessEndpointResult = (output, context) => {
    const contents = {};
    if (output[_vAE] != null) {
        contents[_VAE] = de_VerifiedAccessEndpoint(output[_vAE], context);
    }
    return contents;
};
const de_CreateVerifiedAccessGroupResult = (output, context) => {
    const contents = {};
    if (output[_vAG] != null) {
        contents[_VAG] = de_VerifiedAccessGroup(output[_vAG], context);
    }
    return contents;
};
const de_CreateVerifiedAccessInstanceResult = (output, context) => {
    const contents = {};
    if (output[_vAI] != null) {
        contents[_VAI] = de_VerifiedAccessInstance(output[_vAI], context);
    }
    return contents;
};
const de_CreateVerifiedAccessTrustProviderResult = (output, context) => {
    const contents = {};
    if (output[_vATP] != null) {
        contents[_VATP] = de_VerifiedAccessTrustProvider(output[_vATP], context);
    }
    return contents;
};
const de_CreateVolumePermission = (output, context) => {
    const contents = {};
    if (output[_uI] != null) {
        contents[_UIs] = __expectString(output[_uI]);
    }
    if (output[_g] != null) {
        contents[_Gr] = __expectString(output[_g]);
    }
    return contents;
};
const de_CreateVolumePermissionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CreateVolumePermission(entry, context);
    });
};
const de_CreateVpcBlockPublicAccessExclusionResult = (output, context) => {
    const contents = {};
    if (output[_vBPAE] != null) {
        contents[_VBPAE] = de_VpcBlockPublicAccessExclusion(output[_vBPAE], context);
    }
    return contents;
};
const de_CreateVpcEndpointConnectionNotificationResult = (output, context) => {
    const contents = {};
    if (output[_cNo] != null) {
        contents[_CNo] = de_ConnectionNotification(output[_cNo], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreateVpcEndpointResult = (output, context) => {
    const contents = {};
    if (output[_vE] != null) {
        contents[_VE] = de_VpcEndpoint(output[_vE], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreateVpcEndpointServiceConfigurationResult = (output, context) => {
    const contents = {};
    if (output[_sC] != null) {
        contents[_SCe] = de_ServiceConfiguration(output[_sC], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_CreateVpcPeeringConnectionResult = (output, context) => {
    const contents = {};
    if (output[_vPC] != null) {
        contents[_VPC] = de_VpcPeeringConnection(output[_vPC], context);
    }
    return contents;
};
const de_CreateVpcResult = (output, context) => {
    const contents = {};
    if (output[_vp] != null) {
        contents[_Vp] = de_Vpc(output[_vp], context);
    }
    return contents;
};
const de_CreateVpnConnectionResult = (output, context) => {
    const contents = {};
    if (output[_vC] != null) {
        contents[_VC] = de_VpnConnection(output[_vC], context);
    }
    return contents;
};
const de_CreateVpnGatewayResult = (output, context) => {
    const contents = {};
    if (output[_vG] != null) {
        contents[_VG] = de_VpnGateway(output[_vG], context);
    }
    return contents;
};
const de_CreditSpecification = (output, context) => {
    const contents = {};
    if (output[_cCp] != null) {
        contents[_CCp] = __expectString(output[_cCp]);
    }
    return contents;
};
const de_CustomerGateway = (output, context) => {
    const contents = {};
    if (output[_cAe] != null) {
        contents[_CA] = __expectString(output[_cAe]);
    }
    if (output[_dN] != null) {
        contents[_DN] = __expectString(output[_dN]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_bAE] != null) {
        contents[_BAE] = __expectString(output[_bAE]);
    }
    if (output[_cGIu] != null) {
        contents[_CGIu] = __expectString(output[_cGIu]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_iAp] != null) {
        contents[_IAp] = __expectString(output[_iAp]);
    }
    if (output[_bA] != null) {
        contents[_BA] = __expectString(output[_bA]);
    }
    return contents;
};
const de_CustomerGatewayList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CustomerGateway(entry, context);
    });
};
const de_DataResponse = (output, context) => {
    const contents = {};
    if (output[_id] != null) {
        contents[_Id] = __expectString(output[_id]);
    }
    if (output[_s] != null) {
        contents[_S] = __expectString(output[_s]);
    }
    if (output[_d] != null) {
        contents[_D] = __expectString(output[_d]);
    }
    if (output[_met] != null) {
        contents[_Met] = __expectString(output[_met]);
    }
    if (output[_stat] != null) {
        contents[_Sta] = __expectString(output[_stat]);
    }
    if (output[_pe] != null) {
        contents[_Per] = __expectString(output[_pe]);
    }
    if (output.metricPointSet === "") {
        contents[_MPe] = [];
    }
    else if (output[_mPS] != null && output[_mPS][_i] != null) {
        contents[_MPe] = de_MetricPoints(__getArrayIfSingleItem(output[_mPS][_i]), context);
    }
    return contents;
};
const de_DataResponses = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DataResponse(entry, context);
    });
};
const de_DeclarativePoliciesReport = (output, context) => {
    const contents = {};
    if (output[_rI] != null) {
        contents[_RIep] = __expectString(output[_rI]);
    }
    if (output[_sB] != null) {
        contents[_SB] = __expectString(output[_sB]);
    }
    if (output[_sP] != null) {
        contents[_SP] = __expectString(output[_sP]);
    }
    if (output[_tI] != null) {
        contents[_TIa] = __expectString(output[_tI]);
    }
    if (output[_sT] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));
    }
    if (output[_eTn] != null) {
        contents[_ETn] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTn]));
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_DeclarativePoliciesReportList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeclarativePoliciesReport(entry, context);
    });
};
const de_DedicatedHostIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_DeleteCarrierGatewayResult = (output, context) => {
    const contents = {};
    if (output[_cG] != null) {
        contents[_CG] = de_CarrierGateway(output[_cG], context);
    }
    return contents;
};
const de_DeleteClientVpnEndpointResult = (output, context) => {
    const contents = {};
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnEndpointStatus(output[_sta], context);
    }
    return contents;
};
const de_DeleteClientVpnRouteResult = (output, context) => {
    const contents = {};
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnRouteStatus(output[_sta], context);
    }
    return contents;
};
const de_DeleteCoipCidrResult = (output, context) => {
    const contents = {};
    if (output[_cCoi] != null) {
        contents[_CCo] = de_CoipCidr(output[_cCoi], context);
    }
    return contents;
};
const de_DeleteCoipPoolResult = (output, context) => {
    const contents = {};
    if (output[_cP] != null) {
        contents[_CP] = de_CoipPool(output[_cP], context);
    }
    return contents;
};
const de_DeleteEgressOnlyInternetGatewayResult = (output, context) => {
    const contents = {};
    if (output[_rC] != null) {
        contents[_RCet] = __parseBoolean(output[_rC]);
    }
    return contents;
};
const de_DeleteFleetError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_DeleteFleetErrorItem = (output, context) => {
    const contents = {};
    if (output[_er] != null) {
        contents[_Er] = de_DeleteFleetError(output[_er], context);
    }
    if (output[_fIl] != null) {
        contents[_FIl] = __expectString(output[_fIl]);
    }
    return contents;
};
const de_DeleteFleetErrorSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeleteFleetErrorItem(entry, context);
    });
};
const de_DeleteFleetsResult = (output, context) => {
    const contents = {};
    if (output.successfulFleetDeletionSet === "") {
        contents[_SFD] = [];
    }
    else if (output[_sFDS] != null && output[_sFDS][_i] != null) {
        contents[_SFD] = de_DeleteFleetSuccessSet(__getArrayIfSingleItem(output[_sFDS][_i]), context);
    }
    if (output.unsuccessfulFleetDeletionSet === "") {
        contents[_UFD] = [];
    }
    else if (output[_uFDS] != null && output[_uFDS][_i] != null) {
        contents[_UFD] = de_DeleteFleetErrorSet(__getArrayIfSingleItem(output[_uFDS][_i]), context);
    }
    return contents;
};
const de_DeleteFleetSuccessItem = (output, context) => {
    const contents = {};
    if (output[_cFS] != null) {
        contents[_CFS] = __expectString(output[_cFS]);
    }
    if (output[_pFS] != null) {
        contents[_PFS] = __expectString(output[_pFS]);
    }
    if (output[_fIl] != null) {
        contents[_FIl] = __expectString(output[_fIl]);
    }
    return contents;
};
const de_DeleteFleetSuccessSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeleteFleetSuccessItem(entry, context);
    });
};
const de_DeleteFlowLogsResult = (output, context) => {
    const contents = {};
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_DeleteFpgaImageResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_DeleteInstanceConnectEndpointResult = (output, context) => {
    const contents = {};
    if (output[_iCE] != null) {
        contents[_ICE] = de_Ec2InstanceConnectEndpoint(output[_iCE], context);
    }
    return contents;
};
const de_DeleteInstanceEventWindowResult = (output, context) => {
    const contents = {};
    if (output[_iEWS] != null) {
        contents[_IEWS] = de_InstanceEventWindowStateChange(output[_iEWS], context);
    }
    return contents;
};
const de_DeleteIpamExternalResourceVerificationTokenResult = (output, context) => {
    const contents = {};
    if (output[_iERVT] != null) {
        contents[_IERVT] = de_IpamExternalResourceVerificationToken(output[_iERVT], context);
    }
    return contents;
};
const de_DeleteIpamPoolResult = (output, context) => {
    const contents = {};
    if (output[_iPp] != null) {
        contents[_IPpa] = de_IpamPool(output[_iPp], context);
    }
    return contents;
};
const de_DeleteIpamResourceDiscoveryResult = (output, context) => {
    const contents = {};
    if (output[_iRD] != null) {
        contents[_IRD] = de_IpamResourceDiscovery(output[_iRD], context);
    }
    return contents;
};
const de_DeleteIpamResult = (output, context) => {
    const contents = {};
    if (output[_ip] != null) {
        contents[_Ipa] = de_Ipam(output[_ip], context);
    }
    return contents;
};
const de_DeleteIpamScopeResult = (output, context) => {
    const contents = {};
    if (output[_iS] != null) {
        contents[_ISpa] = de_IpamScope(output[_iS], context);
    }
    return contents;
};
const de_DeleteKeyPairResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    if (output[_kPI] != null) {
        contents[_KPI] = __expectString(output[_kPI]);
    }
    return contents;
};
const de_DeleteLaunchTemplateResult = (output, context) => {
    const contents = {};
    if (output[_lT] != null) {
        contents[_LTa] = de_LaunchTemplate(output[_lT], context);
    }
    return contents;
};
const de_DeleteLaunchTemplateVersionsResponseErrorItem = (output, context) => {
    const contents = {};
    if (output[_lTI] != null) {
        contents[_LTI] = __expectString(output[_lTI]);
    }
    if (output[_lTN] != null) {
        contents[_LTN] = __expectString(output[_lTN]);
    }
    if (output[_vNe] != null) {
        contents[_VNe] = __strictParseLong(output[_vNe]);
    }
    if (output[_rE] != null) {
        contents[_REes] = de_ResponseError(output[_rE], context);
    }
    return contents;
};
const de_DeleteLaunchTemplateVersionsResponseErrorSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeleteLaunchTemplateVersionsResponseErrorItem(entry, context);
    });
};
const de_DeleteLaunchTemplateVersionsResponseSuccessItem = (output, context) => {
    const contents = {};
    if (output[_lTI] != null) {
        contents[_LTI] = __expectString(output[_lTI]);
    }
    if (output[_lTN] != null) {
        contents[_LTN] = __expectString(output[_lTN]);
    }
    if (output[_vNe] != null) {
        contents[_VNe] = __strictParseLong(output[_vNe]);
    }
    return contents;
};
const de_DeleteLaunchTemplateVersionsResponseSuccessSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeleteLaunchTemplateVersionsResponseSuccessItem(entry, context);
    });
};
const de_DeleteLaunchTemplateVersionsResult = (output, context) => {
    const contents = {};
    if (output.successfullyDeletedLaunchTemplateVersionSet === "") {
        contents[_SDLTV] = [];
    }
    else if (output[_sDLTVS] != null && output[_sDLTVS][_i] != null) {
        contents[_SDLTV] = de_DeleteLaunchTemplateVersionsResponseSuccessSet(__getArrayIfSingleItem(output[_sDLTVS][_i]), context);
    }
    if (output.unsuccessfullyDeletedLaunchTemplateVersionSet === "") {
        contents[_UDLTV] = [];
    }
    else if (output[_uDLTVS] != null && output[_uDLTVS][_i] != null) {
        contents[_UDLTV] = de_DeleteLaunchTemplateVersionsResponseErrorSet(__getArrayIfSingleItem(output[_uDLTVS][_i]), context);
    }
    return contents;
};
const de_DeleteLocalGatewayRouteResult = (output, context) => {
    const contents = {};
    if (output[_ro] != null) {
        contents[_Rou] = de_LocalGatewayRoute(output[_ro], context);
    }
    return contents;
};
const de_DeleteLocalGatewayRouteTableResult = (output, context) => {
    const contents = {};
    if (output[_lGRT] != null) {
        contents[_LGRT] = de_LocalGatewayRouteTable(output[_lGRT], context);
    }
    return contents;
};
const de_DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociationResult = (output, context) => {
    const contents = {};
    if (output[_lGRTVIGA] != null) {
        contents[_LGRTVIGA] = de_LocalGatewayRouteTableVirtualInterfaceGroupAssociation(output[_lGRTVIGA], context);
    }
    return contents;
};
const de_DeleteLocalGatewayRouteTableVpcAssociationResult = (output, context) => {
    const contents = {};
    if (output[_lGRTVA] != null) {
        contents[_LGRTVA] = de_LocalGatewayRouteTableVpcAssociation(output[_lGRTVA], context);
    }
    return contents;
};
const de_DeleteManagedPrefixListResult = (output, context) => {
    const contents = {};
    if (output[_pL] != null) {
        contents[_PLr] = de_ManagedPrefixList(output[_pL], context);
    }
    return contents;
};
const de_DeleteNatGatewayResult = (output, context) => {
    const contents = {};
    if (output[_nGI] != null) {
        contents[_NGI] = __expectString(output[_nGI]);
    }
    return contents;
};
const de_DeleteNetworkInsightsAccessScopeAnalysisResult = (output, context) => {
    const contents = {};
    if (output[_nIASAI] != null) {
        contents[_NIASAI] = __expectString(output[_nIASAI]);
    }
    return contents;
};
const de_DeleteNetworkInsightsAccessScopeResult = (output, context) => {
    const contents = {};
    if (output[_nIASI] != null) {
        contents[_NIASI] = __expectString(output[_nIASI]);
    }
    return contents;
};
const de_DeleteNetworkInsightsAnalysisResult = (output, context) => {
    const contents = {};
    if (output[_nIAI] != null) {
        contents[_NIAI] = __expectString(output[_nIAI]);
    }
    return contents;
};
const de_DeleteNetworkInsightsPathResult = (output, context) => {
    const contents = {};
    if (output[_nIPI] != null) {
        contents[_NIPI] = __expectString(output[_nIPI]);
    }
    return contents;
};
const de_DeleteNetworkInterfacePermissionResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_DeletePublicIpv4PoolResult = (output, context) => {
    const contents = {};
    if (output[_rV] != null) {
        contents[_RV] = __parseBoolean(output[_rV]);
    }
    return contents;
};
const de_DeleteQueuedReservedInstancesError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_DeleteQueuedReservedInstancesResult = (output, context) => {
    const contents = {};
    if (output.successfulQueuedPurchaseDeletionSet === "") {
        contents[_SQPD] = [];
    }
    else if (output[_sQPDS] != null && output[_sQPDS][_i] != null) {
        contents[_SQPD] = de_SuccessfulQueuedPurchaseDeletionSet(__getArrayIfSingleItem(output[_sQPDS][_i]), context);
    }
    if (output.failedQueuedPurchaseDeletionSet === "") {
        contents[_FQPD] = [];
    }
    else if (output[_fQPDS] != null && output[_fQPDS][_i] != null) {
        contents[_FQPD] = de_FailedQueuedPurchaseDeletionSet(__getArrayIfSingleItem(output[_fQPDS][_i]), context);
    }
    return contents;
};
const de_DeleteRouteServerEndpointResult = (output, context) => {
    const contents = {};
    if (output[_rSE] != null) {
        contents[_RSE] = de_RouteServerEndpoint(output[_rSE], context);
    }
    return contents;
};
const de_DeleteRouteServerPeerResult = (output, context) => {
    const contents = {};
    if (output[_rSP] != null) {
        contents[_RSP] = de_RouteServerPeer(output[_rSP], context);
    }
    return contents;
};
const de_DeleteRouteServerResult = (output, context) => {
    const contents = {};
    if (output[_rSo] != null) {
        contents[_RSo] = de_RouteServer(output[_rSo], context);
    }
    return contents;
};
const de_DeleteSecurityGroupResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    return contents;
};
const de_DeleteSubnetCidrReservationResult = (output, context) => {
    const contents = {};
    if (output[_dSCR] != null) {
        contents[_DSCRe] = de_SubnetCidrReservation(output[_dSCR], context);
    }
    return contents;
};
const de_DeleteTrafficMirrorFilterResult = (output, context) => {
    const contents = {};
    if (output[_tMFI] != null) {
        contents[_TMFI] = __expectString(output[_tMFI]);
    }
    return contents;
};
const de_DeleteTrafficMirrorFilterRuleResult = (output, context) => {
    const contents = {};
    if (output[_tMFRI] != null) {
        contents[_TMFRI] = __expectString(output[_tMFRI]);
    }
    return contents;
};
const de_DeleteTrafficMirrorSessionResult = (output, context) => {
    const contents = {};
    if (output[_tMSI] != null) {
        contents[_TMSI] = __expectString(output[_tMSI]);
    }
    return contents;
};
const de_DeleteTrafficMirrorTargetResult = (output, context) => {
    const contents = {};
    if (output[_tMTI] != null) {
        contents[_TMTI] = __expectString(output[_tMTI]);
    }
    return contents;
};
const de_DeleteTransitGatewayConnectPeerResult = (output, context) => {
    const contents = {};
    if (output[_tGCP] != null) {
        contents[_TGCP] = de_TransitGatewayConnectPeer(output[_tGCP], context);
    }
    return contents;
};
const de_DeleteTransitGatewayConnectResult = (output, context) => {
    const contents = {};
    if (output[_tGC] != null) {
        contents[_TGCr] = de_TransitGatewayConnect(output[_tGC], context);
    }
    return contents;
};
const de_DeleteTransitGatewayMulticastDomainResult = (output, context) => {
    const contents = {};
    if (output[_tGMD] != null) {
        contents[_TGMD] = de_TransitGatewayMulticastDomain(output[_tGMD], context);
    }
    return contents;
};
const de_DeleteTransitGatewayPeeringAttachmentResult = (output, context) => {
    const contents = {};
    if (output[_tGPA] != null) {
        contents[_TGPA] = de_TransitGatewayPeeringAttachment(output[_tGPA], context);
    }
    return contents;
};
const de_DeleteTransitGatewayPolicyTableResult = (output, context) => {
    const contents = {};
    if (output[_tGPT] != null) {
        contents[_TGPT] = de_TransitGatewayPolicyTable(output[_tGPT], context);
    }
    return contents;
};
const de_DeleteTransitGatewayPrefixListReferenceResult = (output, context) => {
    const contents = {};
    if (output[_tGPLR] != null) {
        contents[_TGPLR] = de_TransitGatewayPrefixListReference(output[_tGPLR], context);
    }
    return contents;
};
const de_DeleteTransitGatewayResult = (output, context) => {
    const contents = {};
    if (output[_tG] != null) {
        contents[_TGr] = de_TransitGateway(output[_tG], context);
    }
    return contents;
};
const de_DeleteTransitGatewayRouteResult = (output, context) => {
    const contents = {};
    if (output[_ro] != null) {
        contents[_Rou] = de_TransitGatewayRoute(output[_ro], context);
    }
    return contents;
};
const de_DeleteTransitGatewayRouteTableAnnouncementResult = (output, context) => {
    const contents = {};
    if (output[_tGRTA] != null) {
        contents[_TGRTA] = de_TransitGatewayRouteTableAnnouncement(output[_tGRTA], context);
    }
    return contents;
};
const de_DeleteTransitGatewayRouteTableResult = (output, context) => {
    const contents = {};
    if (output[_tGRT] != null) {
        contents[_TGRT] = de_TransitGatewayRouteTable(output[_tGRT], context);
    }
    return contents;
};
const de_DeleteTransitGatewayVpcAttachmentResult = (output, context) => {
    const contents = {};
    if (output[_tGVA] != null) {
        contents[_TGVA] = de_TransitGatewayVpcAttachment(output[_tGVA], context);
    }
    return contents;
};
const de_DeleteVerifiedAccessEndpointResult = (output, context) => {
    const contents = {};
    if (output[_vAE] != null) {
        contents[_VAE] = de_VerifiedAccessEndpoint(output[_vAE], context);
    }
    return contents;
};
const de_DeleteVerifiedAccessGroupResult = (output, context) => {
    const contents = {};
    if (output[_vAG] != null) {
        contents[_VAG] = de_VerifiedAccessGroup(output[_vAG], context);
    }
    return contents;
};
const de_DeleteVerifiedAccessInstanceResult = (output, context) => {
    const contents = {};
    if (output[_vAI] != null) {
        contents[_VAI] = de_VerifiedAccessInstance(output[_vAI], context);
    }
    return contents;
};
const de_DeleteVerifiedAccessTrustProviderResult = (output, context) => {
    const contents = {};
    if (output[_vATP] != null) {
        contents[_VATP] = de_VerifiedAccessTrustProvider(output[_vATP], context);
    }
    return contents;
};
const de_DeleteVpcBlockPublicAccessExclusionResult = (output, context) => {
    const contents = {};
    if (output[_vBPAE] != null) {
        contents[_VBPAE] = de_VpcBlockPublicAccessExclusion(output[_vBPAE], context);
    }
    return contents;
};
const de_DeleteVpcEndpointConnectionNotificationsResult = (output, context) => {
    const contents = {};
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_DeleteVpcEndpointServiceConfigurationsResult = (output, context) => {
    const contents = {};
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_DeleteVpcEndpointsResult = (output, context) => {
    const contents = {};
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_DeleteVpcPeeringConnectionResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_DeprovisionByoipCidrResult = (output, context) => {
    const contents = {};
    if (output[_bC] != null) {
        contents[_BC] = de_ByoipCidr(output[_bC], context);
    }
    return contents;
};
const de_DeprovisionedAddressSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_DeprovisionIpamByoasnResult = (output, context) => {
    const contents = {};
    if (output[_b] != null) {
        contents[_Byo] = de_Byoasn(output[_b], context);
    }
    return contents;
};
const de_DeprovisionIpamPoolCidrResult = (output, context) => {
    const contents = {};
    if (output[_iPC] != null) {
        contents[_IPCpa] = de_IpamPoolCidr(output[_iPC], context);
    }
    return contents;
};
const de_DeprovisionPublicIpv4PoolCidrResult = (output, context) => {
    const contents = {};
    if (output[_pIo] != null) {
        contents[_PIo] = __expectString(output[_pIo]);
    }
    if (output.deprovisionedAddressSet === "") {
        contents[_DAep] = [];
    }
    else if (output[_dASe] != null && output[_dASe][_i] != null) {
        contents[_DAep] = de_DeprovisionedAddressSet(__getArrayIfSingleItem(output[_dASe][_i]), context);
    }
    return contents;
};
const de_DeregisterImageResult = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeregisterInstanceEventNotificationAttributesResult = (output, context) => {
    const contents = {};
    if (output[_iTA] != null) {
        contents[_ITA] = de_InstanceTagNotificationAttribute(output[_iTA], context);
    }
    return contents;
};
const de_DeregisterTransitGatewayMulticastGroupMembersResult = (output, context) => {
    const contents = {};
    if (output[_dMGM] != null) {
        contents[_DMGM] = de_TransitGatewayMulticastDeregisteredGroupMembers(output[_dMGM], context);
    }
    return contents;
};
const de_DeregisterTransitGatewayMulticastGroupSourcesResult = (output, context) => {
    const contents = {};
    if (output[_dMGS] != null) {
        contents[_DMGS] = de_TransitGatewayMulticastDeregisteredGroupSources(output[_dMGS], context);
    }
    return contents;
};
const de_DescribeAccountAttributesResult = (output, context) => {
    const contents = {};
    if (output.accountAttributeSet === "") {
        contents[_AAcc] = [];
    }
    else if (output[_aASc] != null && output[_aASc][_i] != null) {
        contents[_AAcc] = de_AccountAttributeList(__getArrayIfSingleItem(output[_aASc][_i]), context);
    }
    return contents;
};
const de_DescribeAddressesAttributeResult = (output, context) => {
    const contents = {};
    if (output.addressSet === "") {
        contents[_Addr] = [];
    }
    else if (output[_aSd] != null && output[_aSd][_i] != null) {
        contents[_Addr] = de_AddressSet(__getArrayIfSingleItem(output[_aSd][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeAddressesResult = (output, context) => {
    const contents = {};
    if (output.addressesSet === "") {
        contents[_Addr] = [];
    }
    else if (output[_aSdd] != null && output[_aSdd][_i] != null) {
        contents[_Addr] = de_AddressList(__getArrayIfSingleItem(output[_aSdd][_i]), context);
    }
    return contents;
};
const de_DescribeAddressTransfersResult = (output, context) => {
    const contents = {};
    if (output.addressTransferSet === "") {
        contents[_ATddr] = [];
    }
    else if (output[_aTSd] != null && output[_aTSd][_i] != null) {
        contents[_ATddr] = de_AddressTransferList(__getArrayIfSingleItem(output[_aTSd][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeAggregateIdFormatResult = (output, context) => {
    const contents = {};
    if (output[_uLIA] != null) {
        contents[_ULIA] = __parseBoolean(output[_uLIA]);
    }
    if (output.statusSet === "") {
        contents[_Status] = [];
    }
    else if (output[_sSt] != null && output[_sSt][_i] != null) {
        contents[_Status] = de_IdFormatList(__getArrayIfSingleItem(output[_sSt][_i]), context);
    }
    return contents;
};
const de_DescribeAvailabilityZonesResult = (output, context) => {
    const contents = {};
    if (output.availabilityZoneInfo === "") {
        contents[_AZv] = [];
    }
    else if (output[_aZIv] != null && output[_aZIv][_i] != null) {
        contents[_AZv] = de_AvailabilityZoneList(__getArrayIfSingleItem(output[_aZIv][_i]), context);
    }
    return contents;
};
const de_DescribeAwsNetworkPerformanceMetricSubscriptionsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.subscriptionSet === "") {
        contents[_Sub] = [];
    }
    else if (output[_sSu] != null && output[_sSu][_i] != null) {
        contents[_Sub] = de_SubscriptionList(__getArrayIfSingleItem(output[_sSu][_i]), context);
    }
    return contents;
};
const de_DescribeBundleTasksResult = (output, context) => {
    const contents = {};
    if (output.bundleInstanceTasksSet === "") {
        contents[_BTun] = [];
    }
    else if (output[_bITS] != null && output[_bITS][_i] != null) {
        contents[_BTun] = de_BundleTaskList(__getArrayIfSingleItem(output[_bITS][_i]), context);
    }
    return contents;
};
const de_DescribeByoipCidrsResult = (output, context) => {
    const contents = {};
    if (output.byoipCidrSet === "") {
        contents[_BCy] = [];
    }
    else if (output[_bCS] != null && output[_bCS][_i] != null) {
        contents[_BCy] = de_ByoipCidrSet(__getArrayIfSingleItem(output[_bCS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeCapacityBlockExtensionHistoryResult = (output, context) => {
    const contents = {};
    if (output.capacityBlockExtensionSet === "") {
        contents[_CBE] = [];
    }
    else if (output[_cBESa] != null && output[_cBESa][_i] != null) {
        contents[_CBE] = de_CapacityBlockExtensionSet(__getArrayIfSingleItem(output[_cBESa][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeCapacityBlockExtensionOfferingsResult = (output, context) => {
    const contents = {};
    if (output.capacityBlockExtensionOfferingSet === "") {
        contents[_CBEO] = [];
    }
    else if (output[_cBEOS] != null && output[_cBEOS][_i] != null) {
        contents[_CBEO] = de_CapacityBlockExtensionOfferingSet(__getArrayIfSingleItem(output[_cBEOS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeCapacityBlockOfferingsResult = (output, context) => {
    const contents = {};
    if (output.capacityBlockOfferingSet === "") {
        contents[_CBO] = [];
    }
    else if (output[_cBOS] != null && output[_cBOS][_i] != null) {
        contents[_CBO] = de_CapacityBlockOfferingSet(__getArrayIfSingleItem(output[_cBOS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeCapacityReservationBillingRequestsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.capacityReservationBillingRequestSet === "") {
        contents[_CRBR] = [];
    }
    else if (output[_cRBRS] != null && output[_cRBRS][_i] != null) {
        contents[_CRBR] = de_CapacityReservationBillingRequestSet(__getArrayIfSingleItem(output[_cRBRS][_i]), context);
    }
    return contents;
};
const de_DescribeCapacityReservationFleetsResult = (output, context) => {
    const contents = {};
    if (output.capacityReservationFleetSet === "") {
        contents[_CRF] = [];
    }
    else if (output[_cRFS] != null && output[_cRFS][_i] != null) {
        contents[_CRF] = de_CapacityReservationFleetSet(__getArrayIfSingleItem(output[_cRFS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeCapacityReservationsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.capacityReservationSet === "") {
        contents[_CRapac] = [];
    }
    else if (output[_cRS] != null && output[_cRS][_i] != null) {
        contents[_CRapac] = de_CapacityReservationSet(__getArrayIfSingleItem(output[_cRS][_i]), context);
    }
    return contents;
};
const de_DescribeCarrierGatewaysResult = (output, context) => {
    const contents = {};
    if (output.carrierGatewaySet === "") {
        contents[_CGa] = [];
    }
    else if (output[_cGS] != null && output[_cGS][_i] != null) {
        contents[_CGa] = de_CarrierGatewaySet(__getArrayIfSingleItem(output[_cGS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeClassicLinkInstancesResult = (output, context) => {
    const contents = {};
    if (output.instancesSet === "") {
        contents[_In] = [];
    }
    else if (output[_iSn] != null && output[_iSn][_i] != null) {
        contents[_In] = de_ClassicLinkInstanceList(__getArrayIfSingleItem(output[_iSn][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeClientVpnAuthorizationRulesResult = (output, context) => {
    const contents = {};
    if (output.authorizationRule === "") {
        contents[_ARut] = [];
    }
    else if (output[_aR] != null && output[_aR][_i] != null) {
        contents[_ARut] = de_AuthorizationRuleSet(__getArrayIfSingleItem(output[_aR][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeClientVpnConnectionsResult = (output, context) => {
    const contents = {};
    if (output.connections === "") {
        contents[_Conn] = [];
    }
    else if (output[_con] != null && output[_con][_i] != null) {
        contents[_Conn] = de_ClientVpnConnectionSet(__getArrayIfSingleItem(output[_con][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeClientVpnEndpointsResult = (output, context) => {
    const contents = {};
    if (output.clientVpnEndpoint === "") {
        contents[_CVEl] = [];
    }
    else if (output[_cVE] != null && output[_cVE][_i] != null) {
        contents[_CVEl] = de_EndpointSet(__getArrayIfSingleItem(output[_cVE][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeClientVpnRoutesResult = (output, context) => {
    const contents = {};
    if (output.routes === "") {
        contents[_Rout] = [];
    }
    else if (output[_rou] != null && output[_rou][_i] != null) {
        contents[_Rout] = de_ClientVpnRouteSet(__getArrayIfSingleItem(output[_rou][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeClientVpnTargetNetworksResult = (output, context) => {
    const contents = {};
    if (output.clientVpnTargetNetworks === "") {
        contents[_CVTN] = [];
    }
    else if (output[_cVTN] != null && output[_cVTN][_i] != null) {
        contents[_CVTN] = de_TargetNetworkSet(__getArrayIfSingleItem(output[_cVTN][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeCoipPoolsResult = (output, context) => {
    const contents = {};
    if (output.coipPoolSet === "") {
        contents[_CPo] = [];
    }
    else if (output[_cPS] != null && output[_cPS][_i] != null) {
        contents[_CPo] = de_CoipPoolSet(__getArrayIfSingleItem(output[_cPS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeConversionTaskList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ConversionTask(entry, context);
    });
};
const de_DescribeConversionTasksResult = (output, context) => {
    const contents = {};
    if (output.conversionTasks === "") {
        contents[_CTon] = [];
    }
    else if (output[_cTo] != null && output[_cTo][_i] != null) {
        contents[_CTon] = de_DescribeConversionTaskList(__getArrayIfSingleItem(output[_cTo][_i]), context);
    }
    return contents;
};
const de_DescribeCustomerGatewaysResult = (output, context) => {
    const contents = {};
    if (output.customerGatewaySet === "") {
        contents[_CGus] = [];
    }
    else if (output[_cGSu] != null && output[_cGSu][_i] != null) {
        contents[_CGus] = de_CustomerGatewayList(__getArrayIfSingleItem(output[_cGSu][_i]), context);
    }
    return contents;
};
const de_DescribeDeclarativePoliciesReportsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.reportSet === "") {
        contents[_Rep] = [];
    }
    else if (output[_rSe] != null && output[_rSe][_i] != null) {
        contents[_Rep] = de_DeclarativePoliciesReportList(__getArrayIfSingleItem(output[_rSe][_i]), context);
    }
    return contents;
};
const de_DescribeDhcpOptionsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.dhcpOptionsSet === "") {
        contents[_DOh] = [];
    }
    else if (output[_dOS] != null && output[_dOS][_i] != null) {
        contents[_DOh] = de_DhcpOptionsList(__getArrayIfSingleItem(output[_dOS][_i]), context);
    }
    return contents;
};
const de_DescribeEgressOnlyInternetGatewaysResult = (output, context) => {
    const contents = {};
    if (output.egressOnlyInternetGatewaySet === "") {
        contents[_EOIGg] = [];
    }
    else if (output[_eOIGS] != null && output[_eOIGS][_i] != null) {
        contents[_EOIGg] = de_EgressOnlyInternetGatewayList(__getArrayIfSingleItem(output[_eOIGS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeElasticGpusResult = (output, context) => {
    const contents = {};
    if (output.elasticGpuSet === "") {
        contents[_EGSla] = [];
    }
    else if (output[_eGS] != null && output[_eGS][_i] != null) {
        contents[_EGSla] = de_ElasticGpuSet(__getArrayIfSingleItem(output[_eGS][_i]), context);
    }
    if (output[_mR] != null) {
        contents[_MR] = __strictParseInt32(output[_mR]);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeExportImageTasksResult = (output, context) => {
    const contents = {};
    if (output.exportImageTaskSet === "") {
        contents[_EITx] = [];
    }
    else if (output[_eITS] != null && output[_eITS][_i] != null) {
        contents[_EITx] = de_ExportImageTaskList(__getArrayIfSingleItem(output[_eITS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeExportTasksResult = (output, context) => {
    const contents = {};
    if (output.exportTaskSet === "") {
        contents[_ETxpo] = [];
    }
    else if (output[_eTS] != null && output[_eTS][_i] != null) {
        contents[_ETxpo] = de_ExportTaskList(__getArrayIfSingleItem(output[_eTS][_i]), context);
    }
    return contents;
};
const de_DescribeFastLaunchImagesResult = (output, context) => {
    const contents = {};
    if (output.fastLaunchImageSet === "") {
        contents[_FLIa] = [];
    }
    else if (output[_fLISa] != null && output[_fLISa][_i] != null) {
        contents[_FLIa] = de_DescribeFastLaunchImagesSuccessSet(__getArrayIfSingleItem(output[_fLISa][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeFastLaunchImagesSuccessItem = (output, context) => {
    const contents = {};
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_sCn] != null) {
        contents[_SCn] = de_FastLaunchSnapshotConfigurationResponse(output[_sCn], context);
    }
    if (output[_lT] != null) {
        contents[_LTa] = de_FastLaunchLaunchTemplateSpecificationResponse(output[_lT], context);
    }
    if (output[_mPL] != null) {
        contents[_MPL] = __strictParseInt32(output[_mPL]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sTR] != null) {
        contents[_STRt] = __expectString(output[_sTR]);
    }
    if (output[_sTT] != null) {
        contents[_STT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sTT]));
    }
    return contents;
};
const de_DescribeFastLaunchImagesSuccessSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DescribeFastLaunchImagesSuccessItem(entry, context);
    });
};
const de_DescribeFastSnapshotRestoresResult = (output, context) => {
    const contents = {};
    if (output.fastSnapshotRestoreSet === "") {
        contents[_FSR] = [];
    }
    else if (output[_fSRS] != null && output[_fSRS][_i] != null) {
        contents[_FSR] = de_DescribeFastSnapshotRestoreSuccessSet(__getArrayIfSingleItem(output[_fSRS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeFastSnapshotRestoreSuccessItem = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sTR] != null) {
        contents[_STRt] = __expectString(output[_sTR]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_oAw] != null) {
        contents[_OAw] = __expectString(output[_oAw]);
    }
    if (output[_eTna] != null) {
        contents[_ETna] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTna]));
    }
    if (output[_oT] != null) {
        contents[_OTpt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_oT]));
    }
    if (output[_eTnab] != null) {
        contents[_ETnab] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTnab]));
    }
    if (output[_dTi] != null) {
        contents[_DTi] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTi]));
    }
    if (output[_dTis] != null) {
        contents[_DTis] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTis]));
    }
    return contents;
};
const de_DescribeFastSnapshotRestoreSuccessSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DescribeFastSnapshotRestoreSuccessItem(entry, context);
    });
};
const de_DescribeFleetError = (output, context) => {
    const contents = {};
    if (output[_lTAO] != null) {
        contents[_LTAO] = de_LaunchTemplateAndOverridesResponse(output[_lTAO], context);
    }
    if (output[_l] != null) {
        contents[_Li] = __expectString(output[_l]);
    }
    if (output[_eC] != null) {
        contents[_EC] = __expectString(output[_eC]);
    }
    if (output[_eM] != null) {
        contents[_EM] = __expectString(output[_eM]);
    }
    return contents;
};
const de_DescribeFleetHistoryResult = (output, context) => {
    const contents = {};
    if (output.historyRecordSet === "") {
        contents[_HRi] = [];
    }
    else if (output[_hRS] != null && output[_hRS][_i] != null) {
        contents[_HRi] = de_HistoryRecordSet(__getArrayIfSingleItem(output[_hRS][_i]), context);
    }
    if (output[_lET] != null) {
        contents[_LET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lET]));
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output[_fIl] != null) {
        contents[_FIl] = __expectString(output[_fIl]);
    }
    if (output[_sT] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));
    }
    return contents;
};
const de_DescribeFleetInstancesResult = (output, context) => {
    const contents = {};
    if (output.activeInstanceSet === "") {
        contents[_AIc] = [];
    }
    else if (output[_aIS] != null && output[_aIS][_i] != null) {
        contents[_AIc] = de_ActiveInstanceSet(__getArrayIfSingleItem(output[_aIS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output[_fIl] != null) {
        contents[_FIl] = __expectString(output[_fIl]);
    }
    return contents;
};
const de_DescribeFleetsErrorSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DescribeFleetError(entry, context);
    });
};
const de_DescribeFleetsInstances = (output, context) => {
    const contents = {};
    if (output[_lTAO] != null) {
        contents[_LTAO] = de_LaunchTemplateAndOverridesResponse(output[_lTAO], context);
    }
    if (output[_l] != null) {
        contents[_Li] = __expectString(output[_l]);
    }
    if (output.instanceIds === "") {
        contents[_IIns] = [];
    }
    else if (output[_iIn] != null && output[_iIn][_i] != null) {
        contents[_IIns] = de_InstanceIdsSet(__getArrayIfSingleItem(output[_iIn][_i]), context);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    return contents;
};
const de_DescribeFleetsInstancesSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DescribeFleetsInstances(entry, context);
    });
};
const de_DescribeFleetsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.fleetSet === "") {
        contents[_Fl] = [];
    }
    else if (output[_fS] != null && output[_fS][_i] != null) {
        contents[_Fl] = de_FleetSet(__getArrayIfSingleItem(output[_fS][_i]), context);
    }
    return contents;
};
const de_DescribeFlowLogsResult = (output, context) => {
    const contents = {};
    if (output.flowLogSet === "") {
        contents[_FL] = [];
    }
    else if (output[_fLS] != null && output[_fLS][_i] != null) {
        contents[_FL] = de_FlowLogSet(__getArrayIfSingleItem(output[_fLS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeFpgaImageAttributeResult = (output, context) => {
    const contents = {};
    if (output[_fIA] != null) {
        contents[_FIAp] = de_FpgaImageAttribute(output[_fIA], context);
    }
    return contents;
};
const de_DescribeFpgaImagesResult = (output, context) => {
    const contents = {};
    if (output.fpgaImageSet === "") {
        contents[_FIp] = [];
    }
    else if (output[_fISp] != null && output[_fISp][_i] != null) {
        contents[_FIp] = de_FpgaImageList(__getArrayIfSingleItem(output[_fISp][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeHostReservationOfferingsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.offeringSet === "") {
        contents[_OS] = [];
    }
    else if (output[_oS] != null && output[_oS][_i] != null) {
        contents[_OS] = de_HostOfferingSet(__getArrayIfSingleItem(output[_oS][_i]), context);
    }
    return contents;
};
const de_DescribeHostReservationsResult = (output, context) => {
    const contents = {};
    if (output.hostReservationSet === "") {
        contents[_HRS] = [];
    }
    else if (output[_hRSo] != null && output[_hRSo][_i] != null) {
        contents[_HRS] = de_HostReservationSet(__getArrayIfSingleItem(output[_hRSo][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeHostsResult = (output, context) => {
    const contents = {};
    if (output.hostSet === "") {
        contents[_Ho] = [];
    }
    else if (output[_hS] != null && output[_hS][_i] != null) {
        contents[_Ho] = de_HostList(__getArrayIfSingleItem(output[_hS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeIamInstanceProfileAssociationsResult = (output, context) => {
    const contents = {};
    if (output.iamInstanceProfileAssociationSet === "") {
        contents[_IIPAa] = [];
    }
    else if (output[_iIPAS] != null && output[_iIPAS][_i] != null) {
        contents[_IIPAa] = de_IamInstanceProfileAssociationSet(__getArrayIfSingleItem(output[_iIPAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeIdentityIdFormatResult = (output, context) => {
    const contents = {};
    if (output.statusSet === "") {
        contents[_Status] = [];
    }
    else if (output[_sSt] != null && output[_sSt][_i] != null) {
        contents[_Status] = de_IdFormatList(__getArrayIfSingleItem(output[_sSt][_i]), context);
    }
    return contents;
};
const de_DescribeIdFormatResult = (output, context) => {
    const contents = {};
    if (output.statusSet === "") {
        contents[_Status] = [];
    }
    else if (output[_sSt] != null && output[_sSt][_i] != null) {
        contents[_Status] = de_IdFormatList(__getArrayIfSingleItem(output[_sSt][_i]), context);
    }
    return contents;
};
const de_DescribeImagesResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.imagesSet === "") {
        contents[_Ima] = [];
    }
    else if (output[_iSm] != null && output[_iSm][_i] != null) {
        contents[_Ima] = de_ImageList(__getArrayIfSingleItem(output[_iSm][_i]), context);
    }
    return contents;
};
const de_DescribeImportImageTasksResult = (output, context) => {
    const contents = {};
    if (output.importImageTaskSet === "") {
        contents[_IIT] = [];
    }
    else if (output[_iITS] != null && output[_iITS][_i] != null) {
        contents[_IIT] = de_ImportImageTaskList(__getArrayIfSingleItem(output[_iITS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeImportSnapshotTasksResult = (output, context) => {
    const contents = {};
    if (output.importSnapshotTaskSet === "") {
        contents[_IST] = [];
    }
    else if (output[_iSTS] != null && output[_iSTS][_i] != null) {
        contents[_IST] = de_ImportSnapshotTaskList(__getArrayIfSingleItem(output[_iSTS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeInstanceConnectEndpointsResult = (output, context) => {
    const contents = {};
    if (output.instanceConnectEndpointSet === "") {
        contents[_ICEn] = [];
    }
    else if (output[_iCES] != null && output[_iCES][_i] != null) {
        contents[_ICEn] = de_InstanceConnectEndpointSet(__getArrayIfSingleItem(output[_iCES][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeInstanceCreditSpecificationsResult = (output, context) => {
    const contents = {};
    if (output.instanceCreditSpecificationSet === "") {
        contents[_ICS] = [];
    }
    else if (output[_iCSS] != null && output[_iCSS][_i] != null) {
        contents[_ICS] = de_InstanceCreditSpecificationList(__getArrayIfSingleItem(output[_iCSS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeInstanceEventNotificationAttributesResult = (output, context) => {
    const contents = {};
    if (output[_iTA] != null) {
        contents[_ITA] = de_InstanceTagNotificationAttribute(output[_iTA], context);
    }
    return contents;
};
const de_DescribeInstanceEventWindowsResult = (output, context) => {
    const contents = {};
    if (output.instanceEventWindowSet === "") {
        contents[_IEWn] = [];
    }
    else if (output[_iEWSn] != null && output[_iEWSn][_i] != null) {
        contents[_IEWn] = de_InstanceEventWindowSet(__getArrayIfSingleItem(output[_iEWSn][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeInstanceImageMetadataResult = (output, context) => {
    const contents = {};
    if (output.instanceImageMetadataSet === "") {
        contents[_IIM] = [];
    }
    else if (output[_iIMS] != null && output[_iIMS][_i] != null) {
        contents[_IIM] = de_InstanceImageMetadataList(__getArrayIfSingleItem(output[_iIMS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeInstancesResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.reservationSet === "") {
        contents[_Rese] = [];
    }
    else if (output[_rSes] != null && output[_rSes][_i] != null) {
        contents[_Rese] = de_ReservationList(__getArrayIfSingleItem(output[_rSes][_i]), context);
    }
    return contents;
};
const de_DescribeInstanceStatusResult = (output, context) => {
    const contents = {};
    if (output.instanceStatusSet === "") {
        contents[_ISns] = [];
    }
    else if (output[_iSS] != null && output[_iSS][_i] != null) {
        contents[_ISns] = de_InstanceStatusList(__getArrayIfSingleItem(output[_iSS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeInstanceTopologyResult = (output, context) => {
    const contents = {};
    if (output.instanceSet === "") {
        contents[_In] = [];
    }
    else if (output[_iSns] != null && output[_iSns][_i] != null) {
        contents[_In] = de_InstanceSet(__getArrayIfSingleItem(output[_iSns][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeInstanceTypeOfferingsResult = (output, context) => {
    const contents = {};
    if (output.instanceTypeOfferingSet === "") {
        contents[_ITO] = [];
    }
    else if (output[_iTOS] != null && output[_iTOS][_i] != null) {
        contents[_ITO] = de_InstanceTypeOfferingsList(__getArrayIfSingleItem(output[_iTOS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeInstanceTypesResult = (output, context) => {
    const contents = {};
    if (output.instanceTypeSet === "") {
        contents[_ITnst] = [];
    }
    else if (output[_iTS] != null && output[_iTS][_i] != null) {
        contents[_ITnst] = de_InstanceTypeInfoList(__getArrayIfSingleItem(output[_iTS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeInternetGatewaysResult = (output, context) => {
    const contents = {};
    if (output.internetGatewaySet === "") {
        contents[_IGnt] = [];
    }
    else if (output[_iGS] != null && output[_iGS][_i] != null) {
        contents[_IGnt] = de_InternetGatewayList(__getArrayIfSingleItem(output[_iGS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeIpamByoasnResult = (output, context) => {
    const contents = {};
    if (output.byoasnSet === "") {
        contents[_Byoa] = [];
    }
    else if (output[_bS] != null && output[_bS][_i] != null) {
        contents[_Byoa] = de_ByoasnSet(__getArrayIfSingleItem(output[_bS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeIpamExternalResourceVerificationTokensResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.ipamExternalResourceVerificationTokenSet === "") {
        contents[_IERVTp] = [];
    }
    else if (output[_iERVTS] != null && output[_iERVTS][_i] != null) {
        contents[_IERVTp] = de_IpamExternalResourceVerificationTokenSet(__getArrayIfSingleItem(output[_iERVTS][_i]), context);
    }
    return contents;
};
const de_DescribeIpamPoolsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.ipamPoolSet === "") {
        contents[_IPpam] = [];
    }
    else if (output[_iPS] != null && output[_iPS][_i] != null) {
        contents[_IPpam] = de_IpamPoolSet(__getArrayIfSingleItem(output[_iPS][_i]), context);
    }
    return contents;
};
const de_DescribeIpamResourceDiscoveriesResult = (output, context) => {
    const contents = {};
    if (output.ipamResourceDiscoverySet === "") {
        contents[_IRDp] = [];
    }
    else if (output[_iRDS] != null && output[_iRDS][_i] != null) {
        contents[_IRDp] = de_IpamResourceDiscoverySet(__getArrayIfSingleItem(output[_iRDS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeIpamResourceDiscoveryAssociationsResult = (output, context) => {
    const contents = {};
    if (output.ipamResourceDiscoveryAssociationSet === "") {
        contents[_IRDAp] = [];
    }
    else if (output[_iRDAS] != null && output[_iRDAS][_i] != null) {
        contents[_IRDAp] = de_IpamResourceDiscoveryAssociationSet(__getArrayIfSingleItem(output[_iRDAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeIpamScopesResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.ipamScopeSet === "") {
        contents[_ISpam] = [];
    }
    else if (output[_iSSp] != null && output[_iSSp][_i] != null) {
        contents[_ISpam] = de_IpamScopeSet(__getArrayIfSingleItem(output[_iSSp][_i]), context);
    }
    return contents;
};
const de_DescribeIpamsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.ipamSet === "") {
        contents[_Ipam] = [];
    }
    else if (output[_iSp] != null && output[_iSp][_i] != null) {
        contents[_Ipam] = de_IpamSet(__getArrayIfSingleItem(output[_iSp][_i]), context);
    }
    return contents;
};
const de_DescribeIpv6PoolsResult = (output, context) => {
    const contents = {};
    if (output.ipv6PoolSet === "") {
        contents[_IPpvo] = [];
    }
    else if (output[_iPSp] != null && output[_iPSp][_i] != null) {
        contents[_IPpvo] = de_Ipv6PoolSet(__getArrayIfSingleItem(output[_iPSp][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeKeyPairsResult = (output, context) => {
    const contents = {};
    if (output.keySet === "") {
        contents[_KP] = [];
    }
    else if (output[_kS] != null && output[_kS][_i] != null) {
        contents[_KP] = de_KeyPairList(__getArrayIfSingleItem(output[_kS][_i]), context);
    }
    return contents;
};
const de_DescribeLaunchTemplatesResult = (output, context) => {
    const contents = {};
    if (output.launchTemplates === "") {
        contents[_LTau] = [];
    }
    else if (output[_lTa] != null && output[_lTa][_i] != null) {
        contents[_LTau] = de_LaunchTemplateSet(__getArrayIfSingleItem(output[_lTa][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeLaunchTemplateVersionsResult = (output, context) => {
    const contents = {};
    if (output.launchTemplateVersionSet === "") {
        contents[_LTVa] = [];
    }
    else if (output[_lTVS] != null && output[_lTVS][_i] != null) {
        contents[_LTVa] = de_LaunchTemplateVersionSet(__getArrayIfSingleItem(output[_lTVS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeLocalGatewayRouteTablesResult = (output, context) => {
    const contents = {};
    if (output.localGatewayRouteTableSet === "") {
        contents[_LGRTo] = [];
    }
    else if (output[_lGRTS] != null && output[_lGRTS][_i] != null) {
        contents[_LGRTo] = de_LocalGatewayRouteTableSet(__getArrayIfSingleItem(output[_lGRTS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult = (output, context) => {
    const contents = {};
    if (output.localGatewayRouteTableVirtualInterfaceGroupAssociationSet === "") {
        contents[_LGRTVIGAo] = [];
    }
    else if (output[_lGRTVIGAS] != null && output[_lGRTVIGAS][_i] != null) {
        contents[_LGRTVIGAo] = de_LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet(__getArrayIfSingleItem(output[_lGRTVIGAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeLocalGatewayRouteTableVpcAssociationsResult = (output, context) => {
    const contents = {};
    if (output.localGatewayRouteTableVpcAssociationSet === "") {
        contents[_LGRTVAo] = [];
    }
    else if (output[_lGRTVAS] != null && output[_lGRTVAS][_i] != null) {
        contents[_LGRTVAo] = de_LocalGatewayRouteTableVpcAssociationSet(__getArrayIfSingleItem(output[_lGRTVAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeLocalGatewaysResult = (output, context) => {
    const contents = {};
    if (output.localGatewaySet === "") {
        contents[_LGoc] = [];
    }
    else if (output[_lGS] != null && output[_lGS][_i] != null) {
        contents[_LGoc] = de_LocalGatewaySet(__getArrayIfSingleItem(output[_lGS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeLocalGatewayVirtualInterfaceGroupsResult = (output, context) => {
    const contents = {};
    if (output.localGatewayVirtualInterfaceGroupSet === "") {
        contents[_LGVIG] = [];
    }
    else if (output[_lGVIGS] != null && output[_lGVIGS][_i] != null) {
        contents[_LGVIG] = de_LocalGatewayVirtualInterfaceGroupSet(__getArrayIfSingleItem(output[_lGVIGS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeLocalGatewayVirtualInterfacesResult = (output, context) => {
    const contents = {};
    if (output.localGatewayVirtualInterfaceSet === "") {
        contents[_LGVI] = [];
    }
    else if (output[_lGVIS] != null && output[_lGVIS][_i] != null) {
        contents[_LGVI] = de_LocalGatewayVirtualInterfaceSet(__getArrayIfSingleItem(output[_lGVIS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeLockedSnapshotsResult = (output, context) => {
    const contents = {};
    if (output.snapshotSet === "") {
        contents[_Sn] = [];
    }
    else if (output[_sS] != null && output[_sS][_i] != null) {
        contents[_Sn] = de_LockedSnapshotsInfoList(__getArrayIfSingleItem(output[_sS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeMacHostsResult = (output, context) => {
    const contents = {};
    if (output.macHostSet === "") {
        contents[_MHa] = [];
    }
    else if (output[_mHS] != null && output[_mHS][_i] != null) {
        contents[_MHa] = de_MacHostList(__getArrayIfSingleItem(output[_mHS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeManagedPrefixListsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.prefixListSet === "") {
        contents[_PLre] = [];
    }
    else if (output[_pLS] != null && output[_pLS][_i] != null) {
        contents[_PLre] = de_ManagedPrefixListSet(__getArrayIfSingleItem(output[_pLS][_i]), context);
    }
    return contents;
};
const de_DescribeMovingAddressesResult = (output, context) => {
    const contents = {};
    if (output.movingAddressStatusSet === "") {
        contents[_MAS] = [];
    }
    else if (output[_mASS] != null && output[_mASS][_i] != null) {
        contents[_MAS] = de_MovingAddressStatusSet(__getArrayIfSingleItem(output[_mASS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeNatGatewaysResult = (output, context) => {
    const contents = {};
    if (output.natGatewaySet === "") {
        contents[_NGa] = [];
    }
    else if (output[_nGS] != null && output[_nGS][_i] != null) {
        contents[_NGa] = de_NatGatewayList(__getArrayIfSingleItem(output[_nGS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeNetworkAclsResult = (output, context) => {
    const contents = {};
    if (output.networkAclSet === "") {
        contents[_NAe] = [];
    }
    else if (output[_nAS] != null && output[_nAS][_i] != null) {
        contents[_NAe] = de_NetworkAclList(__getArrayIfSingleItem(output[_nAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeNetworkInsightsAccessScopeAnalysesResult = (output, context) => {
    const contents = {};
    if (output.networkInsightsAccessScopeAnalysisSet === "") {
        contents[_NIASA] = [];
    }
    else if (output[_nIASAS] != null && output[_nIASAS][_i] != null) {
        contents[_NIASA] = de_NetworkInsightsAccessScopeAnalysisList(__getArrayIfSingleItem(output[_nIASAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeNetworkInsightsAccessScopesResult = (output, context) => {
    const contents = {};
    if (output.networkInsightsAccessScopeSet === "") {
        contents[_NIASe] = [];
    }
    else if (output[_nIASS] != null && output[_nIASS][_i] != null) {
        contents[_NIASe] = de_NetworkInsightsAccessScopeList(__getArrayIfSingleItem(output[_nIASS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeNetworkInsightsAnalysesResult = (output, context) => {
    const contents = {};
    if (output.networkInsightsAnalysisSet === "") {
        contents[_NIA] = [];
    }
    else if (output[_nIASe] != null && output[_nIASe][_i] != null) {
        contents[_NIA] = de_NetworkInsightsAnalysisList(__getArrayIfSingleItem(output[_nIASe][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeNetworkInsightsPathsResult = (output, context) => {
    const contents = {};
    if (output.networkInsightsPathSet === "") {
        contents[_NIPe] = [];
    }
    else if (output[_nIPS] != null && output[_nIPS][_i] != null) {
        contents[_NIPe] = de_NetworkInsightsPathList(__getArrayIfSingleItem(output[_nIPS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeNetworkInterfaceAttributeResult = (output, context) => {
    const contents = {};
    if (output[_at] != null) {
        contents[_Att] = de_NetworkInterfaceAttachment(output[_at], context);
    }
    if (output[_de] != null) {
        contents[_De] = de_AttributeValue(output[_de], context);
    }
    if (output.groupSet === "") {
        contents[_G] = [];
    }
    else if (output[_gS] != null && output[_gS][_i] != null) {
        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_sDC] != null) {
        contents[_SDC] = de_AttributeBooleanValue(output[_sDC], context);
    }
    if (output[_aPIA] != null) {
        contents[_APIAs] = __parseBoolean(output[_aPIA]);
    }
    return contents;
};
const de_DescribeNetworkInterfacePermissionsResult = (output, context) => {
    const contents = {};
    if (output.networkInterfacePermissions === "") {
        contents[_NIPet] = [];
    }
    else if (output[_nIPe] != null && output[_nIPe][_i] != null) {
        contents[_NIPet] = de_NetworkInterfacePermissionList(__getArrayIfSingleItem(output[_nIPe][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeNetworkInterfacesResult = (output, context) => {
    const contents = {};
    if (output.networkInterfaceSet === "") {
        contents[_NI] = [];
    }
    else if (output[_nIS] != null && output[_nIS][_i] != null) {
        contents[_NI] = de_NetworkInterfaceList(__getArrayIfSingleItem(output[_nIS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribePlacementGroupsResult = (output, context) => {
    const contents = {};
    if (output.placementGroupSet === "") {
        contents[_PGl] = [];
    }
    else if (output[_pGS] != null && output[_pGS][_i] != null) {
        contents[_PGl] = de_PlacementGroupList(__getArrayIfSingleItem(output[_pGS][_i]), context);
    }
    return contents;
};
const de_DescribePrefixListsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.prefixListSet === "") {
        contents[_PLre] = [];
    }
    else if (output[_pLS] != null && output[_pLS][_i] != null) {
        contents[_PLre] = de_PrefixListSet(__getArrayIfSingleItem(output[_pLS][_i]), context);
    }
    return contents;
};
const de_DescribePrincipalIdFormatResult = (output, context) => {
    const contents = {};
    if (output.principalSet === "") {
        contents[_Princ] = [];
    }
    else if (output[_pSr] != null && output[_pSr][_i] != null) {
        contents[_Princ] = de_PrincipalIdFormatList(__getArrayIfSingleItem(output[_pSr][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribePublicIpv4PoolsResult = (output, context) => {
    const contents = {};
    if (output.publicIpv4PoolSet === "") {
        contents[_PIPu] = [];
    }
    else if (output[_pIPS] != null && output[_pIPS][_i] != null) {
        contents[_PIPu] = de_PublicIpv4PoolSet(__getArrayIfSingleItem(output[_pIPS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeRegionsResult = (output, context) => {
    const contents = {};
    if (output.regionInfo === "") {
        contents[_Reg] = [];
    }
    else if (output[_rIe] != null && output[_rIe][_i] != null) {
        contents[_Reg] = de_RegionList(__getArrayIfSingleItem(output[_rIe][_i]), context);
    }
    return contents;
};
const de_DescribeReplaceRootVolumeTasksResult = (output, context) => {
    const contents = {};
    if (output.replaceRootVolumeTaskSet === "") {
        contents[_RRVTe] = [];
    }
    else if (output[_rRVTS] != null && output[_rRVTS][_i] != null) {
        contents[_RRVTe] = de_ReplaceRootVolumeTasks(__getArrayIfSingleItem(output[_rRVTS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeReservedInstancesListingsResult = (output, context) => {
    const contents = {};
    if (output.reservedInstancesListingsSet === "") {
        contents[_RIL] = [];
    }
    else if (output[_rILS] != null && output[_rILS][_i] != null) {
        contents[_RIL] = de_ReservedInstancesListingList(__getArrayIfSingleItem(output[_rILS][_i]), context);
    }
    return contents;
};
const de_DescribeReservedInstancesModificationsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.reservedInstancesModificationsSet === "") {
        contents[_RIM] = [];
    }
    else if (output[_rIMS] != null && output[_rIMS][_i] != null) {
        contents[_RIM] = de_ReservedInstancesModificationList(__getArrayIfSingleItem(output[_rIMS][_i]), context);
    }
    return contents;
};
const de_DescribeReservedInstancesOfferingsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.reservedInstancesOfferingsSet === "") {
        contents[_RIO] = [];
    }
    else if (output[_rIOS] != null && output[_rIOS][_i] != null) {
        contents[_RIO] = de_ReservedInstancesOfferingList(__getArrayIfSingleItem(output[_rIOS][_i]), context);
    }
    return contents;
};
const de_DescribeReservedInstancesResult = (output, context) => {
    const contents = {};
    if (output.reservedInstancesSet === "") {
        contents[_RIese] = [];
    }
    else if (output[_rIS] != null && output[_rIS][_i] != null) {
        contents[_RIese] = de_ReservedInstancesList(__getArrayIfSingleItem(output[_rIS][_i]), context);
    }
    return contents;
};
const de_DescribeRouteServerEndpointsResult = (output, context) => {
    const contents = {};
    if (output.routeServerEndpointSet === "") {
        contents[_RSEo] = [];
    }
    else if (output[_rSES] != null && output[_rSES][_i] != null) {
        contents[_RSEo] = de_RouteServerEndpointsList(__getArrayIfSingleItem(output[_rSES][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeRouteServerPeersResult = (output, context) => {
    const contents = {};
    if (output.routeServerPeerSet === "") {
        contents[_RSPo] = [];
    }
    else if (output[_rSPS] != null && output[_rSPS][_i] != null) {
        contents[_RSPo] = de_RouteServerPeersList(__getArrayIfSingleItem(output[_rSPS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeRouteServersResult = (output, context) => {
    const contents = {};
    if (output.routeServerSet === "") {
        contents[_RSou] = [];
    }
    else if (output[_rSSo] != null && output[_rSSo][_i] != null) {
        contents[_RSou] = de_RouteServersList(__getArrayIfSingleItem(output[_rSSo][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeRouteTablesResult = (output, context) => {
    const contents = {};
    if (output.routeTableSet === "") {
        contents[_RTou] = [];
    }
    else if (output[_rTS] != null && output[_rTS][_i] != null) {
        contents[_RTou] = de_RouteTableList(__getArrayIfSingleItem(output[_rTS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeScheduledInstanceAvailabilityResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.scheduledInstanceAvailabilitySet === "") {
        contents[_SIAS] = [];
    }
    else if (output[_sIAS] != null && output[_sIAS][_i] != null) {
        contents[_SIAS] = de_ScheduledInstanceAvailabilitySet(__getArrayIfSingleItem(output[_sIAS][_i]), context);
    }
    return contents;
};
const de_DescribeScheduledInstancesResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.scheduledInstanceSet === "") {
        contents[_SIS] = [];
    }
    else if (output[_sIS] != null && output[_sIS][_i] != null) {
        contents[_SIS] = de_ScheduledInstanceSet(__getArrayIfSingleItem(output[_sIS][_i]), context);
    }
    return contents;
};
const de_DescribeSecurityGroupReferencesResult = (output, context) => {
    const contents = {};
    if (output.securityGroupReferenceSet === "") {
        contents[_SGRSe] = [];
    }
    else if (output[_sGRSe] != null && output[_sGRSe][_i] != null) {
        contents[_SGRSe] = de_SecurityGroupReferences(__getArrayIfSingleItem(output[_sGRSe][_i]), context);
    }
    return contents;
};
const de_DescribeSecurityGroupRulesResult = (output, context) => {
    const contents = {};
    if (output.securityGroupRuleSet === "") {
        contents[_SGR] = [];
    }
    else if (output[_sGRS] != null && output[_sGRS][_i] != null) {
        contents[_SGR] = de_SecurityGroupRuleList(__getArrayIfSingleItem(output[_sGRS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeSecurityGroupsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.securityGroupInfo === "") {
        contents[_SG] = [];
    }
    else if (output[_sGIec] != null && output[_sGIec][_i] != null) {
        contents[_SG] = de_SecurityGroupList(__getArrayIfSingleItem(output[_sGIec][_i]), context);
    }
    return contents;
};
const de_DescribeSecurityGroupVpcAssociationsResult = (output, context) => {
    const contents = {};
    if (output.securityGroupVpcAssociationSet === "") {
        contents[_SGVA] = [];
    }
    else if (output[_sGVAS] != null && output[_sGVAS][_i] != null) {
        contents[_SGVA] = de_SecurityGroupVpcAssociationList(__getArrayIfSingleItem(output[_sGVAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeSnapshotAttributeResult = (output, context) => {
    const contents = {};
    if (output.productCodes === "") {
        contents[_PCr] = [];
    }
    else if (output[_pC] != null && output[_pC][_i] != null) {
        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output.createVolumePermission === "") {
        contents[_CVPr] = [];
    }
    else if (output[_cVP] != null && output[_cVP][_i] != null) {
        contents[_CVPr] = de_CreateVolumePermissionList(__getArrayIfSingleItem(output[_cVP][_i]), context);
    }
    return contents;
};
const de_DescribeSnapshotsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.snapshotSet === "") {
        contents[_Sn] = [];
    }
    else if (output[_sS] != null && output[_sS][_i] != null) {
        contents[_Sn] = de_SnapshotList(__getArrayIfSingleItem(output[_sS][_i]), context);
    }
    return contents;
};
const de_DescribeSnapshotTierStatusResult = (output, context) => {
    const contents = {};
    if (output.snapshotTierStatusSet === "") {
        contents[_STS] = [];
    }
    else if (output[_sTSS] != null && output[_sTSS][_i] != null) {
        contents[_STS] = de_snapshotTierStatusSet(__getArrayIfSingleItem(output[_sTSS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeSpotDatafeedSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_sDS] != null) {
        contents[_SDS] = de_SpotDatafeedSubscription(output[_sDS], context);
    }
    return contents;
};
const de_DescribeSpotFleetInstancesResponse = (output, context) => {
    const contents = {};
    if (output.activeInstanceSet === "") {
        contents[_AIc] = [];
    }
    else if (output[_aIS] != null && output[_aIS][_i] != null) {
        contents[_AIc] = de_ActiveInstanceSet(__getArrayIfSingleItem(output[_aIS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output[_sFRI] != null) {
        contents[_SFRIp] = __expectString(output[_sFRI]);
    }
    return contents;
};
const de_DescribeSpotFleetRequestHistoryResponse = (output, context) => {
    const contents = {};
    if (output.historyRecordSet === "") {
        contents[_HRi] = [];
    }
    else if (output[_hRS] != null && output[_hRS][_i] != null) {
        contents[_HRi] = de_HistoryRecords(__getArrayIfSingleItem(output[_hRS][_i]), context);
    }
    if (output[_lET] != null) {
        contents[_LET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lET]));
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output[_sFRI] != null) {
        contents[_SFRIp] = __expectString(output[_sFRI]);
    }
    if (output[_sT] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));
    }
    return contents;
};
const de_DescribeSpotFleetRequestsResponse = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.spotFleetRequestConfigSet === "") {
        contents[_SFRCp] = [];
    }
    else if (output[_sFRCS] != null && output[_sFRCS][_i] != null) {
        contents[_SFRCp] = de_SpotFleetRequestConfigSet(__getArrayIfSingleItem(output[_sFRCS][_i]), context);
    }
    return contents;
};
const de_DescribeSpotInstanceRequestsResult = (output, context) => {
    const contents = {};
    if (output.spotInstanceRequestSet === "") {
        contents[_SIR] = [];
    }
    else if (output[_sIRS] != null && output[_sIRS][_i] != null) {
        contents[_SIR] = de_SpotInstanceRequestList(__getArrayIfSingleItem(output[_sIRS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeSpotPriceHistoryResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.spotPriceHistorySet === "") {
        contents[_SPH] = [];
    }
    else if (output[_sPHS] != null && output[_sPHS][_i] != null) {
        contents[_SPH] = de_SpotPriceHistoryList(__getArrayIfSingleItem(output[_sPHS][_i]), context);
    }
    return contents;
};
const de_DescribeStaleSecurityGroupsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.staleSecurityGroupSet === "") {
        contents[_SSGS] = [];
    }
    else if (output[_sSGS] != null && output[_sSGS][_i] != null) {
        contents[_SSGS] = de_StaleSecurityGroupSet(__getArrayIfSingleItem(output[_sSGS][_i]), context);
    }
    return contents;
};
const de_DescribeStoreImageTasksResult = (output, context) => {
    const contents = {};
    if (output.storeImageTaskResultSet === "") {
        contents[_SITR] = [];
    }
    else if (output[_sITRS] != null && output[_sITRS][_i] != null) {
        contents[_SITR] = de_StoreImageTaskResultSet(__getArrayIfSingleItem(output[_sITRS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeSubnetsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.subnetSet === "") {
        contents[_Subn] = [];
    }
    else if (output[_sSub] != null && output[_sSub][_i] != null) {
        contents[_Subn] = de_SubnetList(__getArrayIfSingleItem(output[_sSub][_i]), context);
    }
    return contents;
};
const de_DescribeTagsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagDescriptionList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_DescribeTrafficMirrorFilterRulesResult = (output, context) => {
    const contents = {};
    if (output.trafficMirrorFilterRuleSet === "") {
        contents[_TMFRr] = [];
    }
    else if (output[_tMFRS] != null && output[_tMFRS][_i] != null) {
        contents[_TMFRr] = de_TrafficMirrorFilterRuleSet(__getArrayIfSingleItem(output[_tMFRS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTrafficMirrorFiltersResult = (output, context) => {
    const contents = {};
    if (output.trafficMirrorFilterSet === "") {
        contents[_TMFr] = [];
    }
    else if (output[_tMFS] != null && output[_tMFS][_i] != null) {
        contents[_TMFr] = de_TrafficMirrorFilterSet(__getArrayIfSingleItem(output[_tMFS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTrafficMirrorSessionsResult = (output, context) => {
    const contents = {};
    if (output.trafficMirrorSessionSet === "") {
        contents[_TMSr] = [];
    }
    else if (output[_tMSS] != null && output[_tMSS][_i] != null) {
        contents[_TMSr] = de_TrafficMirrorSessionSet(__getArrayIfSingleItem(output[_tMSS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTrafficMirrorTargetsResult = (output, context) => {
    const contents = {};
    if (output.trafficMirrorTargetSet === "") {
        contents[_TMTr] = [];
    }
    else if (output[_tMTS] != null && output[_tMTS][_i] != null) {
        contents[_TMTr] = de_TrafficMirrorTargetSet(__getArrayIfSingleItem(output[_tMTS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTransitGatewayAttachmentsResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayAttachments === "") {
        contents[_TGAr] = [];
    }
    else if (output[_tGA] != null && output[_tGA][_i] != null) {
        contents[_TGAr] = de_TransitGatewayAttachmentList(__getArrayIfSingleItem(output[_tGA][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTransitGatewayConnectPeersResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayConnectPeerSet === "") {
        contents[_TGCPr] = [];
    }
    else if (output[_tGCPS] != null && output[_tGCPS][_i] != null) {
        contents[_TGCPr] = de_TransitGatewayConnectPeerList(__getArrayIfSingleItem(output[_tGCPS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTransitGatewayConnectsResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayConnectSet === "") {
        contents[_TGCra] = [];
    }
    else if (output[_tGCS] != null && output[_tGCS][_i] != null) {
        contents[_TGCra] = de_TransitGatewayConnectList(__getArrayIfSingleItem(output[_tGCS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTransitGatewayMulticastDomainsResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayMulticastDomains === "") {
        contents[_TGMDr] = [];
    }
    else if (output[_tGMDr] != null && output[_tGMDr][_i] != null) {
        contents[_TGMDr] = de_TransitGatewayMulticastDomainList(__getArrayIfSingleItem(output[_tGMDr][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTransitGatewayPeeringAttachmentsResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayPeeringAttachments === "") {
        contents[_TGPAr] = [];
    }
    else if (output[_tGPAr] != null && output[_tGPAr][_i] != null) {
        contents[_TGPAr] = de_TransitGatewayPeeringAttachmentList(__getArrayIfSingleItem(output[_tGPAr][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTransitGatewayPolicyTablesResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayPolicyTables === "") {
        contents[_TGPTr] = [];
    }
    else if (output[_tGPTr] != null && output[_tGPTr][_i] != null) {
        contents[_TGPTr] = de_TransitGatewayPolicyTableList(__getArrayIfSingleItem(output[_tGPTr][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTransitGatewayRouteTableAnnouncementsResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayRouteTableAnnouncements === "") {
        contents[_TGRTAr] = [];
    }
    else if (output[_tGRTAr] != null && output[_tGRTAr][_i] != null) {
        contents[_TGRTAr] = de_TransitGatewayRouteTableAnnouncementList(__getArrayIfSingleItem(output[_tGRTAr][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTransitGatewayRouteTablesResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayRouteTables === "") {
        contents[_TGRTr] = [];
    }
    else if (output[_tGRTr] != null && output[_tGRTr][_i] != null) {
        contents[_TGRTr] = de_TransitGatewayRouteTableList(__getArrayIfSingleItem(output[_tGRTr][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTransitGatewaysResult = (output, context) => {
    const contents = {};
    if (output.transitGatewaySet === "") {
        contents[_TGra] = [];
    }
    else if (output[_tGS] != null && output[_tGS][_i] != null) {
        contents[_TGra] = de_TransitGatewayList(__getArrayIfSingleItem(output[_tGS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTransitGatewayVpcAttachmentsResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayVpcAttachments === "") {
        contents[_TGVAr] = [];
    }
    else if (output[_tGVAr] != null && output[_tGVAr][_i] != null) {
        contents[_TGVAr] = de_TransitGatewayVpcAttachmentList(__getArrayIfSingleItem(output[_tGVAr][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeTrunkInterfaceAssociationsResult = (output, context) => {
    const contents = {};
    if (output.interfaceAssociationSet === "") {
        contents[_IAnt] = [];
    }
    else if (output[_iAS] != null && output[_iAS][_i] != null) {
        contents[_IAnt] = de_TrunkInterfaceAssociationList(__getArrayIfSingleItem(output[_iAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVerifiedAccessEndpointsResult = (output, context) => {
    const contents = {};
    if (output.verifiedAccessEndpointSet === "") {
        contents[_VAEe] = [];
    }
    else if (output[_vAES] != null && output[_vAES][_i] != null) {
        contents[_VAEe] = de_VerifiedAccessEndpointList(__getArrayIfSingleItem(output[_vAES][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVerifiedAccessGroupsResult = (output, context) => {
    const contents = {};
    if (output.verifiedAccessGroupSet === "") {
        contents[_VAGe] = [];
    }
    else if (output[_vAGS] != null && output[_vAGS][_i] != null) {
        contents[_VAGe] = de_VerifiedAccessGroupList(__getArrayIfSingleItem(output[_vAGS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVerifiedAccessInstanceLoggingConfigurationsResult = (output, context) => {
    const contents = {};
    if (output.loggingConfigurationSet === "") {
        contents[_LC] = [];
    }
    else if (output[_lCS] != null && output[_lCS][_i] != null) {
        contents[_LC] = de_VerifiedAccessInstanceLoggingConfigurationList(__getArrayIfSingleItem(output[_lCS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVerifiedAccessInstancesResult = (output, context) => {
    const contents = {};
    if (output.verifiedAccessInstanceSet === "") {
        contents[_VAIe] = [];
    }
    else if (output[_vAIS] != null && output[_vAIS][_i] != null) {
        contents[_VAIe] = de_VerifiedAccessInstanceList(__getArrayIfSingleItem(output[_vAIS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVerifiedAccessTrustProvidersResult = (output, context) => {
    const contents = {};
    if (output.verifiedAccessTrustProviderSet === "") {
        contents[_VATPe] = [];
    }
    else if (output[_vATPS] != null && output[_vATPS][_i] != null) {
        contents[_VATPe] = de_VerifiedAccessTrustProviderList(__getArrayIfSingleItem(output[_vATPS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVolumeAttributeResult = (output, context) => {
    const contents = {};
    if (output[_aEIO] != null) {
        contents[_AEIO] = de_AttributeBooleanValue(output[_aEIO], context);
    }
    if (output.productCodes === "") {
        contents[_PCr] = [];
    }
    else if (output[_pC] != null && output[_pC][_i] != null) {
        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);
    }
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    return contents;
};
const de_DescribeVolumesModificationsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.volumeModificationSet === "") {
        contents[_VMo] = [];
    }
    else if (output[_vMS] != null && output[_vMS][_i] != null) {
        contents[_VMo] = de_VolumeModificationList(__getArrayIfSingleItem(output[_vMS][_i]), context);
    }
    return contents;
};
const de_DescribeVolumesResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.volumeSet === "") {
        contents[_Vol] = [];
    }
    else if (output[_vS] != null && output[_vS][_i] != null) {
        contents[_Vol] = de_VolumeList(__getArrayIfSingleItem(output[_vS][_i]), context);
    }
    return contents;
};
const de_DescribeVolumeStatusResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.volumeStatusSet === "") {
        contents[_VSo] = [];
    }
    else if (output[_vSS] != null && output[_vSS][_i] != null) {
        contents[_VSo] = de_VolumeStatusList(__getArrayIfSingleItem(output[_vSS][_i]), context);
    }
    return contents;
};
const de_DescribeVpcAttributeResult = (output, context) => {
    const contents = {};
    if (output[_eDH] != null) {
        contents[_EDH] = de_AttributeBooleanValue(output[_eDH], context);
    }
    if (output[_eDS] != null) {
        contents[_EDS] = de_AttributeBooleanValue(output[_eDS], context);
    }
    if (output[_eNAUM] != null) {
        contents[_ENAUM] = de_AttributeBooleanValue(output[_eNAUM], context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    return contents;
};
const de_DescribeVpcBlockPublicAccessExclusionsResult = (output, context) => {
    const contents = {};
    if (output.vpcBlockPublicAccessExclusionSet === "") {
        contents[_VBPAEp] = [];
    }
    else if (output[_vBPAES] != null && output[_vBPAES][_i] != null) {
        contents[_VBPAEp] = de_VpcBlockPublicAccessExclusionList(__getArrayIfSingleItem(output[_vBPAES][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVpcBlockPublicAccessOptionsResult = (output, context) => {
    const contents = {};
    if (output[_vBPAO] != null) {
        contents[_VBPAO] = de_VpcBlockPublicAccessOptions(output[_vBPAO], context);
    }
    return contents;
};
const de_DescribeVpcClassicLinkDnsSupportResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.vpcs === "") {
        contents[_Vpc] = [];
    }
    else if (output[_vpc] != null && output[_vpc][_i] != null) {
        contents[_Vpc] = de_ClassicLinkDnsSupportList(__getArrayIfSingleItem(output[_vpc][_i]), context);
    }
    return contents;
};
const de_DescribeVpcClassicLinkResult = (output, context) => {
    const contents = {};
    if (output.vpcSet === "") {
        contents[_Vpc] = [];
    }
    else if (output[_vSp] != null && output[_vSp][_i] != null) {
        contents[_Vpc] = de_VpcClassicLinkList(__getArrayIfSingleItem(output[_vSp][_i]), context);
    }
    return contents;
};
const de_DescribeVpcEndpointAssociationsResult = (output, context) => {
    const contents = {};
    if (output.vpcEndpointAssociationSet === "") {
        contents[_VEA] = [];
    }
    else if (output[_vEAS] != null && output[_vEAS][_i] != null) {
        contents[_VEA] = de_VpcEndpointAssociationSet(__getArrayIfSingleItem(output[_vEAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVpcEndpointConnectionNotificationsResult = (output, context) => {
    const contents = {};
    if (output.connectionNotificationSet === "") {
        contents[_CNSo] = [];
    }
    else if (output[_cNSo] != null && output[_cNSo][_i] != null) {
        contents[_CNSo] = de_ConnectionNotificationSet(__getArrayIfSingleItem(output[_cNSo][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVpcEndpointConnectionsResult = (output, context) => {
    const contents = {};
    if (output.vpcEndpointConnectionSet === "") {
        contents[_VEC] = [];
    }
    else if (output[_vECS] != null && output[_vECS][_i] != null) {
        contents[_VEC] = de_VpcEndpointConnectionSet(__getArrayIfSingleItem(output[_vECS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVpcEndpointServiceConfigurationsResult = (output, context) => {
    const contents = {};
    if (output.serviceConfigurationSet === "") {
        contents[_SCer] = [];
    }
    else if (output[_sCS] != null && output[_sCS][_i] != null) {
        contents[_SCer] = de_ServiceConfigurationSet(__getArrayIfSingleItem(output[_sCS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVpcEndpointServicePermissionsResult = (output, context) => {
    const contents = {};
    if (output.allowedPrincipals === "") {
        contents[_APl] = [];
    }
    else if (output[_aP] != null && output[_aP][_i] != null) {
        contents[_APl] = de_AllowedPrincipalSet(__getArrayIfSingleItem(output[_aP][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVpcEndpointServicesResult = (output, context) => {
    const contents = {};
    if (output.serviceNameSet === "") {
        contents[_SNer] = [];
    }
    else if (output[_sNS] != null && output[_sNS][_i] != null) {
        contents[_SNer] = de_ValueStringList(__getArrayIfSingleItem(output[_sNS][_i]), context);
    }
    if (output.serviceDetailSet === "") {
        contents[_SDe] = [];
    }
    else if (output[_sDSe] != null && output[_sDSe][_i] != null) {
        contents[_SDe] = de_ServiceDetailSet(__getArrayIfSingleItem(output[_sDSe][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVpcEndpointsResult = (output, context) => {
    const contents = {};
    if (output.vpcEndpointSet === "") {
        contents[_VEp] = [];
    }
    else if (output[_vESp] != null && output[_vESp][_i] != null) {
        contents[_VEp] = de_VpcEndpointSet(__getArrayIfSingleItem(output[_vESp][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVpcPeeringConnectionsResult = (output, context) => {
    const contents = {};
    if (output.vpcPeeringConnectionSet === "") {
        contents[_VPCp] = [];
    }
    else if (output[_vPCS] != null && output[_vPCS][_i] != null) {
        contents[_VPCp] = de_VpcPeeringConnectionList(__getArrayIfSingleItem(output[_vPCS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_DescribeVpcsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.vpcSet === "") {
        contents[_Vpc] = [];
    }
    else if (output[_vSp] != null && output[_vSp][_i] != null) {
        contents[_Vpc] = de_VpcList(__getArrayIfSingleItem(output[_vSp][_i]), context);
    }
    return contents;
};
const de_DescribeVpnConnectionsResult = (output, context) => {
    const contents = {};
    if (output.vpnConnectionSet === "") {
        contents[_VCp] = [];
    }
    else if (output[_vCS] != null && output[_vCS][_i] != null) {
        contents[_VCp] = de_VpnConnectionList(__getArrayIfSingleItem(output[_vCS][_i]), context);
    }
    return contents;
};
const de_DescribeVpnGatewaysResult = (output, context) => {
    const contents = {};
    if (output.vpnGatewaySet === "") {
        contents[_VGp] = [];
    }
    else if (output[_vGS] != null && output[_vGS][_i] != null) {
        contents[_VGp] = de_VpnGatewayList(__getArrayIfSingleItem(output[_vGS][_i]), context);
    }
    return contents;
};
const de_DestinationOptionsResponse = (output, context) => {
    const contents = {};
    if (output[_fF] != null) {
        contents[_FF] = __expectString(output[_fF]);
    }
    if (output[_hCP] != null) {
        contents[_HCP] = __parseBoolean(output[_hCP]);
    }
    if (output[_pHP] != null) {
        contents[_PHP] = __parseBoolean(output[_pHP]);
    }
    return contents;
};
const de_DetachClassicLinkVpcResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_DetachVerifiedAccessTrustProviderResult = (output, context) => {
    const contents = {};
    if (output[_vATP] != null) {
        contents[_VATP] = de_VerifiedAccessTrustProvider(output[_vATP], context);
    }
    if (output[_vAI] != null) {
        contents[_VAI] = de_VerifiedAccessInstance(output[_vAI], context);
    }
    return contents;
};
const de_DeviceOptions = (output, context) => {
    const contents = {};
    if (output[_tIe] != null) {
        contents[_TIe] = __expectString(output[_tIe]);
    }
    if (output[_pSKU] != null) {
        contents[_PSKU] = __expectString(output[_pSKU]);
    }
    return contents;
};
const de_DeviceTrustProviderTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_DhcpConfiguration = (output, context) => {
    const contents = {};
    if (output[_k] != null) {
        contents[_Ke] = __expectString(output[_k]);
    }
    if (output.valueSet === "") {
        contents[_Val] = [];
    }
    else if (output[_vSa] != null && output[_vSa][_i] != null) {
        contents[_Val] = de_DhcpConfigurationValueList(__getArrayIfSingleItem(output[_vSa][_i]), context);
    }
    return contents;
};
const de_DhcpConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DhcpConfiguration(entry, context);
    });
};
const de_DhcpConfigurationValueList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AttributeValue(entry, context);
    });
};
const de_DhcpOptions = (output, context) => {
    const contents = {};
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_dOI] != null) {
        contents[_DOI] = __expectString(output[_dOI]);
    }
    if (output.dhcpConfigurationSet === "") {
        contents[_DCh] = [];
    }
    else if (output[_dCS] != null && output[_dCS][_i] != null) {
        contents[_DCh] = de_DhcpConfigurationList(__getArrayIfSingleItem(output[_dCS][_i]), context);
    }
    return contents;
};
const de_DhcpOptionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DhcpOptions(entry, context);
    });
};
const de_DirectoryServiceAuthentication = (output, context) => {
    const contents = {};
    if (output[_dI] != null) {
        contents[_DIir] = __expectString(output[_dI]);
    }
    return contents;
};
const de_DisableAddressTransferResult = (output, context) => {
    const contents = {};
    if (output[_aT] != null) {
        contents[_ATdd] = de_AddressTransfer(output[_aT], context);
    }
    return contents;
};
const de_DisableAllowedImagesSettingsResult = (output, context) => {
    const contents = {};
    if (output[_aISS] != null) {
        contents[_AISS] = __expectString(output[_aISS]);
    }
    return contents;
};
const de_DisableAwsNetworkPerformanceMetricSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_ou] != null) {
        contents[_Ou] = __parseBoolean(output[_ou]);
    }
    return contents;
};
const de_DisableEbsEncryptionByDefaultResult = (output, context) => {
    const contents = {};
    if (output[_eEBD] != null) {
        contents[_EEBD] = __parseBoolean(output[_eEBD]);
    }
    return contents;
};
const de_DisableFastLaunchResult = (output, context) => {
    const contents = {};
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_sCn] != null) {
        contents[_SCn] = de_FastLaunchSnapshotConfigurationResponse(output[_sCn], context);
    }
    if (output[_lT] != null) {
        contents[_LTa] = de_FastLaunchLaunchTemplateSpecificationResponse(output[_lT], context);
    }
    if (output[_mPL] != null) {
        contents[_MPL] = __strictParseInt32(output[_mPL]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sTR] != null) {
        contents[_STRt] = __expectString(output[_sTR]);
    }
    if (output[_sTT] != null) {
        contents[_STT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sTT]));
    }
    return contents;
};
const de_DisableFastSnapshotRestoreErrorItem = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output.fastSnapshotRestoreStateErrorSet === "") {
        contents[_FSRSE] = [];
    }
    else if (output[_fSRSES] != null && output[_fSRSES][_i] != null) {
        contents[_FSRSE] = de_DisableFastSnapshotRestoreStateErrorSet(__getArrayIfSingleItem(output[_fSRSES][_i]), context);
    }
    return contents;
};
const de_DisableFastSnapshotRestoreErrorSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DisableFastSnapshotRestoreErrorItem(entry, context);
    });
};
const de_DisableFastSnapshotRestoresResult = (output, context) => {
    const contents = {};
    if (output.successful === "") {
        contents[_Suc] = [];
    }
    else if (output[_suc] != null && output[_suc][_i] != null) {
        contents[_Suc] = de_DisableFastSnapshotRestoreSuccessSet(__getArrayIfSingleItem(output[_suc][_i]), context);
    }
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_DisableFastSnapshotRestoreErrorSet(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_DisableFastSnapshotRestoreStateError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_DisableFastSnapshotRestoreStateErrorItem = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_er] != null) {
        contents[_Er] = de_DisableFastSnapshotRestoreStateError(output[_er], context);
    }
    return contents;
};
const de_DisableFastSnapshotRestoreStateErrorSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DisableFastSnapshotRestoreStateErrorItem(entry, context);
    });
};
const de_DisableFastSnapshotRestoreSuccessItem = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sTR] != null) {
        contents[_STRt] = __expectString(output[_sTR]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_oAw] != null) {
        contents[_OAw] = __expectString(output[_oAw]);
    }
    if (output[_eTna] != null) {
        contents[_ETna] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTna]));
    }
    if (output[_oT] != null) {
        contents[_OTpt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_oT]));
    }
    if (output[_eTnab] != null) {
        contents[_ETnab] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTnab]));
    }
    if (output[_dTi] != null) {
        contents[_DTi] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTi]));
    }
    if (output[_dTis] != null) {
        contents[_DTis] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTis]));
    }
    return contents;
};
const de_DisableFastSnapshotRestoreSuccessSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DisableFastSnapshotRestoreSuccessItem(entry, context);
    });
};
const de_DisableImageBlockPublicAccessResult = (output, context) => {
    const contents = {};
    if (output[_iBPAS] != null) {
        contents[_IBPAS] = __expectString(output[_iBPAS]);
    }
    return contents;
};
const de_DisableImageDeprecationResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_DisableImageDeregistrationProtectionResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __expectString(output[_r]);
    }
    return contents;
};
const de_DisableImageResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_DisableIpamOrganizationAdminAccountResult = (output, context) => {
    const contents = {};
    if (output[_succ] != null) {
        contents[_Succ] = __parseBoolean(output[_succ]);
    }
    return contents;
};
const de_DisableRouteServerPropagationResult = (output, context) => {
    const contents = {};
    if (output[_rSPo] != null) {
        contents[_RSPou] = de_RouteServerPropagation(output[_rSPo], context);
    }
    return contents;
};
const de_DisableSerialConsoleAccessResult = (output, context) => {
    const contents = {};
    if (output[_sCAE] != null) {
        contents[_SCAE] = __parseBoolean(output[_sCAE]);
    }
    return contents;
};
const de_DisableSnapshotBlockPublicAccessResult = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_DisableTransitGatewayRouteTablePropagationResult = (output, context) => {
    const contents = {};
    if (output[_prop] != null) {
        contents[_Prop] = de_TransitGatewayPropagation(output[_prop], context);
    }
    return contents;
};
const de_DisableVpcClassicLinkDnsSupportResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_DisableVpcClassicLinkResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_DisassociateCapacityReservationBillingOwnerResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_DisassociateClientVpnTargetNetworkResult = (output, context) => {
    const contents = {};
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_AssociationStatus(output[_sta], context);
    }
    return contents;
};
const de_DisassociateEnclaveCertificateIamRoleResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_DisassociateIamInstanceProfileResult = (output, context) => {
    const contents = {};
    if (output[_iIPA] != null) {
        contents[_IIPA] = de_IamInstanceProfileAssociation(output[_iIPA], context);
    }
    return contents;
};
const de_DisassociateInstanceEventWindowResult = (output, context) => {
    const contents = {};
    if (output[_iEW] != null) {
        contents[_IEW] = de_InstanceEventWindow(output[_iEW], context);
    }
    return contents;
};
const de_DisassociateIpamByoasnResult = (output, context) => {
    const contents = {};
    if (output[_aA] != null) {
        contents[_AAsn] = de_AsnAssociation(output[_aA], context);
    }
    return contents;
};
const de_DisassociateIpamResourceDiscoveryResult = (output, context) => {
    const contents = {};
    if (output[_iRDA] != null) {
        contents[_IRDA] = de_IpamResourceDiscoveryAssociation(output[_iRDA], context);
    }
    return contents;
};
const de_DisassociateNatGatewayAddressResult = (output, context) => {
    const contents = {};
    if (output[_nGI] != null) {
        contents[_NGI] = __expectString(output[_nGI]);
    }
    if (output.natGatewayAddressSet === "") {
        contents[_NGA] = [];
    }
    else if (output[_nGAS] != null && output[_nGAS][_i] != null) {
        contents[_NGA] = de_NatGatewayAddressList(__getArrayIfSingleItem(output[_nGAS][_i]), context);
    }
    return contents;
};
const de_DisassociateRouteServerResult = (output, context) => {
    const contents = {};
    if (output[_rSA] != null) {
        contents[_RSAo] = de_RouteServerAssociation(output[_rSA], context);
    }
    return contents;
};
const de_DisassociateSecurityGroupVpcResult = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_DisassociateSubnetCidrBlockResult = (output, context) => {
    const contents = {};
    if (output[_iCBA] != null) {
        contents[_ICBA] = de_SubnetIpv6CidrBlockAssociation(output[_iCBA], context);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    return contents;
};
const de_DisassociateTransitGatewayMulticastDomainResult = (output, context) => {
    const contents = {};
    if (output[_a] != null) {
        contents[_Ass] = de_TransitGatewayMulticastDomainAssociations(output[_a], context);
    }
    return contents;
};
const de_DisassociateTransitGatewayPolicyTableResult = (output, context) => {
    const contents = {};
    if (output[_ass] != null) {
        contents[_Asso] = de_TransitGatewayPolicyTableAssociation(output[_ass], context);
    }
    return contents;
};
const de_DisassociateTransitGatewayRouteTableResult = (output, context) => {
    const contents = {};
    if (output[_ass] != null) {
        contents[_Asso] = de_TransitGatewayAssociation(output[_ass], context);
    }
    return contents;
};
const de_DisassociateTrunkInterfaceResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    return contents;
};
const de_DisassociateVpcCidrBlockResult = (output, context) => {
    const contents = {};
    if (output[_iCBA] != null) {
        contents[_ICBA] = de_VpcIpv6CidrBlockAssociation(output[_iCBA], context);
    }
    if (output[_cBA] != null) {
        contents[_CBA] = de_VpcCidrBlockAssociation(output[_cBA], context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    return contents;
};
const de_DiskImageDescription = (output, context) => {
    const contents = {};
    if (output[_ch] != null) {
        contents[_Ch] = __expectString(output[_ch]);
    }
    if (output[_f] != null) {
        contents[_Fo] = __expectString(output[_f]);
    }
    if (output[_iMU] != null) {
        contents[_IMU] = __expectString(output[_iMU]);
    }
    if (output[_si] != null) {
        contents[_Siz] = __strictParseLong(output[_si]);
    }
    return contents;
};
const de_DiskImageVolumeDescription = (output, context) => {
    const contents = {};
    if (output[_id] != null) {
        contents[_Id] = __expectString(output[_id]);
    }
    if (output[_si] != null) {
        contents[_Siz] = __strictParseLong(output[_si]);
    }
    return contents;
};
const de_DiskInfo = (output, context) => {
    const contents = {};
    if (output[_sIGB] != null) {
        contents[_SIGB] = __strictParseLong(output[_sIGB]);
    }
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    return contents;
};
const de_DiskInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DiskInfo(entry, context);
    });
};
const de_DnsEntry = (output, context) => {
    const contents = {};
    if (output[_dNn] != null) {
        contents[_DNn] = __expectString(output[_dNn]);
    }
    if (output[_hZI] != null) {
        contents[_HZI] = __expectString(output[_hZI]);
    }
    return contents;
};
const de_DnsEntrySet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DnsEntry(entry, context);
    });
};
const de_DnsOptions = (output, context) => {
    const contents = {};
    if (output[_dRIT] != null) {
        contents[_DRIT] = __expectString(output[_dRIT]);
    }
    if (output[_pDOFIRE] != null) {
        contents[_PDOFIRE] = __parseBoolean(output[_pDOFIRE]);
    }
    return contents;
};
const de_EbsBlockDevice = (output, context) => {
    const contents = {};
    if (output[_dOT] != null) {
        contents[_DOT] = __parseBoolean(output[_dOT]);
    }
    if (output[_io] != null) {
        contents[_Io] = __strictParseInt32(output[_io]);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_vSo] != null) {
        contents[_VS] = __strictParseInt32(output[_vSo]);
    }
    if (output[_vT] != null) {
        contents[_VT] = __expectString(output[_vT]);
    }
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    if (output[_th] != null) {
        contents[_Th] = __strictParseInt32(output[_th]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_enc] != null) {
        contents[_Enc] = __parseBoolean(output[_enc]);
    }
    return contents;
};
const de_EbsBlockDeviceResponse = (output, context) => {
    const contents = {};
    if (output[_enc] != null) {
        contents[_Enc] = __parseBoolean(output[_enc]);
    }
    if (output[_dOT] != null) {
        contents[_DOT] = __parseBoolean(output[_dOT]);
    }
    if (output[_io] != null) {
        contents[_Io] = __strictParseInt32(output[_io]);
    }
    if (output[_th] != null) {
        contents[_Th] = __strictParseInt32(output[_th]);
    }
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_vSo] != null) {
        contents[_VS] = __strictParseInt32(output[_vSo]);
    }
    if (output[_vT] != null) {
        contents[_VT] = __expectString(output[_vT]);
    }
    return contents;
};
const de_EbsInfo = (output, context) => {
    const contents = {};
    if (output[_eOS] != null) {
        contents[_EOS] = __expectString(output[_eOS]);
    }
    if (output[_eSn] != null) {
        contents[_ESnc] = __expectString(output[_eSn]);
    }
    if (output[_eOI] != null) {
        contents[_EOI] = de_EbsOptimizedInfo(output[_eOI], context);
    }
    if (output[_nS] != null) {
        contents[_NS] = __expectString(output[_nS]);
    }
    return contents;
};
const de_EbsInstanceBlockDevice = (output, context) => {
    const contents = {};
    if (output[_aTt] != null) {
        contents[_ATtt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aTt]));
    }
    if (output[_dOT] != null) {
        contents[_DOT] = __parseBoolean(output[_dOT]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    if (output[_aRs] != null) {
        contents[_ARs] = __expectString(output[_aRs]);
    }
    if (output[_vOI] != null) {
        contents[_VOI] = __expectString(output[_vOI]);
    }
    if (output[_op] != null) {
        contents[_O] = de_OperatorResponse(output[_op], context);
    }
    return contents;
};
const de_EbsOptimizedInfo = (output, context) => {
    const contents = {};
    if (output[_bBIM] != null) {
        contents[_BBIM] = __strictParseInt32(output[_bBIM]);
    }
    if (output[_bTIMB] != null) {
        contents[_BTIMB] = __strictParseFloat(output[_bTIMB]);
    }
    if (output[_bIa] != null) {
        contents[_BIa] = __strictParseInt32(output[_bIa]);
    }
    if (output[_mBIM] != null) {
        contents[_MBIM] = __strictParseInt32(output[_mBIM]);
    }
    if (output[_mTIMB] != null) {
        contents[_MTIMB] = __strictParseFloat(output[_mTIMB]);
    }
    if (output[_mI] != null) {
        contents[_MIa] = __strictParseInt32(output[_mI]);
    }
    return contents;
};
const de_EbsStatusDetails = (output, context) => {
    const contents = {};
    if (output[_iSmp] != null) {
        contents[_ISmp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_iSmp]));
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_EbsStatusDetailsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EbsStatusDetails(entry, context);
    });
};
const de_EbsStatusSummary = (output, context) => {
    const contents = {};
    if (output.details === "") {
        contents[_Det] = [];
    }
    else if (output[_det] != null && output[_det][_i] != null) {
        contents[_Det] = de_EbsStatusDetailsList(__getArrayIfSingleItem(output[_det][_i]), context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_Ec2InstanceConnectEndpoint = (output, context) => {
    const contents = {};
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_iCEI] != null) {
        contents[_ICEI] = __expectString(output[_iCEI]);
    }
    if (output[_iCEA] != null) {
        contents[_ICEA] = __expectString(output[_iCEA]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMta] != null) {
        contents[_SMta] = __expectString(output[_sMta]);
    }
    if (output[_dNn] != null) {
        contents[_DNn] = __expectString(output[_dNn]);
    }
    if (output[_fDN] != null) {
        contents[_FDN] = __expectString(output[_fDN]);
    }
    if (output.networkInterfaceIdSet === "") {
        contents[_NIIe] = [];
    }
    else if (output[_nIIS] != null && output[_nIIS][_i] != null) {
        contents[_NIIe] = de_NetworkInterfaceIdSet(__getArrayIfSingleItem(output[_nIIS][_i]), context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_cAr] != null) {
        contents[_CAr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cAr]));
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_pCI] != null) {
        contents[_PCI] = __parseBoolean(output[_pCI]);
    }
    if (output.securityGroupIdSet === "") {
        contents[_SGI] = [];
    }
    else if (output[_sGIS] != null && output[_sGIS][_i] != null) {
        contents[_SGI] = de_SecurityGroupIdSet(__getArrayIfSingleItem(output[_sGIS][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_EfaInfo = (output, context) => {
    const contents = {};
    if (output[_mEI] != null) {
        contents[_MEI] = __strictParseInt32(output[_mEI]);
    }
    return contents;
};
const de_EgressOnlyInternetGateway = (output, context) => {
    const contents = {};
    if (output.attachmentSet === "") {
        contents[_Atta] = [];
    }
    else if (output[_aSt] != null && output[_aSt][_i] != null) {
        contents[_Atta] = de_InternetGatewayAttachmentList(__getArrayIfSingleItem(output[_aSt][_i]), context);
    }
    if (output[_eOIGI] != null) {
        contents[_EOIGI] = __expectString(output[_eOIGI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_EgressOnlyInternetGatewayList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EgressOnlyInternetGateway(entry, context);
    });
};
const de_ElasticGpuAssociation = (output, context) => {
    const contents = {};
    if (output[_eGI] != null) {
        contents[_EGIl] = __expectString(output[_eGI]);
    }
    if (output[_eGAI] != null) {
        contents[_EGAI] = __expectString(output[_eGAI]);
    }
    if (output[_eGAS] != null) {
        contents[_EGAS] = __expectString(output[_eGAS]);
    }
    if (output[_eGAT] != null) {
        contents[_EGAT] = __expectString(output[_eGAT]);
    }
    return contents;
};
const de_ElasticGpuAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ElasticGpuAssociation(entry, context);
    });
};
const de_ElasticGpuHealth = (output, context) => {
    const contents = {};
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_ElasticGpus = (output, context) => {
    const contents = {};
    if (output[_eGI] != null) {
        contents[_EGIl] = __expectString(output[_eGI]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_eGT] != null) {
        contents[_EGT] = __expectString(output[_eGT]);
    }
    if (output[_eGH] != null) {
        contents[_EGH] = de_ElasticGpuHealth(output[_eGH], context);
    }
    if (output[_eGSl] != null) {
        contents[_EGSlas] = __expectString(output[_eGSl]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_ElasticGpuSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ElasticGpus(entry, context);
    });
};
const de_ElasticGpuSpecificationResponse = (output, context) => {
    const contents = {};
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    return contents;
};
const de_ElasticGpuSpecificationResponseList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ElasticGpuSpecificationResponse(entry, context);
    });
};
const de_ElasticInferenceAcceleratorAssociation = (output, context) => {
    const contents = {};
    if (output[_eIAA] != null) {
        contents[_EIAA] = __expectString(output[_eIAA]);
    }
    if (output[_eIAAI] != null) {
        contents[_EIAAI] = __expectString(output[_eIAAI]);
    }
    if (output[_eIAAS] != null) {
        contents[_EIAAS] = __expectString(output[_eIAAS]);
    }
    if (output[_eIAAT] != null) {
        contents[_EIAAT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eIAAT]));
    }
    return contents;
};
const de_ElasticInferenceAcceleratorAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ElasticInferenceAcceleratorAssociation(entry, context);
    });
};
const de_EnableAddressTransferResult = (output, context) => {
    const contents = {};
    if (output[_aT] != null) {
        contents[_ATdd] = de_AddressTransfer(output[_aT], context);
    }
    return contents;
};
const de_EnableAllowedImagesSettingsResult = (output, context) => {
    const contents = {};
    if (output[_aISS] != null) {
        contents[_AISS] = __expectString(output[_aISS]);
    }
    return contents;
};
const de_EnableAwsNetworkPerformanceMetricSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_ou] != null) {
        contents[_Ou] = __parseBoolean(output[_ou]);
    }
    return contents;
};
const de_EnableEbsEncryptionByDefaultResult = (output, context) => {
    const contents = {};
    if (output[_eEBD] != null) {
        contents[_EEBD] = __parseBoolean(output[_eEBD]);
    }
    return contents;
};
const de_EnableFastLaunchResult = (output, context) => {
    const contents = {};
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_sCn] != null) {
        contents[_SCn] = de_FastLaunchSnapshotConfigurationResponse(output[_sCn], context);
    }
    if (output[_lT] != null) {
        contents[_LTa] = de_FastLaunchLaunchTemplateSpecificationResponse(output[_lT], context);
    }
    if (output[_mPL] != null) {
        contents[_MPL] = __strictParseInt32(output[_mPL]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sTR] != null) {
        contents[_STRt] = __expectString(output[_sTR]);
    }
    if (output[_sTT] != null) {
        contents[_STT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sTT]));
    }
    return contents;
};
const de_EnableFastSnapshotRestoreErrorItem = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output.fastSnapshotRestoreStateErrorSet === "") {
        contents[_FSRSE] = [];
    }
    else if (output[_fSRSES] != null && output[_fSRSES][_i] != null) {
        contents[_FSRSE] = de_EnableFastSnapshotRestoreStateErrorSet(__getArrayIfSingleItem(output[_fSRSES][_i]), context);
    }
    return contents;
};
const de_EnableFastSnapshotRestoreErrorSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EnableFastSnapshotRestoreErrorItem(entry, context);
    });
};
const de_EnableFastSnapshotRestoresResult = (output, context) => {
    const contents = {};
    if (output.successful === "") {
        contents[_Suc] = [];
    }
    else if (output[_suc] != null && output[_suc][_i] != null) {
        contents[_Suc] = de_EnableFastSnapshotRestoreSuccessSet(__getArrayIfSingleItem(output[_suc][_i]), context);
    }
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_EnableFastSnapshotRestoreErrorSet(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_EnableFastSnapshotRestoreStateError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_EnableFastSnapshotRestoreStateErrorItem = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_er] != null) {
        contents[_Er] = de_EnableFastSnapshotRestoreStateError(output[_er], context);
    }
    return contents;
};
const de_EnableFastSnapshotRestoreStateErrorSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EnableFastSnapshotRestoreStateErrorItem(entry, context);
    });
};
const de_EnableFastSnapshotRestoreSuccessItem = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sTR] != null) {
        contents[_STRt] = __expectString(output[_sTR]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_oAw] != null) {
        contents[_OAw] = __expectString(output[_oAw]);
    }
    if (output[_eTna] != null) {
        contents[_ETna] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTna]));
    }
    if (output[_oT] != null) {
        contents[_OTpt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_oT]));
    }
    if (output[_eTnab] != null) {
        contents[_ETnab] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTnab]));
    }
    if (output[_dTi] != null) {
        contents[_DTi] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTi]));
    }
    if (output[_dTis] != null) {
        contents[_DTis] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTis]));
    }
    return contents;
};
const de_EnableFastSnapshotRestoreSuccessSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EnableFastSnapshotRestoreSuccessItem(entry, context);
    });
};
const de_EnableImageBlockPublicAccessResult = (output, context) => {
    const contents = {};
    if (output[_iBPAS] != null) {
        contents[_IBPAS] = __expectString(output[_iBPAS]);
    }
    return contents;
};
const de_EnableImageDeprecationResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_EnableImageDeregistrationProtectionResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __expectString(output[_r]);
    }
    return contents;
};
const de_EnableImageResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_EnableIpamOrganizationAdminAccountResult = (output, context) => {
    const contents = {};
    if (output[_succ] != null) {
        contents[_Succ] = __parseBoolean(output[_succ]);
    }
    return contents;
};
const de_EnableReachabilityAnalyzerOrganizationSharingResult = (output, context) => {
    const contents = {};
    if (output[_rV] != null) {
        contents[_RV] = __parseBoolean(output[_rV]);
    }
    return contents;
};
const de_EnableRouteServerPropagationResult = (output, context) => {
    const contents = {};
    if (output[_rSPo] != null) {
        contents[_RSPou] = de_RouteServerPropagation(output[_rSPo], context);
    }
    return contents;
};
const de_EnableSerialConsoleAccessResult = (output, context) => {
    const contents = {};
    if (output[_sCAE] != null) {
        contents[_SCAE] = __parseBoolean(output[_sCAE]);
    }
    return contents;
};
const de_EnableSnapshotBlockPublicAccessResult = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_EnableTransitGatewayRouteTablePropagationResult = (output, context) => {
    const contents = {};
    if (output[_prop] != null) {
        contents[_Prop] = de_TransitGatewayPropagation(output[_prop], context);
    }
    return contents;
};
const de_EnableVpcClassicLinkDnsSupportResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_EnableVpcClassicLinkResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_EnaSrdSpecificationRequest = (output, context) => {
    const contents = {};
    if (output[_ESE] != null) {
        contents[_ESE] = __parseBoolean(output[_ESE]);
    }
    if (output[_ESUS] != null) {
        contents[_ESUS] = de_EnaSrdUdpSpecificationRequest(output[_ESUS], context);
    }
    return contents;
};
const de_EnaSrdUdpSpecificationRequest = (output, context) => {
    const contents = {};
    if (output[_ESUE] != null) {
        contents[_ESUE] = __parseBoolean(output[_ESUE]);
    }
    return contents;
};
const de_EnclaveOptions = (output, context) => {
    const contents = {};
    if (output[_en] != null) {
        contents[_En] = __parseBoolean(output[_en]);
    }
    return contents;
};
const de_EndpointSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClientVpnEndpoint(entry, context);
    });
};
const de_ErrorSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ValidationError(entry, context);
    });
};
const de_EventInformation = (output, context) => {
    const contents = {};
    if (output[_eDv] != null) {
        contents[_EDv] = __expectString(output[_eDv]);
    }
    if (output[_eST] != null) {
        contents[_EST] = __expectString(output[_eST]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    return contents;
};
const de_ExcludedInstanceTypeSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Explanation = (output, context) => {
    const contents = {};
    if (output[_ac] != null) {
        contents[_Acl] = de_AnalysisComponent(output[_ac], context);
    }
    if (output[_aRc] != null) {
        contents[_ARcl] = de_AnalysisAclRule(output[_aRc], context);
    }
    if (output[_ad] != null) {
        contents[_Ad] = __expectString(output[_ad]);
    }
    if (output.addressSet === "") {
        contents[_Addr] = [];
    }
    else if (output[_aSd] != null && output[_aSd][_i] != null) {
        contents[_Addr] = de_IpAddressList(__getArrayIfSingleItem(output[_aSd][_i]), context);
    }
    if (output[_aTtt] != null) {
        contents[_ATtta] = de_AnalysisComponent(output[_aTtt], context);
    }
    if (output.availabilityZoneSet === "") {
        contents[_AZv] = [];
    }
    else if (output[_aZS] != null && output[_aZS][_i] != null) {
        contents[_AZv] = de_ValueStringList(__getArrayIfSingleItem(output[_aZS][_i]), context);
    }
    if (output.cidrSet === "") {
        contents[_Ci] = [];
    }
    else if (output[_cS] != null && output[_cS][_i] != null) {
        contents[_Ci] = de_ValueStringList(__getArrayIfSingleItem(output[_cS][_i]), context);
    }
    if (output[_c] != null) {
        contents[_Com] = de_AnalysisComponent(output[_c], context);
    }
    if (output[_cGu] != null) {
        contents[_CGu] = de_AnalysisComponent(output[_cGu], context);
    }
    if (output[_d] != null) {
        contents[_D] = de_AnalysisComponent(output[_d], context);
    }
    if (output[_dV] != null) {
        contents[_DVest] = de_AnalysisComponent(output[_dV], context);
    }
    if (output[_di] != null) {
        contents[_Di] = __expectString(output[_di]);
    }
    if (output[_eCx] != null) {
        contents[_ECx] = __expectString(output[_eCx]);
    }
    if (output[_iRT] != null) {
        contents[_IRT] = de_AnalysisComponent(output[_iRT], context);
    }
    if (output[_iG] != null) {
        contents[_IGn] = de_AnalysisComponent(output[_iG], context);
    }
    if (output[_lBA] != null) {
        contents[_LBA] = __expectString(output[_lBA]);
    }
    if (output[_cLBL] != null) {
        contents[_CLBL] = de_AnalysisLoadBalancerListener(output[_cLBL], context);
    }
    if (output[_lBLP] != null) {
        contents[_LBLP] = __strictParseInt32(output[_lBLP]);
    }
    if (output[_lBT] != null) {
        contents[_LBT] = de_AnalysisLoadBalancerTarget(output[_lBT], context);
    }
    if (output[_lBTG] != null) {
        contents[_LBTG] = de_AnalysisComponent(output[_lBTG], context);
    }
    if (output.loadBalancerTargetGroupSet === "") {
        contents[_LBTGo] = [];
    }
    else if (output[_lBTGS] != null && output[_lBTGS][_i] != null) {
        contents[_LBTGo] = de_AnalysisComponentList(__getArrayIfSingleItem(output[_lBTGS][_i]), context);
    }
    if (output[_lBTP] != null) {
        contents[_LBTP] = __strictParseInt32(output[_lBTP]);
    }
    if (output[_eLBL] != null) {
        contents[_ELBL] = de_AnalysisComponent(output[_eLBL], context);
    }
    if (output[_mC] != null) {
        contents[_MCis] = __expectString(output[_mC]);
    }
    if (output[_nG] != null) {
        contents[_NG] = de_AnalysisComponent(output[_nG], context);
    }
    if (output[_nIe] != null) {
        contents[_NIet] = de_AnalysisComponent(output[_nIe], context);
    }
    if (output[_pF] != null) {
        contents[_PF] = __expectString(output[_pF]);
    }
    if (output[_vPC] != null) {
        contents[_VPC] = de_AnalysisComponent(output[_vPC], context);
    }
    if (output[_po] != null) {
        contents[_Po] = __strictParseInt32(output[_po]);
    }
    if (output.portRangeSet === "") {
        contents[_PRo] = [];
    }
    else if (output[_pRS] != null && output[_pRS][_i] != null) {
        contents[_PRo] = de_PortRangeList(__getArrayIfSingleItem(output[_pRS][_i]), context);
    }
    if (output[_pL] != null) {
        contents[_PLr] = de_AnalysisComponent(output[_pL], context);
    }
    if (output.protocolSet === "") {
        contents[_Pro] = [];
    }
    else if (output[_pSro] != null && output[_pSro][_i] != null) {
        contents[_Pro] = de_StringList(__getArrayIfSingleItem(output[_pSro][_i]), context);
    }
    if (output[_rTR] != null) {
        contents[_RTR] = de_AnalysisRouteTableRoute(output[_rTR], context);
    }
    if (output[_rTo] != null) {
        contents[_RTo] = de_AnalysisComponent(output[_rTo], context);
    }
    if (output[_sG] != null) {
        contents[_SGe] = de_AnalysisComponent(output[_sG], context);
    }
    if (output[_sGR] != null) {
        contents[_SGRe] = de_AnalysisSecurityGroupRule(output[_sGR], context);
    }
    if (output.securityGroupSet === "") {
        contents[_SG] = [];
    }
    else if (output[_sGS] != null && output[_sGS][_i] != null) {
        contents[_SG] = de_AnalysisComponentList(__getArrayIfSingleItem(output[_sGS][_i]), context);
    }
    if (output[_sV] != null) {
        contents[_SVo] = de_AnalysisComponent(output[_sV], context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_su] != null) {
        contents[_Su] = de_AnalysisComponent(output[_su], context);
    }
    if (output[_sRT] != null) {
        contents[_SRT] = de_AnalysisComponent(output[_sRT], context);
    }
    if (output[_vp] != null) {
        contents[_Vp] = de_AnalysisComponent(output[_vp], context);
    }
    if (output[_vE] != null) {
        contents[_VE] = de_AnalysisComponent(output[_vE], context);
    }
    if (output[_vC] != null) {
        contents[_VC] = de_AnalysisComponent(output[_vC], context);
    }
    if (output[_vG] != null) {
        contents[_VG] = de_AnalysisComponent(output[_vG], context);
    }
    if (output[_tG] != null) {
        contents[_TGr] = de_AnalysisComponent(output[_tG], context);
    }
    if (output[_tGRT] != null) {
        contents[_TGRT] = de_AnalysisComponent(output[_tGRT], context);
    }
    if (output[_tGRTR] != null) {
        contents[_TGRTR] = de_TransitGatewayRouteTableRoute(output[_tGRTR], context);
    }
    if (output[_tGAr] != null) {
        contents[_TGAra] = de_AnalysisComponent(output[_tGAr], context);
    }
    if (output[_cAo] != null) {
        contents[_CAom] = __expectString(output[_cAo]);
    }
    if (output[_cRo] != null) {
        contents[_CRo] = __expectString(output[_cRo]);
    }
    if (output[_fSR] != null) {
        contents[_FSRi] = de_FirewallStatelessRule(output[_fSR], context);
    }
    if (output[_fSRi] != null) {
        contents[_FSRir] = de_FirewallStatefulRule(output[_fSRi], context);
    }
    return contents;
};
const de_ExplanationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Explanation(entry, context);
    });
};
const de_ExportClientVpnClientCertificateRevocationListResult = (output, context) => {
    const contents = {};
    if (output[_cRL] != null) {
        contents[_CRL] = __expectString(output[_cRL]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientCertificateRevocationListStatus(output[_sta], context);
    }
    return contents;
};
const de_ExportClientVpnClientConfigurationResult = (output, context) => {
    const contents = {};
    if (output[_cCl] != null) {
        contents[_CCl] = __expectString(output[_cCl]);
    }
    return contents;
};
const de_ExportImageResult = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_dIF] != null) {
        contents[_DIFi] = __expectString(output[_dIF]);
    }
    if (output[_eITI] != null) {
        contents[_EITIx] = __expectString(output[_eITI]);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_rNo] != null) {
        contents[_RNo] = __expectString(output[_rNo]);
    }
    if (output[_pro] != null) {
        contents[_Prog] = __expectString(output[_pro]);
    }
    if (output[_sEL] != null) {
        contents[_SEL] = de_ExportTaskS3Location(output[_sEL], context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_ExportImageTask = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_eITI] != null) {
        contents[_EITIx] = __expectString(output[_eITI]);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_pro] != null) {
        contents[_Prog] = __expectString(output[_pro]);
    }
    if (output[_sEL] != null) {
        contents[_SEL] = de_ExportTaskS3Location(output[_sEL], context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_ExportImageTaskList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExportImageTask(entry, context);
    });
};
const de_ExportTask = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_eTI] != null) {
        contents[_ETI] = __expectString(output[_eTI]);
    }
    if (output[_eTSx] != null) {
        contents[_ETST] = de_ExportToS3Task(output[_eTSx], context);
    }
    if (output[_iE] != null) {
        contents[_IED] = de_InstanceExportDetails(output[_iE], context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_ExportTaskList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExportTask(entry, context);
    });
};
const de_ExportTaskS3Location = (output, context) => {
    const contents = {};
    if (output[_sB] != null) {
        contents[_SB] = __expectString(output[_sB]);
    }
    if (output[_sP] != null) {
        contents[_SP] = __expectString(output[_sP]);
    }
    return contents;
};
const de_ExportToS3Task = (output, context) => {
    const contents = {};
    if (output[_cF] != null) {
        contents[_CFo] = __expectString(output[_cF]);
    }
    if (output[_dIF] != null) {
        contents[_DIFi] = __expectString(output[_dIF]);
    }
    if (output[_sB] != null) {
        contents[_SB] = __expectString(output[_sB]);
    }
    if (output[_sK] != null) {
        contents[_SK] = __expectString(output[_sK]);
    }
    return contents;
};
const de_ExportTransitGatewayRoutesResult = (output, context) => {
    const contents = {};
    if (output[_sL] != null) {
        contents[_SLo] = __expectString(output[_sL]);
    }
    return contents;
};
const de_ExportVerifiedAccessInstanceClientConfigurationResult = (output, context) => {
    const contents = {};
    if (output[_ve] != null) {
        contents[_V] = __expectString(output[_ve]);
    }
    if (output[_vAII] != null) {
        contents[_VAII] = __expectString(output[_vAII]);
    }
    if (output[_re] != null) {
        contents[_Regi] = __expectString(output[_re]);
    }
    if (output.deviceTrustProviderSet === "") {
        contents[_DTP] = [];
    }
    else if (output[_dTPS] != null && output[_dTPS][_i] != null) {
        contents[_DTP] = de_DeviceTrustProviderTypeList(__getArrayIfSingleItem(output[_dTPS][_i]), context);
    }
    if (output[_uTP] != null) {
        contents[_UTP] = de_VerifiedAccessInstanceUserTrustProviderClientConfiguration(output[_uTP], context);
    }
    if (output.openVpnConfigurationSet === "") {
        contents[_OVC] = [];
    }
    else if (output[_oVCS] != null && output[_oVCS][_i] != null) {
        contents[_OVC] = de_VerifiedAccessInstanceOpenVpnClientConfigurationList(__getArrayIfSingleItem(output[_oVCS][_i]), context);
    }
    return contents;
};
const de_FailedCapacityReservationFleetCancellationResult = (output, context) => {
    const contents = {};
    if (output[_cRFI] != null) {
        contents[_CRFIa] = __expectString(output[_cRFI]);
    }
    if (output[_cCRFE] != null) {
        contents[_CCRFE] = de_CancelCapacityReservationFleetError(output[_cCRFE], context);
    }
    return contents;
};
const de_FailedCapacityReservationFleetCancellationResultSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FailedCapacityReservationFleetCancellationResult(entry, context);
    });
};
const de_FailedQueuedPurchaseDeletion = (output, context) => {
    const contents = {};
    if (output[_er] != null) {
        contents[_Er] = de_DeleteQueuedReservedInstancesError(output[_er], context);
    }
    if (output[_rII] != null) {
        contents[_RIIe] = __expectString(output[_rII]);
    }
    return contents;
};
const de_FailedQueuedPurchaseDeletionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FailedQueuedPurchaseDeletion(entry, context);
    });
};
const de_FastLaunchLaunchTemplateSpecificationResponse = (output, context) => {
    const contents = {};
    if (output[_lTI] != null) {
        contents[_LTI] = __expectString(output[_lTI]);
    }
    if (output[_lTN] != null) {
        contents[_LTN] = __expectString(output[_lTN]);
    }
    if (output[_ve] != null) {
        contents[_V] = __expectString(output[_ve]);
    }
    return contents;
};
const de_FastLaunchSnapshotConfigurationResponse = (output, context) => {
    const contents = {};
    if (output[_tRC] != null) {
        contents[_TRC] = __strictParseInt32(output[_tRC]);
    }
    return contents;
};
const de_FederatedAuthentication = (output, context) => {
    const contents = {};
    if (output[_sPA] != null) {
        contents[_SPA] = __expectString(output[_sPA]);
    }
    if (output[_sSSPA] != null) {
        contents[_SSSPA] = __expectString(output[_sSSPA]);
    }
    return contents;
};
const de_FilterPortRange = (output, context) => {
    const contents = {};
    if (output[_fP] != null) {
        contents[_FP] = __strictParseInt32(output[_fP]);
    }
    if (output[_tPo] != null) {
        contents[_TP] = __strictParseInt32(output[_tPo]);
    }
    return contents;
};
const de_FirewallStatefulRule = (output, context) => {
    const contents = {};
    if (output[_rGA] != null) {
        contents[_RGA] = __expectString(output[_rGA]);
    }
    if (output.sourceSet === "") {
        contents[_So] = [];
    }
    else if (output[_sSo] != null && output[_sSo][_i] != null) {
        contents[_So] = de_ValueStringList(__getArrayIfSingleItem(output[_sSo][_i]), context);
    }
    if (output.destinationSet === "") {
        contents[_Des] = [];
    }
    else if (output[_dSe] != null && output[_dSe][_i] != null) {
        contents[_Des] = de_ValueStringList(__getArrayIfSingleItem(output[_dSe][_i]), context);
    }
    if (output.sourcePortSet === "") {
        contents[_SPo] = [];
    }
    else if (output[_sPS] != null && output[_sPS][_i] != null) {
        contents[_SPo] = de_PortRangeList(__getArrayIfSingleItem(output[_sPS][_i]), context);
    }
    if (output.destinationPortSet === "") {
        contents[_DPes] = [];
    }
    else if (output[_dPS] != null && output[_dPS][_i] != null) {
        contents[_DPes] = de_PortRangeList(__getArrayIfSingleItem(output[_dPS][_i]), context);
    }
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output[_rA] != null) {
        contents[_RAu] = __expectString(output[_rA]);
    }
    if (output[_di] != null) {
        contents[_Di] = __expectString(output[_di]);
    }
    return contents;
};
const de_FirewallStatelessRule = (output, context) => {
    const contents = {};
    if (output[_rGA] != null) {
        contents[_RGA] = __expectString(output[_rGA]);
    }
    if (output.sourceSet === "") {
        contents[_So] = [];
    }
    else if (output[_sSo] != null && output[_sSo][_i] != null) {
        contents[_So] = de_ValueStringList(__getArrayIfSingleItem(output[_sSo][_i]), context);
    }
    if (output.destinationSet === "") {
        contents[_Des] = [];
    }
    else if (output[_dSe] != null && output[_dSe][_i] != null) {
        contents[_Des] = de_ValueStringList(__getArrayIfSingleItem(output[_dSe][_i]), context);
    }
    if (output.sourcePortSet === "") {
        contents[_SPo] = [];
    }
    else if (output[_sPS] != null && output[_sPS][_i] != null) {
        contents[_SPo] = de_PortRangeList(__getArrayIfSingleItem(output[_sPS][_i]), context);
    }
    if (output.destinationPortSet === "") {
        contents[_DPes] = [];
    }
    else if (output[_dPS] != null && output[_dPS][_i] != null) {
        contents[_DPes] = de_PortRangeList(__getArrayIfSingleItem(output[_dPS][_i]), context);
    }
    if (output.protocolSet === "") {
        contents[_Pro] = [];
    }
    else if (output[_pSro] != null && output[_pSro][_i] != null) {
        contents[_Pro] = de_ProtocolIntList(__getArrayIfSingleItem(output[_pSro][_i]), context);
    }
    if (output[_rA] != null) {
        contents[_RAu] = __expectString(output[_rA]);
    }
    if (output[_pri] != null) {
        contents[_Pri] = __strictParseInt32(output[_pri]);
    }
    return contents;
};
const de_FleetCapacityReservation = (output, context) => {
    const contents = {};
    if (output[_cRI] != null) {
        contents[_CRI] = __expectString(output[_cRI]);
    }
    if (output[_aZI] != null) {
        contents[_AZI] = __expectString(output[_aZI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_iPn] != null) {
        contents[_IPn] = __expectString(output[_iPn]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_tIC] != null) {
        contents[_TICo] = __strictParseInt32(output[_tIC]);
    }
    if (output[_fC] != null) {
        contents[_FC] = __strictParseFloat(output[_fC]);
    }
    if (output[_eO] != null) {
        contents[_EO] = __parseBoolean(output[_eO]);
    }
    if (output[_cD] != null) {
        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cD]));
    }
    if (output[_we] != null) {
        contents[_W] = __strictParseFloat(output[_we]);
    }
    if (output[_pri] != null) {
        contents[_Pri] = __strictParseInt32(output[_pri]);
    }
    return contents;
};
const de_FleetCapacityReservationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FleetCapacityReservation(entry, context);
    });
};
const de_FleetData = (output, context) => {
    const contents = {};
    if (output[_aSc] != null) {
        contents[_ASc] = __expectString(output[_aSc]);
    }
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output[_fIl] != null) {
        contents[_FIl] = __expectString(output[_fIl]);
    }
    if (output[_fSl] != null) {
        contents[_FS] = __expectString(output[_fSl]);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    if (output[_eCTP] != null) {
        contents[_ECTP] = __expectString(output[_eCTP]);
    }
    if (output[_fC] != null) {
        contents[_FC] = __strictParseFloat(output[_fC]);
    }
    if (output[_fODC] != null) {
        contents[_FODC] = __strictParseFloat(output[_fODC]);
    }
    if (output.launchTemplateConfigs === "") {
        contents[_LTC] = [];
    }
    else if (output[_lTC] != null && output[_lTC][_i] != null) {
        contents[_LTC] = de_FleetLaunchTemplateConfigList(__getArrayIfSingleItem(output[_lTC][_i]), context);
    }
    if (output[_tCS] != null) {
        contents[_TCS] = de_TargetCapacitySpecification(output[_tCS], context);
    }
    if (output[_tIWE] != null) {
        contents[_TIWE] = __parseBoolean(output[_tIWE]);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_vF] != null) {
        contents[_VF] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vF]));
    }
    if (output[_vU] != null) {
        contents[_VU] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vU]));
    }
    if (output[_rUI] != null) {
        contents[_RUI] = __parseBoolean(output[_rUI]);
    }
    if (output[_sO] != null) {
        contents[_SO] = de_SpotOptions(output[_sO], context);
    }
    if (output[_oDO] != null) {
        contents[_ODO] = de_OnDemandOptions(output[_oDO], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output.errorSet === "") {
        contents[_Err] = [];
    }
    else if (output[_eSr] != null && output[_eSr][_i] != null) {
        contents[_Err] = de_DescribeFleetsErrorSet(__getArrayIfSingleItem(output[_eSr][_i]), context);
    }
    if (output.fleetInstanceSet === "") {
        contents[_In] = [];
    }
    else if (output[_fIS] != null && output[_fIS][_i] != null) {
        contents[_In] = de_DescribeFleetsInstancesSet(__getArrayIfSingleItem(output[_fIS][_i]), context);
    }
    if (output[_cont] != null) {
        contents[_Con] = __expectString(output[_cont]);
    }
    return contents;
};
const de_FleetLaunchTemplateConfig = (output, context) => {
    const contents = {};
    if (output[_lTS] != null) {
        contents[_LTS] = de_FleetLaunchTemplateSpecification(output[_lTS], context);
    }
    if (output.overrides === "") {
        contents[_Ov] = [];
    }
    else if (output[_ov] != null && output[_ov][_i] != null) {
        contents[_Ov] = de_FleetLaunchTemplateOverridesList(__getArrayIfSingleItem(output[_ov][_i]), context);
    }
    return contents;
};
const de_FleetLaunchTemplateConfigList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FleetLaunchTemplateConfig(entry, context);
    });
};
const de_FleetLaunchTemplateOverrides = (output, context) => {
    const contents = {};
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_mP] != null) {
        contents[_MPa] = __expectString(output[_mP]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_wC] != null) {
        contents[_WCe] = __strictParseFloat(output[_wC]);
    }
    if (output[_pri] != null) {
        contents[_Pri] = __strictParseFloat(output[_pri]);
    }
    if (output[_pla] != null) {
        contents[_Pl] = de_PlacementResponse(output[_pla], context);
    }
    if (output[_iR] != null) {
        contents[_IR] = de_InstanceRequirements(output[_iR], context);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output.blockDeviceMappingSet === "") {
        contents[_BDM] = [];
    }
    else if (output[_bDMS] != null && output[_bDMS][_i] != null) {
        contents[_BDM] = de_BlockDeviceMappingResponseList(__getArrayIfSingleItem(output[_bDMS][_i]), context);
    }
    return contents;
};
const de_FleetLaunchTemplateOverridesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FleetLaunchTemplateOverrides(entry, context);
    });
};
const de_FleetLaunchTemplateSpecification = (output, context) => {
    const contents = {};
    if (output[_lTI] != null) {
        contents[_LTI] = __expectString(output[_lTI]);
    }
    if (output[_lTN] != null) {
        contents[_LTN] = __expectString(output[_lTN]);
    }
    if (output[_ve] != null) {
        contents[_V] = __expectString(output[_ve]);
    }
    return contents;
};
const de_FleetSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FleetData(entry, context);
    });
};
const de_FleetSpotCapacityRebalance = (output, context) => {
    const contents = {};
    if (output[_rSep] != null) {
        contents[_RS] = __expectString(output[_rSep]);
    }
    if (output[_tD] != null) {
        contents[_TDe] = __strictParseInt32(output[_tD]);
    }
    return contents;
};
const de_FleetSpotMaintenanceStrategies = (output, context) => {
    const contents = {};
    if (output[_cRa] != null) {
        contents[_CRap] = de_FleetSpotCapacityRebalance(output[_cRa], context);
    }
    return contents;
};
const de_FlowLog = (output, context) => {
    const contents = {};
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output[_dLEM] != null) {
        contents[_DLEM] = __expectString(output[_dLEM]);
    }
    if (output[_dLPA] != null) {
        contents[_DLPA] = __expectString(output[_dLPA]);
    }
    if (output[_dCAR] != null) {
        contents[_DCAR] = __expectString(output[_dCAR]);
    }
    if (output[_dLS] != null) {
        contents[_DLSe] = __expectString(output[_dLS]);
    }
    if (output[_fLI] != null) {
        contents[_FLIl] = __expectString(output[_fLI]);
    }
    if (output[_fLSl] != null) {
        contents[_FLS] = __expectString(output[_fLSl]);
    }
    if (output[_lGN] != null) {
        contents[_LGN] = __expectString(output[_lGN]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_tT] != null) {
        contents[_TT] = __expectString(output[_tT]);
    }
    if (output[_lDT] != null) {
        contents[_LDT] = __expectString(output[_lDT]);
    }
    if (output[_lD] != null) {
        contents[_LD] = __expectString(output[_lD]);
    }
    if (output[_lF] != null) {
        contents[_LF] = __expectString(output[_lF]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_mAI] != null) {
        contents[_MAI] = __strictParseInt32(output[_mAI]);
    }
    if (output[_dOe] != null) {
        contents[_DO] = de_DestinationOptionsResponse(output[_dOe], context);
    }
    return contents;
};
const de_FlowLogSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FlowLog(entry, context);
    });
};
const de_FpgaDeviceInfo = (output, context) => {
    const contents = {};
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_man] != null) {
        contents[_Man] = __expectString(output[_man]);
    }
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    if (output[_mIe] != null) {
        contents[_MIe] = de_FpgaDeviceMemoryInfo(output[_mIe], context);
    }
    return contents;
};
const de_FpgaDeviceInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FpgaDeviceInfo(entry, context);
    });
};
const de_FpgaDeviceMemoryInfo = (output, context) => {
    const contents = {};
    if (output[_sIMB] != null) {
        contents[_SIMB] = __strictParseInt32(output[_sIMB]);
    }
    return contents;
};
const de_FpgaImage = (output, context) => {
    const contents = {};
    if (output[_fII] != null) {
        contents[_FII] = __expectString(output[_fII]);
    }
    if (output[_fIGI] != null) {
        contents[_FIGI] = __expectString(output[_fIGI]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_sVh] != null) {
        contents[_SVh] = __expectString(output[_sVh]);
    }
    if (output[_pIc] != null) {
        contents[_PIc] = de_PciId(output[_pIc], context);
    }
    if (output[_st] != null) {
        contents[_Stat] = de_FpgaImageState(output[_st], context);
    }
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output[_uT] != null) {
        contents[_UTp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uT]));
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_oAw] != null) {
        contents[_OAw] = __expectString(output[_oAw]);
    }
    if (output.productCodes === "") {
        contents[_PCr] = [];
    }
    else if (output[_pC] != null && output[_pC][_i] != null) {
        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);
    }
    if (output.tags === "") {
        contents[_Ta] = [];
    }
    else if (output[_ta] != null && output[_ta][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_ta][_i]), context);
    }
    if (output[_pu] != null) {
        contents[_Pu] = __parseBoolean(output[_pu]);
    }
    if (output[_dRS] != null) {
        contents[_DRSa] = __parseBoolean(output[_dRS]);
    }
    if (output.instanceTypes === "") {
        contents[_ITnst] = [];
    }
    else if (output[_iTn] != null && output[_iTn][_i] != null) {
        contents[_ITnst] = de_InstanceTypesList(__getArrayIfSingleItem(output[_iTn][_i]), context);
    }
    return contents;
};
const de_FpgaImageAttribute = (output, context) => {
    const contents = {};
    if (output[_fII] != null) {
        contents[_FII] = __expectString(output[_fII]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.loadPermissions === "") {
        contents[_LPo] = [];
    }
    else if (output[_lP] != null && output[_lP][_i] != null) {
        contents[_LPo] = de_LoadPermissionList(__getArrayIfSingleItem(output[_lP][_i]), context);
    }
    if (output.productCodes === "") {
        contents[_PCr] = [];
    }
    else if (output[_pC] != null && output[_pC][_i] != null) {
        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);
    }
    return contents;
};
const de_FpgaImageList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FpgaImage(entry, context);
    });
};
const de_FpgaImageState = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_FpgaInfo = (output, context) => {
    const contents = {};
    if (output.fpgas === "") {
        contents[_Fp] = [];
    }
    else if (output[_fp] != null && output[_fp][_i] != null) {
        contents[_Fp] = de_FpgaDeviceInfoList(__getArrayIfSingleItem(output[_fp][_i]), context);
    }
    if (output[_tFMIMB] != null) {
        contents[_TFMIMB] = __strictParseInt32(output[_tFMIMB]);
    }
    return contents;
};
const de_GetAllowedImagesSettingsResult = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.imageCriterionSet === "") {
        contents[_ICm] = [];
    }
    else if (output[_iCS] != null && output[_iCS][_i] != null) {
        contents[_ICm] = de_ImageCriterionList(__getArrayIfSingleItem(output[_iCS][_i]), context);
    }
    if (output[_mB] != null) {
        contents[_MB] = __expectString(output[_mB]);
    }
    return contents;
};
const de_GetAssociatedEnclaveCertificateIamRolesResult = (output, context) => {
    const contents = {};
    if (output.associatedRoleSet === "") {
        contents[_ARss] = [];
    }
    else if (output[_aRS] != null && output[_aRS][_i] != null) {
        contents[_ARss] = de_AssociatedRolesList(__getArrayIfSingleItem(output[_aRS][_i]), context);
    }
    return contents;
};
const de_GetAssociatedIpv6PoolCidrsResult = (output, context) => {
    const contents = {};
    if (output.ipv6CidrAssociationSet === "") {
        contents[_ICA] = [];
    }
    else if (output[_iCAS] != null && output[_iCAS][_i] != null) {
        contents[_ICA] = de_Ipv6CidrAssociationSet(__getArrayIfSingleItem(output[_iCAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetAwsNetworkPerformanceDataResult = (output, context) => {
    const contents = {};
    if (output.dataResponseSet === "") {
        contents[_DRa] = [];
    }
    else if (output[_dRSa] != null && output[_dRSa][_i] != null) {
        contents[_DRa] = de_DataResponses(__getArrayIfSingleItem(output[_dRSa][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetCapacityReservationUsageResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output[_cRI] != null) {
        contents[_CRI] = __expectString(output[_cRI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_tIC] != null) {
        contents[_TICo] = __strictParseInt32(output[_tIC]);
    }
    if (output[_aICv] != null) {
        contents[_AICv] = __strictParseInt32(output[_aICv]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.instanceUsageSet === "") {
        contents[_IU] = [];
    }
    else if (output[_iUS] != null && output[_iUS][_i] != null) {
        contents[_IU] = de_InstanceUsageSet(__getArrayIfSingleItem(output[_iUS][_i]), context);
    }
    return contents;
};
const de_GetCoipPoolUsageResult = (output, context) => {
    const contents = {};
    if (output[_cPI] != null) {
        contents[_CPIo] = __expectString(output[_cPI]);
    }
    if (output.coipAddressUsageSet === "") {
        contents[_CAU] = [];
    }
    else if (output[_cAUS] != null && output[_cAUS][_i] != null) {
        contents[_CAU] = de_CoipAddressUsageSet(__getArrayIfSingleItem(output[_cAUS][_i]), context);
    }
    if (output[_lGRTI] != null) {
        contents[_LGRTI] = __expectString(output[_lGRTI]);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetConsoleOutputResult = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_ti] != null) {
        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));
    }
    if (output[_ou] != null) {
        contents[_Ou] = __expectString(output[_ou]);
    }
    return contents;
};
const de_GetConsoleScreenshotResult = (output, context) => {
    const contents = {};
    if (output[_iD] != null) {
        contents[_IDm] = __expectString(output[_iD]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    return contents;
};
const de_GetDeclarativePoliciesReportSummaryResult = (output, context) => {
    const contents = {};
    if (output[_rI] != null) {
        contents[_RIep] = __expectString(output[_rI]);
    }
    if (output[_sB] != null) {
        contents[_SB] = __expectString(output[_sB]);
    }
    if (output[_sP] != null) {
        contents[_SP] = __expectString(output[_sP]);
    }
    if (output[_tI] != null) {
        contents[_TIa] = __expectString(output[_tI]);
    }
    if (output[_sT] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));
    }
    if (output[_eTn] != null) {
        contents[_ETn] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTn]));
    }
    if (output[_nOA] != null) {
        contents[_NOA] = __strictParseInt32(output[_nOA]);
    }
    if (output[_nOFA] != null) {
        contents[_NOFA] = __strictParseInt32(output[_nOFA]);
    }
    if (output.attributeSummarySet === "") {
        contents[_ASt] = [];
    }
    else if (output[_aSSt] != null && output[_aSSt][_i] != null) {
        contents[_ASt] = de_AttributeSummaryList(__getArrayIfSingleItem(output[_aSSt][_i]), context);
    }
    return contents;
};
const de_GetDefaultCreditSpecificationResult = (output, context) => {
    const contents = {};
    if (output[_iFCS] != null) {
        contents[_IFCS] = de_InstanceFamilyCreditSpecification(output[_iFCS], context);
    }
    return contents;
};
const de_GetEbsDefaultKmsKeyIdResult = (output, context) => {
    const contents = {};
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    return contents;
};
const de_GetEbsEncryptionByDefaultResult = (output, context) => {
    const contents = {};
    if (output[_eEBD] != null) {
        contents[_EEBD] = __parseBoolean(output[_eEBD]);
    }
    if (output[_sTs] != null) {
        contents[_STs] = __expectString(output[_sTs]);
    }
    return contents;
};
const de_GetFlowLogsIntegrationTemplateResult = (output, context) => {
    const contents = {};
    if (output[_res] != null) {
        contents[_Resu] = __expectString(output[_res]);
    }
    return contents;
};
const de_GetGroupsForCapacityReservationResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.capacityReservationGroupSet === "") {
        contents[_CRG] = [];
    }
    else if (output[_cRGS] != null && output[_cRGS][_i] != null) {
        contents[_CRG] = de_CapacityReservationGroupSet(__getArrayIfSingleItem(output[_cRGS][_i]), context);
    }
    return contents;
};
const de_GetHostReservationPurchasePreviewResult = (output, context) => {
    const contents = {};
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output.purchase === "") {
        contents[_Pur] = [];
    }
    else if (output[_pur] != null && output[_pur][_i] != null) {
        contents[_Pur] = de_PurchaseSet(__getArrayIfSingleItem(output[_pur][_i]), context);
    }
    if (output[_tHP] != null) {
        contents[_THP] = __expectString(output[_tHP]);
    }
    if (output[_tUP] != null) {
        contents[_TUP] = __expectString(output[_tUP]);
    }
    return contents;
};
const de_GetImageBlockPublicAccessStateResult = (output, context) => {
    const contents = {};
    if (output[_iBPAS] != null) {
        contents[_IBPAS] = __expectString(output[_iBPAS]);
    }
    if (output[_mB] != null) {
        contents[_MB] = __expectString(output[_mB]);
    }
    return contents;
};
const de_GetInstanceMetadataDefaultsResult = (output, context) => {
    const contents = {};
    if (output[_aL] != null) {
        contents[_ALc] = de_InstanceMetadataDefaultsResponse(output[_aL], context);
    }
    return contents;
};
const de_GetInstanceTpmEkPubResult = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_kT] != null) {
        contents[_KT] = __expectString(output[_kT]);
    }
    if (output[_kF] != null) {
        contents[_KF] = __expectString(output[_kF]);
    }
    if (output[_kV] != null) {
        contents[_KV] = __expectString(output[_kV]);
    }
    return contents;
};
const de_GetInstanceTypesFromInstanceRequirementsResult = (output, context) => {
    const contents = {};
    if (output.instanceTypeSet === "") {
        contents[_ITnst] = [];
    }
    else if (output[_iTS] != null && output[_iTS][_i] != null) {
        contents[_ITnst] = de_InstanceTypeInfoFromInstanceRequirementsSet(__getArrayIfSingleItem(output[_iTS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetInstanceUefiDataResult = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_uD] != null) {
        contents[_UDe] = __expectString(output[_uD]);
    }
    return contents;
};
const de_GetIpamAddressHistoryResult = (output, context) => {
    const contents = {};
    if (output.historyRecordSet === "") {
        contents[_HRi] = [];
    }
    else if (output[_hRS] != null && output[_hRS][_i] != null) {
        contents[_HRi] = de_IpamAddressHistoryRecordSet(__getArrayIfSingleItem(output[_hRS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetIpamDiscoveredAccountsResult = (output, context) => {
    const contents = {};
    if (output.ipamDiscoveredAccountSet === "") {
        contents[_IDA] = [];
    }
    else if (output[_iDAS] != null && output[_iDAS][_i] != null) {
        contents[_IDA] = de_IpamDiscoveredAccountSet(__getArrayIfSingleItem(output[_iDAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetIpamDiscoveredPublicAddressesResult = (output, context) => {
    const contents = {};
    if (output.ipamDiscoveredPublicAddressSet === "") {
        contents[_IDPA] = [];
    }
    else if (output[_iDPAS] != null && output[_iDPAS][_i] != null) {
        contents[_IDPA] = de_IpamDiscoveredPublicAddressSet(__getArrayIfSingleItem(output[_iDPAS][_i]), context);
    }
    if (output[_oST] != null) {
        contents[_OST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_oST]));
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetIpamDiscoveredResourceCidrsResult = (output, context) => {
    const contents = {};
    if (output.ipamDiscoveredResourceCidrSet === "") {
        contents[_IDRC] = [];
    }
    else if (output[_iDRCS] != null && output[_iDRCS][_i] != null) {
        contents[_IDRC] = de_IpamDiscoveredResourceCidrSet(__getArrayIfSingleItem(output[_iDRCS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetIpamPoolAllocationsResult = (output, context) => {
    const contents = {};
    if (output.ipamPoolAllocationSet === "") {
        contents[_IPAp] = [];
    }
    else if (output[_iPAS] != null && output[_iPAS][_i] != null) {
        contents[_IPAp] = de_IpamPoolAllocationSet(__getArrayIfSingleItem(output[_iPAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetIpamPoolCidrsResult = (output, context) => {
    const contents = {};
    if (output.ipamPoolCidrSet === "") {
        contents[_IPCpam] = [];
    }
    else if (output[_iPCS] != null && output[_iPCS][_i] != null) {
        contents[_IPCpam] = de_IpamPoolCidrSet(__getArrayIfSingleItem(output[_iPCS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetIpamResourceCidrsResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.ipamResourceCidrSet === "") {
        contents[_IRC] = [];
    }
    else if (output[_iRCS] != null && output[_iRCS][_i] != null) {
        contents[_IRC] = de_IpamResourceCidrSet(__getArrayIfSingleItem(output[_iRCS][_i]), context);
    }
    return contents;
};
const de_GetLaunchTemplateDataResult = (output, context) => {
    const contents = {};
    if (output[_lTD] != null) {
        contents[_LTD] = de_ResponseLaunchTemplateData(output[_lTD], context);
    }
    return contents;
};
const de_GetManagedPrefixListAssociationsResult = (output, context) => {
    const contents = {};
    if (output.prefixListAssociationSet === "") {
        contents[_PLA] = [];
    }
    else if (output[_pLAS] != null && output[_pLAS][_i] != null) {
        contents[_PLA] = de_PrefixListAssociationSet(__getArrayIfSingleItem(output[_pLAS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetManagedPrefixListEntriesResult = (output, context) => {
    const contents = {};
    if (output.entrySet === "") {
        contents[_Ent] = [];
    }
    else if (output[_eSnt] != null && output[_eSnt][_i] != null) {
        contents[_Ent] = de_PrefixListEntrySet(__getArrayIfSingleItem(output[_eSnt][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetNetworkInsightsAccessScopeAnalysisFindingsResult = (output, context) => {
    const contents = {};
    if (output[_nIASAI] != null) {
        contents[_NIASAI] = __expectString(output[_nIASAI]);
    }
    if (output[_aSn] != null) {
        contents[_ASn] = __expectString(output[_aSn]);
    }
    if (output.analysisFindingSet === "") {
        contents[_AFn] = [];
    }
    else if (output[_aFS] != null && output[_aFS][_i] != null) {
        contents[_AFn] = de_AccessScopeAnalysisFindingList(__getArrayIfSingleItem(output[_aFS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetNetworkInsightsAccessScopeContentResult = (output, context) => {
    const contents = {};
    if (output[_nIASC] != null) {
        contents[_NIASC] = de_NetworkInsightsAccessScopeContent(output[_nIASC], context);
    }
    return contents;
};
const de_GetPasswordDataResult = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_ti] != null) {
        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));
    }
    if (output[_pD] != null) {
        contents[_PDa] = __expectString(output[_pD]);
    }
    return contents;
};
const de_GetReservedInstancesExchangeQuoteResult = (output, context) => {
    const contents = {};
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output[_iVE] != null) {
        contents[_IVE] = __parseBoolean(output[_iVE]);
    }
    if (output[_oRIWEA] != null) {
        contents[_ORIWEA] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_oRIWEA]));
    }
    if (output[_pDa] != null) {
        contents[_PDay] = __expectString(output[_pDa]);
    }
    if (output[_rIVR] != null) {
        contents[_RIVR] = de_ReservationValue(output[_rIVR], context);
    }
    if (output.reservedInstanceValueSet === "") {
        contents[_RIVS] = [];
    }
    else if (output[_rIVS] != null && output[_rIVS][_i] != null) {
        contents[_RIVS] = de_ReservedInstanceReservationValueSet(__getArrayIfSingleItem(output[_rIVS][_i]), context);
    }
    if (output[_tCVR] != null) {
        contents[_TCVR] = de_ReservationValue(output[_tCVR], context);
    }
    if (output.targetConfigurationValueSet === "") {
        contents[_TCVS] = [];
    }
    else if (output[_tCVS] != null && output[_tCVS][_i] != null) {
        contents[_TCVS] = de_TargetReservationValueSet(__getArrayIfSingleItem(output[_tCVS][_i]), context);
    }
    if (output[_vFR] != null) {
        contents[_VFR] = __expectString(output[_vFR]);
    }
    return contents;
};
const de_GetRouteServerAssociationsResult = (output, context) => {
    const contents = {};
    if (output.routeServerAssociationSet === "") {
        contents[_RSAou] = [];
    }
    else if (output[_rSAS] != null && output[_rSAS][_i] != null) {
        contents[_RSAou] = de_RouteServerAssociationsList(__getArrayIfSingleItem(output[_rSAS][_i]), context);
    }
    return contents;
};
const de_GetRouteServerPropagationsResult = (output, context) => {
    const contents = {};
    if (output.routeServerPropagationSet === "") {
        contents[_RSPout] = [];
    }
    else if (output[_rSPSo] != null && output[_rSPSo][_i] != null) {
        contents[_RSPout] = de_RouteServerPropagationsList(__getArrayIfSingleItem(output[_rSPSo][_i]), context);
    }
    return contents;
};
const de_GetRouteServerRoutingDatabaseResult = (output, context) => {
    const contents = {};
    if (output[_aRP] != null) {
        contents[_ARP] = __parseBoolean(output[_aRP]);
    }
    if (output.routeSet === "") {
        contents[_Rout] = [];
    }
    else if (output[_rSou] != null && output[_rSou][_i] != null) {
        contents[_Rout] = de_RouteServerRouteList(__getArrayIfSingleItem(output[_rSou][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetSecurityGroupsForVpcResult = (output, context) => {
    const contents = {};
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    if (output.securityGroupForVpcSet === "") {
        contents[_SGFV] = [];
    }
    else if (output[_sGFVS] != null && output[_sGFVS][_i] != null) {
        contents[_SGFV] = de_SecurityGroupForVpcList(__getArrayIfSingleItem(output[_sGFVS][_i]), context);
    }
    return contents;
};
const de_GetSerialConsoleAccessStatusResult = (output, context) => {
    const contents = {};
    if (output[_sCAE] != null) {
        contents[_SCAE] = __parseBoolean(output[_sCAE]);
    }
    if (output[_mB] != null) {
        contents[_MB] = __expectString(output[_mB]);
    }
    return contents;
};
const de_GetSnapshotBlockPublicAccessStateResult = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_mB] != null) {
        contents[_MB] = __expectString(output[_mB]);
    }
    return contents;
};
const de_GetSpotPlacementScoresResult = (output, context) => {
    const contents = {};
    if (output.spotPlacementScoreSet === "") {
        contents[_SPS] = [];
    }
    else if (output[_sPSS] != null && output[_sPSS][_i] != null) {
        contents[_SPS] = de_SpotPlacementScores(__getArrayIfSingleItem(output[_sPSS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetSubnetCidrReservationsResult = (output, context) => {
    const contents = {};
    if (output.subnetIpv4CidrReservationSet === "") {
        contents[_SICR] = [];
    }
    else if (output[_sICRS] != null && output[_sICRS][_i] != null) {
        contents[_SICR] = de_SubnetCidrReservationList(__getArrayIfSingleItem(output[_sICRS][_i]), context);
    }
    if (output.subnetIpv6CidrReservationSet === "") {
        contents[_SICRu] = [];
    }
    else if (output[_sICRSu] != null && output[_sICRSu][_i] != null) {
        contents[_SICRu] = de_SubnetCidrReservationList(__getArrayIfSingleItem(output[_sICRSu][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetTransitGatewayAttachmentPropagationsResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayAttachmentPropagations === "") {
        contents[_TGAP] = [];
    }
    else if (output[_tGAP] != null && output[_tGAP][_i] != null) {
        contents[_TGAP] = de_TransitGatewayAttachmentPropagationList(__getArrayIfSingleItem(output[_tGAP][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetTransitGatewayMulticastDomainAssociationsResult = (output, context) => {
    const contents = {};
    if (output.multicastDomainAssociations === "") {
        contents[_MDA] = [];
    }
    else if (output[_mDA] != null && output[_mDA][_i] != null) {
        contents[_MDA] = de_TransitGatewayMulticastDomainAssociationList(__getArrayIfSingleItem(output[_mDA][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetTransitGatewayPolicyTableAssociationsResult = (output, context) => {
    const contents = {};
    if (output.associations === "") {
        contents[_Ass] = [];
    }
    else if (output[_a] != null && output[_a][_i] != null) {
        contents[_Ass] = de_TransitGatewayPolicyTableAssociationList(__getArrayIfSingleItem(output[_a][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetTransitGatewayPolicyTableEntriesResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayPolicyTableEntries === "") {
        contents[_TGPTE] = [];
    }
    else if (output[_tGPTE] != null && output[_tGPTE][_i] != null) {
        contents[_TGPTE] = de_TransitGatewayPolicyTableEntryList(__getArrayIfSingleItem(output[_tGPTE][_i]), context);
    }
    return contents;
};
const de_GetTransitGatewayPrefixListReferencesResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayPrefixListReferenceSet === "") {
        contents[_TGPLRr] = [];
    }
    else if (output[_tGPLRS] != null && output[_tGPLRS][_i] != null) {
        contents[_TGPLRr] = de_TransitGatewayPrefixListReferenceSet(__getArrayIfSingleItem(output[_tGPLRS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetTransitGatewayRouteTableAssociationsResult = (output, context) => {
    const contents = {};
    if (output.associations === "") {
        contents[_Ass] = [];
    }
    else if (output[_a] != null && output[_a][_i] != null) {
        contents[_Ass] = de_TransitGatewayRouteTableAssociationList(__getArrayIfSingleItem(output[_a][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetTransitGatewayRouteTablePropagationsResult = (output, context) => {
    const contents = {};
    if (output.transitGatewayRouteTablePropagations === "") {
        contents[_TGRTP] = [];
    }
    else if (output[_tGRTP] != null && output[_tGRTP][_i] != null) {
        contents[_TGRTP] = de_TransitGatewayRouteTablePropagationList(__getArrayIfSingleItem(output[_tGRTP][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetVerifiedAccessEndpointPolicyResult = (output, context) => {
    const contents = {};
    if (output[_pE] != null) {
        contents[_PE] = __parseBoolean(output[_pE]);
    }
    if (output[_pDo] != null) {
        contents[_PD] = __expectString(output[_pDo]);
    }
    return contents;
};
const de_GetVerifiedAccessEndpointTargetsResult = (output, context) => {
    const contents = {};
    if (output.verifiedAccessEndpointTargetSet === "") {
        contents[_VAET] = [];
    }
    else if (output[_vAETS] != null && output[_vAETS][_i] != null) {
        contents[_VAET] = de_VerifiedAccessEndpointTargetList(__getArrayIfSingleItem(output[_vAETS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetVerifiedAccessGroupPolicyResult = (output, context) => {
    const contents = {};
    if (output[_pE] != null) {
        contents[_PE] = __parseBoolean(output[_pE]);
    }
    if (output[_pDo] != null) {
        contents[_PD] = __expectString(output[_pDo]);
    }
    return contents;
};
const de_GetVpnConnectionDeviceSampleConfigurationResult = (output, context) => {
    const contents = {};
    if (output[_vCDSC] != null) {
        contents[_VCDSC] = __expectString(output[_vCDSC]);
    }
    return contents;
};
const de_GetVpnConnectionDeviceTypesResult = (output, context) => {
    const contents = {};
    if (output.vpnConnectionDeviceTypeSet === "") {
        contents[_VCDT] = [];
    }
    else if (output[_vCDTS] != null && output[_vCDTS][_i] != null) {
        contents[_VCDT] = de_VpnConnectionDeviceTypeList(__getArrayIfSingleItem(output[_vCDTS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_GetVpnTunnelReplacementStatusResult = (output, context) => {
    const contents = {};
    if (output[_vCI] != null) {
        contents[_VCI] = __expectString(output[_vCI]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_cGIu] != null) {
        contents[_CGIu] = __expectString(output[_cGIu]);
    }
    if (output[_vGI] != null) {
        contents[_VGI] = __expectString(output[_vGI]);
    }
    if (output[_vTOIA] != null) {
        contents[_VTOIA] = __expectString(output[_vTOIA]);
    }
    if (output[_mD] != null) {
        contents[_MDa] = de_MaintenanceDetails(output[_mD], context);
    }
    return contents;
};
const de_GpuDeviceInfo = (output, context) => {
    const contents = {};
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_man] != null) {
        contents[_Man] = __expectString(output[_man]);
    }
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    if (output[_mIe] != null) {
        contents[_MIe] = de_GpuDeviceMemoryInfo(output[_mIe], context);
    }
    return contents;
};
const de_GpuDeviceInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GpuDeviceInfo(entry, context);
    });
};
const de_GpuDeviceMemoryInfo = (output, context) => {
    const contents = {};
    if (output[_sIMB] != null) {
        contents[_SIMB] = __strictParseInt32(output[_sIMB]);
    }
    return contents;
};
const de_GpuInfo = (output, context) => {
    const contents = {};
    if (output.gpus === "") {
        contents[_Gp] = [];
    }
    else if (output[_gp] != null && output[_gp][_i] != null) {
        contents[_Gp] = de_GpuDeviceInfoList(__getArrayIfSingleItem(output[_gp][_i]), context);
    }
    if (output[_tGMIMB] != null) {
        contents[_TGMIMB] = __strictParseInt32(output[_tGMIMB]);
    }
    return contents;
};
const de_GroupIdentifier = (output, context) => {
    const contents = {};
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    return contents;
};
const de_GroupIdentifierList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GroupIdentifier(entry, context);
    });
};
const de_GroupIdentifierSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SecurityGroupIdentifier(entry, context);
    });
};
const de_GroupIdStringList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_HibernationOptions = (output, context) => {
    const contents = {};
    if (output[_conf] != null) {
        contents[_Conf] = __parseBoolean(output[_conf]);
    }
    return contents;
};
const de_HistoryRecord = (output, context) => {
    const contents = {};
    if (output[_eIv] != null) {
        contents[_EIv] = de_EventInformation(output[_eIv], context);
    }
    if (output[_eTv] != null) {
        contents[_ETv] = __expectString(output[_eTv]);
    }
    if (output[_ti] != null) {
        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));
    }
    return contents;
};
const de_HistoryRecordEntry = (output, context) => {
    const contents = {};
    if (output[_eIv] != null) {
        contents[_EIv] = de_EventInformation(output[_eIv], context);
    }
    if (output[_eTv] != null) {
        contents[_ETv] = __expectString(output[_eTv]);
    }
    if (output[_ti] != null) {
        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));
    }
    return contents;
};
const de_HistoryRecords = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HistoryRecord(entry, context);
    });
};
const de_HistoryRecordSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HistoryRecordEntry(entry, context);
    });
};
const de_Host = (output, context) => {
    const contents = {};
    if (output[_aPu] != null) {
        contents[_AP] = __expectString(output[_aPu]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_aC] != null) {
        contents[_ACv] = de_AvailableCapacity(output[_aC], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    if (output[_hI] != null) {
        contents[_HIo] = __expectString(output[_hI]);
    }
    if (output[_hP] != null) {
        contents[_HP] = de_HostProperties(output[_hP], context);
    }
    if (output[_hRI] != null) {
        contents[_HRI] = __expectString(output[_hRI]);
    }
    if (output.instances === "") {
        contents[_In] = [];
    }
    else if (output[_ins] != null && output[_ins][_i] != null) {
        contents[_In] = de_HostInstanceList(__getArrayIfSingleItem(output[_ins][_i]), context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_aTll] != null) {
        contents[_ATll] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aTll]));
    }
    if (output[_rTel] != null) {
        contents[_RTel] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rTel]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_hR] != null) {
        contents[_HR] = __expectString(output[_hR]);
    }
    if (output[_aMIT] != null) {
        contents[_AMIT] = __expectString(output[_aMIT]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_aZI] != null) {
        contents[_AZI] = __expectString(output[_aZI]);
    }
    if (output[_mOSLRG] != null) {
        contents[_MOSLRG] = __parseBoolean(output[_mOSLRG]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_hM] != null) {
        contents[_HM] = __expectString(output[_hM]);
    }
    if (output[_aIss] != null) {
        contents[_AIsse] = __expectString(output[_aIss]);
    }
    return contents;
};
const de_HostInstance = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    return contents;
};
const de_HostInstanceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HostInstance(entry, context);
    });
};
const de_HostList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Host(entry, context);
    });
};
const de_HostOffering = (output, context) => {
    const contents = {};
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output[_du] != null) {
        contents[_Du] = __strictParseInt32(output[_du]);
    }
    if (output[_hPo] != null) {
        contents[_HPo] = __expectString(output[_hPo]);
    }
    if (output[_iF] != null) {
        contents[_IF] = __expectString(output[_iF]);
    }
    if (output[_oIf] != null) {
        contents[_OI] = __expectString(output[_oIf]);
    }
    if (output[_pO] != null) {
        contents[_PO] = __expectString(output[_pO]);
    }
    if (output[_uP] != null) {
        contents[_UPp] = __expectString(output[_uP]);
    }
    return contents;
};
const de_HostOfferingSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HostOffering(entry, context);
    });
};
const de_HostProperties = (output, context) => {
    const contents = {};
    if (output[_cor] != null) {
        contents[_Cor] = __strictParseInt32(output[_cor]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_iF] != null) {
        contents[_IF] = __expectString(output[_iF]);
    }
    if (output[_so] != null) {
        contents[_Soc] = __strictParseInt32(output[_so]);
    }
    if (output[_tVC] != null) {
        contents[_TVC] = __strictParseInt32(output[_tVC]);
    }
    return contents;
};
const de_HostReservation = (output, context) => {
    const contents = {};
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output[_du] != null) {
        contents[_Du] = __strictParseInt32(output[_du]);
    }
    if (output[_end] != null) {
        contents[_End] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_end]));
    }
    if (output.hostIdSet === "") {
        contents[_HIS] = [];
    }
    else if (output[_hIS] != null && output[_hIS][_i] != null) {
        contents[_HIS] = de_ResponseHostIdSet(__getArrayIfSingleItem(output[_hIS][_i]), context);
    }
    if (output[_hRI] != null) {
        contents[_HRI] = __expectString(output[_hRI]);
    }
    if (output[_hPo] != null) {
        contents[_HPo] = __expectString(output[_hPo]);
    }
    if (output[_iF] != null) {
        contents[_IF] = __expectString(output[_iF]);
    }
    if (output[_oIf] != null) {
        contents[_OI] = __expectString(output[_oIf]);
    }
    if (output[_pO] != null) {
        contents[_PO] = __expectString(output[_pO]);
    }
    if (output[_star] != null) {
        contents[_Star] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_star]));
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_uP] != null) {
        contents[_UPp] = __expectString(output[_uP]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_HostReservationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HostReservation(entry, context);
    });
};
const de_IamInstanceProfile = (output, context) => {
    const contents = {};
    if (output[_ar] != null) {
        contents[_Ar] = __expectString(output[_ar]);
    }
    if (output[_id] != null) {
        contents[_Id] = __expectString(output[_id]);
    }
    return contents;
};
const de_IamInstanceProfileAssociation = (output, context) => {
    const contents = {};
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iIP] != null) {
        contents[_IIP] = de_IamInstanceProfile(output[_iIP], context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_ti] != null) {
        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));
    }
    return contents;
};
const de_IamInstanceProfileAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IamInstanceProfileAssociation(entry, context);
    });
};
const de_IamInstanceProfileSpecification = (output, context) => {
    const contents = {};
    if (output[_ar] != null) {
        contents[_Ar] = __expectString(output[_ar]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    return contents;
};
const de_IcmpTypeCode = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __strictParseInt32(output[_co]);
    }
    if (output[_ty] != null) {
        contents[_T] = __strictParseInt32(output[_ty]);
    }
    return contents;
};
const de_IdFormat = (output, context) => {
    const contents = {};
    if (output[_dea] != null) {
        contents[_Dea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dea]));
    }
    if (output[_reso] != null) {
        contents[_Res] = __expectString(output[_reso]);
    }
    if (output[_uLI] != null) {
        contents[_ULI] = __parseBoolean(output[_uLI]);
    }
    return contents;
};
const de_IdFormatList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IdFormat(entry, context);
    });
};
const de_IKEVersionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IKEVersionsListValue(entry, context);
    });
};
const de_IKEVersionsListValue = (output, context) => {
    const contents = {};
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    return contents;
};
const de_Image = (output, context) => {
    const contents = {};
    if (output[_pDl] != null) {
        contents[_PDl] = __expectString(output[_pDl]);
    }
    if (output[_uO] != null) {
        contents[_UO] = __expectString(output[_uO]);
    }
    if (output.blockDeviceMapping === "") {
        contents[_BDM] = [];
    }
    else if (output[_bDM] != null && output[_bDM][_i] != null) {
        contents[_BDM] = de_BlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_eSna] != null) {
        contents[_ESn] = __parseBoolean(output[_eSna]);
    }
    if (output[_h] != null) {
        contents[_H] = __expectString(output[_h]);
    }
    if (output[_iOA] != null) {
        contents[_IOA] = __expectString(output[_iOA]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_rDN] != null) {
        contents[_RDN] = __expectString(output[_rDN]);
    }
    if (output[_rDT] != null) {
        contents[_RDT] = __expectString(output[_rDT]);
    }
    if (output[_sNSr] != null) {
        contents[_SNS] = __expectString(output[_sNSr]);
    }
    if (output[_sRt] != null) {
        contents[_SRt] = de_StateReason(output[_sRt], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vTi] != null) {
        contents[_VTir] = __expectString(output[_vTi]);
    }
    if (output[_bM] != null) {
        contents[_BM] = __expectString(output[_bM]);
    }
    if (output[_tSp] != null) {
        contents[_TSp] = __expectString(output[_tSp]);
    }
    if (output[_dTe] != null) {
        contents[_DTep] = __expectString(output[_dTe]);
    }
    if (output[_iSmd] != null) {
        contents[_ISm] = __expectString(output[_iSmd]);
    }
    if (output[_sII] != null) {
        contents[_SIIo] = __expectString(output[_sII]);
    }
    if (output[_dPe] != null) {
        contents[_DPer] = __expectString(output[_dPe]);
    }
    if (output[_lLT] != null) {
        contents[_LLT] = __expectString(output[_lLT]);
    }
    if (output[_iAm] != null) {
        contents[_IAm] = __parseBoolean(output[_iAm]);
    }
    if (output[_sIIo] != null) {
        contents[_SII] = __expectString(output[_sIIo]);
    }
    if (output[_sIR] != null) {
        contents[_SIRo] = __expectString(output[_sIR]);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_iL] != null) {
        contents[_IL] = __expectString(output[_iL]);
    }
    if (output[_iSma] != null) {
        contents[_Stat] = __expectString(output[_iSma]);
    }
    if (output[_iOI] != null) {
        contents[_OIwn] = __expectString(output[_iOI]);
    }
    if (output[_cDr] != null) {
        contents[_CDre] = __expectString(output[_cDr]);
    }
    if (output[_iPs] != null) {
        contents[_Pu] = __parseBoolean(output[_iPs]);
    }
    if (output.productCodes === "") {
        contents[_PCr] = [];
    }
    else if (output[_pC] != null && output[_pC][_i] != null) {
        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);
    }
    if (output[_arc] != null) {
        contents[_Arc] = __expectString(output[_arc]);
    }
    if (output[_iTm] != null) {
        contents[_ITm] = __expectString(output[_iTm]);
    }
    if (output[_kI] != null) {
        contents[_KI] = __expectString(output[_kI]);
    }
    if (output[_rIa] != null) {
        contents[_RIa] = __expectString(output[_rIa]);
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    return contents;
};
const de_ImageAttribute = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = de_AttributeValue(output[_de], context);
    }
    if (output[_ke] != null) {
        contents[_KI] = de_AttributeValue(output[_ke], context);
    }
    if (output[_ra] != null) {
        contents[_RIa] = de_AttributeValue(output[_ra], context);
    }
    if (output[_sNSr] != null) {
        contents[_SNS] = de_AttributeValue(output[_sNSr], context);
    }
    if (output[_bM] != null) {
        contents[_BM] = de_AttributeValue(output[_bM], context);
    }
    if (output[_tSp] != null) {
        contents[_TSp] = de_AttributeValue(output[_tSp], context);
    }
    if (output[_uD] != null) {
        contents[_UDe] = de_AttributeValue(output[_uD], context);
    }
    if (output[_lLT] != null) {
        contents[_LLT] = de_AttributeValue(output[_lLT], context);
    }
    if (output[_iSmd] != null) {
        contents[_ISm] = de_AttributeValue(output[_iSmd], context);
    }
    if (output[_dPe] != null) {
        contents[_DPer] = de_AttributeValue(output[_dPe], context);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output.launchPermission === "") {
        contents[_LPau] = [];
    }
    else if (output[_lPa] != null && output[_lPa][_i] != null) {
        contents[_LPau] = de_LaunchPermissionList(__getArrayIfSingleItem(output[_lPa][_i]), context);
    }
    if (output.productCodes === "") {
        contents[_PCr] = [];
    }
    else if (output[_pC] != null && output[_pC][_i] != null) {
        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);
    }
    if (output.blockDeviceMapping === "") {
        contents[_BDM] = [];
    }
    else if (output[_bDM] != null && output[_bDM][_i] != null) {
        contents[_BDM] = de_BlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);
    }
    return contents;
};
const de_ImageCriterion = (output, context) => {
    const contents = {};
    if (output.imageProviderSet === "") {
        contents[_IPm] = [];
    }
    else if (output[_iPSm] != null && output[_iPSm][_i] != null) {
        contents[_IPm] = de_ImageProviderList(__getArrayIfSingleItem(output[_iPSm][_i]), context);
    }
    return contents;
};
const de_ImageCriterionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImageCriterion(entry, context);
    });
};
const de_ImageList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Image(entry, context);
    });
};
const de_ImageMetadata = (output, context) => {
    const contents = {};
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_iOI] != null) {
        contents[_OIwn] = __expectString(output[_iOI]);
    }
    if (output[_iSma] != null) {
        contents[_Stat] = __expectString(output[_iSma]);
    }
    if (output[_iOA] != null) {
        contents[_IOA] = __expectString(output[_iOA]);
    }
    if (output[_cDr] != null) {
        contents[_CDre] = __expectString(output[_cDr]);
    }
    if (output[_dTe] != null) {
        contents[_DTep] = __expectString(output[_dTe]);
    }
    if (output[_iAm] != null) {
        contents[_IAm] = __parseBoolean(output[_iAm]);
    }
    if (output[_iPs] != null) {
        contents[_IPs] = __parseBoolean(output[_iPs]);
    }
    return contents;
};
const de_ImageProviderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ImageRecycleBinInfo = (output, context) => {
    const contents = {};
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_rBET] != null) {
        contents[_RBET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rBET]));
    }
    if (output[_rBETe] != null) {
        contents[_RBETe] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rBETe]));
    }
    return contents;
};
const de_ImageRecycleBinInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImageRecycleBinInfo(entry, context);
    });
};
const de_ImportClientVpnClientCertificateRevocationListResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ImportImageLicenseConfigurationResponse = (output, context) => {
    const contents = {};
    if (output[_lCA] != null) {
        contents[_LCA] = __expectString(output[_lCA]);
    }
    return contents;
};
const de_ImportImageLicenseSpecificationListResponse = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImportImageLicenseConfigurationResponse(entry, context);
    });
};
const de_ImportImageResult = (output, context) => {
    const contents = {};
    if (output[_arc] != null) {
        contents[_Arc] = __expectString(output[_arc]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_enc] != null) {
        contents[_Enc] = __parseBoolean(output[_enc]);
    }
    if (output[_h] != null) {
        contents[_H] = __expectString(output[_h]);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_iTI] != null) {
        contents[_ITI] = __expectString(output[_iTI]);
    }
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    if (output[_lTi] != null) {
        contents[_LTi] = __expectString(output[_lTi]);
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    if (output[_pro] != null) {
        contents[_Prog] = __expectString(output[_pro]);
    }
    if (output.snapshotDetailSet === "") {
        contents[_SDn] = [];
    }
    else if (output[_sDSn] != null && output[_sDSn][_i] != null) {
        contents[_SDn] = de_SnapshotDetailList(__getArrayIfSingleItem(output[_sDSn][_i]), context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output.licenseSpecifications === "") {
        contents[_LSi] = [];
    }
    else if (output[_lS] != null && output[_lS][_i] != null) {
        contents[_LSi] = de_ImportImageLicenseSpecificationListResponse(__getArrayIfSingleItem(output[_lS][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_uO] != null) {
        contents[_UO] = __expectString(output[_uO]);
    }
    return contents;
};
const de_ImportImageTask = (output, context) => {
    const contents = {};
    if (output[_arc] != null) {
        contents[_Arc] = __expectString(output[_arc]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_enc] != null) {
        contents[_Enc] = __parseBoolean(output[_enc]);
    }
    if (output[_h] != null) {
        contents[_H] = __expectString(output[_h]);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_iTI] != null) {
        contents[_ITI] = __expectString(output[_iTI]);
    }
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    if (output[_lTi] != null) {
        contents[_LTi] = __expectString(output[_lTi]);
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    if (output[_pro] != null) {
        contents[_Prog] = __expectString(output[_pro]);
    }
    if (output.snapshotDetailSet === "") {
        contents[_SDn] = [];
    }
    else if (output[_sDSn] != null && output[_sDSn][_i] != null) {
        contents[_SDn] = de_SnapshotDetailList(__getArrayIfSingleItem(output[_sDSn][_i]), context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output.licenseSpecifications === "") {
        contents[_LSi] = [];
    }
    else if (output[_lS] != null && output[_lS][_i] != null) {
        contents[_LSi] = de_ImportImageLicenseSpecificationListResponse(__getArrayIfSingleItem(output[_lS][_i]), context);
    }
    if (output[_uO] != null) {
        contents[_UO] = __expectString(output[_uO]);
    }
    if (output[_bM] != null) {
        contents[_BM] = __expectString(output[_bM]);
    }
    return contents;
};
const de_ImportImageTaskList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImportImageTask(entry, context);
    });
};
const de_ImportInstanceResult = (output, context) => {
    const contents = {};
    if (output[_cTon] != null) {
        contents[_CTonv] = de_ConversionTask(output[_cTon], context);
    }
    return contents;
};
const de_ImportInstanceTaskDetails = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    if (output.volumes === "") {
        contents[_Vol] = [];
    }
    else if (output[_vo] != null && output[_vo][_i] != null) {
        contents[_Vol] = de_ImportInstanceVolumeDetailSet(__getArrayIfSingleItem(output[_vo][_i]), context);
    }
    return contents;
};
const de_ImportInstanceVolumeDetailItem = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_bCy] != null) {
        contents[_BCyt] = __strictParseLong(output[_bCy]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_im] != null) {
        contents[_Im] = de_DiskImageDescription(output[_im], context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_vol] != null) {
        contents[_Vo] = de_DiskImageVolumeDescription(output[_vol], context);
    }
    return contents;
};
const de_ImportInstanceVolumeDetailSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImportInstanceVolumeDetailItem(entry, context);
    });
};
const de_ImportKeyPairResult = (output, context) => {
    const contents = {};
    if (output[_kFe] != null) {
        contents[_KFe] = __expectString(output[_kFe]);
    }
    if (output[_kN] != null) {
        contents[_KN] = __expectString(output[_kN]);
    }
    if (output[_kPI] != null) {
        contents[_KPI] = __expectString(output[_kPI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_ImportSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_iTI] != null) {
        contents[_ITI] = __expectString(output[_iTI]);
    }
    if (output[_sTD] != null) {
        contents[_STD] = de_SnapshotTaskDetail(output[_sTD], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_ImportSnapshotTask = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_iTI] != null) {
        contents[_ITI] = __expectString(output[_iTI]);
    }
    if (output[_sTD] != null) {
        contents[_STD] = de_SnapshotTaskDetail(output[_sTD], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_ImportSnapshotTaskList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImportSnapshotTask(entry, context);
    });
};
const de_ImportVolumeResult = (output, context) => {
    const contents = {};
    if (output[_cTon] != null) {
        contents[_CTonv] = de_ConversionTask(output[_cTon], context);
    }
    return contents;
};
const de_ImportVolumeTaskDetails = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_bCy] != null) {
        contents[_BCyt] = __strictParseLong(output[_bCy]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_im] != null) {
        contents[_Im] = de_DiskImageDescription(output[_im], context);
    }
    if (output[_vol] != null) {
        contents[_Vo] = de_DiskImageVolumeDescription(output[_vol], context);
    }
    return contents;
};
const de_InferenceAcceleratorInfo = (output, context) => {
    const contents = {};
    if (output.accelerators === "") {
        contents[_Acc] = [];
    }
    else if (output[_acc] != null && output[_acc][_mem] != null) {
        contents[_Acc] = de_InferenceDeviceInfoList(__getArrayIfSingleItem(output[_acc][_mem]), context);
    }
    if (output[_tIMIMB] != null) {
        contents[_TIMIMB] = __strictParseInt32(output[_tIMIMB]);
    }
    return contents;
};
const de_InferenceDeviceInfo = (output, context) => {
    const contents = {};
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_man] != null) {
        contents[_Man] = __expectString(output[_man]);
    }
    if (output[_mIe] != null) {
        contents[_MIe] = de_InferenceDeviceMemoryInfo(output[_mIe], context);
    }
    return contents;
};
const de_InferenceDeviceInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InferenceDeviceInfo(entry, context);
    });
};
const de_InferenceDeviceMemoryInfo = (output, context) => {
    const contents = {};
    if (output[_sIMB] != null) {
        contents[_SIMB] = __strictParseInt32(output[_sIMB]);
    }
    return contents;
};
const de_InsideCidrBlocksStringList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Instance = (output, context) => {
    const contents = {};
    if (output[_arc] != null) {
        contents[_Arc] = __expectString(output[_arc]);
    }
    if (output.blockDeviceMapping === "") {
        contents[_BDM] = [];
    }
    else if (output[_bDM] != null && output[_bDM][_i] != null) {
        contents[_BDM] = de_InstanceBlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    if (output[_eO] != null) {
        contents[_EO] = __parseBoolean(output[_eO]);
    }
    if (output[_eSna] != null) {
        contents[_ESn] = __parseBoolean(output[_eSna]);
    }
    if (output[_h] != null) {
        contents[_H] = __expectString(output[_h]);
    }
    if (output[_iIP] != null) {
        contents[_IIP] = de_IamInstanceProfile(output[_iIP], context);
    }
    if (output[_iLn] != null) {
        contents[_ILn] = __expectString(output[_iLn]);
    }
    if (output.elasticGpuAssociationSet === "") {
        contents[_EGA] = [];
    }
    else if (output[_eGASl] != null && output[_eGASl][_i] != null) {
        contents[_EGA] = de_ElasticGpuAssociationList(__getArrayIfSingleItem(output[_eGASl][_i]), context);
    }
    if (output.elasticInferenceAcceleratorAssociationSet === "") {
        contents[_EIAAl] = [];
    }
    else if (output[_eIAASl] != null && output[_eIAASl][_i] != null) {
        contents[_EIAAl] = de_ElasticInferenceAcceleratorAssociationList(__getArrayIfSingleItem(output[_eIAASl][_i]), context);
    }
    if (output.networkInterfaceSet === "") {
        contents[_NI] = [];
    }
    else if (output[_nIS] != null && output[_nIS][_i] != null) {
        contents[_NI] = de_InstanceNetworkInterfaceList(__getArrayIfSingleItem(output[_nIS][_i]), context);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_rDN] != null) {
        contents[_RDN] = __expectString(output[_rDN]);
    }
    if (output[_rDT] != null) {
        contents[_RDT] = __expectString(output[_rDT]);
    }
    if (output.groupSet === "") {
        contents[_SG] = [];
    }
    else if (output[_gS] != null && output[_gS][_i] != null) {
        contents[_SG] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);
    }
    if (output[_sDC] != null) {
        contents[_SDC] = __parseBoolean(output[_sDC]);
    }
    if (output[_sIRI] != null) {
        contents[_SIRIp] = __expectString(output[_sIRI]);
    }
    if (output[_sNSr] != null) {
        contents[_SNS] = __expectString(output[_sNSr]);
    }
    if (output[_sRt] != null) {
        contents[_SRt] = de_StateReason(output[_sRt], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vTi] != null) {
        contents[_VTir] = __expectString(output[_vTi]);
    }
    if (output[_cO] != null) {
        contents[_COp] = de_CpuOptions(output[_cO], context);
    }
    if (output[_cRI] != null) {
        contents[_CRI] = __expectString(output[_cRI]);
    }
    if (output[_cRSa] != null) {
        contents[_CRSa] = de_CapacityReservationSpecificationResponse(output[_cRSa], context);
    }
    if (output[_hO] != null) {
        contents[_HO] = de_HibernationOptions(output[_hO], context);
    }
    if (output.licenseSet === "") {
        contents[_Lic] = [];
    }
    else if (output[_lSi] != null && output[_lSi][_i] != null) {
        contents[_Lic] = de_LicenseList(__getArrayIfSingleItem(output[_lSi][_i]), context);
    }
    if (output[_mO] != null) {
        contents[_MO] = de_InstanceMetadataOptionsResponse(output[_mO], context);
    }
    if (output[_eOn] != null) {
        contents[_EOn] = de_EnclaveOptions(output[_eOn], context);
    }
    if (output[_bM] != null) {
        contents[_BM] = __expectString(output[_bM]);
    }
    if (output[_pDl] != null) {
        contents[_PDl] = __expectString(output[_pDl]);
    }
    if (output[_uO] != null) {
        contents[_UO] = __expectString(output[_uO]);
    }
    if (output[_uOUT] != null) {
        contents[_UOUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uOUT]));
    }
    if (output[_pDNO] != null) {
        contents[_PDNO] = de_PrivateDnsNameOptionsResponse(output[_pDNO], context);
    }
    if (output[_iApv] != null) {
        contents[_IApv] = __expectString(output[_iApv]);
    }
    if (output[_tSp] != null) {
        contents[_TSp] = __expectString(output[_tSp]);
    }
    if (output[_mOa] != null) {
        contents[_MOa] = de_InstanceMaintenanceOptions(output[_mOa], context);
    }
    if (output[_cIBM] != null) {
        contents[_CIBM] = __expectString(output[_cIBM]);
    }
    if (output[_nPO] != null) {
        contents[_NPO] = de_InstanceNetworkPerformanceOptions(output[_nPO], context);
    }
    if (output[_op] != null) {
        contents[_O] = de_OperatorResponse(output[_op], context);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_iSnst] != null) {
        contents[_Stat] = de_InstanceState(output[_iSnst], context);
    }
    if (output[_pDN] != null) {
        contents[_PDN] = __expectString(output[_pDN]);
    }
    if (output[_dNn] != null) {
        contents[_PDNu] = __expectString(output[_dNn]);
    }
    if (output[_rea] != null) {
        contents[_STRt] = __expectString(output[_rea]);
    }
    if (output[_kN] != null) {
        contents[_KN] = __expectString(output[_kN]);
    }
    if (output[_aLI] != null) {
        contents[_ALI] = __strictParseInt32(output[_aLI]);
    }
    if (output.productCodes === "") {
        contents[_PCr] = [];
    }
    else if (output[_pC] != null && output[_pC][_i] != null) {
        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_lTau] != null) {
        contents[_LTaun] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lTau]));
    }
    if (output[_pla] != null) {
        contents[_Pl] = de_Placement(output[_pla], context);
    }
    if (output[_kI] != null) {
        contents[_KI] = __expectString(output[_kI]);
    }
    if (output[_rIa] != null) {
        contents[_RIa] = __expectString(output[_rIa]);
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    if (output[_mo] != null) {
        contents[_Mon] = de_Monitoring(output[_mo], context);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_pIA] != null) {
        contents[_PIAr] = __expectString(output[_pIA]);
    }
    if (output[_iAp] != null) {
        contents[_PIAu] = __expectString(output[_iAp]);
    }
    return contents;
};
const de_InstanceAttachmentEnaSrdSpecification = (output, context) => {
    const contents = {};
    if (output[_eSE] != null) {
        contents[_ESE] = __parseBoolean(output[_eSE]);
    }
    if (output[_eSUS] != null) {
        contents[_ESUS] = de_InstanceAttachmentEnaSrdUdpSpecification(output[_eSUS], context);
    }
    return contents;
};
const de_InstanceAttachmentEnaSrdUdpSpecification = (output, context) => {
    const contents = {};
    if (output[_eSUE] != null) {
        contents[_ESUE] = __parseBoolean(output[_eSUE]);
    }
    return contents;
};
const de_InstanceAttribute = (output, context) => {
    const contents = {};
    if (output.blockDeviceMapping === "") {
        contents[_BDM] = [];
    }
    else if (output[_bDM] != null && output[_bDM][_i] != null) {
        contents[_BDM] = de_InstanceBlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);
    }
    if (output[_dAT] != null) {
        contents[_DATis] = de_AttributeBooleanValue(output[_dAT], context);
    }
    if (output[_eSna] != null) {
        contents[_ESn] = de_AttributeBooleanValue(output[_eSna], context);
    }
    if (output[_eOn] != null) {
        contents[_EOn] = de_EnclaveOptions(output[_eOn], context);
    }
    if (output[_eO] != null) {
        contents[_EO] = de_AttributeBooleanValue(output[_eO], context);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iISB] != null) {
        contents[_IISB] = de_AttributeValue(output[_iISB], context);
    }
    if (output[_iT] != null) {
        contents[_IT] = de_AttributeValue(output[_iT], context);
    }
    if (output[_ke] != null) {
        contents[_KI] = de_AttributeValue(output[_ke], context);
    }
    if (output.productCodes === "") {
        contents[_PCr] = [];
    }
    else if (output[_pC] != null && output[_pC][_i] != null) {
        contents[_PCr] = de_ProductCodeList(__getArrayIfSingleItem(output[_pC][_i]), context);
    }
    if (output[_ra] != null) {
        contents[_RIa] = de_AttributeValue(output[_ra], context);
    }
    if (output[_rDN] != null) {
        contents[_RDN] = de_AttributeValue(output[_rDN], context);
    }
    if (output[_sDC] != null) {
        contents[_SDC] = de_AttributeBooleanValue(output[_sDC], context);
    }
    if (output[_sNSr] != null) {
        contents[_SNS] = de_AttributeValue(output[_sNSr], context);
    }
    if (output[_uDs] != null) {
        contents[_UD] = de_AttributeValue(output[_uDs], context);
    }
    if (output[_dASi] != null) {
        contents[_DAS] = de_AttributeBooleanValue(output[_dASi], context);
    }
    if (output.groupSet === "") {
        contents[_G] = [];
    }
    else if (output[_gS] != null && output[_gS][_i] != null) {
        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);
    }
    return contents;
};
const de_InstanceBlockDeviceMapping = (output, context) => {
    const contents = {};
    if (output[_dN] != null) {
        contents[_DN] = __expectString(output[_dN]);
    }
    if (output[_eb] != null) {
        contents[_E] = de_EbsInstanceBlockDevice(output[_eb], context);
    }
    return contents;
};
const de_InstanceBlockDeviceMappingList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceBlockDeviceMapping(entry, context);
    });
};
const de_InstanceCapacity = (output, context) => {
    const contents = {};
    if (output[_aC] != null) {
        contents[_ACv] = __strictParseInt32(output[_aC]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_tC] != null) {
        contents[_TCo] = __strictParseInt32(output[_tC]);
    }
    return contents;
};
const de_InstanceConnectEndpointSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ec2InstanceConnectEndpoint(entry, context);
    });
};
const de_InstanceCount = (output, context) => {
    const contents = {};
    if (output[_iC] != null) {
        contents[_IC] = __strictParseInt32(output[_iC]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_InstanceCountList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceCount(entry, context);
    });
};
const de_InstanceCreditSpecification = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_cCp] != null) {
        contents[_CCp] = __expectString(output[_cCp]);
    }
    return contents;
};
const de_InstanceCreditSpecificationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceCreditSpecification(entry, context);
    });
};
const de_InstanceEventWindow = (output, context) => {
    const contents = {};
    if (output[_iEWI] != null) {
        contents[_IEWI] = __expectString(output[_iEWI]);
    }
    if (output.timeRangeSet === "") {
        contents[_TRi] = [];
    }
    else if (output[_tRSi] != null && output[_tRSi][_i] != null) {
        contents[_TRi] = de_InstanceEventWindowTimeRangeList(__getArrayIfSingleItem(output[_tRSi][_i]), context);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_cEr] != null) {
        contents[_CE] = __expectString(output[_cEr]);
    }
    if (output[_aTs] != null) {
        contents[_AT] = de_InstanceEventWindowAssociationTarget(output[_aTs], context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_InstanceEventWindowAssociationTarget = (output, context) => {
    const contents = {};
    if (output.instanceIdSet === "") {
        contents[_IIns] = [];
    }
    else if (output[_iIS] != null && output[_iIS][_i] != null) {
        contents[_IIns] = de_InstanceIdList(__getArrayIfSingleItem(output[_iIS][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output.dedicatedHostIdSet === "") {
        contents[_DHI] = [];
    }
    else if (output[_dHIS] != null && output[_dHIS][_i] != null) {
        contents[_DHI] = de_DedicatedHostIdList(__getArrayIfSingleItem(output[_dHIS][_i]), context);
    }
    return contents;
};
const de_InstanceEventWindowSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceEventWindow(entry, context);
    });
};
const de_InstanceEventWindowStateChange = (output, context) => {
    const contents = {};
    if (output[_iEWI] != null) {
        contents[_IEWI] = __expectString(output[_iEWI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_InstanceEventWindowTimeRange = (output, context) => {
    const contents = {};
    if (output[_sWD] != null) {
        contents[_SWD] = __expectString(output[_sWD]);
    }
    if (output[_sH] != null) {
        contents[_SH] = __strictParseInt32(output[_sH]);
    }
    if (output[_eWD] != null) {
        contents[_EWD] = __expectString(output[_eWD]);
    }
    if (output[_eH] != null) {
        contents[_EH] = __strictParseInt32(output[_eH]);
    }
    return contents;
};
const de_InstanceEventWindowTimeRangeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceEventWindowTimeRange(entry, context);
    });
};
const de_InstanceExportDetails = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_tE] != null) {
        contents[_TE] = __expectString(output[_tE]);
    }
    return contents;
};
const de_InstanceFamilyCreditSpecification = (output, context) => {
    const contents = {};
    if (output[_iF] != null) {
        contents[_IF] = __expectString(output[_iF]);
    }
    if (output[_cCp] != null) {
        contents[_CCp] = __expectString(output[_cCp]);
    }
    return contents;
};
const de_InstanceGenerationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InstanceIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InstanceIdSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InstanceIdsSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InstanceImageMetadata = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_lTau] != null) {
        contents[_LTaun] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lTau]));
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_zI] != null) {
        contents[_ZIo] = __expectString(output[_zI]);
    }
    if (output[_iSnst] != null) {
        contents[_Stat] = de_InstanceState(output[_iSnst], context);
    }
    if (output[_iOIn] != null) {
        contents[_OIwn] = __expectString(output[_iOIn]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_iM] != null) {
        contents[_IMm] = de_ImageMetadata(output[_iM], context);
    }
    if (output[_op] != null) {
        contents[_O] = de_OperatorResponse(output[_op], context);
    }
    return contents;
};
const de_InstanceImageMetadataList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceImageMetadata(entry, context);
    });
};
const de_InstanceIpv4Prefix = (output, context) => {
    const contents = {};
    if (output[_iPpv] != null) {
        contents[_IPpvr] = __expectString(output[_iPpv]);
    }
    return contents;
};
const de_InstanceIpv4PrefixList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceIpv4Prefix(entry, context);
    });
};
const de_InstanceIpv6Address = (output, context) => {
    const contents = {};
    if (output[_iApv] != null) {
        contents[_IApv] = __expectString(output[_iApv]);
    }
    if (output[_iPI] != null) {
        contents[_IPIs] = __parseBoolean(output[_iPI]);
    }
    return contents;
};
const de_InstanceIpv6AddressList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceIpv6Address(entry, context);
    });
};
const de_InstanceIpv6Prefix = (output, context) => {
    const contents = {};
    if (output[_iPpvr] != null) {
        contents[_IPpvre] = __expectString(output[_iPpvr]);
    }
    return contents;
};
const de_InstanceIpv6PrefixList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceIpv6Prefix(entry, context);
    });
};
const de_InstanceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Instance(entry, context);
    });
};
const de_InstanceMaintenanceOptions = (output, context) => {
    const contents = {};
    if (output[_aRu] != null) {
        contents[_ARu] = __expectString(output[_aRu]);
    }
    return contents;
};
const de_InstanceMetadataDefaultsResponse = (output, context) => {
    const contents = {};
    if (output[_hT] != null) {
        contents[_HT] = __expectString(output[_hT]);
    }
    if (output[_hPRHL] != null) {
        contents[_HPRHL] = __strictParseInt32(output[_hPRHL]);
    }
    if (output[_hE] != null) {
        contents[_HE] = __expectString(output[_hE]);
    }
    if (output[_iMT] != null) {
        contents[_IMT] = __expectString(output[_iMT]);
    }
    if (output[_mB] != null) {
        contents[_MB] = __expectString(output[_mB]);
    }
    if (output[_mEM] != null) {
        contents[_MEM] = __expectString(output[_mEM]);
    }
    return contents;
};
const de_InstanceMetadataOptionsResponse = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_hT] != null) {
        contents[_HT] = __expectString(output[_hT]);
    }
    if (output[_hPRHL] != null) {
        contents[_HPRHL] = __strictParseInt32(output[_hPRHL]);
    }
    if (output[_hE] != null) {
        contents[_HE] = __expectString(output[_hE]);
    }
    if (output[_hPI] != null) {
        contents[_HPI] = __expectString(output[_hPI]);
    }
    if (output[_iMT] != null) {
        contents[_IMT] = __expectString(output[_iMT]);
    }
    return contents;
};
const de_InstanceMonitoring = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_mo] != null) {
        contents[_Mon] = de_Monitoring(output[_mo], context);
    }
    return contents;
};
const de_InstanceMonitoringList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceMonitoring(entry, context);
    });
};
const de_InstanceNetworkInterface = (output, context) => {
    const contents = {};
    if (output[_ass] != null) {
        contents[_Asso] = de_InstanceNetworkInterfaceAssociation(output[_ass], context);
    }
    if (output[_at] != null) {
        contents[_Att] = de_InstanceNetworkInterfaceAttachment(output[_at], context);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.groupSet === "") {
        contents[_G] = [];
    }
    else if (output[_gS] != null && output[_gS][_i] != null) {
        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);
    }
    if (output.ipv6AddressesSet === "") {
        contents[_IA] = [];
    }
    else if (output[_iASp] != null && output[_iASp][_i] != null) {
        contents[_IA] = de_InstanceIpv6AddressList(__getArrayIfSingleItem(output[_iASp][_i]), context);
    }
    if (output[_mAa] != null) {
        contents[_MAa] = __expectString(output[_mAa]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_pDN] != null) {
        contents[_PDN] = __expectString(output[_pDN]);
    }
    if (output[_pIA] != null) {
        contents[_PIAr] = __expectString(output[_pIA]);
    }
    if (output.privateIpAddressesSet === "") {
        contents[_PIA] = [];
    }
    else if (output[_pIAS] != null && output[_pIAS][_i] != null) {
        contents[_PIA] = de_InstancePrivateIpAddressList(__getArrayIfSingleItem(output[_pIAS][_i]), context);
    }
    if (output[_sDC] != null) {
        contents[_SDC] = __parseBoolean(output[_sDC]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_iTnt] != null) {
        contents[_ITn] = __expectString(output[_iTnt]);
    }
    if (output.ipv4PrefixSet === "") {
        contents[_IPp] = [];
    }
    else if (output[_iPSpv] != null && output[_iPSpv][_i] != null) {
        contents[_IPp] = de_InstanceIpv4PrefixList(__getArrayIfSingleItem(output[_iPSpv][_i]), context);
    }
    if (output.ipv6PrefixSet === "") {
        contents[_IP] = [];
    }
    else if (output[_iPSpvr] != null && output[_iPSpvr][_i] != null) {
        contents[_IP] = de_InstanceIpv6PrefixList(__getArrayIfSingleItem(output[_iPSpvr][_i]), context);
    }
    if (output[_cTC] != null) {
        contents[_CTC] = de_ConnectionTrackingSpecificationResponse(output[_cTC], context);
    }
    if (output[_op] != null) {
        contents[_O] = de_OperatorResponse(output[_op], context);
    }
    return contents;
};
const de_InstanceNetworkInterfaceAssociation = (output, context) => {
    const contents = {};
    if (output[_cI] != null) {
        contents[_CIa] = __expectString(output[_cI]);
    }
    if (output[_cOI] != null) {
        contents[_COI] = __expectString(output[_cOI]);
    }
    if (output[_iOIp] != null) {
        contents[_IOI] = __expectString(output[_iOIp]);
    }
    if (output[_pDNu] != null) {
        contents[_PDNu] = __expectString(output[_pDNu]);
    }
    if (output[_pI] != null) {
        contents[_PI] = __expectString(output[_pI]);
    }
    return contents;
};
const de_InstanceNetworkInterfaceAttachment = (output, context) => {
    const contents = {};
    if (output[_aTt] != null) {
        contents[_ATtt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aTt]));
    }
    if (output[_aIt] != null) {
        contents[_AIt] = __expectString(output[_aIt]);
    }
    if (output[_dOT] != null) {
        contents[_DOT] = __parseBoolean(output[_dOT]);
    }
    if (output[_dIe] != null) {
        contents[_DIev] = __strictParseInt32(output[_dIe]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_nCI] != null) {
        contents[_NCI] = __strictParseInt32(output[_nCI]);
    }
    if (output[_eSS] != null) {
        contents[_ESS] = de_InstanceAttachmentEnaSrdSpecification(output[_eSS], context);
    }
    return contents;
};
const de_InstanceNetworkInterfaceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceNetworkInterface(entry, context);
    });
};
const de_InstanceNetworkInterfaceSpecification = (output, context) => {
    const contents = {};
    if (output[_aPIA] != null) {
        contents[_APIAs] = __parseBoolean(output[_aPIA]);
    }
    if (output[_dOT] != null) {
        contents[_DOT] = __parseBoolean(output[_dOT]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_dIe] != null) {
        contents[_DIev] = __strictParseInt32(output[_dIe]);
    }
    if (output.SecurityGroupId === "") {
        contents[_G] = [];
    }
    else if (output[_SGIe] != null && output[_SGIe][_SGIe] != null) {
        contents[_G] = de_SecurityGroupIdStringList(__getArrayIfSingleItem(output[_SGIe][_SGIe]), context);
    }
    if (output[_iAC] != null) {
        contents[_IAC] = __strictParseInt32(output[_iAC]);
    }
    if (output.ipv6AddressesSet === "") {
        contents[_IA] = [];
    }
    else if (output[_iASp] != null && output[_iASp][_i] != null) {
        contents[_IA] = de_InstanceIpv6AddressList(__getArrayIfSingleItem(output[_iASp][_i]), context);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_pIA] != null) {
        contents[_PIAr] = __expectString(output[_pIA]);
    }
    if (output.privateIpAddressesSet === "") {
        contents[_PIA] = [];
    }
    else if (output[_pIAS] != null && output[_pIAS][_i] != null) {
        contents[_PIA] = de_PrivateIpAddressSpecificationList(__getArrayIfSingleItem(output[_pIAS][_i]), context);
    }
    if (output[_sPIAC] != null) {
        contents[_SPIAC] = __strictParseInt32(output[_sPIAC]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_ACIA] != null) {
        contents[_ACIA] = __parseBoolean(output[_ACIA]);
    }
    if (output[_ITn] != null) {
        contents[_ITn] = __expectString(output[_ITn]);
    }
    if (output[_NCI] != null) {
        contents[_NCI] = __strictParseInt32(output[_NCI]);
    }
    if (output.Ipv4Prefix === "") {
        contents[_IPp] = [];
    }
    else if (output[_IPpvr] != null && output[_IPpvr][_i] != null) {
        contents[_IPp] = de_Ipv4PrefixList(__getArrayIfSingleItem(output[_IPpvr][_i]), context);
    }
    if (output[_IPCp] != null) {
        contents[_IPCp] = __strictParseInt32(output[_IPCp]);
    }
    if (output.Ipv6Prefix === "") {
        contents[_IP] = [];
    }
    else if (output[_IPpvre] != null && output[_IPpvre][_i] != null) {
        contents[_IP] = de_Ipv6PrefixList(__getArrayIfSingleItem(output[_IPpvre][_i]), context);
    }
    if (output[_IPC] != null) {
        contents[_IPC] = __strictParseInt32(output[_IPC]);
    }
    if (output[_PIr] != null) {
        contents[_PIr] = __parseBoolean(output[_PIr]);
    }
    if (output[_ESS] != null) {
        contents[_ESS] = de_EnaSrdSpecificationRequest(output[_ESS], context);
    }
    if (output[_CTS] != null) {
        contents[_CTS] = de_ConnectionTrackingSpecificationRequest(output[_CTS], context);
    }
    return contents;
};
const de_InstanceNetworkInterfaceSpecificationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceNetworkInterfaceSpecification(entry, context);
    });
};
const de_InstanceNetworkPerformanceOptions = (output, context) => {
    const contents = {};
    if (output[_bW] != null) {
        contents[_BW] = __expectString(output[_bW]);
    }
    return contents;
};
const de_InstancePrivateIpAddress = (output, context) => {
    const contents = {};
    if (output[_ass] != null) {
        contents[_Asso] = de_InstanceNetworkInterfaceAssociation(output[_ass], context);
    }
    if (output[_prim] != null) {
        contents[_Prim] = __parseBoolean(output[_prim]);
    }
    if (output[_pDN] != null) {
        contents[_PDN] = __expectString(output[_pDN]);
    }
    if (output[_pIA] != null) {
        contents[_PIAr] = __expectString(output[_pIA]);
    }
    return contents;
};
const de_InstancePrivateIpAddressList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstancePrivateIpAddress(entry, context);
    });
};
const de_InstanceRequirements = (output, context) => {
    const contents = {};
    if (output[_vCC] != null) {
        contents[_VCC] = de_VCpuCountRange(output[_vCC], context);
    }
    if (output[_mMB] != null) {
        contents[_MMB] = de_MemoryMiB(output[_mMB], context);
    }
    if (output.cpuManufacturerSet === "") {
        contents[_CM] = [];
    }
    else if (output[_cMS] != null && output[_cMS][_i] != null) {
        contents[_CM] = de_CpuManufacturerSet(__getArrayIfSingleItem(output[_cMS][_i]), context);
    }
    if (output[_mGBPVC] != null) {
        contents[_MGBPVC] = de_MemoryGiBPerVCpu(output[_mGBPVC], context);
    }
    if (output.excludedInstanceTypeSet === "") {
        contents[_EIT] = [];
    }
    else if (output[_eITSx] != null && output[_eITSx][_i] != null) {
        contents[_EIT] = de_ExcludedInstanceTypeSet(__getArrayIfSingleItem(output[_eITSx][_i]), context);
    }
    if (output.instanceGenerationSet === "") {
        contents[_IG] = [];
    }
    else if (output[_iGSn] != null && output[_iGSn][_i] != null) {
        contents[_IG] = de_InstanceGenerationSet(__getArrayIfSingleItem(output[_iGSn][_i]), context);
    }
    if (output[_sMPPOLP] != null) {
        contents[_SMPPOLP] = __strictParseInt32(output[_sMPPOLP]);
    }
    if (output[_oDMPPOLP] != null) {
        contents[_ODMPPOLP] = __strictParseInt32(output[_oDMPPOLP]);
    }
    if (output[_bMa] != null) {
        contents[_BMa] = __expectString(output[_bMa]);
    }
    if (output[_bP] != null) {
        contents[_BP] = __expectString(output[_bP]);
    }
    if (output[_rHS] != null) {
        contents[_RHS] = __parseBoolean(output[_rHS]);
    }
    if (output[_nIC] != null) {
        contents[_NIC] = de_NetworkInterfaceCount(output[_nIC], context);
    }
    if (output[_lSo] != null) {
        contents[_LSo] = __expectString(output[_lSo]);
    }
    if (output.localStorageTypeSet === "") {
        contents[_LST] = [];
    }
    else if (output[_lSTS] != null && output[_lSTS][_i] != null) {
        contents[_LST] = de_LocalStorageTypeSet(__getArrayIfSingleItem(output[_lSTS][_i]), context);
    }
    if (output[_tLSGB] != null) {
        contents[_TLSGB] = de_TotalLocalStorageGB(output[_tLSGB], context);
    }
    if (output[_bEBM] != null) {
        contents[_BEBM] = de_BaselineEbsBandwidthMbps(output[_bEBM], context);
    }
    if (output.acceleratorTypeSet === "") {
        contents[_ATc] = [];
    }
    else if (output[_aTSc] != null && output[_aTSc][_i] != null) {
        contents[_ATc] = de_AcceleratorTypeSet(__getArrayIfSingleItem(output[_aTSc][_i]), context);
    }
    if (output[_aCc] != null) {
        contents[_ACc] = de_AcceleratorCount(output[_aCc], context);
    }
    if (output.acceleratorManufacturerSet === "") {
        contents[_AM] = [];
    }
    else if (output[_aMS] != null && output[_aMS][_i] != null) {
        contents[_AM] = de_AcceleratorManufacturerSet(__getArrayIfSingleItem(output[_aMS][_i]), context);
    }
    if (output.acceleratorNameSet === "") {
        contents[_ANc] = [];
    }
    else if (output[_aNS] != null && output[_aNS][_i] != null) {
        contents[_ANc] = de_AcceleratorNameSet(__getArrayIfSingleItem(output[_aNS][_i]), context);
    }
    if (output[_aTMMB] != null) {
        contents[_ATMMB] = de_AcceleratorTotalMemoryMiB(output[_aTMMB], context);
    }
    if (output[_nBGe] != null) {
        contents[_NBGe] = de_NetworkBandwidthGbps(output[_nBGe], context);
    }
    if (output.allowedInstanceTypeSet === "") {
        contents[_AIT] = [];
    }
    else if (output[_aITS] != null && output[_aITS][_i] != null) {
        contents[_AIT] = de_AllowedInstanceTypeSet(__getArrayIfSingleItem(output[_aITS][_i]), context);
    }
    if (output[_mSPAPOOODP] != null) {
        contents[_MSPAPOOODP] = __strictParseInt32(output[_mSPAPOOODP]);
    }
    if (output[_bPF] != null) {
        contents[_BPF] = de_BaselinePerformanceFactors(output[_bPF], context);
    }
    return contents;
};
const de_InstanceSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceTopology(entry, context);
    });
};
const de_InstanceState = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __strictParseInt32(output[_co]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    return contents;
};
const de_InstanceStateChange = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_cSu] != null) {
        contents[_CSu] = de_InstanceState(output[_cSu], context);
    }
    if (output[_pS] != null) {
        contents[_PSr] = de_InstanceState(output[_pS], context);
    }
    return contents;
};
const de_InstanceStateChangeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceStateChange(entry, context);
    });
};
const de_InstanceStatus = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_op] != null) {
        contents[_O] = de_OperatorResponse(output[_op], context);
    }
    if (output.eventsSet === "") {
        contents[_Ev] = [];
    }
    else if (output[_eSv] != null && output[_eSv][_i] != null) {
        contents[_Ev] = de_InstanceStatusEventList(__getArrayIfSingleItem(output[_eSv][_i]), context);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iSnst] != null) {
        contents[_ISnst] = de_InstanceState(output[_iSnst], context);
    }
    if (output[_iSnsta] != null) {
        contents[_ISnsta] = de_InstanceStatusSummary(output[_iSnsta], context);
    }
    if (output[_sSy] != null) {
        contents[_SSy] = de_InstanceStatusSummary(output[_sSy], context);
    }
    if (output[_aES] != null) {
        contents[_AES] = de_EbsStatusSummary(output[_aES], context);
    }
    return contents;
};
const de_InstanceStatusDetails = (output, context) => {
    const contents = {};
    if (output[_iSmp] != null) {
        contents[_ISmp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_iSmp]));
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_InstanceStatusDetailsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceStatusDetails(entry, context);
    });
};
const de_InstanceStatusEvent = (output, context) => {
    const contents = {};
    if (output[_iEI] != null) {
        contents[_IEI] = __expectString(output[_iEI]);
    }
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_nAo] != null) {
        contents[_NAo] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nAo]));
    }
    if (output[_nB] != null) {
        contents[_NB] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nB]));
    }
    if (output[_nBD] != null) {
        contents[_NBD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nBD]));
    }
    return contents;
};
const de_InstanceStatusEventList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceStatusEvent(entry, context);
    });
};
const de_InstanceStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceStatus(entry, context);
    });
};
const de_InstanceStatusSummary = (output, context) => {
    const contents = {};
    if (output.details === "") {
        contents[_Det] = [];
    }
    else if (output[_det] != null && output[_det][_i] != null) {
        contents[_Det] = de_InstanceStatusDetailsList(__getArrayIfSingleItem(output[_det][_i]), context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_InstanceStorageInfo = (output, context) => {
    const contents = {};
    if (output[_tSIGB] != null) {
        contents[_TSIGB] = __strictParseLong(output[_tSIGB]);
    }
    if (output.disks === "") {
        contents[_Dis] = [];
    }
    else if (output[_dis] != null && output[_dis][_i] != null) {
        contents[_Dis] = de_DiskInfoList(__getArrayIfSingleItem(output[_dis][_i]), context);
    }
    if (output[_nS] != null) {
        contents[_NS] = __expectString(output[_nS]);
    }
    if (output[_eSn] != null) {
        contents[_ESnc] = __expectString(output[_eSn]);
    }
    return contents;
};
const de_InstanceTagKeySet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InstanceTagNotificationAttribute = (output, context) => {
    const contents = {};
    if (output.instanceTagKeySet === "") {
        contents[_ITK] = [];
    }
    else if (output[_iTKS] != null && output[_iTKS][_i] != null) {
        contents[_ITK] = de_InstanceTagKeySet(__getArrayIfSingleItem(output[_iTKS][_i]), context);
    }
    if (output[_iATOI] != null) {
        contents[_IATOI] = __parseBoolean(output[_iATOI]);
    }
    return contents;
};
const de_InstanceTopology = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output.networkNodeSet === "") {
        contents[_NN] = [];
    }
    else if (output[_nNS] != null && output[_nNS][_i] != null) {
        contents[_NN] = de_NetworkNodesList(__getArrayIfSingleItem(output[_nNS][_i]), context);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_zI] != null) {
        contents[_ZIo] = __expectString(output[_zI]);
    }
    return contents;
};
const de_InstanceTypeInfo = (output, context) => {
    const contents = {};
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_cGur] != null) {
        contents[_CGur] = __parseBoolean(output[_cGur]);
    }
    if (output[_fTE] != null) {
        contents[_FTE] = __parseBoolean(output[_fTE]);
    }
    if (output.supportedUsageClasses === "") {
        contents[_SUC] = [];
    }
    else if (output[_sUC] != null && output[_sUC][_i] != null) {
        contents[_SUC] = de_UsageClassTypeList(__getArrayIfSingleItem(output[_sUC][_i]), context);
    }
    if (output.supportedRootDeviceTypes === "") {
        contents[_SRDT] = [];
    }
    else if (output[_sRDT] != null && output[_sRDT][_i] != null) {
        contents[_SRDT] = de_RootDeviceTypeList(__getArrayIfSingleItem(output[_sRDT][_i]), context);
    }
    if (output.supportedVirtualizationTypes === "") {
        contents[_SVT] = [];
    }
    else if (output[_sVT] != null && output[_sVT][_i] != null) {
        contents[_SVT] = de_VirtualizationTypeList(__getArrayIfSingleItem(output[_sVT][_i]), context);
    }
    if (output[_bMa] != null) {
        contents[_BMa] = __parseBoolean(output[_bMa]);
    }
    if (output[_h] != null) {
        contents[_H] = __expectString(output[_h]);
    }
    if (output[_pIr] != null) {
        contents[_PIro] = de_ProcessorInfo(output[_pIr], context);
    }
    if (output[_vCIp] != null) {
        contents[_VCIpu] = de_VCpuInfo(output[_vCIp], context);
    }
    if (output[_mIe] != null) {
        contents[_MIe] = de_MemoryInfo(output[_mIe], context);
    }
    if (output[_iSSn] != null) {
        contents[_ISS] = __parseBoolean(output[_iSSn]);
    }
    if (output[_iSI] != null) {
        contents[_ISIn] = de_InstanceStorageInfo(output[_iSI], context);
    }
    if (output[_eIb] != null) {
        contents[_EIb] = de_EbsInfo(output[_eIb], context);
    }
    if (output[_nIet] != null) {
        contents[_NIetw] = de_NetworkInfo(output[_nIet], context);
    }
    if (output[_gIp] != null) {
        contents[_GIp] = de_GpuInfo(output[_gIp], context);
    }
    if (output[_fIp] != null) {
        contents[_FIpg] = de_FpgaInfo(output[_fIp], context);
    }
    if (output[_pGI] != null) {
        contents[_PGI] = de_PlacementGroupInfo(output[_pGI], context);
    }
    if (output[_iAI] != null) {
        contents[_IAIn] = de_InferenceAcceleratorInfo(output[_iAI], context);
    }
    if (output[_hSi] != null) {
        contents[_HS] = __parseBoolean(output[_hSi]);
    }
    if (output[_bPS] != null) {
        contents[_BPS] = __parseBoolean(output[_bPS]);
    }
    if (output[_dHS] != null) {
        contents[_DHS] = __parseBoolean(output[_dHS]);
    }
    if (output[_aRSu] != null) {
        contents[_ARSu] = __parseBoolean(output[_aRSu]);
    }
    if (output.supportedBootModes === "") {
        contents[_SBM] = [];
    }
    else if (output[_sBM] != null && output[_sBM][_i] != null) {
        contents[_SBM] = de_BootModeTypeList(__getArrayIfSingleItem(output[_sBM][_i]), context);
    }
    if (output[_nES] != null) {
        contents[_NES] = __expectString(output[_nES]);
    }
    if (output[_nTS] != null) {
        contents[_NTS] = __expectString(output[_nTS]);
    }
    if (output[_nTI] != null) {
        contents[_NTI] = de_NitroTpmInfo(output[_nTI], context);
    }
    if (output[_mAIe] != null) {
        contents[_MAIe] = de_MediaAcceleratorInfo(output[_mAIe], context);
    }
    if (output[_nIeu] != null) {
        contents[_NIeu] = de_NeuronInfo(output[_nIeu], context);
    }
    if (output[_pSh] != null) {
        contents[_PSh] = __expectString(output[_pSh]);
    }
    return contents;
};
const de_InstanceTypeInfoFromInstanceRequirements = (output, context) => {
    const contents = {};
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    return contents;
};
const de_InstanceTypeInfoFromInstanceRequirementsSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceTypeInfoFromInstanceRequirements(entry, context);
    });
};
const de_InstanceTypeInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceTypeInfo(entry, context);
    });
};
const de_InstanceTypeOffering = (output, context) => {
    const contents = {};
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_lTo] != null) {
        contents[_LT] = __expectString(output[_lTo]);
    }
    if (output[_lo] != null) {
        contents[_Lo] = __expectString(output[_lo]);
    }
    return contents;
};
const de_InstanceTypeOfferingsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceTypeOffering(entry, context);
    });
};
const de_InstanceTypesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InstanceUsage = (output, context) => {
    const contents = {};
    if (output[_aIc] != null) {
        contents[_AIcc] = __expectString(output[_aIc]);
    }
    if (output[_uIC] != null) {
        contents[_UIC] = __strictParseInt32(output[_uIC]);
    }
    return contents;
};
const de_InstanceUsageSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceUsage(entry, context);
    });
};
const de_InternetGateway = (output, context) => {
    const contents = {};
    if (output.attachmentSet === "") {
        contents[_Atta] = [];
    }
    else if (output[_aSt] != null && output[_aSt][_i] != null) {
        contents[_Atta] = de_InternetGatewayAttachmentList(__getArrayIfSingleItem(output[_aSt][_i]), context);
    }
    if (output[_iGI] != null) {
        contents[_IGI] = __expectString(output[_iGI]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_InternetGatewayAttachment = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    return contents;
};
const de_InternetGatewayAttachmentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InternetGatewayAttachment(entry, context);
    });
};
const de_InternetGatewayList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InternetGateway(entry, context);
    });
};
const de_IpAddressList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Ipam = (output, context) => {
    const contents = {};
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_iIp] != null) {
        contents[_IIp] = __expectString(output[_iIp]);
    }
    if (output[_iApa] != null) {
        contents[_IApa] = __expectString(output[_iApa]);
    }
    if (output[_iRp] != null) {
        contents[_IRpa] = __expectString(output[_iRp]);
    }
    if (output[_pDSI] != null) {
        contents[_PDSI] = __expectString(output[_pDSI]);
    }
    if (output[_pDSIr] != null) {
        contents[_PDSIr] = __expectString(output[_pDSIr]);
    }
    if (output[_sCc] != null) {
        contents[_SCc] = __strictParseInt32(output[_sCc]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.operatingRegionSet === "") {
        contents[_OR] = [];
    }
    else if (output[_oRS] != null && output[_oRS][_i] != null) {
        contents[_OR] = de_IpamOperatingRegionSet(__getArrayIfSingleItem(output[_oRS][_i]), context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_dRDI] != null) {
        contents[_DRDI] = __expectString(output[_dRDI]);
    }
    if (output[_dRDAI] != null) {
        contents[_DRDAI] = __expectString(output[_dRDAI]);
    }
    if (output[_rDAC] != null) {
        contents[_RDAC] = __strictParseInt32(output[_rDAC]);
    }
    if (output[_sMta] != null) {
        contents[_SMta] = __expectString(output[_sMta]);
    }
    if (output[_tie] != null) {
        contents[_Ti] = __expectString(output[_tie]);
    }
    if (output[_ePG] != null) {
        contents[_EPG] = __parseBoolean(output[_ePG]);
    }
    return contents;
};
const de_IpamAddressHistoryRecord = (output, context) => {
    const contents = {};
    if (output[_rOI] != null) {
        contents[_ROI] = __expectString(output[_rOI]);
    }
    if (output[_rR] != null) {
        contents[_RRe] = __expectString(output[_rR]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rCe] != null) {
        contents[_RC] = __expectString(output[_rCe]);
    }
    if (output[_rNes] != null) {
        contents[_RNes] = __expectString(output[_rNes]);
    }
    if (output[_rCS] != null) {
        contents[_RCS] = __expectString(output[_rCS]);
    }
    if (output[_rOSe] != null) {
        contents[_ROS] = __expectString(output[_rOSe]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_sST] != null) {
        contents[_SST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sST]));
    }
    if (output[_sET] != null) {
        contents[_SET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sET]));
    }
    return contents;
};
const de_IpamAddressHistoryRecordSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamAddressHistoryRecord(entry, context);
    });
};
const de_IpamDiscoveredAccount = (output, context) => {
    const contents = {};
    if (output[_aIc] != null) {
        contents[_AIcc] = __expectString(output[_aIc]);
    }
    if (output[_dR] != null) {
        contents[_DRi] = __expectString(output[_dR]);
    }
    if (output[_fR] != null) {
        contents[_FR] = de_IpamDiscoveryFailureReason(output[_fR], context);
    }
    if (output[_lADT] != null) {
        contents[_LADT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lADT]));
    }
    if (output[_lSDT] != null) {
        contents[_LSDT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lSDT]));
    }
    if (output[_oUI] != null) {
        contents[_OUI] = __expectString(output[_oUI]);
    }
    return contents;
};
const de_IpamDiscoveredAccountSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamDiscoveredAccount(entry, context);
    });
};
const de_IpamDiscoveredPublicAddress = (output, context) => {
    const contents = {};
    if (output[_iRDI] != null) {
        contents[_IRDI] = __expectString(output[_iRDI]);
    }
    if (output[_aRd] != null) {
        contents[_ARd] = __expectString(output[_aRd]);
    }
    if (output[_ad] != null) {
        contents[_Ad] = __expectString(output[_ad]);
    }
    if (output[_aOI] != null) {
        contents[_AOI] = __expectString(output[_aOI]);
    }
    if (output[_aAId] != null) {
        contents[_AAId] = __expectString(output[_aAId]);
    }
    if (output[_aSs] != null) {
        contents[_ASss] = __expectString(output[_aSs]);
    }
    if (output[_aTd] != null) {
        contents[_ATddre] = __expectString(output[_aTd]);
    }
    if (output[_se] != null) {
        contents[_Se] = __expectString(output[_se]);
    }
    if (output[_sRe] != null) {
        contents[_SRerv] = __expectString(output[_sRe]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_pIPI] != null) {
        contents[_PIPI] = __expectString(output[_pIPI]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_nID] != null) {
        contents[_NID] = __expectString(output[_nID]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_ta] != null) {
        contents[_Ta] = de_IpamPublicAddressTags(output[_ta], context);
    }
    if (output[_nBG] != null) {
        contents[_NBG] = __expectString(output[_nBG]);
    }
    if (output.securityGroupSet === "") {
        contents[_SG] = [];
    }
    else if (output[_sGS] != null && output[_sGS][_i] != null) {
        contents[_SG] = de_IpamPublicAddressSecurityGroupList(__getArrayIfSingleItem(output[_sGS][_i]), context);
    }
    if (output[_sTa] != null) {
        contents[_STa] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sTa]));
    }
    return contents;
};
const de_IpamDiscoveredPublicAddressSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamDiscoveredPublicAddress(entry, context);
    });
};
const de_IpamDiscoveredResourceCidr = (output, context) => {
    const contents = {};
    if (output[_iRDI] != null) {
        contents[_IRDI] = __expectString(output[_iRDI]);
    }
    if (output[_rR] != null) {
        contents[_RRe] = __expectString(output[_rR]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rOI] != null) {
        contents[_ROI] = __expectString(output[_rOI]);
    }
    if (output[_rCe] != null) {
        contents[_RC] = __expectString(output[_rCe]);
    }
    if (output[_iSpo] != null) {
        contents[_ISpo] = __expectString(output[_iSpo]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output.resourceTagSet === "") {
        contents[_RTesou] = [];
    }
    else if (output[_rTSe] != null && output[_rTSe][_i] != null) {
        contents[_RTesou] = de_IpamResourceTagList(__getArrayIfSingleItem(output[_rTSe][_i]), context);
    }
    if (output[_iU] != null) {
        contents[_IUp] = __strictParseFloat(output[_iU]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_nIASet] != null) {
        contents[_NIASet] = __expectString(output[_nIASet]);
    }
    if (output[_sTa] != null) {
        contents[_STa] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sTa]));
    }
    if (output[_aZI] != null) {
        contents[_AZI] = __expectString(output[_aZI]);
    }
    return contents;
};
const de_IpamDiscoveredResourceCidrSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamDiscoveredResourceCidr(entry, context);
    });
};
const de_IpamDiscoveryFailureReason = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_IpamExternalResourceVerificationToken = (output, context) => {
    const contents = {};
    if (output[_iERVTI] != null) {
        contents[_IERVTI] = __expectString(output[_iERVTI]);
    }
    if (output[_iERVTA] != null) {
        contents[_IERVTA] = __expectString(output[_iERVTA]);
    }
    if (output[_iIp] != null) {
        contents[_IIp] = __expectString(output[_iIp]);
    }
    if (output[_iApa] != null) {
        contents[_IApa] = __expectString(output[_iApa]);
    }
    if (output[_iRp] != null) {
        contents[_IRpa] = __expectString(output[_iRp]);
    }
    if (output[_tV] != null) {
        contents[_TVo] = __expectString(output[_tV]);
    }
    if (output[_tN] != null) {
        contents[_TN] = __expectString(output[_tN]);
    }
    if (output[_nAo] != null) {
        contents[_NAo] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nAo]));
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_IpamExternalResourceVerificationTokenSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamExternalResourceVerificationToken(entry, context);
    });
};
const de_IpamOperatingRegion = (output, context) => {
    const contents = {};
    if (output[_rNe] != null) {
        contents[_RN] = __expectString(output[_rNe]);
    }
    return contents;
};
const de_IpamOperatingRegionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamOperatingRegion(entry, context);
    });
};
const de_IpamOrganizationalUnitExclusion = (output, context) => {
    const contents = {};
    if (output[_oEP] != null) {
        contents[_OEP] = __expectString(output[_oEP]);
    }
    return contents;
};
const de_IpamOrganizationalUnitExclusionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamOrganizationalUnitExclusion(entry, context);
    });
};
const de_IpamPool = (output, context) => {
    const contents = {};
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_iPIp] != null) {
        contents[_IPI] = __expectString(output[_iPIp]);
    }
    if (output[_sIPI] != null) {
        contents[_SIPI] = __expectString(output[_sIPI]);
    }
    if (output[_iPAp] != null) {
        contents[_IPApa] = __expectString(output[_iPAp]);
    }
    if (output[_iSA] != null) {
        contents[_ISA] = __expectString(output[_iSA]);
    }
    if (output[_iST] != null) {
        contents[_ISTp] = __expectString(output[_iST]);
    }
    if (output[_iApa] != null) {
        contents[_IApa] = __expectString(output[_iApa]);
    }
    if (output[_iRp] != null) {
        contents[_IRpa] = __expectString(output[_iRp]);
    }
    if (output[_loc] != null) {
        contents[_L] = __expectString(output[_loc]);
    }
    if (output[_pDoo] != null) {
        contents[_PDo] = __strictParseInt32(output[_pDoo]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMta] != null) {
        contents[_SMta] = __expectString(output[_sMta]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_aIu] != null) {
        contents[_AIu] = __parseBoolean(output[_aIu]);
    }
    if (output[_pAu] != null) {
        contents[_PA] = __parseBoolean(output[_pAu]);
    }
    if (output[_aF] != null) {
        contents[_AF] = __expectString(output[_aF]);
    }
    if (output[_aMNL] != null) {
        contents[_AMNL] = __strictParseInt32(output[_aMNL]);
    }
    if (output[_aMNLl] != null) {
        contents[_AMNLl] = __strictParseInt32(output[_aMNLl]);
    }
    if (output[_aDNL] != null) {
        contents[_ADNL] = __strictParseInt32(output[_aDNL]);
    }
    if (output.allocationResourceTagSet === "") {
        contents[_ARTl] = [];
    }
    else if (output[_aRTS] != null && output[_aRTS][_i] != null) {
        contents[_ARTl] = de_IpamResourceTagList(__getArrayIfSingleItem(output[_aRTS][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_aSw] != null) {
        contents[_ASw] = __expectString(output[_aSw]);
    }
    if (output[_pIS] != null) {
        contents[_PIS] = __expectString(output[_pIS]);
    }
    if (output[_sRo] != null) {
        contents[_SRo] = de_IpamPoolSourceResource(output[_sRo], context);
    }
    return contents;
};
const de_IpamPoolAllocation = (output, context) => {
    const contents = {};
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    if (output[_iPAI] != null) {
        contents[_IPAI] = __expectString(output[_iPAI]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_rR] != null) {
        contents[_RRe] = __expectString(output[_rR]);
    }
    if (output[_rO] != null) {
        contents[_ROe] = __expectString(output[_rO]);
    }
    return contents;
};
const de_IpamPoolAllocationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamPoolAllocation(entry, context);
    });
};
const de_IpamPoolCidr = (output, context) => {
    const contents = {};
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_fR] != null) {
        contents[_FR] = de_IpamPoolCidrFailureReason(output[_fR], context);
    }
    if (output[_iPCI] != null) {
        contents[_IPCI] = __expectString(output[_iPCI]);
    }
    if (output[_nL] != null) {
        contents[_NL] = __strictParseInt32(output[_nL]);
    }
    return contents;
};
const de_IpamPoolCidrFailureReason = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_IpamPoolCidrSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamPoolCidr(entry, context);
    });
};
const de_IpamPoolSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamPool(entry, context);
    });
};
const de_IpamPoolSourceResource = (output, context) => {
    const contents = {};
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_rR] != null) {
        contents[_RRe] = __expectString(output[_rR]);
    }
    if (output[_rO] != null) {
        contents[_ROe] = __expectString(output[_rO]);
    }
    return contents;
};
const de_IpamPublicAddressSecurityGroup = (output, context) => {
    const contents = {};
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    return contents;
};
const de_IpamPublicAddressSecurityGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamPublicAddressSecurityGroup(entry, context);
    });
};
const de_IpamPublicAddressTag = (output, context) => {
    const contents = {};
    if (output[_k] != null) {
        contents[_Ke] = __expectString(output[_k]);
    }
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    return contents;
};
const de_IpamPublicAddressTagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamPublicAddressTag(entry, context);
    });
};
const de_IpamPublicAddressTags = (output, context) => {
    const contents = {};
    if (output.eipTagSet === "") {
        contents[_ETi] = [];
    }
    else if (output[_eTSi] != null && output[_eTSi][_i] != null) {
        contents[_ETi] = de_IpamPublicAddressTagList(__getArrayIfSingleItem(output[_eTSi][_i]), context);
    }
    return contents;
};
const de_IpamResourceCidr = (output, context) => {
    const contents = {};
    if (output[_iIp] != null) {
        contents[_IIp] = __expectString(output[_iIp]);
    }
    if (output[_iSIp] != null) {
        contents[_ISI] = __expectString(output[_iSIp]);
    }
    if (output[_iPIp] != null) {
        contents[_IPI] = __expectString(output[_iPIp]);
    }
    if (output[_rR] != null) {
        contents[_RRe] = __expectString(output[_rR]);
    }
    if (output[_rOI] != null) {
        contents[_ROI] = __expectString(output[_rOI]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rNes] != null) {
        contents[_RNes] = __expectString(output[_rNes]);
    }
    if (output[_rCe] != null) {
        contents[_RC] = __expectString(output[_rCe]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output.resourceTagSet === "") {
        contents[_RTesou] = [];
    }
    else if (output[_rTSe] != null && output[_rTSe][_i] != null) {
        contents[_RTesou] = de_IpamResourceTagList(__getArrayIfSingleItem(output[_rTSe][_i]), context);
    }
    if (output[_iU] != null) {
        contents[_IUp] = __strictParseFloat(output[_iU]);
    }
    if (output[_cSo] != null) {
        contents[_CSo] = __expectString(output[_cSo]);
    }
    if (output[_mSa] != null) {
        contents[_MSa] = __expectString(output[_mSa]);
    }
    if (output[_oSv] != null) {
        contents[_OSv] = __expectString(output[_oSv]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_aZI] != null) {
        contents[_AZI] = __expectString(output[_aZI]);
    }
    return contents;
};
const de_IpamResourceCidrSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamResourceCidr(entry, context);
    });
};
const de_IpamResourceDiscovery = (output, context) => {
    const contents = {};
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_iRDI] != null) {
        contents[_IRDI] = __expectString(output[_iRDI]);
    }
    if (output[_iRDAp] != null) {
        contents[_IRDApa] = __expectString(output[_iRDAp]);
    }
    if (output[_iRDR] != null) {
        contents[_IRDR] = __expectString(output[_iRDR]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.operatingRegionSet === "") {
        contents[_OR] = [];
    }
    else if (output[_oRS] != null && output[_oRS][_i] != null) {
        contents[_OR] = de_IpamOperatingRegionSet(__getArrayIfSingleItem(output[_oRS][_i]), context);
    }
    if (output[_iDs] != null) {
        contents[_IDs] = __parseBoolean(output[_iDs]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output.organizationalUnitExclusionSet === "") {
        contents[_OUE] = [];
    }
    else if (output[_oUES] != null && output[_oUES][_i] != null) {
        contents[_OUE] = de_IpamOrganizationalUnitExclusionSet(__getArrayIfSingleItem(output[_oUES][_i]), context);
    }
    return contents;
};
const de_IpamResourceDiscoveryAssociation = (output, context) => {
    const contents = {};
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_iRDAI] != null) {
        contents[_IRDAIp] = __expectString(output[_iRDAI]);
    }
    if (output[_iRDAA] != null) {
        contents[_IRDAA] = __expectString(output[_iRDAA]);
    }
    if (output[_iRDI] != null) {
        contents[_IRDI] = __expectString(output[_iRDI]);
    }
    if (output[_iIp] != null) {
        contents[_IIp] = __expectString(output[_iIp]);
    }
    if (output[_iApa] != null) {
        contents[_IApa] = __expectString(output[_iApa]);
    }
    if (output[_iRp] != null) {
        contents[_IRpa] = __expectString(output[_iRp]);
    }
    if (output[_iDs] != null) {
        contents[_IDs] = __parseBoolean(output[_iDs]);
    }
    if (output[_rDS] != null) {
        contents[_RDS] = __expectString(output[_rDS]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_IpamResourceDiscoveryAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamResourceDiscoveryAssociation(entry, context);
    });
};
const de_IpamResourceDiscoverySet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamResourceDiscovery(entry, context);
    });
};
const de_IpamResourceTag = (output, context) => {
    const contents = {};
    if (output[_k] != null) {
        contents[_Ke] = __expectString(output[_k]);
    }
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    return contents;
};
const de_IpamResourceTagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamResourceTag(entry, context);
    });
};
const de_IpamScope = (output, context) => {
    const contents = {};
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_iSIp] != null) {
        contents[_ISI] = __expectString(output[_iSIp]);
    }
    if (output[_iSA] != null) {
        contents[_ISA] = __expectString(output[_iSA]);
    }
    if (output[_iApa] != null) {
        contents[_IApa] = __expectString(output[_iApa]);
    }
    if (output[_iRp] != null) {
        contents[_IRpa] = __expectString(output[_iRp]);
    }
    if (output[_iST] != null) {
        contents[_ISTp] = __expectString(output[_iST]);
    }
    if (output[_iDs] != null) {
        contents[_IDs] = __parseBoolean(output[_iDs]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_pCo] != null) {
        contents[_PCoo] = __strictParseInt32(output[_pCo]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_IpamScopeSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpamScope(entry, context);
    });
};
const de_IpamSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipam(entry, context);
    });
};
const de_IpPermission = (output, context) => {
    const contents = {};
    if (output[_iPpr] != null) {
        contents[_IPpr] = __expectString(output[_iPpr]);
    }
    if (output[_fP] != null) {
        contents[_FP] = __strictParseInt32(output[_fP]);
    }
    if (output[_tPo] != null) {
        contents[_TP] = __strictParseInt32(output[_tPo]);
    }
    if (output.groups === "") {
        contents[_UIGP] = [];
    }
    else if (output[_gr] != null && output[_gr][_i] != null) {
        contents[_UIGP] = de_UserIdGroupPairList(__getArrayIfSingleItem(output[_gr][_i]), context);
    }
    if (output.ipRanges === "") {
        contents[_IRp] = [];
    }
    else if (output[_iRpa] != null && output[_iRpa][_i] != null) {
        contents[_IRp] = de_IpRangeList(__getArrayIfSingleItem(output[_iRpa][_i]), context);
    }
    if (output.ipv6Ranges === "") {
        contents[_IRpv] = [];
    }
    else if (output[_iRpv] != null && output[_iRpv][_i] != null) {
        contents[_IRpv] = de_Ipv6RangeList(__getArrayIfSingleItem(output[_iRpv][_i]), context);
    }
    if (output.prefixListIds === "") {
        contents[_PLIr] = [];
    }
    else if (output[_pLIr] != null && output[_pLIr][_i] != null) {
        contents[_PLIr] = de_PrefixListIdList(__getArrayIfSingleItem(output[_pLIr][_i]), context);
    }
    return contents;
};
const de_IpPermissionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpPermission(entry, context);
    });
};
const de_IpPrefixList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_IpRange = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_cIi] != null) {
        contents[_CIi] = __expectString(output[_cIi]);
    }
    return contents;
};
const de_IpRangeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IpRange(entry, context);
    });
};
const de_IpRanges = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Ipv4PrefixesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipv4PrefixSpecification(entry, context);
    });
};
const de_Ipv4PrefixList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipv4PrefixSpecificationRequest(entry, context);
    });
};
const de_Ipv4PrefixListResponse = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipv4PrefixSpecificationResponse(entry, context);
    });
};
const de_Ipv4PrefixSpecification = (output, context) => {
    const contents = {};
    if (output[_iPpv] != null) {
        contents[_IPpvr] = __expectString(output[_iPpv]);
    }
    return contents;
};
const de_Ipv4PrefixSpecificationRequest = (output, context) => {
    const contents = {};
    if (output[_IPpvr] != null) {
        contents[_IPpvr] = __expectString(output[_IPpvr]);
    }
    return contents;
};
const de_Ipv4PrefixSpecificationResponse = (output, context) => {
    const contents = {};
    if (output[_iPpv] != null) {
        contents[_IPpvr] = __expectString(output[_iPpv]);
    }
    return contents;
};
const de_Ipv6AddressList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Ipv6CidrAssociation = (output, context) => {
    const contents = {};
    if (output[_iCp] != null) {
        contents[_ICp] = __expectString(output[_iCp]);
    }
    if (output[_aRs] != null) {
        contents[_ARs] = __expectString(output[_aRs]);
    }
    return contents;
};
const de_Ipv6CidrAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipv6CidrAssociation(entry, context);
    });
};
const de_Ipv6CidrBlock = (output, context) => {
    const contents = {};
    if (output[_iCB] != null) {
        contents[_ICB] = __expectString(output[_iCB]);
    }
    return contents;
};
const de_Ipv6CidrBlockSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipv6CidrBlock(entry, context);
    });
};
const de_Ipv6Pool = (output, context) => {
    const contents = {};
    if (output[_pIo] != null) {
        contents[_PIo] = __expectString(output[_pIo]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.poolCidrBlockSet === "") {
        contents[_PCBo] = [];
    }
    else if (output[_pCBS] != null && output[_pCBS][_i] != null) {
        contents[_PCBo] = de_PoolCidrBlocksSet(__getArrayIfSingleItem(output[_pCBS][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_Ipv6PoolSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipv6Pool(entry, context);
    });
};
const de_Ipv6PrefixesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipv6PrefixSpecification(entry, context);
    });
};
const de_Ipv6PrefixList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipv6PrefixSpecificationRequest(entry, context);
    });
};
const de_Ipv6PrefixListResponse = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipv6PrefixSpecificationResponse(entry, context);
    });
};
const de_Ipv6PrefixSpecification = (output, context) => {
    const contents = {};
    if (output[_iPpvr] != null) {
        contents[_IPpvre] = __expectString(output[_iPpvr]);
    }
    return contents;
};
const de_Ipv6PrefixSpecificationRequest = (output, context) => {
    const contents = {};
    if (output[_IPpvre] != null) {
        contents[_IPpvre] = __expectString(output[_IPpvre]);
    }
    return contents;
};
const de_Ipv6PrefixSpecificationResponse = (output, context) => {
    const contents = {};
    if (output[_iPpvr] != null) {
        contents[_IPpvre] = __expectString(output[_iPpvr]);
    }
    return contents;
};
const de_Ipv6Range = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_cIid] != null) {
        contents[_CIid] = __expectString(output[_cIid]);
    }
    return contents;
};
const de_Ipv6RangeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Ipv6Range(entry, context);
    });
};
const de_KeyPair = (output, context) => {
    const contents = {};
    if (output[_kPI] != null) {
        contents[_KPI] = __expectString(output[_kPI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_kN] != null) {
        contents[_KN] = __expectString(output[_kN]);
    }
    if (output[_kFe] != null) {
        contents[_KFe] = __expectString(output[_kFe]);
    }
    if (output[_kM] != null) {
        contents[_KM] = __expectString(output[_kM]);
    }
    return contents;
};
const de_KeyPairInfo = (output, context) => {
    const contents = {};
    if (output[_kPI] != null) {
        contents[_KPI] = __expectString(output[_kPI]);
    }
    if (output[_kT] != null) {
        contents[_KT] = __expectString(output[_kT]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_pK] != null) {
        contents[_PK] = __expectString(output[_pK]);
    }
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output[_kN] != null) {
        contents[_KN] = __expectString(output[_kN]);
    }
    if (output[_kFe] != null) {
        contents[_KFe] = __expectString(output[_kFe]);
    }
    return contents;
};
const de_KeyPairList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KeyPairInfo(entry, context);
    });
};
const de_LastError = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    return contents;
};
const de_LaunchPermission = (output, context) => {
    const contents = {};
    if (output[_oAr] != null) {
        contents[_OAr] = __expectString(output[_oAr]);
    }
    if (output[_oUA] != null) {
        contents[_OUA] = __expectString(output[_oUA]);
    }
    if (output[_uI] != null) {
        contents[_UIs] = __expectString(output[_uI]);
    }
    if (output[_g] != null) {
        contents[_Gr] = __expectString(output[_g]);
    }
    return contents;
};
const de_LaunchPermissionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchPermission(entry, context);
    });
};
const de_LaunchSpecification = (output, context) => {
    const contents = {};
    if (output[_uDs] != null) {
        contents[_UD] = __expectString(output[_uDs]);
    }
    if (output[_aTdd] != null) {
        contents[_ATd] = __expectString(output[_aTdd]);
    }
    if (output.blockDeviceMapping === "") {
        contents[_BDM] = [];
    }
    else if (output[_bDM] != null && output[_bDM][_i] != null) {
        contents[_BDM] = de_BlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);
    }
    if (output[_eO] != null) {
        contents[_EO] = __parseBoolean(output[_eO]);
    }
    if (output[_iIP] != null) {
        contents[_IIP] = de_IamInstanceProfileSpecification(output[_iIP], context);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_kI] != null) {
        contents[_KI] = __expectString(output[_kI]);
    }
    if (output[_kN] != null) {
        contents[_KN] = __expectString(output[_kN]);
    }
    if (output.networkInterfaceSet === "") {
        contents[_NI] = [];
    }
    else if (output[_nIS] != null && output[_nIS][_i] != null) {
        contents[_NI] = de_InstanceNetworkInterfaceSpecificationList(__getArrayIfSingleItem(output[_nIS][_i]), context);
    }
    if (output[_pla] != null) {
        contents[_Pl] = de_SpotPlacement(output[_pla], context);
    }
    if (output[_rIa] != null) {
        contents[_RIa] = __expectString(output[_rIa]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output.groupSet === "") {
        contents[_SG] = [];
    }
    else if (output[_gS] != null && output[_gS][_i] != null) {
        contents[_SG] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);
    }
    if (output[_mo] != null) {
        contents[_Mon] = de_RunInstancesMonitoringEnabled(output[_mo], context);
    }
    return contents;
};
const de_LaunchSpecsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SpotFleetLaunchSpecification(entry, context);
    });
};
const de_LaunchTemplate = (output, context) => {
    const contents = {};
    if (output[_lTI] != null) {
        contents[_LTI] = __expectString(output[_lTI]);
    }
    if (output[_lTN] != null) {
        contents[_LTN] = __expectString(output[_lTN]);
    }
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output[_cBr] != null) {
        contents[_CBr] = __expectString(output[_cBr]);
    }
    if (output[_dVN] != null) {
        contents[_DVN] = __strictParseLong(output[_dVN]);
    }
    if (output[_lVN] != null) {
        contents[_LVN] = __strictParseLong(output[_lVN]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_op] != null) {
        contents[_O] = de_OperatorResponse(output[_op], context);
    }
    return contents;
};
const de_LaunchTemplateAndOverridesResponse = (output, context) => {
    const contents = {};
    if (output[_lTS] != null) {
        contents[_LTS] = de_FleetLaunchTemplateSpecification(output[_lTS], context);
    }
    if (output[_ov] != null) {
        contents[_Ov] = de_FleetLaunchTemplateOverrides(output[_ov], context);
    }
    return contents;
};
const de_LaunchTemplateBlockDeviceMapping = (output, context) => {
    const contents = {};
    if (output[_dN] != null) {
        contents[_DN] = __expectString(output[_dN]);
    }
    if (output[_vN] != null) {
        contents[_VN] = __expectString(output[_vN]);
    }
    if (output[_eb] != null) {
        contents[_E] = de_LaunchTemplateEbsBlockDevice(output[_eb], context);
    }
    if (output[_nD] != null) {
        contents[_ND] = __expectString(output[_nD]);
    }
    return contents;
};
const de_LaunchTemplateBlockDeviceMappingList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplateBlockDeviceMapping(entry, context);
    });
};
const de_LaunchTemplateCapacityReservationSpecificationResponse = (output, context) => {
    const contents = {};
    if (output[_cRP] != null) {
        contents[_CRP] = __expectString(output[_cRP]);
    }
    if (output[_cRT] != null) {
        contents[_CRTa] = de_CapacityReservationTargetResponse(output[_cRT], context);
    }
    return contents;
};
const de_LaunchTemplateConfig = (output, context) => {
    const contents = {};
    if (output[_lTS] != null) {
        contents[_LTS] = de_FleetLaunchTemplateSpecification(output[_lTS], context);
    }
    if (output.overrides === "") {
        contents[_Ov] = [];
    }
    else if (output[_ov] != null && output[_ov][_i] != null) {
        contents[_Ov] = de_LaunchTemplateOverridesList(__getArrayIfSingleItem(output[_ov][_i]), context);
    }
    return contents;
};
const de_LaunchTemplateConfigList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplateConfig(entry, context);
    });
};
const de_LaunchTemplateCpuOptions = (output, context) => {
    const contents = {};
    if (output[_cCo] != null) {
        contents[_CC] = __strictParseInt32(output[_cCo]);
    }
    if (output[_tPC] != null) {
        contents[_TPC] = __strictParseInt32(output[_tPC]);
    }
    if (output[_aSS] != null) {
        contents[_ASS] = __expectString(output[_aSS]);
    }
    return contents;
};
const de_LaunchTemplateEbsBlockDevice = (output, context) => {
    const contents = {};
    if (output[_enc] != null) {
        contents[_Enc] = __parseBoolean(output[_enc]);
    }
    if (output[_dOT] != null) {
        contents[_DOT] = __parseBoolean(output[_dOT]);
    }
    if (output[_io] != null) {
        contents[_Io] = __strictParseInt32(output[_io]);
    }
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_vSo] != null) {
        contents[_VS] = __strictParseInt32(output[_vSo]);
    }
    if (output[_vT] != null) {
        contents[_VT] = __expectString(output[_vT]);
    }
    if (output[_th] != null) {
        contents[_Th] = __strictParseInt32(output[_th]);
    }
    return contents;
};
const de_LaunchTemplateElasticInferenceAcceleratorResponse = (output, context) => {
    const contents = {};
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    return contents;
};
const de_LaunchTemplateElasticInferenceAcceleratorResponseList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplateElasticInferenceAcceleratorResponse(entry, context);
    });
};
const de_LaunchTemplateEnaSrdSpecification = (output, context) => {
    const contents = {};
    if (output[_eSE] != null) {
        contents[_ESE] = __parseBoolean(output[_eSE]);
    }
    if (output[_eSUS] != null) {
        contents[_ESUS] = de_LaunchTemplateEnaSrdUdpSpecification(output[_eSUS], context);
    }
    return contents;
};
const de_LaunchTemplateEnaSrdUdpSpecification = (output, context) => {
    const contents = {};
    if (output[_eSUE] != null) {
        contents[_ESUE] = __parseBoolean(output[_eSUE]);
    }
    return contents;
};
const de_LaunchTemplateEnclaveOptions = (output, context) => {
    const contents = {};
    if (output[_en] != null) {
        contents[_En] = __parseBoolean(output[_en]);
    }
    return contents;
};
const de_LaunchTemplateHibernationOptions = (output, context) => {
    const contents = {};
    if (output[_conf] != null) {
        contents[_Conf] = __parseBoolean(output[_conf]);
    }
    return contents;
};
const de_LaunchTemplateIamInstanceProfileSpecification = (output, context) => {
    const contents = {};
    if (output[_ar] != null) {
        contents[_Ar] = __expectString(output[_ar]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    return contents;
};
const de_LaunchTemplateInstanceMaintenanceOptions = (output, context) => {
    const contents = {};
    if (output[_aRu] != null) {
        contents[_ARu] = __expectString(output[_aRu]);
    }
    return contents;
};
const de_LaunchTemplateInstanceMarketOptions = (output, context) => {
    const contents = {};
    if (output[_mT] != null) {
        contents[_MT] = __expectString(output[_mT]);
    }
    if (output[_sO] != null) {
        contents[_SO] = de_LaunchTemplateSpotMarketOptions(output[_sO], context);
    }
    return contents;
};
const de_LaunchTemplateInstanceMetadataOptions = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_hT] != null) {
        contents[_HT] = __expectString(output[_hT]);
    }
    if (output[_hPRHL] != null) {
        contents[_HPRHL] = __strictParseInt32(output[_hPRHL]);
    }
    if (output[_hE] != null) {
        contents[_HE] = __expectString(output[_hE]);
    }
    if (output[_hPI] != null) {
        contents[_HPI] = __expectString(output[_hPI]);
    }
    if (output[_iMT] != null) {
        contents[_IMT] = __expectString(output[_iMT]);
    }
    return contents;
};
const de_LaunchTemplateInstanceNetworkInterfaceSpecification = (output, context) => {
    const contents = {};
    if (output[_aCIA] != null) {
        contents[_ACIA] = __parseBoolean(output[_aCIA]);
    }
    if (output[_aPIA] != null) {
        contents[_APIAs] = __parseBoolean(output[_aPIA]);
    }
    if (output[_dOT] != null) {
        contents[_DOT] = __parseBoolean(output[_dOT]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_dIe] != null) {
        contents[_DIev] = __strictParseInt32(output[_dIe]);
    }
    if (output.groupSet === "") {
        contents[_G] = [];
    }
    else if (output[_gS] != null && output[_gS][_gIr] != null) {
        contents[_G] = de_GroupIdStringList(__getArrayIfSingleItem(output[_gS][_gIr]), context);
    }
    if (output[_iTnt] != null) {
        contents[_ITn] = __expectString(output[_iTnt]);
    }
    if (output[_iAC] != null) {
        contents[_IAC] = __strictParseInt32(output[_iAC]);
    }
    if (output.ipv6AddressesSet === "") {
        contents[_IA] = [];
    }
    else if (output[_iASp] != null && output[_iASp][_i] != null) {
        contents[_IA] = de_InstanceIpv6AddressList(__getArrayIfSingleItem(output[_iASp][_i]), context);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_pIA] != null) {
        contents[_PIAr] = __expectString(output[_pIA]);
    }
    if (output.privateIpAddressesSet === "") {
        contents[_PIA] = [];
    }
    else if (output[_pIAS] != null && output[_pIAS][_i] != null) {
        contents[_PIA] = de_PrivateIpAddressSpecificationList(__getArrayIfSingleItem(output[_pIAS][_i]), context);
    }
    if (output[_sPIAC] != null) {
        contents[_SPIAC] = __strictParseInt32(output[_sPIAC]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_nCI] != null) {
        contents[_NCI] = __strictParseInt32(output[_nCI]);
    }
    if (output.ipv4PrefixSet === "") {
        contents[_IPp] = [];
    }
    else if (output[_iPSpv] != null && output[_iPSpv][_i] != null) {
        contents[_IPp] = de_Ipv4PrefixListResponse(__getArrayIfSingleItem(output[_iPSpv][_i]), context);
    }
    if (output[_iPCp] != null) {
        contents[_IPCp] = __strictParseInt32(output[_iPCp]);
    }
    if (output.ipv6PrefixSet === "") {
        contents[_IP] = [];
    }
    else if (output[_iPSpvr] != null && output[_iPSpvr][_i] != null) {
        contents[_IP] = de_Ipv6PrefixListResponse(__getArrayIfSingleItem(output[_iPSpvr][_i]), context);
    }
    if (output[_iPCpv] != null) {
        contents[_IPC] = __strictParseInt32(output[_iPCpv]);
    }
    if (output[_pIri] != null) {
        contents[_PIr] = __parseBoolean(output[_pIri]);
    }
    if (output[_eSS] != null) {
        contents[_ESS] = de_LaunchTemplateEnaSrdSpecification(output[_eSS], context);
    }
    if (output[_cTS] != null) {
        contents[_CTS] = de_ConnectionTrackingSpecification(output[_cTS], context);
    }
    return contents;
};
const de_LaunchTemplateInstanceNetworkInterfaceSpecificationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplateInstanceNetworkInterfaceSpecification(entry, context);
    });
};
const de_LaunchTemplateLicenseConfiguration = (output, context) => {
    const contents = {};
    if (output[_lCA] != null) {
        contents[_LCA] = __expectString(output[_lCA]);
    }
    return contents;
};
const de_LaunchTemplateLicenseList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplateLicenseConfiguration(entry, context);
    });
};
const de_LaunchTemplateNetworkPerformanceOptions = (output, context) => {
    const contents = {};
    if (output[_bW] != null) {
        contents[_BW] = __expectString(output[_bW]);
    }
    return contents;
};
const de_LaunchTemplateOverrides = (output, context) => {
    const contents = {};
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_sPp] != null) {
        contents[_SPp] = __expectString(output[_sPp]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_wC] != null) {
        contents[_WCe] = __strictParseFloat(output[_wC]);
    }
    if (output[_pri] != null) {
        contents[_Pri] = __strictParseFloat(output[_pri]);
    }
    if (output[_iR] != null) {
        contents[_IR] = de_InstanceRequirements(output[_iR], context);
    }
    return contents;
};
const de_LaunchTemplateOverridesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplateOverrides(entry, context);
    });
};
const de_LaunchTemplatePlacement = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_af] != null) {
        contents[_Af] = __expectString(output[_af]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output[_hI] != null) {
        contents[_HIo] = __expectString(output[_hI]);
    }
    if (output[_t] != null) {
        contents[_Te] = __expectString(output[_t]);
    }
    if (output[_sDp] != null) {
        contents[_SDp] = __expectString(output[_sDp]);
    }
    if (output[_hRGA] != null) {
        contents[_HRGA] = __expectString(output[_hRGA]);
    }
    if (output[_pN] != null) {
        contents[_PN] = __strictParseInt32(output[_pN]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    return contents;
};
const de_LaunchTemplatePrivateDnsNameOptions = (output, context) => {
    const contents = {};
    if (output[_hTo] != null) {
        contents[_HTo] = __expectString(output[_hTo]);
    }
    if (output[_eRNDAR] != null) {
        contents[_ERNDAR] = __parseBoolean(output[_eRNDAR]);
    }
    if (output[_eRNDAAAAR] != null) {
        contents[_ERNDAAAAR] = __parseBoolean(output[_eRNDAAAAR]);
    }
    return contents;
};
const de_LaunchTemplateSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplate(entry, context);
    });
};
const de_LaunchTemplatesMonitoring = (output, context) => {
    const contents = {};
    if (output[_en] != null) {
        contents[_En] = __parseBoolean(output[_en]);
    }
    return contents;
};
const de_LaunchTemplateSpotMarketOptions = (output, context) => {
    const contents = {};
    if (output[_mP] != null) {
        contents[_MPa] = __expectString(output[_mP]);
    }
    if (output[_sIT] != null) {
        contents[_SIT] = __expectString(output[_sIT]);
    }
    if (output[_bDMl] != null) {
        contents[_BDMl] = __strictParseInt32(output[_bDMl]);
    }
    if (output[_vU] != null) {
        contents[_VU] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vU]));
    }
    if (output[_iIB] != null) {
        contents[_IIB] = __expectString(output[_iIB]);
    }
    return contents;
};
const de_LaunchTemplateTagSpecification = (output, context) => {
    const contents = {};
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_LaunchTemplateTagSpecificationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplateTagSpecification(entry, context);
    });
};
const de_LaunchTemplateVersion = (output, context) => {
    const contents = {};
    if (output[_lTI] != null) {
        contents[_LTI] = __expectString(output[_lTI]);
    }
    if (output[_lTN] != null) {
        contents[_LTN] = __expectString(output[_lTN]);
    }
    if (output[_vNe] != null) {
        contents[_VNe] = __strictParseLong(output[_vNe]);
    }
    if (output[_vD] != null) {
        contents[_VD] = __expectString(output[_vD]);
    }
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output[_cBr] != null) {
        contents[_CBr] = __expectString(output[_cBr]);
    }
    if (output[_dVe] != null) {
        contents[_DVef] = __parseBoolean(output[_dVe]);
    }
    if (output[_lTD] != null) {
        contents[_LTD] = de_ResponseLaunchTemplateData(output[_lTD], context);
    }
    if (output[_op] != null) {
        contents[_O] = de_OperatorResponse(output[_op], context);
    }
    return contents;
};
const de_LaunchTemplateVersionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplateVersion(entry, context);
    });
};
const de_LicenseConfiguration = (output, context) => {
    const contents = {};
    if (output[_lCA] != null) {
        contents[_LCA] = __expectString(output[_lCA]);
    }
    return contents;
};
const de_LicenseList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LicenseConfiguration(entry, context);
    });
};
const de_ListImagesInRecycleBinResult = (output, context) => {
    const contents = {};
    if (output.imageSet === "") {
        contents[_Ima] = [];
    }
    else if (output[_iSmag] != null && output[_iSmag][_i] != null) {
        contents[_Ima] = de_ImageRecycleBinInfoList(__getArrayIfSingleItem(output[_iSmag][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_ListSnapshotsInRecycleBinResult = (output, context) => {
    const contents = {};
    if (output.snapshotSet === "") {
        contents[_Sn] = [];
    }
    else if (output[_sS] != null && output[_sS][_i] != null) {
        contents[_Sn] = de_SnapshotRecycleBinInfoList(__getArrayIfSingleItem(output[_sS][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_LoadBalancersConfig = (output, context) => {
    const contents = {};
    if (output[_cLBC] != null) {
        contents[_CLBC] = de_ClassicLoadBalancersConfig(output[_cLBC], context);
    }
    if (output[_tGCa] != null) {
        contents[_TGC] = de_TargetGroupsConfig(output[_tGCa], context);
    }
    return contents;
};
const de_LoadPermission = (output, context) => {
    const contents = {};
    if (output[_uI] != null) {
        contents[_UIs] = __expectString(output[_uI]);
    }
    if (output[_g] != null) {
        contents[_Gr] = __expectString(output[_g]);
    }
    return contents;
};
const de_LoadPermissionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadPermission(entry, context);
    });
};
const de_LocalGateway = (output, context) => {
    const contents = {};
    if (output[_lGI] != null) {
        contents[_LGI] = __expectString(output[_lGI]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_LocalGatewayRoute = (output, context) => {
    const contents = {};
    if (output[_dCB] != null) {
        contents[_DCB] = __expectString(output[_dCB]);
    }
    if (output[_lGVIGI] != null) {
        contents[_LGVIGI] = __expectString(output[_lGVIGI]);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_lGRTI] != null) {
        contents[_LGRTI] = __expectString(output[_lGRTI]);
    }
    if (output[_lGRTA] != null) {
        contents[_LGRTA] = __expectString(output[_lGRTA]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_cPI] != null) {
        contents[_CPIo] = __expectString(output[_cPI]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_dPLI] != null) {
        contents[_DPLI] = __expectString(output[_dPLI]);
    }
    return contents;
};
const de_LocalGatewayRouteList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LocalGatewayRoute(entry, context);
    });
};
const de_LocalGatewayRouteTable = (output, context) => {
    const contents = {};
    if (output[_lGRTI] != null) {
        contents[_LGRTI] = __expectString(output[_lGRTI]);
    }
    if (output[_lGRTA] != null) {
        contents[_LGRTA] = __expectString(output[_lGRTA]);
    }
    if (output[_lGI] != null) {
        contents[_LGI] = __expectString(output[_lGI]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_mod] != null) {
        contents[_Mo] = __expectString(output[_mod]);
    }
    if (output[_sRt] != null) {
        contents[_SRt] = de_StateReason(output[_sRt], context);
    }
    return contents;
};
const de_LocalGatewayRouteTableSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LocalGatewayRouteTable(entry, context);
    });
};
const de_LocalGatewayRouteTableVirtualInterfaceGroupAssociation = (output, context) => {
    const contents = {};
    if (output[_lGRTVIGAI] != null) {
        contents[_LGRTVIGAI] = __expectString(output[_lGRTVIGAI]);
    }
    if (output[_lGVIGI] != null) {
        contents[_LGVIGI] = __expectString(output[_lGVIGI]);
    }
    if (output[_lGI] != null) {
        contents[_LGI] = __expectString(output[_lGI]);
    }
    if (output[_lGRTI] != null) {
        contents[_LGRTI] = __expectString(output[_lGRTI]);
    }
    if (output[_lGRTA] != null) {
        contents[_LGRTA] = __expectString(output[_lGRTA]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LocalGatewayRouteTableVirtualInterfaceGroupAssociation(entry, context);
    });
};
const de_LocalGatewayRouteTableVpcAssociation = (output, context) => {
    const contents = {};
    if (output[_lGRTVAI] != null) {
        contents[_LGRTVAI] = __expectString(output[_lGRTVAI]);
    }
    if (output[_lGRTI] != null) {
        contents[_LGRTI] = __expectString(output[_lGRTI]);
    }
    if (output[_lGRTA] != null) {
        contents[_LGRTA] = __expectString(output[_lGRTA]);
    }
    if (output[_lGI] != null) {
        contents[_LGI] = __expectString(output[_lGI]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_LocalGatewayRouteTableVpcAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LocalGatewayRouteTableVpcAssociation(entry, context);
    });
};
const de_LocalGatewaySet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LocalGateway(entry, context);
    });
};
const de_LocalGatewayVirtualInterface = (output, context) => {
    const contents = {};
    if (output[_lGVII] != null) {
        contents[_LGVIIo] = __expectString(output[_lGVII]);
    }
    if (output[_lGI] != null) {
        contents[_LGI] = __expectString(output[_lGI]);
    }
    if (output[_vl] != null) {
        contents[_Vl] = __strictParseInt32(output[_vl]);
    }
    if (output[_lA] != null) {
        contents[_LA] = __expectString(output[_lA]);
    }
    if (output[_pAe] != null) {
        contents[_PAe] = __expectString(output[_pAe]);
    }
    if (output[_lBAo] != null) {
        contents[_LBAo] = __strictParseInt32(output[_lBAo]);
    }
    if (output[_pBA] != null) {
        contents[_PBA] = __strictParseInt32(output[_pBA]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_LocalGatewayVirtualInterfaceGroup = (output, context) => {
    const contents = {};
    if (output[_lGVIGI] != null) {
        contents[_LGVIGI] = __expectString(output[_lGVIGI]);
    }
    if (output.localGatewayVirtualInterfaceIdSet === "") {
        contents[_LGVII] = [];
    }
    else if (output[_lGVIIS] != null && output[_lGVIIS][_i] != null) {
        contents[_LGVII] = de_LocalGatewayVirtualInterfaceIdSet(__getArrayIfSingleItem(output[_lGVIIS][_i]), context);
    }
    if (output[_lGI] != null) {
        contents[_LGI] = __expectString(output[_lGI]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_LocalGatewayVirtualInterfaceGroupSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LocalGatewayVirtualInterfaceGroup(entry, context);
    });
};
const de_LocalGatewayVirtualInterfaceIdSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_LocalGatewayVirtualInterfaceSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LocalGatewayVirtualInterface(entry, context);
    });
};
const de_LocalStorageTypeSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_LockedSnapshotsInfo = (output, context) => {
    const contents = {};
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_lSoc] != null) {
        contents[_LSoc] = __expectString(output[_lSoc]);
    }
    if (output[_lDo] != null) {
        contents[_LDo] = __strictParseInt32(output[_lDo]);
    }
    if (output[_cOP] != null) {
        contents[_COP] = __strictParseInt32(output[_cOP]);
    }
    if (output[_cOPEO] != null) {
        contents[_COPEO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cOPEO]));
    }
    if (output[_lCO] != null) {
        contents[_LCO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lCO]));
    }
    if (output[_lDST] != null) {
        contents[_LDST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lDST]));
    }
    if (output[_lEO] != null) {
        contents[_LEO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lEO]));
    }
    return contents;
};
const de_LockedSnapshotsInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LockedSnapshotsInfo(entry, context);
    });
};
const de_LockSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_lSoc] != null) {
        contents[_LSoc] = __expectString(output[_lSoc]);
    }
    if (output[_lDo] != null) {
        contents[_LDo] = __strictParseInt32(output[_lDo]);
    }
    if (output[_cOP] != null) {
        contents[_COP] = __strictParseInt32(output[_cOP]);
    }
    if (output[_cOPEO] != null) {
        contents[_COPEO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cOPEO]));
    }
    if (output[_lCO] != null) {
        contents[_LCO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lCO]));
    }
    if (output[_lEO] != null) {
        contents[_LEO] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lEO]));
    }
    if (output[_lDST] != null) {
        contents[_LDST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lDST]));
    }
    return contents;
};
const de_MacHost = (output, context) => {
    const contents = {};
    if (output[_hI] != null) {
        contents[_HIo] = __expectString(output[_hI]);
    }
    if (output.macOSLatestSupportedVersionSet === "") {
        contents[_MOSLSV] = [];
    }
    else if (output[_mOSLSVS] != null && output[_mOSLSVS][_i] != null) {
        contents[_MOSLSV] = de_MacOSVersionStringList(__getArrayIfSingleItem(output[_mOSLSVS][_i]), context);
    }
    return contents;
};
const de_MacHostList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MacHost(entry, context);
    });
};
const de_MacOSVersionStringList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_MaintenanceDetails = (output, context) => {
    const contents = {};
    if (output[_pM] != null) {
        contents[_PM] = __expectString(output[_pM]);
    }
    if (output[_mAAA] != null) {
        contents[_MAAA] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_mAAA]));
    }
    if (output[_lMA] != null) {
        contents[_LMA] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lMA]));
    }
    return contents;
};
const de_ManagedPrefixList = (output, context) => {
    const contents = {};
    if (output[_pLI] != null) {
        contents[_PLI] = __expectString(output[_pLI]);
    }
    if (output[_aF] != null) {
        contents[_AF] = __expectString(output[_aF]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMta] != null) {
        contents[_SMta] = __expectString(output[_sMta]);
    }
    if (output[_pLA] != null) {
        contents[_PLAr] = __expectString(output[_pLA]);
    }
    if (output[_pLN] != null) {
        contents[_PLN] = __expectString(output[_pLN]);
    }
    if (output[_mE] != null) {
        contents[_ME] = __strictParseInt32(output[_mE]);
    }
    if (output[_ve] != null) {
        contents[_V] = __strictParseLong(output[_ve]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    return contents;
};
const de_ManagedPrefixListSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ManagedPrefixList(entry, context);
    });
};
const de_MediaAcceleratorInfo = (output, context) => {
    const contents = {};
    if (output.accelerators === "") {
        contents[_Acc] = [];
    }
    else if (output[_acc] != null && output[_acc][_i] != null) {
        contents[_Acc] = de_MediaDeviceInfoList(__getArrayIfSingleItem(output[_acc][_i]), context);
    }
    if (output[_tMMIMB] != null) {
        contents[_TMMIMB] = __strictParseInt32(output[_tMMIMB]);
    }
    return contents;
};
const de_MediaDeviceInfo = (output, context) => {
    const contents = {};
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_man] != null) {
        contents[_Man] = __expectString(output[_man]);
    }
    if (output[_mIe] != null) {
        contents[_MIe] = de_MediaDeviceMemoryInfo(output[_mIe], context);
    }
    return contents;
};
const de_MediaDeviceInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MediaDeviceInfo(entry, context);
    });
};
const de_MediaDeviceMemoryInfo = (output, context) => {
    const contents = {};
    if (output[_sIMB] != null) {
        contents[_SIMB] = __strictParseInt32(output[_sIMB]);
    }
    return contents;
};
const de_MemoryGiBPerVCpu = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_M] = __strictParseFloat(output[_m]);
    }
    if (output[_ma] != null) {
        contents[_Ma] = __strictParseFloat(output[_ma]);
    }
    return contents;
};
const de_MemoryInfo = (output, context) => {
    const contents = {};
    if (output[_sIMB] != null) {
        contents[_SIMB] = __strictParseLong(output[_sIMB]);
    }
    return contents;
};
const de_MemoryMiB = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_M] = __strictParseInt32(output[_m]);
    }
    if (output[_ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_ma]);
    }
    return contents;
};
const de_MetricPoint = (output, context) => {
    const contents = {};
    if (output[_sD] != null) {
        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));
    }
    if (output[_eD] != null) {
        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));
    }
    if (output[_v] != null) {
        contents[_Va] = __strictParseFloat(output[_v]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_MetricPoints = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricPoint(entry, context);
    });
};
const de_ModifyAddressAttributeResult = (output, context) => {
    const contents = {};
    if (output[_ad] != null) {
        contents[_Ad] = de_AddressAttribute(output[_ad], context);
    }
    return contents;
};
const de_ModifyAvailabilityZoneGroupResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyCapacityReservationFleetResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyCapacityReservationResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyClientVpnEndpointResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyDefaultCreditSpecificationResult = (output, context) => {
    const contents = {};
    if (output[_iFCS] != null) {
        contents[_IFCS] = de_InstanceFamilyCreditSpecification(output[_iFCS], context);
    }
    return contents;
};
const de_ModifyEbsDefaultKmsKeyIdResult = (output, context) => {
    const contents = {};
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    return contents;
};
const de_ModifyFleetResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyFpgaImageAttributeResult = (output, context) => {
    const contents = {};
    if (output[_fIA] != null) {
        contents[_FIAp] = de_FpgaImageAttribute(output[_fIA], context);
    }
    return contents;
};
const de_ModifyHostsResult = (output, context) => {
    const contents = {};
    if (output.successful === "") {
        contents[_Suc] = [];
    }
    else if (output[_suc] != null && output[_suc][_i] != null) {
        contents[_Suc] = de_ResponseHostIdList(__getArrayIfSingleItem(output[_suc][_i]), context);
    }
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_UnsuccessfulItemList(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_ModifyInstanceCapacityReservationAttributesResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyInstanceCpuOptionsResult = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_cCo] != null) {
        contents[_CC] = __strictParseInt32(output[_cCo]);
    }
    if (output[_tPC] != null) {
        contents[_TPC] = __strictParseInt32(output[_tPC]);
    }
    return contents;
};
const de_ModifyInstanceCreditSpecificationResult = (output, context) => {
    const contents = {};
    if (output.successfulInstanceCreditSpecificationSet === "") {
        contents[_SICS] = [];
    }
    else if (output[_sICSS] != null && output[_sICSS][_i] != null) {
        contents[_SICS] = de_SuccessfulInstanceCreditSpecificationSet(__getArrayIfSingleItem(output[_sICSS][_i]), context);
    }
    if (output.unsuccessfulInstanceCreditSpecificationSet === "") {
        contents[_UICS] = [];
    }
    else if (output[_uICSS] != null && output[_uICSS][_i] != null) {
        contents[_UICS] = de_UnsuccessfulInstanceCreditSpecificationSet(__getArrayIfSingleItem(output[_uICSS][_i]), context);
    }
    return contents;
};
const de_ModifyInstanceEventStartTimeResult = (output, context) => {
    const contents = {};
    if (output[_ev] != null) {
        contents[_Eve] = de_InstanceStatusEvent(output[_ev], context);
    }
    return contents;
};
const de_ModifyInstanceEventWindowResult = (output, context) => {
    const contents = {};
    if (output[_iEW] != null) {
        contents[_IEW] = de_InstanceEventWindow(output[_iEW], context);
    }
    return contents;
};
const de_ModifyInstanceMaintenanceOptionsResult = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_aRu] != null) {
        contents[_ARu] = __expectString(output[_aRu]);
    }
    return contents;
};
const de_ModifyInstanceMetadataDefaultsResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyInstanceMetadataOptionsResult = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iMO] != null) {
        contents[_IMOn] = de_InstanceMetadataOptionsResponse(output[_iMO], context);
    }
    return contents;
};
const de_ModifyInstanceNetworkPerformanceResult = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_bW] != null) {
        contents[_BW] = __expectString(output[_bW]);
    }
    return contents;
};
const de_ModifyInstancePlacementResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyIpamPoolResult = (output, context) => {
    const contents = {};
    if (output[_iPp] != null) {
        contents[_IPpa] = de_IpamPool(output[_iPp], context);
    }
    return contents;
};
const de_ModifyIpamResourceCidrResult = (output, context) => {
    const contents = {};
    if (output[_iRC] != null) {
        contents[_IRCp] = de_IpamResourceCidr(output[_iRC], context);
    }
    return contents;
};
const de_ModifyIpamResourceDiscoveryResult = (output, context) => {
    const contents = {};
    if (output[_iRD] != null) {
        contents[_IRD] = de_IpamResourceDiscovery(output[_iRD], context);
    }
    return contents;
};
const de_ModifyIpamResult = (output, context) => {
    const contents = {};
    if (output[_ip] != null) {
        contents[_Ipa] = de_Ipam(output[_ip], context);
    }
    return contents;
};
const de_ModifyIpamScopeResult = (output, context) => {
    const contents = {};
    if (output[_iS] != null) {
        contents[_ISpa] = de_IpamScope(output[_iS], context);
    }
    return contents;
};
const de_ModifyLaunchTemplateResult = (output, context) => {
    const contents = {};
    if (output[_lT] != null) {
        contents[_LTa] = de_LaunchTemplate(output[_lT], context);
    }
    return contents;
};
const de_ModifyLocalGatewayRouteResult = (output, context) => {
    const contents = {};
    if (output[_ro] != null) {
        contents[_Rou] = de_LocalGatewayRoute(output[_ro], context);
    }
    return contents;
};
const de_ModifyManagedPrefixListResult = (output, context) => {
    const contents = {};
    if (output[_pL] != null) {
        contents[_PLr] = de_ManagedPrefixList(output[_pL], context);
    }
    return contents;
};
const de_ModifyPrivateDnsNameOptionsResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyReservedInstancesResult = (output, context) => {
    const contents = {};
    if (output[_rIMI] != null) {
        contents[_RIMIe] = __expectString(output[_rIMI]);
    }
    return contents;
};
const de_ModifyRouteServerResult = (output, context) => {
    const contents = {};
    if (output[_rSo] != null) {
        contents[_RSo] = de_RouteServer(output[_rSo], context);
    }
    return contents;
};
const de_ModifySecurityGroupRulesResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifySnapshotTierResult = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_tST] != null) {
        contents[_TST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tST]));
    }
    return contents;
};
const de_ModifySpotFleetRequestResponse = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyTrafficMirrorFilterNetworkServicesResult = (output, context) => {
    const contents = {};
    if (output[_tMF] != null) {
        contents[_TMF] = de_TrafficMirrorFilter(output[_tMF], context);
    }
    return contents;
};
const de_ModifyTrafficMirrorFilterRuleResult = (output, context) => {
    const contents = {};
    if (output[_tMFR] != null) {
        contents[_TMFR] = de_TrafficMirrorFilterRule(output[_tMFR], context);
    }
    return contents;
};
const de_ModifyTrafficMirrorSessionResult = (output, context) => {
    const contents = {};
    if (output[_tMS] != null) {
        contents[_TMS] = de_TrafficMirrorSession(output[_tMS], context);
    }
    return contents;
};
const de_ModifyTransitGatewayPrefixListReferenceResult = (output, context) => {
    const contents = {};
    if (output[_tGPLR] != null) {
        contents[_TGPLR] = de_TransitGatewayPrefixListReference(output[_tGPLR], context);
    }
    return contents;
};
const de_ModifyTransitGatewayResult = (output, context) => {
    const contents = {};
    if (output[_tG] != null) {
        contents[_TGr] = de_TransitGateway(output[_tG], context);
    }
    return contents;
};
const de_ModifyTransitGatewayVpcAttachmentResult = (output, context) => {
    const contents = {};
    if (output[_tGVA] != null) {
        contents[_TGVA] = de_TransitGatewayVpcAttachment(output[_tGVA], context);
    }
    return contents;
};
const de_ModifyVerifiedAccessEndpointPolicyResult = (output, context) => {
    const contents = {};
    if (output[_pE] != null) {
        contents[_PE] = __parseBoolean(output[_pE]);
    }
    if (output[_pDo] != null) {
        contents[_PD] = __expectString(output[_pDo]);
    }
    if (output[_sSs] != null) {
        contents[_SS] = de_VerifiedAccessSseSpecificationResponse(output[_sSs], context);
    }
    return contents;
};
const de_ModifyVerifiedAccessEndpointResult = (output, context) => {
    const contents = {};
    if (output[_vAE] != null) {
        contents[_VAE] = de_VerifiedAccessEndpoint(output[_vAE], context);
    }
    return contents;
};
const de_ModifyVerifiedAccessGroupPolicyResult = (output, context) => {
    const contents = {};
    if (output[_pE] != null) {
        contents[_PE] = __parseBoolean(output[_pE]);
    }
    if (output[_pDo] != null) {
        contents[_PD] = __expectString(output[_pDo]);
    }
    if (output[_sSs] != null) {
        contents[_SS] = de_VerifiedAccessSseSpecificationResponse(output[_sSs], context);
    }
    return contents;
};
const de_ModifyVerifiedAccessGroupResult = (output, context) => {
    const contents = {};
    if (output[_vAG] != null) {
        contents[_VAG] = de_VerifiedAccessGroup(output[_vAG], context);
    }
    return contents;
};
const de_ModifyVerifiedAccessInstanceLoggingConfigurationResult = (output, context) => {
    const contents = {};
    if (output[_lC] != null) {
        contents[_LCo] = de_VerifiedAccessInstanceLoggingConfiguration(output[_lC], context);
    }
    return contents;
};
const de_ModifyVerifiedAccessInstanceResult = (output, context) => {
    const contents = {};
    if (output[_vAI] != null) {
        contents[_VAI] = de_VerifiedAccessInstance(output[_vAI], context);
    }
    return contents;
};
const de_ModifyVerifiedAccessTrustProviderResult = (output, context) => {
    const contents = {};
    if (output[_vATP] != null) {
        contents[_VATP] = de_VerifiedAccessTrustProvider(output[_vATP], context);
    }
    return contents;
};
const de_ModifyVolumeResult = (output, context) => {
    const contents = {};
    if (output[_vM] != null) {
        contents[_VMol] = de_VolumeModification(output[_vM], context);
    }
    return contents;
};
const de_ModifyVpcBlockPublicAccessExclusionResult = (output, context) => {
    const contents = {};
    if (output[_vBPAE] != null) {
        contents[_VBPAE] = de_VpcBlockPublicAccessExclusion(output[_vBPAE], context);
    }
    return contents;
};
const de_ModifyVpcBlockPublicAccessOptionsResult = (output, context) => {
    const contents = {};
    if (output[_vBPAO] != null) {
        contents[_VBPAO] = de_VpcBlockPublicAccessOptions(output[_vBPAO], context);
    }
    return contents;
};
const de_ModifyVpcEndpointConnectionNotificationResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_RV] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyVpcEndpointResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyVpcEndpointServiceConfigurationResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyVpcEndpointServicePayerResponsibilityResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_RV] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyVpcEndpointServicePermissionsResult = (output, context) => {
    const contents = {};
    if (output.addedPrincipalSet === "") {
        contents[_APd] = [];
    }
    else if (output[_aPS] != null && output[_aPS][_i] != null) {
        contents[_APd] = de_AddedPrincipalSet(__getArrayIfSingleItem(output[_aPS][_i]), context);
    }
    if (output[_r] != null) {
        contents[_RV] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyVpcPeeringConnectionOptionsResult = (output, context) => {
    const contents = {};
    if (output[_aPCO] != null) {
        contents[_APCO] = de_PeeringConnectionOptions(output[_aPCO], context);
    }
    if (output[_rPCO] != null) {
        contents[_RPCO] = de_PeeringConnectionOptions(output[_rPCO], context);
    }
    return contents;
};
const de_ModifyVpcTenancyResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_RV] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ModifyVpnConnectionOptionsResult = (output, context) => {
    const contents = {};
    if (output[_vC] != null) {
        contents[_VC] = de_VpnConnection(output[_vC], context);
    }
    return contents;
};
const de_ModifyVpnConnectionResult = (output, context) => {
    const contents = {};
    if (output[_vC] != null) {
        contents[_VC] = de_VpnConnection(output[_vC], context);
    }
    return contents;
};
const de_ModifyVpnTunnelCertificateResult = (output, context) => {
    const contents = {};
    if (output[_vC] != null) {
        contents[_VC] = de_VpnConnection(output[_vC], context);
    }
    return contents;
};
const de_ModifyVpnTunnelOptionsResult = (output, context) => {
    const contents = {};
    if (output[_vC] != null) {
        contents[_VC] = de_VpnConnection(output[_vC], context);
    }
    return contents;
};
const de_Monitoring = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_MonitorInstancesResult = (output, context) => {
    const contents = {};
    if (output.instancesSet === "") {
        contents[_IMn] = [];
    }
    else if (output[_iSn] != null && output[_iSn][_i] != null) {
        contents[_IMn] = de_InstanceMonitoringList(__getArrayIfSingleItem(output[_iSn][_i]), context);
    }
    return contents;
};
const de_MoveAddressToVpcResult = (output, context) => {
    const contents = {};
    if (output[_aI] != null) {
        contents[_AIl] = __expectString(output[_aI]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_MoveByoipCidrToIpamResult = (output, context) => {
    const contents = {};
    if (output[_bC] != null) {
        contents[_BC] = de_ByoipCidr(output[_bC], context);
    }
    return contents;
};
const de_MoveCapacityReservationInstancesResult = (output, context) => {
    const contents = {};
    if (output[_sCR] != null) {
        contents[_SCR] = de_CapacityReservation(output[_sCR], context);
    }
    if (output[_dCR] != null) {
        contents[_DCRe] = de_CapacityReservation(output[_dCR], context);
    }
    if (output[_iC] != null) {
        contents[_IC] = __strictParseInt32(output[_iC]);
    }
    return contents;
};
const de_MovingAddressStatus = (output, context) => {
    const contents = {};
    if (output[_mSo] != null) {
        contents[_MSo] = __expectString(output[_mSo]);
    }
    if (output[_pI] != null) {
        contents[_PI] = __expectString(output[_pI]);
    }
    return contents;
};
const de_MovingAddressStatusSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MovingAddressStatus(entry, context);
    });
};
const de_NatGateway = (output, context) => {
    const contents = {};
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output[_dTel] != null) {
        contents[_DTele] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTel]));
    }
    if (output[_fCa] != null) {
        contents[_FCa] = __expectString(output[_fCa]);
    }
    if (output[_fM] != null) {
        contents[_FM] = __expectString(output[_fM]);
    }
    if (output.natGatewayAddressSet === "") {
        contents[_NGA] = [];
    }
    else if (output[_nGAS] != null && output[_nGAS][_i] != null) {
        contents[_NGA] = de_NatGatewayAddressList(__getArrayIfSingleItem(output[_nGAS][_i]), context);
    }
    if (output[_nGI] != null) {
        contents[_NGI] = __expectString(output[_nGI]);
    }
    if (output[_pB] != null) {
        contents[_PB] = de_ProvisionedBandwidth(output[_pB], context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_cTonn] != null) {
        contents[_CTo] = __expectString(output[_cTonn]);
    }
    return contents;
};
const de_NatGatewayAddress = (output, context) => {
    const contents = {};
    if (output[_aI] != null) {
        contents[_AIl] = __expectString(output[_aI]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_pIriv] != null) {
        contents[_PIri] = __expectString(output[_pIriv]);
    }
    if (output[_pI] != null) {
        contents[_PI] = __expectString(output[_pI]);
    }
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_iPsr] != null) {
        contents[_IPsr] = __parseBoolean(output[_iPsr]);
    }
    if (output[_fM] != null) {
        contents[_FM] = __expectString(output[_fM]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_NatGatewayAddressList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NatGatewayAddress(entry, context);
    });
};
const de_NatGatewayList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NatGateway(entry, context);
    });
};
const de_NativeApplicationOidcOptions = (output, context) => {
    const contents = {};
    if (output[_pSKE] != null) {
        contents[_PSKE] = __expectString(output[_pSKE]);
    }
    if (output[_is] != null) {
        contents[_I] = __expectString(output[_is]);
    }
    if (output[_aE] != null) {
        contents[_AE] = __expectString(output[_aE]);
    }
    if (output[_tEo] != null) {
        contents[_TEo] = __expectString(output[_tEo]);
    }
    if (output[_uIE] != null) {
        contents[_UIE] = __expectString(output[_uIE]);
    }
    if (output[_cIli] != null) {
        contents[_CIl] = __expectString(output[_cIli]);
    }
    if (output[_sc] != null) {
        contents[_Sc] = __expectString(output[_sc]);
    }
    return contents;
};
const de_NetworkAcl = (output, context) => {
    const contents = {};
    if (output.associationSet === "") {
        contents[_Ass] = [];
    }
    else if (output[_aSss] != null && output[_aSss][_i] != null) {
        contents[_Ass] = de_NetworkAclAssociationList(__getArrayIfSingleItem(output[_aSss][_i]), context);
    }
    if (output.entrySet === "") {
        contents[_Ent] = [];
    }
    else if (output[_eSnt] != null && output[_eSnt][_i] != null) {
        contents[_Ent] = de_NetworkAclEntryList(__getArrayIfSingleItem(output[_eSnt][_i]), context);
    }
    if (output[_def] != null) {
        contents[_IDs] = __parseBoolean(output[_def]);
    }
    if (output[_nAI] != null) {
        contents[_NAI] = __expectString(output[_nAI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    return contents;
};
const de_NetworkAclAssociation = (output, context) => {
    const contents = {};
    if (output[_nAAI] != null) {
        contents[_NAAI] = __expectString(output[_nAAI]);
    }
    if (output[_nAI] != null) {
        contents[_NAI] = __expectString(output[_nAI]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    return contents;
};
const de_NetworkAclAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkAclAssociation(entry, context);
    });
};
const de_NetworkAclEntry = (output, context) => {
    const contents = {};
    if (output[_cB] != null) {
        contents[_CB] = __expectString(output[_cB]);
    }
    if (output[_e] != null) {
        contents[_Eg] = __parseBoolean(output[_e]);
    }
    if (output[_iTC] != null) {
        contents[_ITC] = de_IcmpTypeCode(output[_iTC], context);
    }
    if (output[_iCB] != null) {
        contents[_ICB] = __expectString(output[_iCB]);
    }
    if (output[_pRo] != null) {
        contents[_PR] = de_PortRange(output[_pRo], context);
    }
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output[_rA] != null) {
        contents[_RAu] = __expectString(output[_rA]);
    }
    if (output[_rN] != null) {
        contents[_RNu] = __strictParseInt32(output[_rN]);
    }
    return contents;
};
const de_NetworkAclEntryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkAclEntry(entry, context);
    });
};
const de_NetworkAclList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkAcl(entry, context);
    });
};
const de_NetworkBandwidthGbps = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_M] = __strictParseFloat(output[_m]);
    }
    if (output[_ma] != null) {
        contents[_Ma] = __strictParseFloat(output[_ma]);
    }
    return contents;
};
const de_NetworkCardInfo = (output, context) => {
    const contents = {};
    if (output[_nCI] != null) {
        contents[_NCI] = __strictParseInt32(output[_nCI]);
    }
    if (output[_nP] != null) {
        contents[_NP] = __expectString(output[_nP]);
    }
    if (output[_mNI] != null) {
        contents[_MNI] = __strictParseInt32(output[_mNI]);
    }
    if (output[_bBIG] != null) {
        contents[_BBIG] = __strictParseFloat(output[_bBIG]);
    }
    if (output[_pBIG] != null) {
        contents[_PBIG] = __strictParseFloat(output[_pBIG]);
    }
    return contents;
};
const de_NetworkCardInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkCardInfo(entry, context);
    });
};
const de_NetworkInfo = (output, context) => {
    const contents = {};
    if (output[_nP] != null) {
        contents[_NP] = __expectString(output[_nP]);
    }
    if (output[_mNI] != null) {
        contents[_MNI] = __strictParseInt32(output[_mNI]);
    }
    if (output[_mNC] != null) {
        contents[_MNC] = __strictParseInt32(output[_mNC]);
    }
    if (output[_dNCI] != null) {
        contents[_DNCI] = __strictParseInt32(output[_dNCI]);
    }
    if (output.networkCards === "") {
        contents[_NC] = [];
    }
    else if (output[_nC] != null && output[_nC][_i] != null) {
        contents[_NC] = de_NetworkCardInfoList(__getArrayIfSingleItem(output[_nC][_i]), context);
    }
    if (output[_iAPI] != null) {
        contents[_IAPI] = __strictParseInt32(output[_iAPI]);
    }
    if (output[_iAPIp] != null) {
        contents[_IAPIp] = __strictParseInt32(output[_iAPIp]);
    }
    if (output[_iSpv] != null) {
        contents[_ISpv] = __parseBoolean(output[_iSpv]);
    }
    if (output[_eSna] != null) {
        contents[_ESn] = __expectString(output[_eSna]);
    }
    if (output[_eSf] != null) {
        contents[_ESf] = __parseBoolean(output[_eSf]);
    }
    if (output[_eIf] != null) {
        contents[_EIf] = de_EfaInfo(output[_eIf], context);
    }
    if (output[_eITSn] != null) {
        contents[_EITS] = __parseBoolean(output[_eITSn]);
    }
    if (output[_eSSn] != null) {
        contents[_ESSn] = __parseBoolean(output[_eSSn]);
    }
    if (output.bandwidthWeightings === "") {
        contents[_BWa] = [];
    }
    else if (output[_bWa] != null && output[_bWa][_i] != null) {
        contents[_BWa] = de_BandwidthWeightingTypeList(__getArrayIfSingleItem(output[_bWa][_i]), context);
    }
    return contents;
};
const de_NetworkInsightsAccessScope = (output, context) => {
    const contents = {};
    if (output[_nIASI] != null) {
        contents[_NIASI] = __expectString(output[_nIASI]);
    }
    if (output[_nIASA] != null) {
        contents[_NIASAe] = __expectString(output[_nIASA]);
    }
    if (output[_cDre] != null) {
        contents[_CDrea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cDre]));
    }
    if (output[_uDp] != null) {
        contents[_UDp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uDp]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_NetworkInsightsAccessScopeAnalysis = (output, context) => {
    const contents = {};
    if (output[_nIASAI] != null) {
        contents[_NIASAI] = __expectString(output[_nIASAI]);
    }
    if (output[_nIASAA] != null) {
        contents[_NIASAA] = __expectString(output[_nIASAA]);
    }
    if (output[_nIASI] != null) {
        contents[_NIASI] = __expectString(output[_nIASI]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_wM] != null) {
        contents[_WM] = __expectString(output[_wM]);
    }
    if (output[_sD] != null) {
        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));
    }
    if (output[_eD] != null) {
        contents[_ED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eD]));
    }
    if (output[_fFi] != null) {
        contents[_FFi] = __expectString(output[_fFi]);
    }
    if (output[_aEC] != null) {
        contents[_AEC] = __strictParseInt32(output[_aEC]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_NetworkInsightsAccessScopeAnalysisList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkInsightsAccessScopeAnalysis(entry, context);
    });
};
const de_NetworkInsightsAccessScopeContent = (output, context) => {
    const contents = {};
    if (output[_nIASI] != null) {
        contents[_NIASI] = __expectString(output[_nIASI]);
    }
    if (output.matchPathSet === "") {
        contents[_MP] = [];
    }
    else if (output[_mPSa] != null && output[_mPSa][_i] != null) {
        contents[_MP] = de_AccessScopePathList(__getArrayIfSingleItem(output[_mPSa][_i]), context);
    }
    if (output.excludePathSet === "") {
        contents[_EP] = [];
    }
    else if (output[_ePS] != null && output[_ePS][_i] != null) {
        contents[_EP] = de_AccessScopePathList(__getArrayIfSingleItem(output[_ePS][_i]), context);
    }
    return contents;
};
const de_NetworkInsightsAccessScopeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkInsightsAccessScope(entry, context);
    });
};
const de_NetworkInsightsAnalysis = (output, context) => {
    const contents = {};
    if (output[_nIAI] != null) {
        contents[_NIAI] = __expectString(output[_nIAI]);
    }
    if (output[_nIAA] != null) {
        contents[_NIAA] = __expectString(output[_nIAA]);
    }
    if (output[_nIPI] != null) {
        contents[_NIPI] = __expectString(output[_nIPI]);
    }
    if (output.additionalAccountSet === "") {
        contents[_AAd] = [];
    }
    else if (output[_aASd] != null && output[_aASd][_i] != null) {
        contents[_AAd] = de_ValueStringList(__getArrayIfSingleItem(output[_aASd][_i]), context);
    }
    if (output.filterInArnSet === "") {
        contents[_FIA] = [];
    }
    else if (output[_fIAS] != null && output[_fIAS][_i] != null) {
        contents[_FIA] = de_ArnList(__getArrayIfSingleItem(output[_fIAS][_i]), context);
    }
    if (output[_sD] != null) {
        contents[_SD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sD]));
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_wM] != null) {
        contents[_WM] = __expectString(output[_wM]);
    }
    if (output[_nPF] != null) {
        contents[_NPF] = __parseBoolean(output[_nPF]);
    }
    if (output.forwardPathComponentSet === "") {
        contents[_FPC] = [];
    }
    else if (output[_fPCS] != null && output[_fPCS][_i] != null) {
        contents[_FPC] = de_PathComponentList(__getArrayIfSingleItem(output[_fPCS][_i]), context);
    }
    if (output.returnPathComponentSet === "") {
        contents[_RPC] = [];
    }
    else if (output[_rPCS] != null && output[_rPCS][_i] != null) {
        contents[_RPC] = de_PathComponentList(__getArrayIfSingleItem(output[_rPCS][_i]), context);
    }
    if (output.explanationSet === "") {
        contents[_Ex] = [];
    }
    else if (output[_eSx] != null && output[_eSx][_i] != null) {
        contents[_Ex] = de_ExplanationList(__getArrayIfSingleItem(output[_eSx][_i]), context);
    }
    if (output.alternatePathHintSet === "") {
        contents[_APH] = [];
    }
    else if (output[_aPHS] != null && output[_aPHS][_i] != null) {
        contents[_APH] = de_AlternatePathHintList(__getArrayIfSingleItem(output[_aPHS][_i]), context);
    }
    if (output.suggestedAccountSet === "") {
        contents[_SAu] = [];
    }
    else if (output[_sASu] != null && output[_sASu][_i] != null) {
        contents[_SAu] = de_ValueStringList(__getArrayIfSingleItem(output[_sASu][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_NetworkInsightsAnalysisList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkInsightsAnalysis(entry, context);
    });
};
const de_NetworkInsightsPath = (output, context) => {
    const contents = {};
    if (output[_nIPI] != null) {
        contents[_NIPI] = __expectString(output[_nIPI]);
    }
    if (output[_nIPA] != null) {
        contents[_NIPA] = __expectString(output[_nIPA]);
    }
    if (output[_cDre] != null) {
        contents[_CDrea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cDre]));
    }
    if (output[_s] != null) {
        contents[_S] = __expectString(output[_s]);
    }
    if (output[_d] != null) {
        contents[_D] = __expectString(output[_d]);
    }
    if (output[_sA] != null) {
        contents[_SAour] = __expectString(output[_sA]);
    }
    if (output[_dA] != null) {
        contents[_DAesti] = __expectString(output[_dA]);
    }
    if (output[_sIo] != null) {
        contents[_SIo] = __expectString(output[_sIo]);
    }
    if (output[_dIes] != null) {
        contents[_DIest] = __expectString(output[_dIes]);
    }
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output[_dPes] != null) {
        contents[_DPe] = __strictParseInt32(output[_dPes]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_fAS] != null) {
        contents[_FAS] = de_PathFilter(output[_fAS], context);
    }
    if (output[_fAD] != null) {
        contents[_FAD] = de_PathFilter(output[_fAD], context);
    }
    return contents;
};
const de_NetworkInsightsPathList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkInsightsPath(entry, context);
    });
};
const de_NetworkInterface = (output, context) => {
    const contents = {};
    if (output[_ass] != null) {
        contents[_Asso] = de_NetworkInterfaceAssociation(output[_ass], context);
    }
    if (output[_at] != null) {
        contents[_Att] = de_NetworkInterfaceAttachment(output[_at], context);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_cTC] != null) {
        contents[_CTC] = de_ConnectionTrackingConfiguration(output[_cTC], context);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.groupSet === "") {
        contents[_G] = [];
    }
    else if (output[_gS] != null && output[_gS][_i] != null) {
        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);
    }
    if (output[_iTnt] != null) {
        contents[_ITn] = __expectString(output[_iTnt]);
    }
    if (output.ipv6AddressesSet === "") {
        contents[_IA] = [];
    }
    else if (output[_iASp] != null && output[_iASp][_i] != null) {
        contents[_IA] = de_NetworkInterfaceIpv6AddressesList(__getArrayIfSingleItem(output[_iASp][_i]), context);
    }
    if (output[_mAa] != null) {
        contents[_MAa] = __expectString(output[_mAa]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_pDN] != null) {
        contents[_PDN] = __expectString(output[_pDN]);
    }
    if (output[_pIA] != null) {
        contents[_PIAr] = __expectString(output[_pIA]);
    }
    if (output.privateIpAddressesSet === "") {
        contents[_PIA] = [];
    }
    else if (output[_pIAS] != null && output[_pIAS][_i] != null) {
        contents[_PIA] = de_NetworkInterfacePrivateIpAddressList(__getArrayIfSingleItem(output[_pIAS][_i]), context);
    }
    if (output.ipv4PrefixSet === "") {
        contents[_IPp] = [];
    }
    else if (output[_iPSpv] != null && output[_iPSpv][_i] != null) {
        contents[_IPp] = de_Ipv4PrefixesList(__getArrayIfSingleItem(output[_iPSpv][_i]), context);
    }
    if (output.ipv6PrefixSet === "") {
        contents[_IP] = [];
    }
    else if (output[_iPSpvr] != null && output[_iPSpvr][_i] != null) {
        contents[_IP] = de_Ipv6PrefixesList(__getArrayIfSingleItem(output[_iPSpvr][_i]), context);
    }
    if (output[_rIeq] != null) {
        contents[_RIeq] = __expectString(output[_rIeq]);
    }
    if (output[_rM] != null) {
        contents[_RMe] = __parseBoolean(output[_rM]);
    }
    if (output[_sDC] != null) {
        contents[_SDC] = __parseBoolean(output[_sDC]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output.tagSet === "") {
        contents[_TSag] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_TSag] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_dAIT] != null) {
        contents[_DAIT] = __parseBoolean(output[_dAIT]);
    }
    if (output[_iN] != null) {
        contents[_IN] = __parseBoolean(output[_iN]);
    }
    if (output[_iApv] != null) {
        contents[_IApv] = __expectString(output[_iApv]);
    }
    if (output[_op] != null) {
        contents[_O] = de_OperatorResponse(output[_op], context);
    }
    return contents;
};
const de_NetworkInterfaceAssociation = (output, context) => {
    const contents = {};
    if (output[_aI] != null) {
        contents[_AIl] = __expectString(output[_aI]);
    }
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_iOIp] != null) {
        contents[_IOI] = __expectString(output[_iOIp]);
    }
    if (output[_pDNu] != null) {
        contents[_PDNu] = __expectString(output[_pDNu]);
    }
    if (output[_pI] != null) {
        contents[_PI] = __expectString(output[_pI]);
    }
    if (output[_cOI] != null) {
        contents[_COI] = __expectString(output[_cOI]);
    }
    if (output[_cI] != null) {
        contents[_CIa] = __expectString(output[_cI]);
    }
    return contents;
};
const de_NetworkInterfaceAttachment = (output, context) => {
    const contents = {};
    if (output[_aTt] != null) {
        contents[_ATtt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aTt]));
    }
    if (output[_aIt] != null) {
        contents[_AIt] = __expectString(output[_aIt]);
    }
    if (output[_dOT] != null) {
        contents[_DOT] = __parseBoolean(output[_dOT]);
    }
    if (output[_dIe] != null) {
        contents[_DIev] = __strictParseInt32(output[_dIe]);
    }
    if (output[_nCI] != null) {
        contents[_NCI] = __strictParseInt32(output[_nCI]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iOIn] != null) {
        contents[_IOIn] = __expectString(output[_iOIn]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_eSS] != null) {
        contents[_ESS] = de_AttachmentEnaSrdSpecification(output[_eSS], context);
    }
    return contents;
};
const de_NetworkInterfaceCount = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_M] = __strictParseInt32(output[_m]);
    }
    if (output[_ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_ma]);
    }
    return contents;
};
const de_NetworkInterfaceIdSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_NetworkInterfaceIpv6Address = (output, context) => {
    const contents = {};
    if (output[_iApv] != null) {
        contents[_IApv] = __expectString(output[_iApv]);
    }
    if (output[_iPI] != null) {
        contents[_IPIs] = __parseBoolean(output[_iPI]);
    }
    return contents;
};
const de_NetworkInterfaceIpv6AddressesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkInterfaceIpv6Address(entry, context);
    });
};
const de_NetworkInterfaceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkInterface(entry, context);
    });
};
const de_NetworkInterfacePermission = (output, context) => {
    const contents = {};
    if (output[_nIPIe] != null) {
        contents[_NIPIe] = __expectString(output[_nIPIe]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_aAI] != null) {
        contents[_AAI] = __expectString(output[_aAI]);
    }
    if (output[_aSw] != null) {
        contents[_ASw] = __expectString(output[_aSw]);
    }
    if (output[_per] != null) {
        contents[_Pe] = __expectString(output[_per]);
    }
    if (output[_pSe] != null) {
        contents[_PSer] = de_NetworkInterfacePermissionState(output[_pSe], context);
    }
    return contents;
};
const de_NetworkInterfacePermissionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkInterfacePermission(entry, context);
    });
};
const de_NetworkInterfacePermissionState = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    return contents;
};
const de_NetworkInterfacePrivateIpAddress = (output, context) => {
    const contents = {};
    if (output[_ass] != null) {
        contents[_Asso] = de_NetworkInterfaceAssociation(output[_ass], context);
    }
    if (output[_prim] != null) {
        contents[_Prim] = __parseBoolean(output[_prim]);
    }
    if (output[_pDN] != null) {
        contents[_PDN] = __expectString(output[_pDN]);
    }
    if (output[_pIA] != null) {
        contents[_PIAr] = __expectString(output[_pIA]);
    }
    return contents;
};
const de_NetworkInterfacePrivateIpAddressList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkInterfacePrivateIpAddress(entry, context);
    });
};
const de_NetworkNodesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_NeuronDeviceCoreInfo = (output, context) => {
    const contents = {};
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    if (output[_ve] != null) {
        contents[_V] = __strictParseInt32(output[_ve]);
    }
    return contents;
};
const de_NeuronDeviceInfo = (output, context) => {
    const contents = {};
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_cIor] != null) {
        contents[_CIor] = de_NeuronDeviceCoreInfo(output[_cIor], context);
    }
    if (output[_mIe] != null) {
        contents[_MIe] = de_NeuronDeviceMemoryInfo(output[_mIe], context);
    }
    return contents;
};
const de_NeuronDeviceInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NeuronDeviceInfo(entry, context);
    });
};
const de_NeuronDeviceMemoryInfo = (output, context) => {
    const contents = {};
    if (output[_sIMB] != null) {
        contents[_SIMB] = __strictParseInt32(output[_sIMB]);
    }
    return contents;
};
const de_NeuronInfo = (output, context) => {
    const contents = {};
    if (output.neuronDevices === "") {
        contents[_NDe] = [];
    }
    else if (output[_nDe] != null && output[_nDe][_i] != null) {
        contents[_NDe] = de_NeuronDeviceInfoList(__getArrayIfSingleItem(output[_nDe][_i]), context);
    }
    if (output[_tNDMIMB] != null) {
        contents[_TNDMIMB] = __strictParseInt32(output[_tNDMIMB]);
    }
    return contents;
};
const de_NitroTpmInfo = (output, context) => {
    const contents = {};
    if (output.supportedVersions === "") {
        contents[_SVu] = [];
    }
    else if (output[_sVu] != null && output[_sVu][_i] != null) {
        contents[_SVu] = de_NitroTpmSupportedVersionsList(__getArrayIfSingleItem(output[_sVu][_i]), context);
    }
    return contents;
};
const de_NitroTpmSupportedVersionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_OccurrenceDaySet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __strictParseInt32(entry);
    });
};
const de_OidcOptions = (output, context) => {
    const contents = {};
    if (output[_is] != null) {
        contents[_I] = __expectString(output[_is]);
    }
    if (output[_aE] != null) {
        contents[_AE] = __expectString(output[_aE]);
    }
    if (output[_tEo] != null) {
        contents[_TEo] = __expectString(output[_tEo]);
    }
    if (output[_uIE] != null) {
        contents[_UIE] = __expectString(output[_uIE]);
    }
    if (output[_cIli] != null) {
        contents[_CIl] = __expectString(output[_cIli]);
    }
    if (output[_cSl] != null) {
        contents[_CSl] = __expectString(output[_cSl]);
    }
    if (output[_sc] != null) {
        contents[_Sc] = __expectString(output[_sc]);
    }
    return contents;
};
const de_OnDemandOptions = (output, context) => {
    const contents = {};
    if (output[_aSl] != null) {
        contents[_AS] = __expectString(output[_aSl]);
    }
    if (output[_cRO] != null) {
        contents[_CRO] = de_CapacityReservationOptions(output[_cRO], context);
    }
    if (output[_sITi] != null) {
        contents[_SITi] = __parseBoolean(output[_sITi]);
    }
    if (output[_sAZ] != null) {
        contents[_SAZ] = __parseBoolean(output[_sAZ]);
    }
    if (output[_mTC] != null) {
        contents[_MTC] = __strictParseInt32(output[_mTC]);
    }
    if (output[_mTP] != null) {
        contents[_MTP] = __expectString(output[_mTP]);
    }
    return contents;
};
const de_OperatorResponse = (output, context) => {
    const contents = {};
    if (output[_mana] != null) {
        contents[_Mana] = __parseBoolean(output[_mana]);
    }
    if (output[_p] != null) {
        contents[_Prin] = __expectString(output[_p]);
    }
    return contents;
};
const de_PacketHeaderStatement = (output, context) => {
    const contents = {};
    if (output.sourceAddressSet === "") {
        contents[_SAo] = [];
    }
    else if (output[_sAS] != null && output[_sAS][_i] != null) {
        contents[_SAo] = de_ValueStringList(__getArrayIfSingleItem(output[_sAS][_i]), context);
    }
    if (output.destinationAddressSet === "") {
        contents[_DAes] = [];
    }
    else if (output[_dAS] != null && output[_dAS][_i] != null) {
        contents[_DAes] = de_ValueStringList(__getArrayIfSingleItem(output[_dAS][_i]), context);
    }
    if (output.sourcePortSet === "") {
        contents[_SPo] = [];
    }
    else if (output[_sPS] != null && output[_sPS][_i] != null) {
        contents[_SPo] = de_ValueStringList(__getArrayIfSingleItem(output[_sPS][_i]), context);
    }
    if (output.destinationPortSet === "") {
        contents[_DPes] = [];
    }
    else if (output[_dPS] != null && output[_dPS][_i] != null) {
        contents[_DPes] = de_ValueStringList(__getArrayIfSingleItem(output[_dPS][_i]), context);
    }
    if (output.sourcePrefixListSet === "") {
        contents[_SPL] = [];
    }
    else if (output[_sPLS] != null && output[_sPLS][_i] != null) {
        contents[_SPL] = de_ValueStringList(__getArrayIfSingleItem(output[_sPLS][_i]), context);
    }
    if (output.destinationPrefixListSet === "") {
        contents[_DPLe] = [];
    }
    else if (output[_dPLS] != null && output[_dPLS][_i] != null) {
        contents[_DPLe] = de_ValueStringList(__getArrayIfSingleItem(output[_dPLS][_i]), context);
    }
    if (output.protocolSet === "") {
        contents[_Pro] = [];
    }
    else if (output[_pSro] != null && output[_pSro][_i] != null) {
        contents[_Pro] = de_ProtocolList(__getArrayIfSingleItem(output[_pSro][_i]), context);
    }
    return contents;
};
const de_PathComponent = (output, context) => {
    const contents = {};
    if (output[_sNe] != null) {
        contents[_SNeq] = __strictParseInt32(output[_sNe]);
    }
    if (output[_aRc] != null) {
        contents[_ARcl] = de_AnalysisAclRule(output[_aRc], context);
    }
    if (output[_aTtt] != null) {
        contents[_ATtta] = de_AnalysisComponent(output[_aTtt], context);
    }
    if (output[_c] != null) {
        contents[_Com] = de_AnalysisComponent(output[_c], context);
    }
    if (output[_dV] != null) {
        contents[_DVest] = de_AnalysisComponent(output[_dV], context);
    }
    if (output[_oH] != null) {
        contents[_OH] = de_AnalysisPacketHeader(output[_oH], context);
    }
    if (output[_iHn] != null) {
        contents[_IHn] = de_AnalysisPacketHeader(output[_iHn], context);
    }
    if (output[_rTR] != null) {
        contents[_RTR] = de_AnalysisRouteTableRoute(output[_rTR], context);
    }
    if (output[_sGR] != null) {
        contents[_SGRe] = de_AnalysisSecurityGroupRule(output[_sGR], context);
    }
    if (output[_sV] != null) {
        contents[_SVo] = de_AnalysisComponent(output[_sV], context);
    }
    if (output[_su] != null) {
        contents[_Su] = de_AnalysisComponent(output[_su], context);
    }
    if (output[_vp] != null) {
        contents[_Vp] = de_AnalysisComponent(output[_vp], context);
    }
    if (output.additionalDetailSet === "") {
        contents[_ADd] = [];
    }
    else if (output[_aDS] != null && output[_aDS][_i] != null) {
        contents[_ADd] = de_AdditionalDetailList(__getArrayIfSingleItem(output[_aDS][_i]), context);
    }
    if (output[_tG] != null) {
        contents[_TGr] = de_AnalysisComponent(output[_tG], context);
    }
    if (output[_tGRTR] != null) {
        contents[_TGRTR] = de_TransitGatewayRouteTableRoute(output[_tGRTR], context);
    }
    if (output.explanationSet === "") {
        contents[_Ex] = [];
    }
    else if (output[_eSx] != null && output[_eSx][_i] != null) {
        contents[_Ex] = de_ExplanationList(__getArrayIfSingleItem(output[_eSx][_i]), context);
    }
    if (output[_eLBL] != null) {
        contents[_ELBL] = de_AnalysisComponent(output[_eLBL], context);
    }
    if (output[_fSR] != null) {
        contents[_FSRi] = de_FirewallStatelessRule(output[_fSR], context);
    }
    if (output[_fSRi] != null) {
        contents[_FSRir] = de_FirewallStatefulRule(output[_fSRi], context);
    }
    if (output[_sN] != null) {
        contents[_SNe] = __expectString(output[_sN]);
    }
    return contents;
};
const de_PathComponentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PathComponent(entry, context);
    });
};
const de_PathFilter = (output, context) => {
    const contents = {};
    if (output[_sAo] != null) {
        contents[_SAou] = __expectString(output[_sAo]);
    }
    if (output[_sPR] != null) {
        contents[_SPR] = de_FilterPortRange(output[_sPR], context);
    }
    if (output[_dAe] != null) {
        contents[_DAest] = __expectString(output[_dAe]);
    }
    if (output[_dPR] != null) {
        contents[_DPR] = de_FilterPortRange(output[_dPR], context);
    }
    return contents;
};
const de_PathStatement = (output, context) => {
    const contents = {};
    if (output[_pHS] != null) {
        contents[_PHS] = de_PacketHeaderStatement(output[_pHS], context);
    }
    if (output[_rSeso] != null) {
        contents[_RSe] = de_ResourceStatement(output[_rSeso], context);
    }
    return contents;
};
const de_PciId = (output, context) => {
    const contents = {};
    if (output[_DIevi] != null) {
        contents[_DIevi] = __expectString(output[_DIevi]);
    }
    if (output[_VIe] != null) {
        contents[_VIe] = __expectString(output[_VIe]);
    }
    if (output[_SIubs] != null) {
        contents[_SIubs] = __expectString(output[_SIubs]);
    }
    if (output[_SVI] != null) {
        contents[_SVI] = __expectString(output[_SVI]);
    }
    return contents;
};
const de_PeeringAttachmentStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_PeeringConnectionOptions = (output, context) => {
    const contents = {};
    if (output[_aDRFRV] != null) {
        contents[_ADRFRV] = __parseBoolean(output[_aDRFRV]);
    }
    if (output[_aEFLCLTRV] != null) {
        contents[_AEFLCLTRV] = __parseBoolean(output[_aEFLCLTRV]);
    }
    if (output[_aEFLVTRCL] != null) {
        contents[_AEFLVTRCL] = __parseBoolean(output[_aEFLVTRCL]);
    }
    return contents;
};
const de_PeeringTgwInfo = (output, context) => {
    const contents = {};
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_cNIo] != null) {
        contents[_CNIor] = __expectString(output[_cNIo]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_re] != null) {
        contents[_Regi] = __expectString(output[_re]);
    }
    return contents;
};
const de_PerformanceFactorReference = (output, context) => {
    const contents = {};
    if (output[_iF] != null) {
        contents[_IF] = __expectString(output[_iF]);
    }
    return contents;
};
const de_PerformanceFactorReferenceSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PerformanceFactorReference(entry, context);
    });
};
const de_Phase1DHGroupNumbersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Phase1DHGroupNumbersListValue(entry, context);
    });
};
const de_Phase1DHGroupNumbersListValue = (output, context) => {
    const contents = {};
    if (output[_v] != null) {
        contents[_Va] = __strictParseInt32(output[_v]);
    }
    return contents;
};
const de_Phase1EncryptionAlgorithmsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Phase1EncryptionAlgorithmsListValue(entry, context);
    });
};
const de_Phase1EncryptionAlgorithmsListValue = (output, context) => {
    const contents = {};
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    return contents;
};
const de_Phase1IntegrityAlgorithmsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Phase1IntegrityAlgorithmsListValue(entry, context);
    });
};
const de_Phase1IntegrityAlgorithmsListValue = (output, context) => {
    const contents = {};
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    return contents;
};
const de_Phase2DHGroupNumbersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Phase2DHGroupNumbersListValue(entry, context);
    });
};
const de_Phase2DHGroupNumbersListValue = (output, context) => {
    const contents = {};
    if (output[_v] != null) {
        contents[_Va] = __strictParseInt32(output[_v]);
    }
    return contents;
};
const de_Phase2EncryptionAlgorithmsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Phase2EncryptionAlgorithmsListValue(entry, context);
    });
};
const de_Phase2EncryptionAlgorithmsListValue = (output, context) => {
    const contents = {};
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    return contents;
};
const de_Phase2IntegrityAlgorithmsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Phase2IntegrityAlgorithmsListValue(entry, context);
    });
};
const de_Phase2IntegrityAlgorithmsListValue = (output, context) => {
    const contents = {};
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    return contents;
};
const de_Placement = (output, context) => {
    const contents = {};
    if (output[_af] != null) {
        contents[_Af] = __expectString(output[_af]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output[_pN] != null) {
        contents[_PN] = __strictParseInt32(output[_pN]);
    }
    if (output[_hI] != null) {
        contents[_HIo] = __expectString(output[_hI]);
    }
    if (output[_t] != null) {
        contents[_Te] = __expectString(output[_t]);
    }
    if (output[_sDp] != null) {
        contents[_SDp] = __expectString(output[_sDp]);
    }
    if (output[_hRGA] != null) {
        contents[_HRGA] = __expectString(output[_hRGA]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    return contents;
};
const de_PlacementGroup = (output, context) => {
    const contents = {};
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_str] != null) {
        contents[_Str] = __expectString(output[_str]);
    }
    if (output[_pCa] != null) {
        contents[_PCa] = __strictParseInt32(output[_pCa]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_gA] != null) {
        contents[_GA] = __expectString(output[_gA]);
    }
    if (output[_sLp] != null) {
        contents[_SL] = __expectString(output[_sLp]);
    }
    return contents;
};
const de_PlacementGroupInfo = (output, context) => {
    const contents = {};
    if (output.supportedStrategies === "") {
        contents[_SSu] = [];
    }
    else if (output[_sSup] != null && output[_sSup][_i] != null) {
        contents[_SSu] = de_PlacementGroupStrategyList(__getArrayIfSingleItem(output[_sSup][_i]), context);
    }
    return contents;
};
const de_PlacementGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PlacementGroup(entry, context);
    });
};
const de_PlacementGroupStrategyList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_PlacementResponse = (output, context) => {
    const contents = {};
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    return contents;
};
const de_PoolCidrBlock = (output, context) => {
    const contents = {};
    if (output[_pCB] != null) {
        contents[_C] = __expectString(output[_pCB]);
    }
    return contents;
};
const de_PoolCidrBlocksSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PoolCidrBlock(entry, context);
    });
};
const de_PortRange = (output, context) => {
    const contents = {};
    if (output[_fr] != null) {
        contents[_Fr] = __strictParseInt32(output[_fr]);
    }
    if (output[_to] != null) {
        contents[_To] = __strictParseInt32(output[_to]);
    }
    return contents;
};
const de_PortRangeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PortRange(entry, context);
    });
};
const de_PrefixList = (output, context) => {
    const contents = {};
    if (output.cidrSet === "") {
        contents[_Ci] = [];
    }
    else if (output[_cS] != null && output[_cS][_i] != null) {
        contents[_Ci] = de_ValueStringList(__getArrayIfSingleItem(output[_cS][_i]), context);
    }
    if (output[_pLI] != null) {
        contents[_PLI] = __expectString(output[_pLI]);
    }
    if (output[_pLN] != null) {
        contents[_PLN] = __expectString(output[_pLN]);
    }
    return contents;
};
const de_PrefixListAssociation = (output, context) => {
    const contents = {};
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rO] != null) {
        contents[_ROe] = __expectString(output[_rO]);
    }
    return contents;
};
const de_PrefixListAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PrefixListAssociation(entry, context);
    });
};
const de_PrefixListEntry = (output, context) => {
    const contents = {};
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    return contents;
};
const de_PrefixListEntrySet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PrefixListEntry(entry, context);
    });
};
const de_PrefixListId = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_pLI] != null) {
        contents[_PLI] = __expectString(output[_pLI]);
    }
    return contents;
};
const de_PrefixListIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PrefixListId(entry, context);
    });
};
const de_PrefixListIdSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_PrefixListSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PrefixList(entry, context);
    });
};
const de_PriceSchedule = (output, context) => {
    const contents = {};
    if (output[_act] != null) {
        contents[_Act] = __parseBoolean(output[_act]);
    }
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output[_pric] != null) {
        contents[_Pric] = __strictParseFloat(output[_pric]);
    }
    if (output[_te] != null) {
        contents[_Ter] = __strictParseLong(output[_te]);
    }
    return contents;
};
const de_PriceScheduleList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PriceSchedule(entry, context);
    });
};
const de_PricingDetail = (output, context) => {
    const contents = {};
    if (output[_cou] != null) {
        contents[_Cou] = __strictParseInt32(output[_cou]);
    }
    if (output[_pric] != null) {
        contents[_Pric] = __strictParseFloat(output[_pric]);
    }
    return contents;
};
const de_PricingDetailsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PricingDetail(entry, context);
    });
};
const de_PrincipalIdFormat = (output, context) => {
    const contents = {};
    if (output[_ar] != null) {
        contents[_Ar] = __expectString(output[_ar]);
    }
    if (output.statusSet === "") {
        contents[_Status] = [];
    }
    else if (output[_sSt] != null && output[_sSt][_i] != null) {
        contents[_Status] = de_IdFormatList(__getArrayIfSingleItem(output[_sSt][_i]), context);
    }
    return contents;
};
const de_PrincipalIdFormatList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PrincipalIdFormat(entry, context);
    });
};
const de_PrivateDnsDetails = (output, context) => {
    const contents = {};
    if (output[_pDN] != null) {
        contents[_PDN] = __expectString(output[_pDN]);
    }
    return contents;
};
const de_PrivateDnsDetailsSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PrivateDnsDetails(entry, context);
    });
};
const de_PrivateDnsNameConfiguration = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    return contents;
};
const de_PrivateDnsNameOptionsOnLaunch = (output, context) => {
    const contents = {};
    if (output[_hTo] != null) {
        contents[_HTo] = __expectString(output[_hTo]);
    }
    if (output[_eRNDAR] != null) {
        contents[_ERNDAR] = __parseBoolean(output[_eRNDAR]);
    }
    if (output[_eRNDAAAAR] != null) {
        contents[_ERNDAAAAR] = __parseBoolean(output[_eRNDAAAAR]);
    }
    return contents;
};
const de_PrivateDnsNameOptionsResponse = (output, context) => {
    const contents = {};
    if (output[_hTo] != null) {
        contents[_HTo] = __expectString(output[_hTo]);
    }
    if (output[_eRNDAR] != null) {
        contents[_ERNDAR] = __parseBoolean(output[_eRNDAR]);
    }
    if (output[_eRNDAAAAR] != null) {
        contents[_ERNDAAAAR] = __parseBoolean(output[_eRNDAAAAR]);
    }
    return contents;
};
const de_PrivateIpAddressSpecification = (output, context) => {
    const contents = {};
    if (output[_prim] != null) {
        contents[_Prim] = __parseBoolean(output[_prim]);
    }
    if (output[_pIA] != null) {
        contents[_PIAr] = __expectString(output[_pIA]);
    }
    return contents;
};
const de_PrivateIpAddressSpecificationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PrivateIpAddressSpecification(entry, context);
    });
};
const de_ProcessorInfo = (output, context) => {
    const contents = {};
    if (output.supportedArchitectures === "") {
        contents[_SAup] = [];
    }
    else if (output[_sAu] != null && output[_sAu][_i] != null) {
        contents[_SAup] = de_ArchitectureTypeList(__getArrayIfSingleItem(output[_sAu][_i]), context);
    }
    if (output[_sCSIG] != null) {
        contents[_SCSIG] = __strictParseFloat(output[_sCSIG]);
    }
    if (output.supportedFeatures === "") {
        contents[_SF] = [];
    }
    else if (output[_sF] != null && output[_sF][_i] != null) {
        contents[_SF] = de_SupportedAdditionalProcessorFeatureList(__getArrayIfSingleItem(output[_sF][_i]), context);
    }
    if (output[_man] != null) {
        contents[_Man] = __expectString(output[_man]);
    }
    return contents;
};
const de_ProductCode = (output, context) => {
    const contents = {};
    if (output[_pCr] != null) {
        contents[_PCIr] = __expectString(output[_pCr]);
    }
    if (output[_ty] != null) {
        contents[_PCT] = __expectString(output[_ty]);
    }
    return contents;
};
const de_ProductCodeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ProductCode(entry, context);
    });
};
const de_PropagatingVgw = (output, context) => {
    const contents = {};
    if (output[_gI] != null) {
        contents[_GI] = __expectString(output[_gI]);
    }
    return contents;
};
const de_PropagatingVgwList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PropagatingVgw(entry, context);
    });
};
const de_ProtocolIntList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __strictParseInt32(entry);
    });
};
const de_ProtocolList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ProvisionByoipCidrResult = (output, context) => {
    const contents = {};
    if (output[_bC] != null) {
        contents[_BC] = de_ByoipCidr(output[_bC], context);
    }
    return contents;
};
const de_ProvisionedBandwidth = (output, context) => {
    const contents = {};
    if (output[_pTr] != null) {
        contents[_PTro] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_pTr]));
    }
    if (output[_prov] != null) {
        contents[_Prov] = __expectString(output[_prov]);
    }
    if (output[_rTeq] != null) {
        contents[_RTeq] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rTeq]));
    }
    if (output[_req] != null) {
        contents[_Req] = __expectString(output[_req]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_ProvisionIpamByoasnResult = (output, context) => {
    const contents = {};
    if (output[_b] != null) {
        contents[_Byo] = de_Byoasn(output[_b], context);
    }
    return contents;
};
const de_ProvisionIpamPoolCidrResult = (output, context) => {
    const contents = {};
    if (output[_iPC] != null) {
        contents[_IPCpa] = de_IpamPoolCidr(output[_iPC], context);
    }
    return contents;
};
const de_ProvisionPublicIpv4PoolCidrResult = (output, context) => {
    const contents = {};
    if (output[_pIo] != null) {
        contents[_PIo] = __expectString(output[_pIo]);
    }
    if (output[_pAR] != null) {
        contents[_PAR] = de_PublicIpv4PoolRange(output[_pAR], context);
    }
    return contents;
};
const de_PtrUpdateStatus = (output, context) => {
    const contents = {};
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_rea] != null) {
        contents[_Rea] = __expectString(output[_rea]);
    }
    return contents;
};
const de_PublicIpv4Pool = (output, context) => {
    const contents = {};
    if (output[_pIo] != null) {
        contents[_PIo] = __expectString(output[_pIo]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.poolAddressRangeSet === "") {
        contents[_PARo] = [];
    }
    else if (output[_pARS] != null && output[_pARS][_i] != null) {
        contents[_PARo] = de_PublicIpv4PoolRangeSet(__getArrayIfSingleItem(output[_pARS][_i]), context);
    }
    if (output[_tAC] != null) {
        contents[_TAC] = __strictParseInt32(output[_tAC]);
    }
    if (output[_tAAC] != null) {
        contents[_TAAC] = __strictParseInt32(output[_tAAC]);
    }
    if (output[_nBG] != null) {
        contents[_NBG] = __expectString(output[_nBG]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_PublicIpv4PoolRange = (output, context) => {
    const contents = {};
    if (output[_fAi] != null) {
        contents[_FAi] = __expectString(output[_fAi]);
    }
    if (output[_lAa] != null) {
        contents[_LAa] = __expectString(output[_lAa]);
    }
    if (output[_aCd] != null) {
        contents[_ACd] = __strictParseInt32(output[_aCd]);
    }
    if (output[_aAC] != null) {
        contents[_AACv] = __strictParseInt32(output[_aAC]);
    }
    return contents;
};
const de_PublicIpv4PoolRangeSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PublicIpv4PoolRange(entry, context);
    });
};
const de_PublicIpv4PoolSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PublicIpv4Pool(entry, context);
    });
};
const de_Purchase = (output, context) => {
    const contents = {};
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output[_du] != null) {
        contents[_Du] = __strictParseInt32(output[_du]);
    }
    if (output.hostIdSet === "") {
        contents[_HIS] = [];
    }
    else if (output[_hIS] != null && output[_hIS][_i] != null) {
        contents[_HIS] = de_ResponseHostIdSet(__getArrayIfSingleItem(output[_hIS][_i]), context);
    }
    if (output[_hRI] != null) {
        contents[_HRI] = __expectString(output[_hRI]);
    }
    if (output[_hPo] != null) {
        contents[_HPo] = __expectString(output[_hPo]);
    }
    if (output[_iF] != null) {
        contents[_IF] = __expectString(output[_iF]);
    }
    if (output[_pO] != null) {
        contents[_PO] = __expectString(output[_pO]);
    }
    if (output[_uP] != null) {
        contents[_UPp] = __expectString(output[_uP]);
    }
    return contents;
};
const de_PurchaseCapacityBlockExtensionResult = (output, context) => {
    const contents = {};
    if (output.capacityBlockExtensionSet === "") {
        contents[_CBE] = [];
    }
    else if (output[_cBESa] != null && output[_cBESa][_i] != null) {
        contents[_CBE] = de_CapacityBlockExtensionSet(__getArrayIfSingleItem(output[_cBESa][_i]), context);
    }
    return contents;
};
const de_PurchaseCapacityBlockResult = (output, context) => {
    const contents = {};
    if (output[_cR] != null) {
        contents[_CRapa] = de_CapacityReservation(output[_cR], context);
    }
    return contents;
};
const de_PurchasedScheduledInstanceSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ScheduledInstance(entry, context);
    });
};
const de_PurchaseHostReservationResult = (output, context) => {
    const contents = {};
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output.purchase === "") {
        contents[_Pur] = [];
    }
    else if (output[_pur] != null && output[_pur][_i] != null) {
        contents[_Pur] = de_PurchaseSet(__getArrayIfSingleItem(output[_pur][_i]), context);
    }
    if (output[_tHP] != null) {
        contents[_THP] = __expectString(output[_tHP]);
    }
    if (output[_tUP] != null) {
        contents[_TUP] = __expectString(output[_tUP]);
    }
    return contents;
};
const de_PurchaseReservedInstancesOfferingResult = (output, context) => {
    const contents = {};
    if (output[_rII] != null) {
        contents[_RIIe] = __expectString(output[_rII]);
    }
    return contents;
};
const de_PurchaseScheduledInstancesResult = (output, context) => {
    const contents = {};
    if (output.scheduledInstanceSet === "") {
        contents[_SIS] = [];
    }
    else if (output[_sIS] != null && output[_sIS][_i] != null) {
        contents[_SIS] = de_PurchasedScheduledInstanceSet(__getArrayIfSingleItem(output[_sIS][_i]), context);
    }
    return contents;
};
const de_PurchaseSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Purchase(entry, context);
    });
};
const de_RecurringCharge = (output, context) => {
    const contents = {};
    if (output[_am] != null) {
        contents[_Am] = __strictParseFloat(output[_am]);
    }
    if (output[_fre] != null) {
        contents[_Fre] = __expectString(output[_fre]);
    }
    return contents;
};
const de_RecurringChargesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RecurringCharge(entry, context);
    });
};
const de_ReferencedSecurityGroup = (output, context) => {
    const contents = {};
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_pSee] != null) {
        contents[_PSe] = __expectString(output[_pSee]);
    }
    if (output[_uI] != null) {
        contents[_UIs] = __expectString(output[_uI]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_vPCI] != null) {
        contents[_VPCI] = __expectString(output[_vPCI]);
    }
    return contents;
};
const de_Region = (output, context) => {
    const contents = {};
    if (output[_oIS] != null) {
        contents[_OIS] = __expectString(output[_oIS]);
    }
    if (output[_rNe] != null) {
        contents[_RN] = __expectString(output[_rNe]);
    }
    if (output[_rEe] != null) {
        contents[_Endp] = __expectString(output[_rEe]);
    }
    return contents;
};
const de_RegionalSummary = (output, context) => {
    const contents = {};
    if (output[_rNe] != null) {
        contents[_RN] = __expectString(output[_rNe]);
    }
    if (output[_nOMA] != null) {
        contents[_NOMA] = __strictParseInt32(output[_nOMA]);
    }
    if (output[_nOUA] != null) {
        contents[_NOUA] = __strictParseInt32(output[_nOUA]);
    }
    return contents;
};
const de_RegionalSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RegionalSummary(entry, context);
    });
};
const de_RegionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Region(entry, context);
    });
};
const de_RegisterImageResult = (output, context) => {
    const contents = {};
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    return contents;
};
const de_RegisterInstanceEventNotificationAttributesResult = (output, context) => {
    const contents = {};
    if (output[_iTA] != null) {
        contents[_ITA] = de_InstanceTagNotificationAttribute(output[_iTA], context);
    }
    return contents;
};
const de_RegisterTransitGatewayMulticastGroupMembersResult = (output, context) => {
    const contents = {};
    if (output[_rMGM] != null) {
        contents[_RMGM] = de_TransitGatewayMulticastRegisteredGroupMembers(output[_rMGM], context);
    }
    return contents;
};
const de_RegisterTransitGatewayMulticastGroupSourcesResult = (output, context) => {
    const contents = {};
    if (output[_rMGS] != null) {
        contents[_RMGS] = de_TransitGatewayMulticastRegisteredGroupSources(output[_rMGS], context);
    }
    return contents;
};
const de_RejectCapacityReservationBillingOwnershipResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_RejectTransitGatewayMulticastDomainAssociationsResult = (output, context) => {
    const contents = {};
    if (output[_a] != null) {
        contents[_Ass] = de_TransitGatewayMulticastDomainAssociations(output[_a], context);
    }
    return contents;
};
const de_RejectTransitGatewayPeeringAttachmentResult = (output, context) => {
    const contents = {};
    if (output[_tGPA] != null) {
        contents[_TGPA] = de_TransitGatewayPeeringAttachment(output[_tGPA], context);
    }
    return contents;
};
const de_RejectTransitGatewayVpcAttachmentResult = (output, context) => {
    const contents = {};
    if (output[_tGVA] != null) {
        contents[_TGVA] = de_TransitGatewayVpcAttachment(output[_tGVA], context);
    }
    return contents;
};
const de_RejectVpcEndpointConnectionsResult = (output, context) => {
    const contents = {};
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_UnsuccessfulItemSet(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_RejectVpcPeeringConnectionResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ReleaseHostsResult = (output, context) => {
    const contents = {};
    if (output.successful === "") {
        contents[_Suc] = [];
    }
    else if (output[_suc] != null && output[_suc][_i] != null) {
        contents[_Suc] = de_ResponseHostIdList(__getArrayIfSingleItem(output[_suc][_i]), context);
    }
    if (output.unsuccessful === "") {
        contents[_Un] = [];
    }
    else if (output[_u] != null && output[_u][_i] != null) {
        contents[_Un] = de_UnsuccessfulItemList(__getArrayIfSingleItem(output[_u][_i]), context);
    }
    return contents;
};
const de_ReleaseIpamPoolAllocationResult = (output, context) => {
    const contents = {};
    if (output[_succ] != null) {
        contents[_Succ] = __parseBoolean(output[_succ]);
    }
    return contents;
};
const de_ReplaceIamInstanceProfileAssociationResult = (output, context) => {
    const contents = {};
    if (output[_iIPA] != null) {
        contents[_IIPA] = de_IamInstanceProfileAssociation(output[_iIPA], context);
    }
    return contents;
};
const de_ReplaceImageCriteriaInAllowedImagesSettingsResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_RV] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ReplaceNetworkAclAssociationResult = (output, context) => {
    const contents = {};
    if (output[_nAIe] != null) {
        contents[_NAIew] = __expectString(output[_nAIe]);
    }
    return contents;
};
const de_ReplaceRootVolumeTask = (output, context) => {
    const contents = {};
    if (output[_rRVTI] != null) {
        contents[_RRVTIe] = __expectString(output[_rRVTI]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_tSas] != null) {
        contents[_TSas] = __expectString(output[_tSas]);
    }
    if (output[_sT] != null) {
        contents[_STt] = __expectString(output[_sT]);
    }
    if (output[_cTom] != null) {
        contents[_CTom] = __expectString(output[_cTom]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_dRRV] != null) {
        contents[_DRRV] = __parseBoolean(output[_dRRV]);
    }
    return contents;
};
const de_ReplaceRootVolumeTasks = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReplaceRootVolumeTask(entry, context);
    });
};
const de_ReplaceRouteTableAssociationResult = (output, context) => {
    const contents = {};
    if (output[_nAIe] != null) {
        contents[_NAIew] = __expectString(output[_nAIe]);
    }
    if (output[_aS] != null) {
        contents[_ASs] = de_RouteTableAssociationState(output[_aS], context);
    }
    return contents;
};
const de_ReplaceTransitGatewayRouteResult = (output, context) => {
    const contents = {};
    if (output[_ro] != null) {
        contents[_Rou] = de_TransitGatewayRoute(output[_ro], context);
    }
    return contents;
};
const de_ReplaceVpnTunnelResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_RequestSpotFleetResponse = (output, context) => {
    const contents = {};
    if (output[_sFRI] != null) {
        contents[_SFRIp] = __expectString(output[_sFRI]);
    }
    return contents;
};
const de_RequestSpotInstancesResult = (output, context) => {
    const contents = {};
    if (output.spotInstanceRequestSet === "") {
        contents[_SIR] = [];
    }
    else if (output[_sIRS] != null && output[_sIRS][_i] != null) {
        contents[_SIR] = de_SpotInstanceRequestList(__getArrayIfSingleItem(output[_sIRS][_i]), context);
    }
    return contents;
};
const de_Reservation = (output, context) => {
    const contents = {};
    if (output[_rIese] != null) {
        contents[_RIeser] = __expectString(output[_rIese]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_rIeq] != null) {
        contents[_RIeq] = __expectString(output[_rIeq]);
    }
    if (output.groupSet === "") {
        contents[_G] = [];
    }
    else if (output[_gS] != null && output[_gS][_i] != null) {
        contents[_G] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);
    }
    if (output.instancesSet === "") {
        contents[_In] = [];
    }
    else if (output[_iSn] != null && output[_iSn][_i] != null) {
        contents[_In] = de_InstanceList(__getArrayIfSingleItem(output[_iSn][_i]), context);
    }
    return contents;
};
const de_ReservationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Reservation(entry, context);
    });
};
const de_ReservationValue = (output, context) => {
    const contents = {};
    if (output[_hPo] != null) {
        contents[_HPo] = __expectString(output[_hPo]);
    }
    if (output[_rTV] != null) {
        contents[_RTV] = __expectString(output[_rTV]);
    }
    if (output[_rUV] != null) {
        contents[_RUV] = __expectString(output[_rUV]);
    }
    return contents;
};
const de_ReservedInstanceReservationValue = (output, context) => {
    const contents = {};
    if (output[_rVe] != null) {
        contents[_RVe] = de_ReservationValue(output[_rVe], context);
    }
    if (output[_rIIe] != null) {
        contents[_RIIese] = __expectString(output[_rIIe]);
    }
    return contents;
};
const de_ReservedInstanceReservationValueSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedInstanceReservationValue(entry, context);
    });
};
const de_ReservedInstances = (output, context) => {
    const contents = {};
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output[_iTns] != null) {
        contents[_ITns] = __expectString(output[_iTns]);
    }
    if (output[_oC] != null) {
        contents[_OC] = __expectString(output[_oC]);
    }
    if (output[_oTf] != null) {
        contents[_OT] = __expectString(output[_oTf]);
    }
    if (output.recurringCharges === "") {
        contents[_RCec] = [];
    }
    else if (output[_rCec] != null && output[_rCec][_i] != null) {
        contents[_RCec] = de_RecurringChargesList(__getArrayIfSingleItem(output[_rCec][_i]), context);
    }
    if (output[_sc] != null) {
        contents[_Sc] = __expectString(output[_sc]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_rII] != null) {
        contents[_RIIe] = __expectString(output[_rII]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_star] != null) {
        contents[_Star] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_star]));
    }
    if (output[_end] != null) {
        contents[_End] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_end]));
    }
    if (output[_du] != null) {
        contents[_Du] = __strictParseLong(output[_du]);
    }
    if (output[_uPs] != null) {
        contents[_UPs] = __strictParseFloat(output[_uPs]);
    }
    if (output[_fPi] != null) {
        contents[_FPi] = __strictParseFloat(output[_fPi]);
    }
    if (output[_iC] != null) {
        contents[_IC] = __strictParseInt32(output[_iC]);
    }
    if (output[_pDr] != null) {
        contents[_PDr] = __expectString(output[_pDr]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_ReservedInstancesConfiguration = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_iC] != null) {
        contents[_IC] = __strictParseInt32(output[_iC]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    if (output[_sc] != null) {
        contents[_Sc] = __expectString(output[_sc]);
    }
    return contents;
};
const de_ReservedInstancesId = (output, context) => {
    const contents = {};
    if (output[_rII] != null) {
        contents[_RIIe] = __expectString(output[_rII]);
    }
    return contents;
};
const de_ReservedInstancesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedInstances(entry, context);
    });
};
const de_ReservedInstancesListing = (output, context) => {
    const contents = {};
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    if (output[_cD] != null) {
        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cD]));
    }
    if (output.instanceCounts === "") {
        contents[_ICn] = [];
    }
    else if (output[_iCn] != null && output[_iCn][_i] != null) {
        contents[_ICn] = de_InstanceCountList(__getArrayIfSingleItem(output[_iCn][_i]), context);
    }
    if (output.priceSchedules === "") {
        contents[_PS] = [];
    }
    else if (output[_pSri] != null && output[_pSri][_i] != null) {
        contents[_PS] = de_PriceScheduleList(__getArrayIfSingleItem(output[_pSri][_i]), context);
    }
    if (output[_rII] != null) {
        contents[_RIIe] = __expectString(output[_rII]);
    }
    if (output[_rILI] != null) {
        contents[_RILI] = __expectString(output[_rILI]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_uDpd] != null) {
        contents[_UDpd] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uDpd]));
    }
    return contents;
};
const de_ReservedInstancesListingList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedInstancesListing(entry, context);
    });
};
const de_ReservedInstancesModification = (output, context) => {
    const contents = {};
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    if (output[_cD] != null) {
        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cD]));
    }
    if (output[_eDf] != null) {
        contents[_EDf] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eDf]));
    }
    if (output.modificationResultSet === "") {
        contents[_MRo] = [];
    }
    else if (output[_mRS] != null && output[_mRS][_i] != null) {
        contents[_MRo] = de_ReservedInstancesModificationResultList(__getArrayIfSingleItem(output[_mRS][_i]), context);
    }
    if (output.reservedInstancesSet === "") {
        contents[_RIIes] = [];
    }
    else if (output[_rIS] != null && output[_rIS][_i] != null) {
        contents[_RIIes] = de_ReservedIntancesIds(__getArrayIfSingleItem(output[_rIS][_i]), context);
    }
    if (output[_rIMI] != null) {
        contents[_RIMIe] = __expectString(output[_rIMI]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_uDpd] != null) {
        contents[_UDpd] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uDpd]));
    }
    return contents;
};
const de_ReservedInstancesModificationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedInstancesModification(entry, context);
    });
};
const de_ReservedInstancesModificationResult = (output, context) => {
    const contents = {};
    if (output[_rII] != null) {
        contents[_RIIe] = __expectString(output[_rII]);
    }
    if (output[_tCa] != null) {
        contents[_TCar] = de_ReservedInstancesConfiguration(output[_tCa], context);
    }
    return contents;
};
const de_ReservedInstancesModificationResultList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedInstancesModificationResult(entry, context);
    });
};
const de_ReservedInstancesOffering = (output, context) => {
    const contents = {};
    if (output[_cC] != null) {
        contents[_CCu] = __expectString(output[_cC]);
    }
    if (output[_iTns] != null) {
        contents[_ITns] = __expectString(output[_iTns]);
    }
    if (output[_mar] != null) {
        contents[_Mar] = __parseBoolean(output[_mar]);
    }
    if (output[_oC] != null) {
        contents[_OC] = __expectString(output[_oC]);
    }
    if (output[_oTf] != null) {
        contents[_OT] = __expectString(output[_oTf]);
    }
    if (output.pricingDetailsSet === "") {
        contents[_PDri] = [];
    }
    else if (output[_pDS] != null && output[_pDS][_i] != null) {
        contents[_PDri] = de_PricingDetailsList(__getArrayIfSingleItem(output[_pDS][_i]), context);
    }
    if (output.recurringCharges === "") {
        contents[_RCec] = [];
    }
    else if (output[_rCec] != null && output[_rCec][_i] != null) {
        contents[_RCec] = de_RecurringChargesList(__getArrayIfSingleItem(output[_rCec][_i]), context);
    }
    if (output[_sc] != null) {
        contents[_Sc] = __expectString(output[_sc]);
    }
    if (output[_rIOI] != null) {
        contents[_RIOIe] = __expectString(output[_rIOI]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_du] != null) {
        contents[_Du] = __strictParseLong(output[_du]);
    }
    if (output[_uPs] != null) {
        contents[_UPs] = __strictParseFloat(output[_uPs]);
    }
    if (output[_fPi] != null) {
        contents[_FPi] = __strictParseFloat(output[_fPi]);
    }
    if (output[_pDr] != null) {
        contents[_PDr] = __expectString(output[_pDr]);
    }
    return contents;
};
const de_ReservedInstancesOfferingList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedInstancesOffering(entry, context);
    });
};
const de_ReservedIntancesIds = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedInstancesId(entry, context);
    });
};
const de_ResetAddressAttributeResult = (output, context) => {
    const contents = {};
    if (output[_ad] != null) {
        contents[_Ad] = de_AddressAttribute(output[_ad], context);
    }
    return contents;
};
const de_ResetEbsDefaultKmsKeyIdResult = (output, context) => {
    const contents = {};
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    return contents;
};
const de_ResetFpgaImageAttributeResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_ResourceStatement = (output, context) => {
    const contents = {};
    if (output.resourceSet === "") {
        contents[_Re] = [];
    }
    else if (output[_rSesou] != null && output[_rSesou][_i] != null) {
        contents[_Re] = de_ValueStringList(__getArrayIfSingleItem(output[_rSesou][_i]), context);
    }
    if (output.resourceTypeSet === "") {
        contents[_RTeso] = [];
    }
    else if (output[_rTSes] != null && output[_rTSes][_i] != null) {
        contents[_RTeso] = de_ValueStringList(__getArrayIfSingleItem(output[_rTSes][_i]), context);
    }
    return contents;
};
const de_ResponseError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ResponseHostIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ResponseHostIdSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ResponseLaunchTemplateData = (output, context) => {
    const contents = {};
    if (output[_kI] != null) {
        contents[_KI] = __expectString(output[_kI]);
    }
    if (output[_eO] != null) {
        contents[_EO] = __parseBoolean(output[_eO]);
    }
    if (output[_iIP] != null) {
        contents[_IIP] = de_LaunchTemplateIamInstanceProfileSpecification(output[_iIP], context);
    }
    if (output.blockDeviceMappingSet === "") {
        contents[_BDM] = [];
    }
    else if (output[_bDMS] != null && output[_bDMS][_i] != null) {
        contents[_BDM] = de_LaunchTemplateBlockDeviceMappingList(__getArrayIfSingleItem(output[_bDMS][_i]), context);
    }
    if (output.networkInterfaceSet === "") {
        contents[_NI] = [];
    }
    else if (output[_nIS] != null && output[_nIS][_i] != null) {
        contents[_NI] = de_LaunchTemplateInstanceNetworkInterfaceSpecificationList(__getArrayIfSingleItem(output[_nIS][_i]), context);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_kN] != null) {
        contents[_KN] = __expectString(output[_kN]);
    }
    if (output[_mo] != null) {
        contents[_Mon] = de_LaunchTemplatesMonitoring(output[_mo], context);
    }
    if (output[_pla] != null) {
        contents[_Pl] = de_LaunchTemplatePlacement(output[_pla], context);
    }
    if (output[_rDI] != null) {
        contents[_RDI] = __expectString(output[_rDI]);
    }
    if (output[_dAT] != null) {
        contents[_DATis] = __parseBoolean(output[_dAT]);
    }
    if (output[_iISB] != null) {
        contents[_IISB] = __expectString(output[_iISB]);
    }
    if (output[_uDs] != null) {
        contents[_UD] = __expectString(output[_uDs]);
    }
    if (output.tagSpecificationSet === "") {
        contents[_TS] = [];
    }
    else if (output[_tSS] != null && output[_tSS][_i] != null) {
        contents[_TS] = de_LaunchTemplateTagSpecificationList(__getArrayIfSingleItem(output[_tSS][_i]), context);
    }
    if (output.elasticGpuSpecificationSet === "") {
        contents[_EGS] = [];
    }
    else if (output[_eGSS] != null && output[_eGSS][_i] != null) {
        contents[_EGS] = de_ElasticGpuSpecificationResponseList(__getArrayIfSingleItem(output[_eGSS][_i]), context);
    }
    if (output.elasticInferenceAcceleratorSet === "") {
        contents[_EIA] = [];
    }
    else if (output[_eIAS] != null && output[_eIAS][_i] != null) {
        contents[_EIA] = de_LaunchTemplateElasticInferenceAcceleratorResponseList(__getArrayIfSingleItem(output[_eIAS][_i]), context);
    }
    if (output.securityGroupIdSet === "") {
        contents[_SGI] = [];
    }
    else if (output[_sGIS] != null && output[_sGIS][_i] != null) {
        contents[_SGI] = de_ValueStringList(__getArrayIfSingleItem(output[_sGIS][_i]), context);
    }
    if (output.securityGroupSet === "") {
        contents[_SG] = [];
    }
    else if (output[_sGS] != null && output[_sGS][_i] != null) {
        contents[_SG] = de_ValueStringList(__getArrayIfSingleItem(output[_sGS][_i]), context);
    }
    if (output[_iMOn] != null) {
        contents[_IMO] = de_LaunchTemplateInstanceMarketOptions(output[_iMOn], context);
    }
    if (output[_cSr] != null) {
        contents[_CSred] = de_CreditSpecification(output[_cSr], context);
    }
    if (output[_cO] != null) {
        contents[_COp] = de_LaunchTemplateCpuOptions(output[_cO], context);
    }
    if (output[_cRSa] != null) {
        contents[_CRSa] = de_LaunchTemplateCapacityReservationSpecificationResponse(output[_cRSa], context);
    }
    if (output.licenseSet === "") {
        contents[_LSi] = [];
    }
    else if (output[_lSi] != null && output[_lSi][_i] != null) {
        contents[_LSi] = de_LaunchTemplateLicenseList(__getArrayIfSingleItem(output[_lSi][_i]), context);
    }
    if (output[_hO] != null) {
        contents[_HO] = de_LaunchTemplateHibernationOptions(output[_hO], context);
    }
    if (output[_mO] != null) {
        contents[_MO] = de_LaunchTemplateInstanceMetadataOptions(output[_mO], context);
    }
    if (output[_eOn] != null) {
        contents[_EOn] = de_LaunchTemplateEnclaveOptions(output[_eOn], context);
    }
    if (output[_iR] != null) {
        contents[_IR] = de_InstanceRequirements(output[_iR], context);
    }
    if (output[_pDNO] != null) {
        contents[_PDNO] = de_LaunchTemplatePrivateDnsNameOptions(output[_pDNO], context);
    }
    if (output[_mOa] != null) {
        contents[_MOa] = de_LaunchTemplateInstanceMaintenanceOptions(output[_mOa], context);
    }
    if (output[_dASi] != null) {
        contents[_DAS] = __parseBoolean(output[_dASi]);
    }
    if (output[_op] != null) {
        contents[_O] = de_OperatorResponse(output[_op], context);
    }
    if (output[_nPO] != null) {
        contents[_NPO] = de_LaunchTemplateNetworkPerformanceOptions(output[_nPO], context);
    }
    return contents;
};
const de_RestoreAddressToClassicResult = (output, context) => {
    const contents = {};
    if (output[_pI] != null) {
        contents[_PI] = __expectString(output[_pI]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_RestoreImageFromRecycleBinResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_RestoreManagedPrefixListVersionResult = (output, context) => {
    const contents = {};
    if (output[_pL] != null) {
        contents[_PLr] = de_ManagedPrefixList(output[_pL], context);
    }
    return contents;
};
const de_RestoreSnapshotFromRecycleBinResult = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_enc] != null) {
        contents[_Enc] = __parseBoolean(output[_enc]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_pro] != null) {
        contents[_Prog] = __expectString(output[_pro]);
    }
    if (output[_sT] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));
    }
    if (output[_sta] != null) {
        contents[_Stat] = __expectString(output[_sta]);
    }
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    if (output[_vSo] != null) {
        contents[_VS] = __strictParseInt32(output[_vSo]);
    }
    if (output[_sTs] != null) {
        contents[_STs] = __expectString(output[_sTs]);
    }
    return contents;
};
const de_RestoreSnapshotTierResult = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_rST] != null) {
        contents[_RSTe] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rST]));
    }
    if (output[_rD] != null) {
        contents[_RD] = __strictParseInt32(output[_rD]);
    }
    if (output[_iPR] != null) {
        contents[_IPR] = __parseBoolean(output[_iPR]);
    }
    return contents;
};
const de_RevokeClientVpnIngressResult = (output, context) => {
    const contents = {};
    if (output[_sta] != null) {
        contents[_Statu] = de_ClientVpnAuthorizationRuleStatus(output[_sta], context);
    }
    return contents;
};
const de_RevokedSecurityGroupRule = (output, context) => {
    const contents = {};
    if (output[_sGRI] != null) {
        contents[_SGRIe] = __expectString(output[_sGRI]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_iEs] != null) {
        contents[_IE] = __parseBoolean(output[_iEs]);
    }
    if (output[_iPpr] != null) {
        contents[_IPpr] = __expectString(output[_iPpr]);
    }
    if (output[_fP] != null) {
        contents[_FP] = __strictParseInt32(output[_fP]);
    }
    if (output[_tPo] != null) {
        contents[_TP] = __strictParseInt32(output[_tPo]);
    }
    if (output[_cIidr] != null) {
        contents[_CIidr] = __expectString(output[_cIidr]);
    }
    if (output[_cIid] != null) {
        contents[_CIid] = __expectString(output[_cIid]);
    }
    if (output[_pLI] != null) {
        contents[_PLI] = __expectString(output[_pLI]);
    }
    if (output[_rGI] != null) {
        contents[_RGI] = __expectString(output[_rGI]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    return contents;
};
const de_RevokedSecurityGroupRuleList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RevokedSecurityGroupRule(entry, context);
    });
};
const de_RevokeSecurityGroupEgressResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    if (output.unknownIpPermissionSet === "") {
        contents[_UIP] = [];
    }
    else if (output[_uIPS] != null && output[_uIPS][_i] != null) {
        contents[_UIP] = de_IpPermissionList(__getArrayIfSingleItem(output[_uIPS][_i]), context);
    }
    if (output.revokedSecurityGroupRuleSet === "") {
        contents[_RSGR] = [];
    }
    else if (output[_rSGRS] != null && output[_rSGRS][_i] != null) {
        contents[_RSGR] = de_RevokedSecurityGroupRuleList(__getArrayIfSingleItem(output[_rSGRS][_i]), context);
    }
    return contents;
};
const de_RevokeSecurityGroupIngressResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    if (output.unknownIpPermissionSet === "") {
        contents[_UIP] = [];
    }
    else if (output[_uIPS] != null && output[_uIPS][_i] != null) {
        contents[_UIP] = de_IpPermissionList(__getArrayIfSingleItem(output[_uIPS][_i]), context);
    }
    if (output.revokedSecurityGroupRuleSet === "") {
        contents[_RSGR] = [];
    }
    else if (output[_rSGRS] != null && output[_rSGRS][_i] != null) {
        contents[_RSGR] = de_RevokedSecurityGroupRuleList(__getArrayIfSingleItem(output[_rSGRS][_i]), context);
    }
    return contents;
};
const de_RootDeviceTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Route = (output, context) => {
    const contents = {};
    if (output[_dCB] != null) {
        contents[_DCB] = __expectString(output[_dCB]);
    }
    if (output[_dICB] != null) {
        contents[_DICB] = __expectString(output[_dICB]);
    }
    if (output[_dPLI] != null) {
        contents[_DPLI] = __expectString(output[_dPLI]);
    }
    if (output[_eOIGI] != null) {
        contents[_EOIGI] = __expectString(output[_eOIGI]);
    }
    if (output[_gI] != null) {
        contents[_GI] = __expectString(output[_gI]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_iOIn] != null) {
        contents[_IOIn] = __expectString(output[_iOIn]);
    }
    if (output[_nGI] != null) {
        contents[_NGI] = __expectString(output[_nGI]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_lGI] != null) {
        contents[_LGI] = __expectString(output[_lGI]);
    }
    if (output[_cGI] != null) {
        contents[_CGI] = __expectString(output[_cGI]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_o] != null) {
        contents[_Or] = __expectString(output[_o]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_vPCI] != null) {
        contents[_VPCI] = __expectString(output[_vPCI]);
    }
    if (output[_cNA] != null) {
        contents[_CNAo] = __expectString(output[_cNA]);
    }
    return contents;
};
const de_RouteList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Route(entry, context);
    });
};
const de_RouteServer = (output, context) => {
    const contents = {};
    if (output[_rSI] != null) {
        contents[_RSIo] = __expectString(output[_rSI]);
    }
    if (output[_aSA] != null) {
        contents[_ASA] = __strictParseLong(output[_aSA]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_pRSe] != null) {
        contents[_PRS] = __expectString(output[_pRSe]);
    }
    if (output[_pRD] != null) {
        contents[_PRD] = __strictParseLong(output[_pRD]);
    }
    if (output[_sNE] != null) {
        contents[_SNE] = __parseBoolean(output[_sNE]);
    }
    if (output[_sTA] != null) {
        contents[_STA] = __expectString(output[_sTA]);
    }
    return contents;
};
const de_RouteServerAssociation = (output, context) => {
    const contents = {};
    if (output[_rSI] != null) {
        contents[_RSIo] = __expectString(output[_rSI]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_RouteServerAssociationsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteServerAssociation(entry, context);
    });
};
const de_RouteServerBfdStatus = (output, context) => {
    const contents = {};
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_RouteServerBgpOptions = (output, context) => {
    const contents = {};
    if (output[_pAee] != null) {
        contents[_PAee] = __strictParseLong(output[_pAee]);
    }
    if (output[_pLD] != null) {
        contents[_PLD] = __expectString(output[_pLD]);
    }
    return contents;
};
const de_RouteServerBgpStatus = (output, context) => {
    const contents = {};
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_RouteServerEndpoint = (output, context) => {
    const contents = {};
    if (output[_rSI] != null) {
        contents[_RSIo] = __expectString(output[_rSI]);
    }
    if (output[_rSEI] != null) {
        contents[_RSEI] = __expectString(output[_rSEI]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_eIn] != null) {
        contents[_EIn] = __expectString(output[_eIn]);
    }
    if (output[_eA] != null) {
        contents[_EAn] = __expectString(output[_eA]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_fR] != null) {
        contents[_FR] = __expectString(output[_fR]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_RouteServerEndpointsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteServerEndpoint(entry, context);
    });
};
const de_RouteServerPeer = (output, context) => {
    const contents = {};
    if (output[_rSPI] != null) {
        contents[_RSPI] = __expectString(output[_rSPI]);
    }
    if (output[_rSEI] != null) {
        contents[_RSEI] = __expectString(output[_rSEI]);
    }
    if (output[_rSI] != null) {
        contents[_RSIo] = __expectString(output[_rSI]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_fR] != null) {
        contents[_FR] = __expectString(output[_fR]);
    }
    if (output[_eEI] != null) {
        contents[_EEI] = __expectString(output[_eEI]);
    }
    if (output[_eEA] != null) {
        contents[_EEA] = __expectString(output[_eEA]);
    }
    if (output[_pAe] != null) {
        contents[_PAe] = __expectString(output[_pAe]);
    }
    if (output[_bO] != null) {
        contents[_BO] = de_RouteServerBgpOptions(output[_bO], context);
    }
    if (output[_bSg] != null) {
        contents[_BS] = de_RouteServerBgpStatus(output[_bSg], context);
    }
    if (output[_bSf] != null) {
        contents[_BSf] = de_RouteServerBfdStatus(output[_bSf], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_RouteServerPeersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteServerPeer(entry, context);
    });
};
const de_RouteServerPropagation = (output, context) => {
    const contents = {};
    if (output[_rSI] != null) {
        contents[_RSIo] = __expectString(output[_rSI]);
    }
    if (output[_rTI] != null) {
        contents[_RTI] = __expectString(output[_rTI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_RouteServerPropagationsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteServerPropagation(entry, context);
    });
};
const de_RouteServerRoute = (output, context) => {
    const contents = {};
    if (output[_rSEI] != null) {
        contents[_RSEI] = __expectString(output[_rSEI]);
    }
    if (output[_rSPI] != null) {
        contents[_RSPI] = __expectString(output[_rSPI]);
    }
    if (output.routeInstallationDetailSet === "") {
        contents[_RID] = [];
    }
    else if (output[_rIDS] != null && output[_rIDS][_i] != null) {
        contents[_RID] = de_RouteServerRouteInstallationDetails(__getArrayIfSingleItem(output[_rIDS][_i]), context);
    }
    if (output[_rSout] != null) {
        contents[_RSout] = __expectString(output[_rSout]);
    }
    if (output[_pre] != null) {
        contents[_Pr] = __expectString(output[_pre]);
    }
    if (output.asPathSet === "") {
        contents[_APs] = [];
    }
    else if (output[_aPSs] != null && output[_aPSs][_i] != null) {
        contents[_APs] = de_AsPath(__getArrayIfSingleItem(output[_aPSs][_i]), context);
    }
    if (output[_med] != null) {
        contents[_Med] = __strictParseInt32(output[_med]);
    }
    if (output[_nHI] != null) {
        contents[_NHI] = __expectString(output[_nHI]);
    }
    return contents;
};
const de_RouteServerRouteInstallationDetail = (output, context) => {
    const contents = {};
    if (output[_rTI] != null) {
        contents[_RTI] = __expectString(output[_rTI]);
    }
    if (output[_rISo] != null) {
        contents[_RISo] = __expectString(output[_rISo]);
    }
    if (output[_rISR] != null) {
        contents[_RISR] = __expectString(output[_rISR]);
    }
    return contents;
};
const de_RouteServerRouteInstallationDetails = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteServerRouteInstallationDetail(entry, context);
    });
};
const de_RouteServerRouteList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteServerRoute(entry, context);
    });
};
const de_RouteServersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteServer(entry, context);
    });
};
const de_RouteTable = (output, context) => {
    const contents = {};
    if (output.associationSet === "") {
        contents[_Ass] = [];
    }
    else if (output[_aSss] != null && output[_aSss][_i] != null) {
        contents[_Ass] = de_RouteTableAssociationList(__getArrayIfSingleItem(output[_aSss][_i]), context);
    }
    if (output.propagatingVgwSet === "") {
        contents[_PVr] = [];
    }
    else if (output[_pVS] != null && output[_pVS][_i] != null) {
        contents[_PVr] = de_PropagatingVgwList(__getArrayIfSingleItem(output[_pVS][_i]), context);
    }
    if (output[_rTI] != null) {
        contents[_RTI] = __expectString(output[_rTI]);
    }
    if (output.routeSet === "") {
        contents[_Rout] = [];
    }
    else if (output[_rSou] != null && output[_rSou][_i] != null) {
        contents[_Rout] = de_RouteList(__getArrayIfSingleItem(output[_rSou][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    return contents;
};
const de_RouteTableAssociation = (output, context) => {
    const contents = {};
    if (output[_mai] != null) {
        contents[_Mai] = __parseBoolean(output[_mai]);
    }
    if (output[_rTAI] != null) {
        contents[_RTAI] = __expectString(output[_rTAI]);
    }
    if (output[_rTI] != null) {
        contents[_RTI] = __expectString(output[_rTI]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_gI] != null) {
        contents[_GI] = __expectString(output[_gI]);
    }
    if (output[_aS] != null) {
        contents[_ASs] = de_RouteTableAssociationState(output[_aS], context);
    }
    return contents;
};
const de_RouteTableAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteTableAssociation(entry, context);
    });
};
const de_RouteTableAssociationState = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    return contents;
};
const de_RouteTableList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteTable(entry, context);
    });
};
const de_RuleGroupRuleOptionsPair = (output, context) => {
    const contents = {};
    if (output[_rGA] != null) {
        contents[_RGA] = __expectString(output[_rGA]);
    }
    if (output.ruleOptionSet === "") {
        contents[_ROu] = [];
    }
    else if (output[_rOS] != null && output[_rOS][_i] != null) {
        contents[_ROu] = de_RuleOptionList(__getArrayIfSingleItem(output[_rOS][_i]), context);
    }
    return contents;
};
const de_RuleGroupRuleOptionsPairList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RuleGroupRuleOptionsPair(entry, context);
    });
};
const de_RuleGroupTypePair = (output, context) => {
    const contents = {};
    if (output[_rGA] != null) {
        contents[_RGA] = __expectString(output[_rGA]);
    }
    if (output[_rGT] != null) {
        contents[_RGT] = __expectString(output[_rGT]);
    }
    return contents;
};
const de_RuleGroupTypePairList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RuleGroupTypePair(entry, context);
    });
};
const de_RuleOption = (output, context) => {
    const contents = {};
    if (output[_key] != null) {
        contents[_Key] = __expectString(output[_key]);
    }
    if (output.settingSet === "") {
        contents[_Set] = [];
    }
    else if (output[_sSe] != null && output[_sSe][_i] != null) {
        contents[_Set] = de_StringList(__getArrayIfSingleItem(output[_sSe][_i]), context);
    }
    return contents;
};
const de_RuleOptionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RuleOption(entry, context);
    });
};
const de_RunInstancesMonitoringEnabled = (output, context) => {
    const contents = {};
    if (output[_en] != null) {
        contents[_En] = __parseBoolean(output[_en]);
    }
    return contents;
};
const de_RunScheduledInstancesResult = (output, context) => {
    const contents = {};
    if (output.instanceIdSet === "") {
        contents[_IIS] = [];
    }
    else if (output[_iIS] != null && output[_iIS][_i] != null) {
        contents[_IIS] = de_InstanceIdSet(__getArrayIfSingleItem(output[_iIS][_i]), context);
    }
    return contents;
};
const de_S3Storage = (output, context) => {
    const contents = {};
    if (output[_AWSAKI] != null) {
        contents[_AWSAKI] = __expectString(output[_AWSAKI]);
    }
    if (output[_bu] != null) {
        contents[_B] = __expectString(output[_bu]);
    }
    if (output[_pre] != null) {
        contents[_Pr] = __expectString(output[_pre]);
    }
    if (output[_uPp] != null) {
        contents[_UP] = context.base64Decoder(output[_uPp]);
    }
    if (output[_uPS] != null) {
        contents[_UPS] = __expectString(output[_uPS]);
    }
    return contents;
};
const de_ScheduledInstance = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_cD] != null) {
        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cD]));
    }
    if (output[_hPo] != null) {
        contents[_HPo] = __expectString(output[_hPo]);
    }
    if (output[_iC] != null) {
        contents[_IC] = __strictParseInt32(output[_iC]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_nPe] != null) {
        contents[_NPe] = __expectString(output[_nPe]);
    }
    if (output[_nSST] != null) {
        contents[_NSST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nSST]));
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    if (output[_pSET] != null) {
        contents[_PSET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_pSET]));
    }
    if (output[_rec] != null) {
        contents[_Rec] = de_ScheduledInstanceRecurrence(output[_rec], context);
    }
    if (output[_sIIc] != null) {
        contents[_SIIch] = __expectString(output[_sIIc]);
    }
    if (output[_sDIH] != null) {
        contents[_SDIH] = __strictParseInt32(output[_sDIH]);
    }
    if (output[_tED] != null) {
        contents[_TED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tED]));
    }
    if (output[_tSD] != null) {
        contents[_TSD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tSD]));
    }
    if (output[_tSIH] != null) {
        contents[_TSIH] = __strictParseInt32(output[_tSIH]);
    }
    return contents;
};
const de_ScheduledInstanceAvailability = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_aICv] != null) {
        contents[_AICv] = __strictParseInt32(output[_aICv]);
    }
    if (output[_fSST] != null) {
        contents[_FSST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_fSST]));
    }
    if (output[_hPo] != null) {
        contents[_HPo] = __expectString(output[_hPo]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_mTDID] != null) {
        contents[_MTDID] = __strictParseInt32(output[_mTDID]);
    }
    if (output[_mTDIDi] != null) {
        contents[_MTDIDi] = __strictParseInt32(output[_mTDIDi]);
    }
    if (output[_nPe] != null) {
        contents[_NPe] = __expectString(output[_nPe]);
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    if (output[_pTu] != null) {
        contents[_PT] = __expectString(output[_pTu]);
    }
    if (output[_rec] != null) {
        contents[_Rec] = de_ScheduledInstanceRecurrence(output[_rec], context);
    }
    if (output[_sDIH] != null) {
        contents[_SDIH] = __strictParseInt32(output[_sDIH]);
    }
    if (output[_tSIH] != null) {
        contents[_TSIH] = __strictParseInt32(output[_tSIH]);
    }
    return contents;
};
const de_ScheduledInstanceAvailabilitySet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ScheduledInstanceAvailability(entry, context);
    });
};
const de_ScheduledInstanceRecurrence = (output, context) => {
    const contents = {};
    if (output[_fre] != null) {
        contents[_Fre] = __expectString(output[_fre]);
    }
    if (output[_int] != null) {
        contents[_Int] = __strictParseInt32(output[_int]);
    }
    if (output.occurrenceDaySet === "") {
        contents[_ODS] = [];
    }
    else if (output[_oDS] != null && output[_oDS][_i] != null) {
        contents[_ODS] = de_OccurrenceDaySet(__getArrayIfSingleItem(output[_oDS][_i]), context);
    }
    if (output[_oRTE] != null) {
        contents[_ORTE] = __parseBoolean(output[_oRTE]);
    }
    if (output[_oU] != null) {
        contents[_OU] = __expectString(output[_oU]);
    }
    return contents;
};
const de_ScheduledInstanceSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ScheduledInstance(entry, context);
    });
};
const de_SearchLocalGatewayRoutesResult = (output, context) => {
    const contents = {};
    if (output.routeSet === "") {
        contents[_Rout] = [];
    }
    else if (output[_rSou] != null && output[_rSou][_i] != null) {
        contents[_Rout] = de_LocalGatewayRouteList(__getArrayIfSingleItem(output[_rSou][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_SearchTransitGatewayMulticastGroupsResult = (output, context) => {
    const contents = {};
    if (output.multicastGroups === "") {
        contents[_MG] = [];
    }
    else if (output[_mG] != null && output[_mG][_i] != null) {
        contents[_MG] = de_TransitGatewayMulticastGroupList(__getArrayIfSingleItem(output[_mG][_i]), context);
    }
    if (output[_nTe] != null) {
        contents[_NT] = __expectString(output[_nTe]);
    }
    return contents;
};
const de_SearchTransitGatewayRoutesResult = (output, context) => {
    const contents = {};
    if (output.routeSet === "") {
        contents[_Rout] = [];
    }
    else if (output[_rSou] != null && output[_rSou][_i] != null) {
        contents[_Rout] = de_TransitGatewayRouteList(__getArrayIfSingleItem(output[_rSou][_i]), context);
    }
    if (output[_aRAd] != null) {
        contents[_ARAd] = __parseBoolean(output[_aRAd]);
    }
    return contents;
};
const de_SecurityGroup = (output, context) => {
    const contents = {};
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output.ipPermissionsEgress === "") {
        contents[_IPE] = [];
    }
    else if (output[_iPE] != null && output[_iPE][_i] != null) {
        contents[_IPE] = de_IpPermissionList(__getArrayIfSingleItem(output[_iPE][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_sGA] != null) {
        contents[_SGA] = __expectString(output[_sGA]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output[_gD] != null) {
        contents[_De] = __expectString(output[_gD]);
    }
    if (output.ipPermissions === "") {
        contents[_IPpe] = [];
    }
    else if (output[_iPpe] != null && output[_iPpe][_i] != null) {
        contents[_IPpe] = de_IpPermissionList(__getArrayIfSingleItem(output[_iPpe][_i]), context);
    }
    return contents;
};
const de_SecurityGroupForVpc = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_pVI] != null) {
        contents[_PVIr] = __expectString(output[_pVI]);
    }
    return contents;
};
const de_SecurityGroupForVpcList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SecurityGroupForVpc(entry, context);
    });
};
const de_SecurityGroupIdentifier = (output, context) => {
    const contents = {};
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    return contents;
};
const de_SecurityGroupIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SecurityGroupIdSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SecurityGroupIdStringList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SecurityGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SecurityGroup(entry, context);
    });
};
const de_SecurityGroupReference = (output, context) => {
    const contents = {};
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_rVI] != null) {
        contents[_RVI] = __expectString(output[_rVI]);
    }
    if (output[_vPCI] != null) {
        contents[_VPCI] = __expectString(output[_vPCI]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    return contents;
};
const de_SecurityGroupReferences = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SecurityGroupReference(entry, context);
    });
};
const de_SecurityGroupRule = (output, context) => {
    const contents = {};
    if (output[_sGRI] != null) {
        contents[_SGRIe] = __expectString(output[_sGRI]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_gOI] != null) {
        contents[_GOI] = __expectString(output[_gOI]);
    }
    if (output[_iEs] != null) {
        contents[_IE] = __parseBoolean(output[_iEs]);
    }
    if (output[_iPpr] != null) {
        contents[_IPpr] = __expectString(output[_iPpr]);
    }
    if (output[_fP] != null) {
        contents[_FP] = __strictParseInt32(output[_fP]);
    }
    if (output[_tPo] != null) {
        contents[_TP] = __strictParseInt32(output[_tPo]);
    }
    if (output[_cIidr] != null) {
        contents[_CIidr] = __expectString(output[_cIidr]);
    }
    if (output[_cIid] != null) {
        contents[_CIid] = __expectString(output[_cIid]);
    }
    if (output[_pLI] != null) {
        contents[_PLI] = __expectString(output[_pLI]);
    }
    if (output[_rGIe] != null) {
        contents[_RGIe] = de_ReferencedSecurityGroup(output[_rGIe], context);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_sGRA] != null) {
        contents[_SGRA] = __expectString(output[_sGRA]);
    }
    return contents;
};
const de_SecurityGroupRuleList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SecurityGroupRule(entry, context);
    });
};
const de_SecurityGroupVpcAssociation = (output, context) => {
    const contents = {};
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_vOIp] != null) {
        contents[_VOIp] = __expectString(output[_vOIp]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sRt] != null) {
        contents[_SRt] = __expectString(output[_sRt]);
    }
    return contents;
};
const de_SecurityGroupVpcAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SecurityGroupVpcAssociation(entry, context);
    });
};
const de_ServiceConfiguration = (output, context) => {
    const contents = {};
    if (output.serviceType === "") {
        contents[_STe] = [];
    }
    else if (output[_sTe] != null && output[_sTe][_i] != null) {
        contents[_STe] = de_ServiceTypeDetailSet(__getArrayIfSingleItem(output[_sTe][_i]), context);
    }
    if (output[_sI] != null) {
        contents[_SIe] = __expectString(output[_sI]);
    }
    if (output[_sN] != null) {
        contents[_SNe] = __expectString(output[_sN]);
    }
    if (output[_sSer] != null) {
        contents[_SSe] = __expectString(output[_sSer]);
    }
    if (output.availabilityZoneSet === "") {
        contents[_AZv] = [];
    }
    else if (output[_aZS] != null && output[_aZS][_i] != null) {
        contents[_AZv] = de_ValueStringList(__getArrayIfSingleItem(output[_aZS][_i]), context);
    }
    if (output[_aRcc] != null) {
        contents[_ARc] = __parseBoolean(output[_aRcc]);
    }
    if (output[_mVE] != null) {
        contents[_MVEa] = __parseBoolean(output[_mVE]);
    }
    if (output.networkLoadBalancerArnSet === "") {
        contents[_NLBAe] = [];
    }
    else if (output[_nLBAS] != null && output[_nLBAS][_i] != null) {
        contents[_NLBAe] = de_ValueStringList(__getArrayIfSingleItem(output[_nLBAS][_i]), context);
    }
    if (output.gatewayLoadBalancerArnSet === "") {
        contents[_GLBA] = [];
    }
    else if (output[_gLBAS] != null && output[_gLBAS][_i] != null) {
        contents[_GLBA] = de_ValueStringList(__getArrayIfSingleItem(output[_gLBAS][_i]), context);
    }
    if (output.supportedIpAddressTypeSet === "") {
        contents[_SIAT] = [];
    }
    else if (output[_sIATS] != null && output[_sIATS][_i] != null) {
        contents[_SIAT] = de_SupportedIpAddressTypes(__getArrayIfSingleItem(output[_sIATS][_i]), context);
    }
    if (output.baseEndpointDnsNameSet === "") {
        contents[_BEDN] = [];
    }
    else if (output[_bEDNS] != null && output[_bEDNS][_i] != null) {
        contents[_BEDN] = de_ValueStringList(__getArrayIfSingleItem(output[_bEDNS][_i]), context);
    }
    if (output[_pDN] != null) {
        contents[_PDN] = __expectString(output[_pDN]);
    }
    if (output[_pDNC] != null) {
        contents[_PDNC] = de_PrivateDnsNameConfiguration(output[_pDNC], context);
    }
    if (output[_pRa] != null) {
        contents[_PRa] = __expectString(output[_pRa]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output.supportedRegionSet === "") {
        contents[_SRu] = [];
    }
    else if (output[_sRS] != null && output[_sRS][_i] != null) {
        contents[_SRu] = de_SupportedRegionSet(__getArrayIfSingleItem(output[_sRS][_i]), context);
    }
    if (output[_rAE] != null) {
        contents[_RAE] = __parseBoolean(output[_rAE]);
    }
    return contents;
};
const de_ServiceConfigurationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceConfiguration(entry, context);
    });
};
const de_ServiceDetail = (output, context) => {
    const contents = {};
    if (output[_sN] != null) {
        contents[_SNe] = __expectString(output[_sN]);
    }
    if (output[_sI] != null) {
        contents[_SIe] = __expectString(output[_sI]);
    }
    if (output.serviceType === "") {
        contents[_STe] = [];
    }
    else if (output[_sTe] != null && output[_sTe][_i] != null) {
        contents[_STe] = de_ServiceTypeDetailSet(__getArrayIfSingleItem(output[_sTe][_i]), context);
    }
    if (output[_sR] != null) {
        contents[_SRe] = __expectString(output[_sR]);
    }
    if (output.availabilityZoneSet === "") {
        contents[_AZv] = [];
    }
    else if (output[_aZS] != null && output[_aZS][_i] != null) {
        contents[_AZv] = de_ValueStringList(__getArrayIfSingleItem(output[_aZS][_i]), context);
    }
    if (output[_ow] != null) {
        contents[_Own] = __expectString(output[_ow]);
    }
    if (output.baseEndpointDnsNameSet === "") {
        contents[_BEDN] = [];
    }
    else if (output[_bEDNS] != null && output[_bEDNS][_i] != null) {
        contents[_BEDN] = de_ValueStringList(__getArrayIfSingleItem(output[_bEDNS][_i]), context);
    }
    if (output[_pDN] != null) {
        contents[_PDN] = __expectString(output[_pDN]);
    }
    if (output.privateDnsNameSet === "") {
        contents[_PDNr] = [];
    }
    else if (output[_pDNS] != null && output[_pDNS][_i] != null) {
        contents[_PDNr] = de_PrivateDnsDetailsSet(__getArrayIfSingleItem(output[_pDNS][_i]), context);
    }
    if (output[_vEPS] != null) {
        contents[_VEPS] = __parseBoolean(output[_vEPS]);
    }
    if (output[_aRcc] != null) {
        contents[_ARc] = __parseBoolean(output[_aRcc]);
    }
    if (output[_mVE] != null) {
        contents[_MVEa] = __parseBoolean(output[_mVE]);
    }
    if (output[_pRa] != null) {
        contents[_PRa] = __expectString(output[_pRa]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_pDNVS] != null) {
        contents[_PDNVS] = __expectString(output[_pDNVS]);
    }
    if (output.supportedIpAddressTypeSet === "") {
        contents[_SIAT] = [];
    }
    else if (output[_sIATS] != null && output[_sIATS][_i] != null) {
        contents[_SIAT] = de_SupportedIpAddressTypes(__getArrayIfSingleItem(output[_sIATS][_i]), context);
    }
    return contents;
};
const de_ServiceDetailSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceDetail(entry, context);
    });
};
const de_ServiceTypeDetail = (output, context) => {
    const contents = {};
    if (output[_sTe] != null) {
        contents[_STe] = __expectString(output[_sTe]);
    }
    return contents;
};
const de_ServiceTypeDetailSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceTypeDetail(entry, context);
    });
};
const de_Snapshot = (output, context) => {
    const contents = {};
    if (output[_oAw] != null) {
        contents[_OAw] = __expectString(output[_oAw]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_sTt] != null) {
        contents[_STto] = __expectString(output[_sTt]);
    }
    if (output[_rET] != null) {
        contents[_RET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rET]));
    }
    if (output[_sTs] != null) {
        contents[_STs] = __expectString(output[_sTs]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_tTr] != null) {
        contents[_TTr] = __expectString(output[_tTr]);
    }
    if (output[_cDM] != null) {
        contents[_CDM] = __strictParseInt32(output[_cDM]);
    }
    if (output[_cTomp] != null) {
        contents[_CTomp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTomp]));
    }
    if (output[_fSSIB] != null) {
        contents[_FSSIB] = __strictParseLong(output[_fSSIB]);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    if (output[_sta] != null) {
        contents[_Stat] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMta] = __expectString(output[_sMt]);
    }
    if (output[_sT] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));
    }
    if (output[_pro] != null) {
        contents[_Prog] = __expectString(output[_pro]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_vSo] != null) {
        contents[_VS] = __strictParseInt32(output[_vSo]);
    }
    if (output[_enc] != null) {
        contents[_Enc] = __parseBoolean(output[_enc]);
    }
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    if (output[_dEKI] != null) {
        contents[_DEKI] = __expectString(output[_dEKI]);
    }
    return contents;
};
const de_SnapshotDetail = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_dN] != null) {
        contents[_DN] = __expectString(output[_dN]);
    }
    if (output[_dIS] != null) {
        contents[_DISi] = __strictParseFloat(output[_dIS]);
    }
    if (output[_f] != null) {
        contents[_Fo] = __expectString(output[_f]);
    }
    if (output[_pro] != null) {
        contents[_Prog] = __expectString(output[_pro]);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_ur] != null) {
        contents[_U] = __expectString(output[_ur]);
    }
    if (output[_uB] != null) {
        contents[_UB] = de_UserBucketDetails(output[_uB], context);
    }
    return contents;
};
const de_SnapshotDetailList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SnapshotDetail(entry, context);
    });
};
const de_SnapshotInfo = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_enc] != null) {
        contents[_Enc] = __parseBoolean(output[_enc]);
    }
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_vSo] != null) {
        contents[_VS] = __strictParseInt32(output[_vSo]);
    }
    if (output[_sT] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));
    }
    if (output[_pro] != null) {
        contents[_Prog] = __expectString(output[_pro]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_sTs] != null) {
        contents[_STs] = __expectString(output[_sTs]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    return contents;
};
const de_SnapshotList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Snapshot(entry, context);
    });
};
const de_SnapshotRecycleBinInfo = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_rBET] != null) {
        contents[_RBET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rBET]));
    }
    if (output[_rBETe] != null) {
        contents[_RBETe] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rBETe]));
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    return contents;
};
const de_SnapshotRecycleBinInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SnapshotRecycleBinInfo(entry, context);
    });
};
const de_SnapshotSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SnapshotInfo(entry, context);
    });
};
const de_SnapshotTaskDetail = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_dIS] != null) {
        contents[_DISi] = __strictParseFloat(output[_dIS]);
    }
    if (output[_enc] != null) {
        contents[_Enc] = __parseBoolean(output[_enc]);
    }
    if (output[_f] != null) {
        contents[_Fo] = __expectString(output[_f]);
    }
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    if (output[_pro] != null) {
        contents[_Prog] = __expectString(output[_pro]);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_ur] != null) {
        contents[_U] = __expectString(output[_ur]);
    }
    if (output[_uB] != null) {
        contents[_UB] = de_UserBucketDetails(output[_uB], context);
    }
    return contents;
};
const de_SnapshotTierStatus = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_sTt] != null) {
        contents[_STto] = __expectString(output[_sTt]);
    }
    if (output[_lTST] != null) {
        contents[_LTST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lTST]));
    }
    if (output[_lTP] != null) {
        contents[_LTP] = __strictParseInt32(output[_lTP]);
    }
    if (output[_lTOS] != null) {
        contents[_LTOS] = __expectString(output[_lTOS]);
    }
    if (output[_lTOSD] != null) {
        contents[_LTOSD] = __expectString(output[_lTOSD]);
    }
    if (output[_aCT] != null) {
        contents[_ACT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aCT]));
    }
    if (output[_rET] != null) {
        contents[_RET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_rET]));
    }
    return contents;
};
const de_snapshotTierStatusSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SnapshotTierStatus(entry, context);
    });
};
const de_SpotCapacityRebalance = (output, context) => {
    const contents = {};
    if (output[_rSep] != null) {
        contents[_RS] = __expectString(output[_rSep]);
    }
    if (output[_tD] != null) {
        contents[_TDe] = __strictParseInt32(output[_tD]);
    }
    return contents;
};
const de_SpotDatafeedSubscription = (output, context) => {
    const contents = {};
    if (output[_bu] != null) {
        contents[_B] = __expectString(output[_bu]);
    }
    if (output[_fa] != null) {
        contents[_Fa] = de_SpotInstanceStateFault(output[_fa], context);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_pre] != null) {
        contents[_Pr] = __expectString(output[_pre]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_SpotFleetLaunchSpecification = (output, context) => {
    const contents = {};
    if (output[_aTdd] != null) {
        contents[_ATd] = __expectString(output[_aTdd]);
    }
    if (output.blockDeviceMapping === "") {
        contents[_BDM] = [];
    }
    else if (output[_bDM] != null && output[_bDM][_i] != null) {
        contents[_BDM] = de_BlockDeviceMappingList(__getArrayIfSingleItem(output[_bDM][_i]), context);
    }
    if (output[_eO] != null) {
        contents[_EO] = __parseBoolean(output[_eO]);
    }
    if (output[_iIP] != null) {
        contents[_IIP] = de_IamInstanceProfileSpecification(output[_iIP], context);
    }
    if (output[_iIma] != null) {
        contents[_IIma] = __expectString(output[_iIma]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_kI] != null) {
        contents[_KI] = __expectString(output[_kI]);
    }
    if (output[_kN] != null) {
        contents[_KN] = __expectString(output[_kN]);
    }
    if (output[_mo] != null) {
        contents[_Mon] = de_SpotFleetMonitoring(output[_mo], context);
    }
    if (output.networkInterfaceSet === "") {
        contents[_NI] = [];
    }
    else if (output[_nIS] != null && output[_nIS][_i] != null) {
        contents[_NI] = de_InstanceNetworkInterfaceSpecificationList(__getArrayIfSingleItem(output[_nIS][_i]), context);
    }
    if (output[_pla] != null) {
        contents[_Pl] = de_SpotPlacement(output[_pla], context);
    }
    if (output[_rIa] != null) {
        contents[_RIa] = __expectString(output[_rIa]);
    }
    if (output[_sPp] != null) {
        contents[_SPp] = __expectString(output[_sPp]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_uDs] != null) {
        contents[_UD] = __expectString(output[_uDs]);
    }
    if (output[_wC] != null) {
        contents[_WCe] = __strictParseFloat(output[_wC]);
    }
    if (output.tagSpecificationSet === "") {
        contents[_TS] = [];
    }
    else if (output[_tSS] != null && output[_tSS][_i] != null) {
        contents[_TS] = de_SpotFleetTagSpecificationList(__getArrayIfSingleItem(output[_tSS][_i]), context);
    }
    if (output[_iR] != null) {
        contents[_IR] = de_InstanceRequirements(output[_iR], context);
    }
    if (output.groupSet === "") {
        contents[_SG] = [];
    }
    else if (output[_gS] != null && output[_gS][_i] != null) {
        contents[_SG] = de_GroupIdentifierList(__getArrayIfSingleItem(output[_gS][_i]), context);
    }
    return contents;
};
const de_SpotFleetMonitoring = (output, context) => {
    const contents = {};
    if (output[_en] != null) {
        contents[_En] = __parseBoolean(output[_en]);
    }
    return contents;
};
const de_SpotFleetRequestConfig = (output, context) => {
    const contents = {};
    if (output[_aSc] != null) {
        contents[_ASc] = __expectString(output[_aSc]);
    }
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output[_sFRC] != null) {
        contents[_SFRC] = de_SpotFleetRequestConfigData(output[_sFRC], context);
    }
    if (output[_sFRI] != null) {
        contents[_SFRIp] = __expectString(output[_sFRI]);
    }
    if (output[_sFRSp] != null) {
        contents[_SFRS] = __expectString(output[_sFRSp]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_SpotFleetRequestConfigData = (output, context) => {
    const contents = {};
    if (output[_aSl] != null) {
        contents[_AS] = __expectString(output[_aSl]);
    }
    if (output[_oDAS] != null) {
        contents[_ODAS] = __expectString(output[_oDAS]);
    }
    if (output[_sMS] != null) {
        contents[_SMS] = de_SpotMaintenanceStrategies(output[_sMS], context);
    }
    if (output[_cT] != null) {
        contents[_CTl] = __expectString(output[_cT]);
    }
    if (output[_eCTP] != null) {
        contents[_ECTP] = __expectString(output[_eCTP]);
    }
    if (output[_fC] != null) {
        contents[_FC] = __strictParseFloat(output[_fC]);
    }
    if (output[_oDFC] != null) {
        contents[_ODFC] = __strictParseFloat(output[_oDFC]);
    }
    if (output[_iFR] != null) {
        contents[_IFR] = __expectString(output[_iFR]);
    }
    if (output.launchSpecifications === "") {
        contents[_LSau] = [];
    }
    else if (output[_lSa] != null && output[_lSa][_i] != null) {
        contents[_LSau] = de_LaunchSpecsList(__getArrayIfSingleItem(output[_lSa][_i]), context);
    }
    if (output.launchTemplateConfigs === "") {
        contents[_LTC] = [];
    }
    else if (output[_lTC] != null && output[_lTC][_i] != null) {
        contents[_LTC] = de_LaunchTemplateConfigList(__getArrayIfSingleItem(output[_lTC][_i]), context);
    }
    if (output[_sPp] != null) {
        contents[_SPp] = __expectString(output[_sPp]);
    }
    if (output[_tCar] != null) {
        contents[_TCa] = __strictParseInt32(output[_tCar]);
    }
    if (output[_oDTC] != null) {
        contents[_ODTC] = __strictParseInt32(output[_oDTC]);
    }
    if (output[_oDMTP] != null) {
        contents[_ODMTP] = __expectString(output[_oDMTP]);
    }
    if (output[_sMTP] != null) {
        contents[_SMTP] = __expectString(output[_sMTP]);
    }
    if (output[_tIWE] != null) {
        contents[_TIWE] = __parseBoolean(output[_tIWE]);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_vF] != null) {
        contents[_VF] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vF]));
    }
    if (output[_vU] != null) {
        contents[_VU] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vU]));
    }
    if (output[_rUI] != null) {
        contents[_RUI] = __parseBoolean(output[_rUI]);
    }
    if (output[_iIB] != null) {
        contents[_IIB] = __expectString(output[_iIB]);
    }
    if (output[_lBC] != null) {
        contents[_LBC] = de_LoadBalancersConfig(output[_lBC], context);
    }
    if (output[_iPTUC] != null) {
        contents[_IPTUC] = __strictParseInt32(output[_iPTUC]);
    }
    if (output[_cont] != null) {
        contents[_Con] = __expectString(output[_cont]);
    }
    if (output[_tCUT] != null) {
        contents[_TCUT] = __expectString(output[_tCUT]);
    }
    if (output.TagSpecification === "") {
        contents[_TS] = [];
    }
    else if (output[_TSagp] != null && output[_TSagp][_i] != null) {
        contents[_TS] = de_TagSpecificationList(__getArrayIfSingleItem(output[_TSagp][_i]), context);
    }
    return contents;
};
const de_SpotFleetRequestConfigSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SpotFleetRequestConfig(entry, context);
    });
};
const de_SpotFleetTagSpecification = (output, context) => {
    const contents = {};
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output.tag === "") {
        contents[_Ta] = [];
    }
    else if (output[_tag] != null && output[_tag][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tag][_i]), context);
    }
    return contents;
};
const de_SpotFleetTagSpecificationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SpotFleetTagSpecification(entry, context);
    });
};
const de_SpotInstanceRequest = (output, context) => {
    const contents = {};
    if (output[_aBHP] != null) {
        contents[_ABHP] = __expectString(output[_aBHP]);
    }
    if (output[_aZG] != null) {
        contents[_AZG] = __expectString(output[_aZG]);
    }
    if (output[_bDMl] != null) {
        contents[_BDMl] = __strictParseInt32(output[_bDMl]);
    }
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output[_fa] != null) {
        contents[_Fa] = de_SpotInstanceStateFault(output[_fa], context);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_lG] != null) {
        contents[_LG] = __expectString(output[_lG]);
    }
    if (output[_lSau] != null) {
        contents[_LSa] = de_LaunchSpecification(output[_lSau], context);
    }
    if (output[_lAZ] != null) {
        contents[_LAZ] = __expectString(output[_lAZ]);
    }
    if (output[_pDr] != null) {
        contents[_PDr] = __expectString(output[_pDr]);
    }
    if (output[_sIRI] != null) {
        contents[_SIRIp] = __expectString(output[_sIRI]);
    }
    if (output[_sPp] != null) {
        contents[_SPp] = __expectString(output[_sPp]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_SpotInstanceStatus(output[_sta], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_vF] != null) {
        contents[_VF] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vF]));
    }
    if (output[_vU] != null) {
        contents[_VU] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_vU]));
    }
    if (output[_iIB] != null) {
        contents[_IIB] = __expectString(output[_iIB]);
    }
    return contents;
};
const de_SpotInstanceRequestList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SpotInstanceRequest(entry, context);
    });
};
const de_SpotInstanceStateFault = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_SpotInstanceStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    if (output[_uT] != null) {
        contents[_UTp] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_uT]));
    }
    return contents;
};
const de_SpotMaintenanceStrategies = (output, context) => {
    const contents = {};
    if (output[_cRa] != null) {
        contents[_CRap] = de_SpotCapacityRebalance(output[_cRa], context);
    }
    return contents;
};
const de_SpotOptions = (output, context) => {
    const contents = {};
    if (output[_aSl] != null) {
        contents[_AS] = __expectString(output[_aSl]);
    }
    if (output[_mSai] != null) {
        contents[_MS] = de_FleetSpotMaintenanceStrategies(output[_mSai], context);
    }
    if (output[_iIB] != null) {
        contents[_IIB] = __expectString(output[_iIB]);
    }
    if (output[_iPTUC] != null) {
        contents[_IPTUC] = __strictParseInt32(output[_iPTUC]);
    }
    if (output[_sITi] != null) {
        contents[_SITi] = __parseBoolean(output[_sITi]);
    }
    if (output[_sAZ] != null) {
        contents[_SAZ] = __parseBoolean(output[_sAZ]);
    }
    if (output[_mTC] != null) {
        contents[_MTC] = __strictParseInt32(output[_mTC]);
    }
    if (output[_mTP] != null) {
        contents[_MTP] = __expectString(output[_mTP]);
    }
    return contents;
};
const de_SpotPlacement = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output[_t] != null) {
        contents[_Te] = __expectString(output[_t]);
    }
    return contents;
};
const de_SpotPlacementScore = (output, context) => {
    const contents = {};
    if (output[_re] != null) {
        contents[_Regi] = __expectString(output[_re]);
    }
    if (output[_aZI] != null) {
        contents[_AZI] = __expectString(output[_aZI]);
    }
    if (output[_sco] != null) {
        contents[_Sco] = __strictParseInt32(output[_sco]);
    }
    return contents;
};
const de_SpotPlacementScores = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SpotPlacementScore(entry, context);
    });
};
const de_SpotPrice = (output, context) => {
    const contents = {};
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_iT] != null) {
        contents[_IT] = __expectString(output[_iT]);
    }
    if (output[_pDr] != null) {
        contents[_PDr] = __expectString(output[_pDr]);
    }
    if (output[_sPp] != null) {
        contents[_SPp] = __expectString(output[_sPp]);
    }
    if (output[_ti] != null) {
        contents[_Tim] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ti]));
    }
    return contents;
};
const de_SpotPriceHistoryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SpotPrice(entry, context);
    });
};
const de_StaleIpPermission = (output, context) => {
    const contents = {};
    if (output[_fP] != null) {
        contents[_FP] = __strictParseInt32(output[_fP]);
    }
    if (output[_iPpr] != null) {
        contents[_IPpr] = __expectString(output[_iPpr]);
    }
    if (output.ipRanges === "") {
        contents[_IRp] = [];
    }
    else if (output[_iRpa] != null && output[_iRpa][_i] != null) {
        contents[_IRp] = de_IpRanges(__getArrayIfSingleItem(output[_iRpa][_i]), context);
    }
    if (output.prefixListIds === "") {
        contents[_PLIr] = [];
    }
    else if (output[_pLIr] != null && output[_pLIr][_i] != null) {
        contents[_PLIr] = de_PrefixListIdSet(__getArrayIfSingleItem(output[_pLIr][_i]), context);
    }
    if (output[_tPo] != null) {
        contents[_TP] = __strictParseInt32(output[_tPo]);
    }
    if (output.groups === "") {
        contents[_UIGP] = [];
    }
    else if (output[_gr] != null && output[_gr][_i] != null) {
        contents[_UIGP] = de_UserIdGroupPairSet(__getArrayIfSingleItem(output[_gr][_i]), context);
    }
    return contents;
};
const de_StaleIpPermissionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StaleIpPermission(entry, context);
    });
};
const de_StaleSecurityGroup = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output.staleIpPermissions === "") {
        contents[_SIP] = [];
    }
    else if (output[_sIP] != null && output[_sIP][_i] != null) {
        contents[_SIP] = de_StaleIpPermissionSet(__getArrayIfSingleItem(output[_sIP][_i]), context);
    }
    if (output.staleIpPermissionsEgress === "") {
        contents[_SIPE] = [];
    }
    else if (output[_sIPE] != null && output[_sIPE][_i] != null) {
        contents[_SIPE] = de_StaleIpPermissionSet(__getArrayIfSingleItem(output[_sIPE][_i]), context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    return contents;
};
const de_StaleSecurityGroupSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StaleSecurityGroup(entry, context);
    });
};
const de_StartDeclarativePoliciesReportResult = (output, context) => {
    const contents = {};
    if (output[_rI] != null) {
        contents[_RIep] = __expectString(output[_rI]);
    }
    return contents;
};
const de_StartInstancesResult = (output, context) => {
    const contents = {};
    if (output.instancesSet === "") {
        contents[_SIta] = [];
    }
    else if (output[_iSn] != null && output[_iSn][_i] != null) {
        contents[_SIta] = de_InstanceStateChangeList(__getArrayIfSingleItem(output[_iSn][_i]), context);
    }
    return contents;
};
const de_StartNetworkInsightsAccessScopeAnalysisResult = (output, context) => {
    const contents = {};
    if (output[_nIASAe] != null) {
        contents[_NIASAet] = de_NetworkInsightsAccessScopeAnalysis(output[_nIASAe], context);
    }
    return contents;
};
const de_StartNetworkInsightsAnalysisResult = (output, context) => {
    const contents = {};
    if (output[_nIA] != null) {
        contents[_NIAe] = de_NetworkInsightsAnalysis(output[_nIA], context);
    }
    return contents;
};
const de_StartVpcEndpointServicePrivateDnsVerificationResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_RV] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_StateReason = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_StopInstancesResult = (output, context) => {
    const contents = {};
    if (output.instancesSet === "") {
        contents[_SIto] = [];
    }
    else if (output[_iSn] != null && output[_iSn][_i] != null) {
        contents[_SIto] = de_InstanceStateChangeList(__getArrayIfSingleItem(output[_iSn][_i]), context);
    }
    return contents;
};
const de_Storage = (output, context) => {
    const contents = {};
    if (output[_S_] != null) {
        contents[_S_] = de_S3Storage(output[_S_], context);
    }
    return contents;
};
const de_StoreImageTaskResult = (output, context) => {
    const contents = {};
    if (output[_aIm] != null) {
        contents[_AIm] = __expectString(output[_aIm]);
    }
    if (output[_tSTa] != null) {
        contents[_TSTa] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_tSTa]));
    }
    if (output[_bu] != null) {
        contents[_B] = __expectString(output[_bu]);
    }
    if (output[_sKo] != null) {
        contents[_SKo] = __expectString(output[_sKo]);
    }
    if (output[_pP] != null) {
        contents[_PP] = __strictParseInt32(output[_pP]);
    }
    if (output[_sTS] != null) {
        contents[_STSt] = __expectString(output[_sTS]);
    }
    if (output[_sTFR] != null) {
        contents[_STFR] = __expectString(output[_sTFR]);
    }
    return contents;
};
const de_StoreImageTaskResultSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StoreImageTaskResult(entry, context);
    });
};
const de_StringList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Subnet = (output, context) => {
    const contents = {};
    if (output[_aZI] != null) {
        contents[_AZI] = __expectString(output[_aZI]);
    }
    if (output[_eLADI] != null) {
        contents[_ELADI] = __strictParseInt32(output[_eLADI]);
    }
    if (output[_mCOIOL] != null) {
        contents[_MCOIOL] = __parseBoolean(output[_mCOIOL]);
    }
    if (output[_cOIP] != null) {
        contents[_COIP] = __expectString(output[_cOIP]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_aIAOC] != null) {
        contents[_AIAOC] = __parseBoolean(output[_aIAOC]);
    }
    if (output.ipv6CidrBlockAssociationSet === "") {
        contents[_ICBAS] = [];
    }
    else if (output[_iCBAS] != null && output[_iCBAS][_i] != null) {
        contents[_ICBAS] = de_SubnetIpv6CidrBlockAssociationSet(__getArrayIfSingleItem(output[_iCBAS][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_sAub] != null) {
        contents[_SAub] = __expectString(output[_sAub]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_eDn] != null) {
        contents[_EDn] = __parseBoolean(output[_eDn]);
    }
    if (output[_iN] != null) {
        contents[_IN] = __parseBoolean(output[_iN]);
    }
    if (output[_pDNOOL] != null) {
        contents[_PDNOOL] = de_PrivateDnsNameOptionsOnLaunch(output[_pDNOOL], context);
    }
    if (output[_bPAS] != null) {
        contents[_BPAS] = de_BlockPublicAccessStates(output[_bPAS], context);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_cB] != null) {
        contents[_CB] = __expectString(output[_cB]);
    }
    if (output[_aIAC] != null) {
        contents[_AIAC] = __strictParseInt32(output[_aIAC]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_dFA] != null) {
        contents[_DFA] = __parseBoolean(output[_dFA]);
    }
    if (output[_mPIOL] != null) {
        contents[_MPIOL] = __parseBoolean(output[_mPIOL]);
    }
    return contents;
};
const de_SubnetAssociation = (output, context) => {
    const contents = {};
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_SubnetAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SubnetAssociation(entry, context);
    });
};
const de_SubnetCidrBlockState = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    return contents;
};
const de_SubnetCidrReservation = (output, context) => {
    const contents = {};
    if (output[_sCRI] != null) {
        contents[_SCRIu] = __expectString(output[_sCRI]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    if (output[_rT] != null) {
        contents[_RTe] = __expectString(output[_rT]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_SubnetCidrReservationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SubnetCidrReservation(entry, context);
    });
};
const de_SubnetIpPrefixes = (output, context) => {
    const contents = {};
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output.ipPrefixSet === "") {
        contents[_IPpre] = [];
    }
    else if (output[_iPSpr] != null && output[_iPSpr][_i] != null) {
        contents[_IPpre] = de_ValueStringList(__getArrayIfSingleItem(output[_iPSpr][_i]), context);
    }
    return contents;
};
const de_SubnetIpPrefixesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SubnetIpPrefixes(entry, context);
    });
};
const de_SubnetIpv6CidrBlockAssociation = (output, context) => {
    const contents = {};
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_iCB] != null) {
        contents[_ICB] = __expectString(output[_iCB]);
    }
    if (output[_iCBS] != null) {
        contents[_ICBS] = de_SubnetCidrBlockState(output[_iCBS], context);
    }
    if (output[_iAA] != null) {
        contents[_IAA] = __expectString(output[_iAA]);
    }
    if (output[_iSpo] != null) {
        contents[_ISpo] = __expectString(output[_iSpo]);
    }
    return contents;
};
const de_SubnetIpv6CidrBlockAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SubnetIpv6CidrBlockAssociation(entry, context);
    });
};
const de_SubnetList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Subnet(entry, context);
    });
};
const de_Subscription = (output, context) => {
    const contents = {};
    if (output[_s] != null) {
        contents[_S] = __expectString(output[_s]);
    }
    if (output[_d] != null) {
        contents[_D] = __expectString(output[_d]);
    }
    if (output[_met] != null) {
        contents[_Met] = __expectString(output[_met]);
    }
    if (output[_stat] != null) {
        contents[_Sta] = __expectString(output[_stat]);
    }
    if (output[_pe] != null) {
        contents[_Per] = __expectString(output[_pe]);
    }
    return contents;
};
const de_SubscriptionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Subscription(entry, context);
    });
};
const de_SuccessfulInstanceCreditSpecificationItem = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    return contents;
};
const de_SuccessfulInstanceCreditSpecificationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SuccessfulInstanceCreditSpecificationItem(entry, context);
    });
};
const de_SuccessfulQueuedPurchaseDeletion = (output, context) => {
    const contents = {};
    if (output[_rII] != null) {
        contents[_RIIe] = __expectString(output[_rII]);
    }
    return contents;
};
const de_SuccessfulQueuedPurchaseDeletionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SuccessfulQueuedPurchaseDeletion(entry, context);
    });
};
const de_SupportedAdditionalProcessorFeatureList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SupportedIpAddressTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SupportedRegionDetail = (output, context) => {
    const contents = {};
    if (output[_re] != null) {
        contents[_Regi] = __expectString(output[_re]);
    }
    if (output[_sSer] != null) {
        contents[_SSe] = __expectString(output[_sSer]);
    }
    return contents;
};
const de_SupportedRegionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SupportedRegionDetail(entry, context);
    });
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_k] != null) {
        contents[_Ke] = __expectString(output[_k]);
    }
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    return contents;
};
const de_TagDescription = (output, context) => {
    const contents = {};
    if (output[_k] != null) {
        contents[_Ke] = __expectString(output[_k]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_v] != null) {
        contents[_Va] = __expectString(output[_v]);
    }
    return contents;
};
const de_TagDescriptionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TagDescription(entry, context);
    });
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TagSpecification = (output, context) => {
    const contents = {};
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output.Tag === "") {
        contents[_Ta] = [];
    }
    else if (output[_Tag] != null && output[_Tag][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_Tag][_i]), context);
    }
    return contents;
};
const de_TagSpecificationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TagSpecification(entry, context);
    });
};
const de_TargetCapacitySpecification = (output, context) => {
    const contents = {};
    if (output[_tTC] != null) {
        contents[_TTC] = __strictParseInt32(output[_tTC]);
    }
    if (output[_oDTC] != null) {
        contents[_ODTC] = __strictParseInt32(output[_oDTC]);
    }
    if (output[_sTC] != null) {
        contents[_STC] = __strictParseInt32(output[_sTC]);
    }
    if (output[_dTCT] != null) {
        contents[_DTCT] = __expectString(output[_dTCT]);
    }
    if (output[_tCUT] != null) {
        contents[_TCUT] = __expectString(output[_tCUT]);
    }
    return contents;
};
const de_TargetConfiguration = (output, context) => {
    const contents = {};
    if (output[_iC] != null) {
        contents[_IC] = __strictParseInt32(output[_iC]);
    }
    if (output[_oIf] != null) {
        contents[_OI] = __expectString(output[_oIf]);
    }
    return contents;
};
const de_TargetGroup = (output, context) => {
    const contents = {};
    if (output[_ar] != null) {
        contents[_Ar] = __expectString(output[_ar]);
    }
    return contents;
};
const de_TargetGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetGroup(entry, context);
    });
};
const de_TargetGroupsConfig = (output, context) => {
    const contents = {};
    if (output.targetGroups === "") {
        contents[_TG] = [];
    }
    else if (output[_tGa] != null && output[_tGa][_i] != null) {
        contents[_TG] = de_TargetGroups(__getArrayIfSingleItem(output[_tGa][_i]), context);
    }
    return contents;
};
const de_TargetNetwork = (output, context) => {
    const contents = {};
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_tNI] != null) {
        contents[_TNI] = __expectString(output[_tNI]);
    }
    if (output[_cVEI] != null) {
        contents[_CVEI] = __expectString(output[_cVEI]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_AssociationStatus(output[_sta], context);
    }
    if (output.securityGroups === "") {
        contents[_SG] = [];
    }
    else if (output[_sGe] != null && output[_sGe][_i] != null) {
        contents[_SG] = de_ValueStringList(__getArrayIfSingleItem(output[_sGe][_i]), context);
    }
    return contents;
};
const de_TargetNetworkSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetNetwork(entry, context);
    });
};
const de_TargetReservationValue = (output, context) => {
    const contents = {};
    if (output[_rVe] != null) {
        contents[_RVe] = de_ReservationValue(output[_rVe], context);
    }
    if (output[_tCa] != null) {
        contents[_TCar] = de_TargetConfiguration(output[_tCa], context);
    }
    return contents;
};
const de_TargetReservationValueSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetReservationValue(entry, context);
    });
};
const de_TerminateClientVpnConnectionsResult = (output, context) => {
    const contents = {};
    if (output[_cVEI] != null) {
        contents[_CVEI] = __expectString(output[_cVEI]);
    }
    if (output[_us] != null) {
        contents[_Us] = __expectString(output[_us]);
    }
    if (output.connectionStatuses === "") {
        contents[_CSon] = [];
    }
    else if (output[_cSon] != null && output[_cSon][_i] != null) {
        contents[_CSon] = de_TerminateConnectionStatusSet(__getArrayIfSingleItem(output[_cSon][_i]), context);
    }
    return contents;
};
const de_TerminateConnectionStatus = (output, context) => {
    const contents = {};
    if (output[_cIon] != null) {
        contents[_CIo] = __expectString(output[_cIon]);
    }
    if (output[_pSre] != null) {
        contents[_PSre] = de_ClientVpnConnectionStatus(output[_pSre], context);
    }
    if (output[_cSur] != null) {
        contents[_CSur] = de_ClientVpnConnectionStatus(output[_cSur], context);
    }
    return contents;
};
const de_TerminateConnectionStatusSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TerminateConnectionStatus(entry, context);
    });
};
const de_TerminateInstancesResult = (output, context) => {
    const contents = {};
    if (output.instancesSet === "") {
        contents[_TIer] = [];
    }
    else if (output[_iSn] != null && output[_iSn][_i] != null) {
        contents[_TIer] = de_InstanceStateChangeList(__getArrayIfSingleItem(output[_iSn][_i]), context);
    }
    return contents;
};
const de_ThreadsPerCoreList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __strictParseInt32(entry);
    });
};
const de_ThroughResourcesStatement = (output, context) => {
    const contents = {};
    if (output[_rSeso] != null) {
        contents[_RSe] = de_ResourceStatement(output[_rSeso], context);
    }
    return contents;
};
const de_ThroughResourcesStatementList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ThroughResourcesStatement(entry, context);
    });
};
const de_TotalLocalStorageGB = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_M] = __strictParseFloat(output[_m]);
    }
    if (output[_ma] != null) {
        contents[_Ma] = __strictParseFloat(output[_ma]);
    }
    return contents;
};
const de_TrafficMirrorFilter = (output, context) => {
    const contents = {};
    if (output[_tMFI] != null) {
        contents[_TMFI] = __expectString(output[_tMFI]);
    }
    if (output.ingressFilterRuleSet === "") {
        contents[_IFRn] = [];
    }
    else if (output[_iFRS] != null && output[_iFRS][_i] != null) {
        contents[_IFRn] = de_TrafficMirrorFilterRuleList(__getArrayIfSingleItem(output[_iFRS][_i]), context);
    }
    if (output.egressFilterRuleSet === "") {
        contents[_EFR] = [];
    }
    else if (output[_eFRS] != null && output[_eFRS][_i] != null) {
        contents[_EFR] = de_TrafficMirrorFilterRuleList(__getArrayIfSingleItem(output[_eFRS][_i]), context);
    }
    if (output.networkServiceSet === "") {
        contents[_NSe] = [];
    }
    else if (output[_nSS] != null && output[_nSS][_i] != null) {
        contents[_NSe] = de_TrafficMirrorNetworkServiceList(__getArrayIfSingleItem(output[_nSS][_i]), context);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TrafficMirrorFilterRule = (output, context) => {
    const contents = {};
    if (output[_tMFRI] != null) {
        contents[_TMFRI] = __expectString(output[_tMFRI]);
    }
    if (output[_tMFI] != null) {
        contents[_TMFI] = __expectString(output[_tMFI]);
    }
    if (output[_tDr] != null) {
        contents[_TD] = __expectString(output[_tDr]);
    }
    if (output[_rN] != null) {
        contents[_RNu] = __strictParseInt32(output[_rN]);
    }
    if (output[_rA] != null) {
        contents[_RAu] = __expectString(output[_rA]);
    }
    if (output[_pr] != null) {
        contents[_P] = __strictParseInt32(output[_pr]);
    }
    if (output[_dPR] != null) {
        contents[_DPR] = de_TrafficMirrorPortRange(output[_dPR], context);
    }
    if (output[_sPR] != null) {
        contents[_SPR] = de_TrafficMirrorPortRange(output[_sPR], context);
    }
    if (output[_dCB] != null) {
        contents[_DCB] = __expectString(output[_dCB]);
    }
    if (output[_sCB] != null) {
        contents[_SCB] = __expectString(output[_sCB]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TrafficMirrorFilterRuleList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficMirrorFilterRule(entry, context);
    });
};
const de_TrafficMirrorFilterRuleSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficMirrorFilterRule(entry, context);
    });
};
const de_TrafficMirrorFilterSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficMirrorFilter(entry, context);
    });
};
const de_TrafficMirrorNetworkServiceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_TrafficMirrorPortRange = (output, context) => {
    const contents = {};
    if (output[_fP] != null) {
        contents[_FP] = __strictParseInt32(output[_fP]);
    }
    if (output[_tPo] != null) {
        contents[_TP] = __strictParseInt32(output[_tPo]);
    }
    return contents;
};
const de_TrafficMirrorSession = (output, context) => {
    const contents = {};
    if (output[_tMSI] != null) {
        contents[_TMSI] = __expectString(output[_tMSI]);
    }
    if (output[_tMTI] != null) {
        contents[_TMTI] = __expectString(output[_tMTI]);
    }
    if (output[_tMFI] != null) {
        contents[_TMFI] = __expectString(output[_tMFI]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_pLa] != null) {
        contents[_PL] = __strictParseInt32(output[_pLa]);
    }
    if (output[_sNes] != null) {
        contents[_SN] = __strictParseInt32(output[_sNes]);
    }
    if (output[_vNI] != null) {
        contents[_VNI] = __strictParseInt32(output[_vNI]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TrafficMirrorSessionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficMirrorSession(entry, context);
    });
};
const de_TrafficMirrorTarget = (output, context) => {
    const contents = {};
    if (output[_tMTI] != null) {
        contents[_TMTI] = __expectString(output[_tMTI]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_nLBA] != null) {
        contents[_NLBA] = __expectString(output[_nLBA]);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_gLBEI] != null) {
        contents[_GLBEI] = __expectString(output[_gLBEI]);
    }
    return contents;
};
const de_TrafficMirrorTargetSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficMirrorTarget(entry, context);
    });
};
const de_TransitGateway = (output, context) => {
    const contents = {};
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_tGAra] != null) {
        contents[_TGAran] = __expectString(output[_tGAra]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output[_opt] != null) {
        contents[_Op] = de_TransitGatewayOptions(output[_opt], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TransitGatewayAssociation = (output, context) => {
    const contents = {};
    if (output[_tGRTI] != null) {
        contents[_TGRTI] = __expectString(output[_tGRTI]);
    }
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_TransitGatewayAttachment = (output, context) => {
    const contents = {};
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_tGOI] != null) {
        contents[_TGOI] = __expectString(output[_tGOI]);
    }
    if (output[_rOI] != null) {
        contents[_ROI] = __expectString(output[_rOI]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_ass] != null) {
        contents[_Asso] = de_TransitGatewayAttachmentAssociation(output[_ass], context);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TransitGatewayAttachmentAssociation = (output, context) => {
    const contents = {};
    if (output[_tGRTI] != null) {
        contents[_TGRTI] = __expectString(output[_tGRTI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_TransitGatewayAttachmentBgpConfiguration = (output, context) => {
    const contents = {};
    if (output[_tGAran] != null) {
        contents[_TGArans] = __strictParseLong(output[_tGAran]);
    }
    if (output[_pAee] != null) {
        contents[_PAee] = __strictParseLong(output[_pAee]);
    }
    if (output[_tGArans] != null) {
        contents[_TGA] = __expectString(output[_tGArans]);
    }
    if (output[_pAe] != null) {
        contents[_PAe] = __expectString(output[_pAe]);
    }
    if (output[_bSg] != null) {
        contents[_BS] = __expectString(output[_bSg]);
    }
    return contents;
};
const de_TransitGatewayAttachmentBgpConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayAttachmentBgpConfiguration(entry, context);
    });
};
const de_TransitGatewayAttachmentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayAttachment(entry, context);
    });
};
const de_TransitGatewayAttachmentPropagation = (output, context) => {
    const contents = {};
    if (output[_tGRTI] != null) {
        contents[_TGRTI] = __expectString(output[_tGRTI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_TransitGatewayAttachmentPropagationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayAttachmentPropagation(entry, context);
    });
};
const de_TransitGatewayConnect = (output, context) => {
    const contents = {};
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_tTGAI] != null) {
        contents[_TTGAI] = __expectString(output[_tTGAI]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output[_opt] != null) {
        contents[_Op] = de_TransitGatewayConnectOptions(output[_opt], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TransitGatewayConnectList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayConnect(entry, context);
    });
};
const de_TransitGatewayConnectOptions = (output, context) => {
    const contents = {};
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    return contents;
};
const de_TransitGatewayConnectPeer = (output, context) => {
    const contents = {};
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_tGCPI] != null) {
        contents[_TGCPI] = __expectString(output[_tGCPI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output[_cPC] != null) {
        contents[_CPC] = de_TransitGatewayConnectPeerConfiguration(output[_cPC], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TransitGatewayConnectPeerConfiguration = (output, context) => {
    const contents = {};
    if (output[_tGArans] != null) {
        contents[_TGA] = __expectString(output[_tGArans]);
    }
    if (output[_pAe] != null) {
        contents[_PAe] = __expectString(output[_pAe]);
    }
    if (output.insideCidrBlocks === "") {
        contents[_ICBn] = [];
    }
    else if (output[_iCBn] != null && output[_iCBn][_i] != null) {
        contents[_ICBn] = de_InsideCidrBlocksStringList(__getArrayIfSingleItem(output[_iCBn][_i]), context);
    }
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output.bgpConfigurations === "") {
        contents[_BCg] = [];
    }
    else if (output[_bCg] != null && output[_bCg][_i] != null) {
        contents[_BCg] = de_TransitGatewayAttachmentBgpConfigurationList(__getArrayIfSingleItem(output[_bCg][_i]), context);
    }
    return contents;
};
const de_TransitGatewayConnectPeerList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayConnectPeer(entry, context);
    });
};
const de_TransitGatewayList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGateway(entry, context);
    });
};
const de_TransitGatewayMulticastDeregisteredGroupMembers = (output, context) => {
    const contents = {};
    if (output[_tGMDI] != null) {
        contents[_TGMDI] = __expectString(output[_tGMDI]);
    }
    if (output.deregisteredNetworkInterfaceIds === "") {
        contents[_DNII] = [];
    }
    else if (output[_dNII] != null && output[_dNII][_i] != null) {
        contents[_DNII] = de_ValueStringList(__getArrayIfSingleItem(output[_dNII][_i]), context);
    }
    if (output[_gIA] != null) {
        contents[_GIA] = __expectString(output[_gIA]);
    }
    return contents;
};
const de_TransitGatewayMulticastDeregisteredGroupSources = (output, context) => {
    const contents = {};
    if (output[_tGMDI] != null) {
        contents[_TGMDI] = __expectString(output[_tGMDI]);
    }
    if (output.deregisteredNetworkInterfaceIds === "") {
        contents[_DNII] = [];
    }
    else if (output[_dNII] != null && output[_dNII][_i] != null) {
        contents[_DNII] = de_ValueStringList(__getArrayIfSingleItem(output[_dNII][_i]), context);
    }
    if (output[_gIA] != null) {
        contents[_GIA] = __expectString(output[_gIA]);
    }
    return contents;
};
const de_TransitGatewayMulticastDomain = (output, context) => {
    const contents = {};
    if (output[_tGMDI] != null) {
        contents[_TGMDI] = __expectString(output[_tGMDI]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_tGMDA] != null) {
        contents[_TGMDA] = __expectString(output[_tGMDA]);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_opt] != null) {
        contents[_Op] = de_TransitGatewayMulticastDomainOptions(output[_opt], context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TransitGatewayMulticastDomainAssociation = (output, context) => {
    const contents = {};
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_rOI] != null) {
        contents[_ROI] = __expectString(output[_rOI]);
    }
    if (output[_su] != null) {
        contents[_Su] = de_SubnetAssociation(output[_su], context);
    }
    return contents;
};
const de_TransitGatewayMulticastDomainAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayMulticastDomainAssociation(entry, context);
    });
};
const de_TransitGatewayMulticastDomainAssociations = (output, context) => {
    const contents = {};
    if (output[_tGMDI] != null) {
        contents[_TGMDI] = __expectString(output[_tGMDI]);
    }
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_rOI] != null) {
        contents[_ROI] = __expectString(output[_rOI]);
    }
    if (output.subnets === "") {
        contents[_Subn] = [];
    }
    else if (output[_sub] != null && output[_sub][_i] != null) {
        contents[_Subn] = de_SubnetAssociationList(__getArrayIfSingleItem(output[_sub][_i]), context);
    }
    return contents;
};
const de_TransitGatewayMulticastDomainList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayMulticastDomain(entry, context);
    });
};
const de_TransitGatewayMulticastDomainOptions = (output, context) => {
    const contents = {};
    if (output[_iSg] != null) {
        contents[_ISg] = __expectString(output[_iSg]);
    }
    if (output[_sSS] != null) {
        contents[_SSS] = __expectString(output[_sSS]);
    }
    if (output[_aASA] != null) {
        contents[_AASA] = __expectString(output[_aASA]);
    }
    return contents;
};
const de_TransitGatewayMulticastGroup = (output, context) => {
    const contents = {};
    if (output[_gIA] != null) {
        contents[_GIA] = __expectString(output[_gIA]);
    }
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_sIu] != null) {
        contents[_SIub] = __expectString(output[_sIu]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_rOI] != null) {
        contents[_ROI] = __expectString(output[_rOI]);
    }
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_gM] != null) {
        contents[_GM] = __parseBoolean(output[_gM]);
    }
    if (output[_gSr] != null) {
        contents[_GS] = __parseBoolean(output[_gSr]);
    }
    if (output[_mTe] != null) {
        contents[_MTe] = __expectString(output[_mTe]);
    }
    if (output[_sTo] != null) {
        contents[_STo] = __expectString(output[_sTo]);
    }
    return contents;
};
const de_TransitGatewayMulticastGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayMulticastGroup(entry, context);
    });
};
const de_TransitGatewayMulticastRegisteredGroupMembers = (output, context) => {
    const contents = {};
    if (output[_tGMDI] != null) {
        contents[_TGMDI] = __expectString(output[_tGMDI]);
    }
    if (output.registeredNetworkInterfaceIds === "") {
        contents[_RNII] = [];
    }
    else if (output[_rNII] != null && output[_rNII][_i] != null) {
        contents[_RNII] = de_ValueStringList(__getArrayIfSingleItem(output[_rNII][_i]), context);
    }
    if (output[_gIA] != null) {
        contents[_GIA] = __expectString(output[_gIA]);
    }
    return contents;
};
const de_TransitGatewayMulticastRegisteredGroupSources = (output, context) => {
    const contents = {};
    if (output[_tGMDI] != null) {
        contents[_TGMDI] = __expectString(output[_tGMDI]);
    }
    if (output.registeredNetworkInterfaceIds === "") {
        contents[_RNII] = [];
    }
    else if (output[_rNII] != null && output[_rNII][_i] != null) {
        contents[_RNII] = de_ValueStringList(__getArrayIfSingleItem(output[_rNII][_i]), context);
    }
    if (output[_gIA] != null) {
        contents[_GIA] = __expectString(output[_gIA]);
    }
    return contents;
};
const de_TransitGatewayOptions = (output, context) => {
    const contents = {};
    if (output[_aSA] != null) {
        contents[_ASA] = __strictParseLong(output[_aSA]);
    }
    if (output.transitGatewayCidrBlocks === "") {
        contents[_TGCB] = [];
    }
    else if (output[_tGCB] != null && output[_tGCB][_i] != null) {
        contents[_TGCB] = de_ValueStringList(__getArrayIfSingleItem(output[_tGCB][_i]), context);
    }
    if (output[_aASAu] != null) {
        contents[_AASAu] = __expectString(output[_aASAu]);
    }
    if (output[_dRTA] != null) {
        contents[_DRTA] = __expectString(output[_dRTA]);
    }
    if (output[_aDRTI] != null) {
        contents[_ADRTI] = __expectString(output[_aDRTI]);
    }
    if (output[_dRTP] != null) {
        contents[_DRTP] = __expectString(output[_dRTP]);
    }
    if (output[_pDRTI] != null) {
        contents[_PDRTI] = __expectString(output[_pDRTI]);
    }
    if (output[_vESpn] != null) {
        contents[_VES] = __expectString(output[_vESpn]);
    }
    if (output[_dSn] != null) {
        contents[_DSns] = __expectString(output[_dSn]);
    }
    if (output[_sGRSec] != null) {
        contents[_SGRS] = __expectString(output[_sGRSec]);
    }
    if (output[_mSu] != null) {
        contents[_MSu] = __expectString(output[_mSu]);
    }
    return contents;
};
const de_TransitGatewayPeeringAttachment = (output, context) => {
    const contents = {};
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_aTGAI] != null) {
        contents[_ATGAI] = __expectString(output[_aTGAI]);
    }
    if (output[_rTIe] != null) {
        contents[_RTIe] = de_PeeringTgwInfo(output[_rTIe], context);
    }
    if (output[_aTI] != null) {
        contents[_ATIc] = de_PeeringTgwInfo(output[_aTI], context);
    }
    if (output[_opt] != null) {
        contents[_Op] = de_TransitGatewayPeeringAttachmentOptions(output[_opt], context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_PeeringAttachmentStatus(output[_sta], context);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TransitGatewayPeeringAttachmentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayPeeringAttachment(entry, context);
    });
};
const de_TransitGatewayPeeringAttachmentOptions = (output, context) => {
    const contents = {};
    if (output[_dRy] != null) {
        contents[_DRy] = __expectString(output[_dRy]);
    }
    return contents;
};
const de_TransitGatewayPolicyRule = (output, context) => {
    const contents = {};
    if (output[_sCB] != null) {
        contents[_SCB] = __expectString(output[_sCB]);
    }
    if (output[_sPR] != null) {
        contents[_SPR] = __expectString(output[_sPR]);
    }
    if (output[_dCB] != null) {
        contents[_DCB] = __expectString(output[_dCB]);
    }
    if (output[_dPR] != null) {
        contents[_DPR] = __expectString(output[_dPR]);
    }
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output[_mDe] != null) {
        contents[_MDe] = de_TransitGatewayPolicyRuleMetaData(output[_mDe], context);
    }
    return contents;
};
const de_TransitGatewayPolicyRuleMetaData = (output, context) => {
    const contents = {};
    if (output[_mDK] != null) {
        contents[_MDK] = __expectString(output[_mDK]);
    }
    if (output[_mDV] != null) {
        contents[_MDV] = __expectString(output[_mDV]);
    }
    return contents;
};
const de_TransitGatewayPolicyTable = (output, context) => {
    const contents = {};
    if (output[_tGPTI] != null) {
        contents[_TGPTI] = __expectString(output[_tGPTI]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TransitGatewayPolicyTableAssociation = (output, context) => {
    const contents = {};
    if (output[_tGPTI] != null) {
        contents[_TGPTI] = __expectString(output[_tGPTI]);
    }
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_TransitGatewayPolicyTableAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayPolicyTableAssociation(entry, context);
    });
};
const de_TransitGatewayPolicyTableEntry = (output, context) => {
    const contents = {};
    if (output[_pRN] != null) {
        contents[_PRNo] = __expectString(output[_pRN]);
    }
    if (output[_pRol] != null) {
        contents[_PRol] = de_TransitGatewayPolicyRule(output[_pRol], context);
    }
    if (output[_tRTI] != null) {
        contents[_TRTI] = __expectString(output[_tRTI]);
    }
    return contents;
};
const de_TransitGatewayPolicyTableEntryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayPolicyTableEntry(entry, context);
    });
};
const de_TransitGatewayPolicyTableList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayPolicyTable(entry, context);
    });
};
const de_TransitGatewayPrefixListAttachment = (output, context) => {
    const contents = {};
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    return contents;
};
const de_TransitGatewayPrefixListReference = (output, context) => {
    const contents = {};
    if (output[_tGRTI] != null) {
        contents[_TGRTI] = __expectString(output[_tGRTI]);
    }
    if (output[_pLI] != null) {
        contents[_PLI] = __expectString(output[_pLI]);
    }
    if (output[_pLOI] != null) {
        contents[_PLOI] = __expectString(output[_pLOI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_bl] != null) {
        contents[_Bl] = __parseBoolean(output[_bl]);
    }
    if (output[_tGAr] != null) {
        contents[_TGAra] = de_TransitGatewayPrefixListAttachment(output[_tGAr], context);
    }
    return contents;
};
const de_TransitGatewayPrefixListReferenceSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayPrefixListReference(entry, context);
    });
};
const de_TransitGatewayPropagation = (output, context) => {
    const contents = {};
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_tGRTI] != null) {
        contents[_TGRTI] = __expectString(output[_tGRTI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_tGRTAI] != null) {
        contents[_TGRTAI] = __expectString(output[_tGRTAI]);
    }
    return contents;
};
const de_TransitGatewayRoute = (output, context) => {
    const contents = {};
    if (output[_dCB] != null) {
        contents[_DCB] = __expectString(output[_dCB]);
    }
    if (output[_pLI] != null) {
        contents[_PLI] = __expectString(output[_pLI]);
    }
    if (output[_tGRTAI] != null) {
        contents[_TGRTAI] = __expectString(output[_tGRTAI]);
    }
    if (output.transitGatewayAttachments === "") {
        contents[_TGAr] = [];
    }
    else if (output[_tGA] != null && output[_tGA][_i] != null) {
        contents[_TGAr] = de_TransitGatewayRouteAttachmentList(__getArrayIfSingleItem(output[_tGA][_i]), context);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_TransitGatewayRouteAttachment = (output, context) => {
    const contents = {};
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    return contents;
};
const de_TransitGatewayRouteAttachmentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayRouteAttachment(entry, context);
    });
};
const de_TransitGatewayRouteList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayRoute(entry, context);
    });
};
const de_TransitGatewayRouteTable = (output, context) => {
    const contents = {};
    if (output[_tGRTI] != null) {
        contents[_TGRTI] = __expectString(output[_tGRTI]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_dART] != null) {
        contents[_DART] = __parseBoolean(output[_dART]);
    }
    if (output[_dPRT] != null) {
        contents[_DPRT] = __parseBoolean(output[_dPRT]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TransitGatewayRouteTableAnnouncement = (output, context) => {
    const contents = {};
    if (output[_tGRTAI] != null) {
        contents[_TGRTAI] = __expectString(output[_tGRTAI]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_cNIo] != null) {
        contents[_CNIor] = __expectString(output[_cNIo]);
    }
    if (output[_pTGI] != null) {
        contents[_PTGI] = __expectString(output[_pTGI]);
    }
    if (output[_pCNI] != null) {
        contents[_PCNI] = __expectString(output[_pCNI]);
    }
    if (output[_pAI] != null) {
        contents[_PAIe] = __expectString(output[_pAI]);
    }
    if (output[_aDn] != null) {
        contents[_ADn] = __expectString(output[_aDn]);
    }
    if (output[_tGRTI] != null) {
        contents[_TGRTI] = __expectString(output[_tGRTI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TransitGatewayRouteTableAnnouncementList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayRouteTableAnnouncement(entry, context);
    });
};
const de_TransitGatewayRouteTableAssociation = (output, context) => {
    const contents = {};
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_TransitGatewayRouteTableAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayRouteTableAssociation(entry, context);
    });
};
const de_TransitGatewayRouteTableList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayRouteTable(entry, context);
    });
};
const de_TransitGatewayRouteTablePropagation = (output, context) => {
    const contents = {};
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_tGRTAI] != null) {
        contents[_TGRTAI] = __expectString(output[_tGRTAI]);
    }
    return contents;
};
const de_TransitGatewayRouteTablePropagationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayRouteTablePropagation(entry, context);
    });
};
const de_TransitGatewayRouteTableRoute = (output, context) => {
    const contents = {};
    if (output[_dC] != null) {
        contents[_DCe] = __expectString(output[_dC]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_rOo] != null) {
        contents[_ROo] = __expectString(output[_rOo]);
    }
    if (output[_pLI] != null) {
        contents[_PLI] = __expectString(output[_pLI]);
    }
    if (output[_aIt] != null) {
        contents[_AIt] = __expectString(output[_aIt]);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    if (output[_rTe] != null) {
        contents[_RT] = __expectString(output[_rTe]);
    }
    return contents;
};
const de_TransitGatewayVpcAttachment = (output, context) => {
    const contents = {};
    if (output[_tGAI] != null) {
        contents[_TGAI] = __expectString(output[_tGAI]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_vOIp] != null) {
        contents[_VOIp] = __expectString(output[_vOIp]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output.subnetIds === "") {
        contents[_SIu] = [];
    }
    else if (output[_sIub] != null && output[_sIub][_i] != null) {
        contents[_SIu] = de_ValueStringList(__getArrayIfSingleItem(output[_sIub][_i]), context);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTre]));
    }
    if (output[_opt] != null) {
        contents[_Op] = de_TransitGatewayVpcAttachmentOptions(output[_opt], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TransitGatewayVpcAttachmentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransitGatewayVpcAttachment(entry, context);
    });
};
const de_TransitGatewayVpcAttachmentOptions = (output, context) => {
    const contents = {};
    if (output[_dSn] != null) {
        contents[_DSns] = __expectString(output[_dSn]);
    }
    if (output[_sGRSec] != null) {
        contents[_SGRS] = __expectString(output[_sGRSec]);
    }
    if (output[_iSpvu] != null) {
        contents[_ISp] = __expectString(output[_iSpvu]);
    }
    if (output[_aMSp] != null) {
        contents[_AMS] = __expectString(output[_aMSp]);
    }
    return contents;
};
const de_TrunkInterfaceAssociation = (output, context) => {
    const contents = {};
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_bII] != null) {
        contents[_BII] = __expectString(output[_bII]);
    }
    if (output[_tII] != null) {
        contents[_TII] = __expectString(output[_tII]);
    }
    if (output[_iPnte] != null) {
        contents[_IPnte] = __expectString(output[_iPnte]);
    }
    if (output[_vIl] != null) {
        contents[_VIl] = __strictParseInt32(output[_vIl]);
    }
    if (output[_gK] != null) {
        contents[_GK] = __strictParseInt32(output[_gK]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_TrunkInterfaceAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrunkInterfaceAssociation(entry, context);
    });
};
const de_TunnelOption = (output, context) => {
    const contents = {};
    if (output[_oIA] != null) {
        contents[_OIA] = __expectString(output[_oIA]);
    }
    if (output[_tICu] != null) {
        contents[_TIC] = __expectString(output[_tICu]);
    }
    if (output[_tIIC] != null) {
        contents[_TIIC] = __expectString(output[_tIIC]);
    }
    if (output[_pSK] != null) {
        contents[_PSK] = __expectString(output[_pSK]);
    }
    if (output[_pLSh] != null) {
        contents[_PLS] = __strictParseInt32(output[_pLSh]);
    }
    if (output[_pLSha] != null) {
        contents[_PLSh] = __strictParseInt32(output[_pLSha]);
    }
    if (output[_rMTS] != null) {
        contents[_RMTS] = __strictParseInt32(output[_rMTS]);
    }
    if (output[_rFP] != null) {
        contents[_RFP] = __strictParseInt32(output[_rFP]);
    }
    if (output[_rWS] != null) {
        contents[_RWS] = __strictParseInt32(output[_rWS]);
    }
    if (output[_dTS] != null) {
        contents[_DTS] = __strictParseInt32(output[_dTS]);
    }
    if (output[_dTA] != null) {
        contents[_DTA] = __expectString(output[_dTA]);
    }
    if (output.phase1EncryptionAlgorithmSet === "") {
        contents[_PEA] = [];
    }
    else if (output[_pEAS] != null && output[_pEAS][_i] != null) {
        contents[_PEA] = de_Phase1EncryptionAlgorithmsList(__getArrayIfSingleItem(output[_pEAS][_i]), context);
    }
    if (output.phase2EncryptionAlgorithmSet === "") {
        contents[_PEAh] = [];
    }
    else if (output[_pEASh] != null && output[_pEASh][_i] != null) {
        contents[_PEAh] = de_Phase2EncryptionAlgorithmsList(__getArrayIfSingleItem(output[_pEASh][_i]), context);
    }
    if (output.phase1IntegrityAlgorithmSet === "") {
        contents[_PIAh] = [];
    }
    else if (output[_pIASh] != null && output[_pIASh][_i] != null) {
        contents[_PIAh] = de_Phase1IntegrityAlgorithmsList(__getArrayIfSingleItem(output[_pIASh][_i]), context);
    }
    if (output.phase2IntegrityAlgorithmSet === "") {
        contents[_PIAha] = [];
    }
    else if (output[_pIASha] != null && output[_pIASha][_i] != null) {
        contents[_PIAha] = de_Phase2IntegrityAlgorithmsList(__getArrayIfSingleItem(output[_pIASha][_i]), context);
    }
    if (output.phase1DHGroupNumberSet === "") {
        contents[_PDHGN] = [];
    }
    else if (output[_pDHGNS] != null && output[_pDHGNS][_i] != null) {
        contents[_PDHGN] = de_Phase1DHGroupNumbersList(__getArrayIfSingleItem(output[_pDHGNS][_i]), context);
    }
    if (output.phase2DHGroupNumberSet === "") {
        contents[_PDHGNh] = [];
    }
    else if (output[_pDHGNSh] != null && output[_pDHGNSh][_i] != null) {
        contents[_PDHGNh] = de_Phase2DHGroupNumbersList(__getArrayIfSingleItem(output[_pDHGNSh][_i]), context);
    }
    if (output.ikeVersionSet === "") {
        contents[_IVk] = [];
    }
    else if (output[_iVS] != null && output[_iVS][_i] != null) {
        contents[_IVk] = de_IKEVersionsList(__getArrayIfSingleItem(output[_iVS][_i]), context);
    }
    if (output[_sAt] != null) {
        contents[_SA] = __expectString(output[_sAt]);
    }
    if (output[_lO] != null) {
        contents[_LO] = de_VpnTunnelLogOptions(output[_lO], context);
    }
    if (output[_eTLC] != null) {
        contents[_ETLC] = __parseBoolean(output[_eTLC]);
    }
    return contents;
};
const de_TunnelOptionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TunnelOption(entry, context);
    });
};
const de_UnassignIpv6AddressesResult = (output, context) => {
    const contents = {};
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output.unassignedIpv6Addresses === "") {
        contents[_UIAn] = [];
    }
    else if (output[_uIA] != null && output[_uIA][_i] != null) {
        contents[_UIAn] = de_Ipv6AddressList(__getArrayIfSingleItem(output[_uIA][_i]), context);
    }
    if (output.unassignedIpv6PrefixSet === "") {
        contents[_UIPn] = [];
    }
    else if (output[_uIPSn] != null && output[_uIPSn][_i] != null) {
        contents[_UIPn] = de_IpPrefixList(__getArrayIfSingleItem(output[_uIPSn][_i]), context);
    }
    return contents;
};
const de_UnassignPrivateNatGatewayAddressResult = (output, context) => {
    const contents = {};
    if (output[_nGI] != null) {
        contents[_NGI] = __expectString(output[_nGI]);
    }
    if (output.natGatewayAddressSet === "") {
        contents[_NGA] = [];
    }
    else if (output[_nGAS] != null && output[_nGAS][_i] != null) {
        contents[_NGA] = de_NatGatewayAddressList(__getArrayIfSingleItem(output[_nGAS][_i]), context);
    }
    return contents;
};
const de_UnlockSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    return contents;
};
const de_UnmonitorInstancesResult = (output, context) => {
    const contents = {};
    if (output.instancesSet === "") {
        contents[_IMn] = [];
    }
    else if (output[_iSn] != null && output[_iSn][_i] != null) {
        contents[_IMn] = de_InstanceMonitoringList(__getArrayIfSingleItem(output[_iSn][_i]), context);
    }
    return contents;
};
const de_UnsuccessfulInstanceCreditSpecificationItem = (output, context) => {
    const contents = {};
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_er] != null) {
        contents[_Er] = de_UnsuccessfulInstanceCreditSpecificationItemError(output[_er], context);
    }
    return contents;
};
const de_UnsuccessfulInstanceCreditSpecificationItemError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_UnsuccessfulInstanceCreditSpecificationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UnsuccessfulInstanceCreditSpecificationItem(entry, context);
    });
};
const de_UnsuccessfulItem = (output, context) => {
    const contents = {};
    if (output[_er] != null) {
        contents[_Er] = de_UnsuccessfulItemError(output[_er], context);
    }
    if (output[_rIes] != null) {
        contents[_RIeso] = __expectString(output[_rIes]);
    }
    return contents;
};
const de_UnsuccessfulItemError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_UnsuccessfulItemList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UnsuccessfulItem(entry, context);
    });
};
const de_UnsuccessfulItemSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UnsuccessfulItem(entry, context);
    });
};
const de_UpdateSecurityGroupRuleDescriptionsEgressResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_UpdateSecurityGroupRuleDescriptionsIngressResult = (output, context) => {
    const contents = {};
    if (output[_r] != null) {
        contents[_Ret] = __parseBoolean(output[_r]);
    }
    return contents;
};
const de_UsageClassTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_UserBucketDetails = (output, context) => {
    const contents = {};
    if (output[_sB] != null) {
        contents[_SB] = __expectString(output[_sB]);
    }
    if (output[_sK] != null) {
        contents[_SK] = __expectString(output[_sK]);
    }
    return contents;
};
const de_UserIdGroupPair = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_uI] != null) {
        contents[_UIs] = __expectString(output[_uI]);
    }
    if (output[_gN] != null) {
        contents[_GN] = __expectString(output[_gN]);
    }
    if (output[_gIr] != null) {
        contents[_GIr] = __expectString(output[_gIr]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_vPCI] != null) {
        contents[_VPCI] = __expectString(output[_vPCI]);
    }
    if (output[_pSee] != null) {
        contents[_PSe] = __expectString(output[_pSee]);
    }
    return contents;
};
const de_UserIdGroupPairList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UserIdGroupPair(entry, context);
    });
};
const de_UserIdGroupPairSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UserIdGroupPair(entry, context);
    });
};
const de_ValidationError = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ValidationWarning = (output, context) => {
    const contents = {};
    if (output.errorSet === "") {
        contents[_Err] = [];
    }
    else if (output[_eSr] != null && output[_eSr][_i] != null) {
        contents[_Err] = de_ErrorSet(__getArrayIfSingleItem(output[_eSr][_i]), context);
    }
    return contents;
};
const de_ValueStringList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_VCpuCountRange = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_M] = __strictParseInt32(output[_m]);
    }
    if (output[_ma] != null) {
        contents[_Ma] = __strictParseInt32(output[_ma]);
    }
    return contents;
};
const de_VCpuInfo = (output, context) => {
    const contents = {};
    if (output[_dVC] != null) {
        contents[_DVCef] = __strictParseInt32(output[_dVC]);
    }
    if (output[_dCe] != null) {
        contents[_DCef] = __strictParseInt32(output[_dCe]);
    }
    if (output[_dTPC] != null) {
        contents[_DTPC] = __strictParseInt32(output[_dTPC]);
    }
    if (output.validCores === "") {
        contents[_VCa] = [];
    }
    else if (output[_vCa] != null && output[_vCa][_i] != null) {
        contents[_VCa] = de_CoreCountList(__getArrayIfSingleItem(output[_vCa][_i]), context);
    }
    if (output.validThreadsPerCore === "") {
        contents[_VTPC] = [];
    }
    else if (output[_vTPC] != null && output[_vTPC][_i] != null) {
        contents[_VTPC] = de_ThreadsPerCoreList(__getArrayIfSingleItem(output[_vTPC][_i]), context);
    }
    return contents;
};
const de_VerifiedAccessEndpoint = (output, context) => {
    const contents = {};
    if (output[_vAII] != null) {
        contents[_VAII] = __expectString(output[_vAII]);
    }
    if (output[_vAGI] != null) {
        contents[_VAGI] = __expectString(output[_vAGI]);
    }
    if (output[_vAEI] != null) {
        contents[_VAEI] = __expectString(output[_vAEI]);
    }
    if (output[_aDp] != null) {
        contents[_ADp] = __expectString(output[_aDp]);
    }
    if (output[_eTnd] != null) {
        contents[_ET] = __expectString(output[_eTnd]);
    }
    if (output[_aTtta] != null) {
        contents[_ATt] = __expectString(output[_aTtta]);
    }
    if (output[_dCA] != null) {
        contents[_DCA] = __expectString(output[_dCA]);
    }
    if (output[_eDnd] != null) {
        contents[_EDnd] = __expectString(output[_eDnd]);
    }
    if (output[_dVD] != null) {
        contents[_DVD] = __expectString(output[_dVD]);
    }
    if (output.securityGroupIdSet === "") {
        contents[_SGI] = [];
    }
    else if (output[_sGIS] != null && output[_sGIS][_i] != null) {
        contents[_SGI] = de_SecurityGroupIdList(__getArrayIfSingleItem(output[_sGIS][_i]), context);
    }
    if (output[_lBO] != null) {
        contents[_LBO] = de_VerifiedAccessEndpointLoadBalancerOptions(output[_lBO], context);
    }
    if (output[_nIO] != null) {
        contents[_NIO] = de_VerifiedAccessEndpointEniOptions(output[_nIO], context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_VerifiedAccessEndpointStatus(output[_sta], context);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectString(output[_cTre]);
    }
    if (output[_lUTa] != null) {
        contents[_LUTa] = __expectString(output[_lUTa]);
    }
    if (output[_dT] != null) {
        contents[_DTel] = __expectString(output[_dT]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_sSs] != null) {
        contents[_SS] = de_VerifiedAccessSseSpecificationResponse(output[_sSs], context);
    }
    if (output[_rOd] != null) {
        contents[_RO] = de_VerifiedAccessEndpointRdsOptions(output[_rOd], context);
    }
    if (output[_cOi] != null) {
        contents[_CO] = de_VerifiedAccessEndpointCidrOptions(output[_cOi], context);
    }
    return contents;
};
const de_VerifiedAccessEndpointCidrOptions = (output, context) => {
    const contents = {};
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    if (output.portRangeSet === "") {
        contents[_PRo] = [];
    }
    else if (output[_pRS] != null && output[_pRS][_i] != null) {
        contents[_PRo] = de_VerifiedAccessEndpointPortRangeList(__getArrayIfSingleItem(output[_pRS][_i]), context);
    }
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output.subnetIdSet === "") {
        contents[_SIu] = [];
    }
    else if (output[_sISu] != null && output[_sISu][_i] != null) {
        contents[_SIu] = de_VerifiedAccessEndpointSubnetIdList(__getArrayIfSingleItem(output[_sISu][_i]), context);
    }
    return contents;
};
const de_VerifiedAccessEndpointEniOptions = (output, context) => {
    const contents = {};
    if (output[_nII] != null) {
        contents[_NII] = __expectString(output[_nII]);
    }
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output[_po] != null) {
        contents[_Po] = __strictParseInt32(output[_po]);
    }
    if (output.portRangeSet === "") {
        contents[_PRo] = [];
    }
    else if (output[_pRS] != null && output[_pRS][_i] != null) {
        contents[_PRo] = de_VerifiedAccessEndpointPortRangeList(__getArrayIfSingleItem(output[_pRS][_i]), context);
    }
    return contents;
};
const de_VerifiedAccessEndpointList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VerifiedAccessEndpoint(entry, context);
    });
};
const de_VerifiedAccessEndpointLoadBalancerOptions = (output, context) => {
    const contents = {};
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output[_po] != null) {
        contents[_Po] = __strictParseInt32(output[_po]);
    }
    if (output[_lBA] != null) {
        contents[_LBA] = __expectString(output[_lBA]);
    }
    if (output.subnetIdSet === "") {
        contents[_SIu] = [];
    }
    else if (output[_sISu] != null && output[_sISu][_i] != null) {
        contents[_SIu] = de_VerifiedAccessEndpointSubnetIdList(__getArrayIfSingleItem(output[_sISu][_i]), context);
    }
    if (output.portRangeSet === "") {
        contents[_PRo] = [];
    }
    else if (output[_pRS] != null && output[_pRS][_i] != null) {
        contents[_PRo] = de_VerifiedAccessEndpointPortRangeList(__getArrayIfSingleItem(output[_pRS][_i]), context);
    }
    return contents;
};
const de_VerifiedAccessEndpointPortRange = (output, context) => {
    const contents = {};
    if (output[_fP] != null) {
        contents[_FP] = __strictParseInt32(output[_fP]);
    }
    if (output[_tPo] != null) {
        contents[_TP] = __strictParseInt32(output[_tPo]);
    }
    return contents;
};
const de_VerifiedAccessEndpointPortRangeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VerifiedAccessEndpointPortRange(entry, context);
    });
};
const de_VerifiedAccessEndpointRdsOptions = (output, context) => {
    const contents = {};
    if (output[_pr] != null) {
        contents[_P] = __expectString(output[_pr]);
    }
    if (output[_po] != null) {
        contents[_Po] = __strictParseInt32(output[_po]);
    }
    if (output[_rDIA] != null) {
        contents[_RDIA] = __expectString(output[_rDIA]);
    }
    if (output[_rDCA] != null) {
        contents[_RDCA] = __expectString(output[_rDCA]);
    }
    if (output[_rDPA] != null) {
        contents[_RDPA] = __expectString(output[_rDPA]);
    }
    if (output[_rEd] != null) {
        contents[_RE] = __expectString(output[_rEd]);
    }
    if (output.subnetIdSet === "") {
        contents[_SIu] = [];
    }
    else if (output[_sISu] != null && output[_sISu][_i] != null) {
        contents[_SIu] = de_VerifiedAccessEndpointSubnetIdList(__getArrayIfSingleItem(output[_sISu][_i]), context);
    }
    return contents;
};
const de_VerifiedAccessEndpointStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_VerifiedAccessEndpointSubnetIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_VerifiedAccessEndpointTarget = (output, context) => {
    const contents = {};
    if (output[_vAEI] != null) {
        contents[_VAEI] = __expectString(output[_vAEI]);
    }
    if (output[_vAETIA] != null) {
        contents[_VAETIA] = __expectString(output[_vAETIA]);
    }
    if (output[_vAETD] != null) {
        contents[_VAETD] = __expectString(output[_vAETD]);
    }
    return contents;
};
const de_VerifiedAccessEndpointTargetList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VerifiedAccessEndpointTarget(entry, context);
    });
};
const de_VerifiedAccessGroup = (output, context) => {
    const contents = {};
    if (output[_vAGI] != null) {
        contents[_VAGI] = __expectString(output[_vAGI]);
    }
    if (output[_vAII] != null) {
        contents[_VAII] = __expectString(output[_vAII]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_ow] != null) {
        contents[_Own] = __expectString(output[_ow]);
    }
    if (output[_vAGA] != null) {
        contents[_VAGA] = __expectString(output[_vAGA]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectString(output[_cTre]);
    }
    if (output[_lUTa] != null) {
        contents[_LUTa] = __expectString(output[_lUTa]);
    }
    if (output[_dT] != null) {
        contents[_DTel] = __expectString(output[_dT]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_sSs] != null) {
        contents[_SS] = de_VerifiedAccessSseSpecificationResponse(output[_sSs], context);
    }
    return contents;
};
const de_VerifiedAccessGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VerifiedAccessGroup(entry, context);
    });
};
const de_VerifiedAccessInstance = (output, context) => {
    const contents = {};
    if (output[_vAII] != null) {
        contents[_VAII] = __expectString(output[_vAII]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output.verifiedAccessTrustProviderSet === "") {
        contents[_VATPe] = [];
    }
    else if (output[_vATPS] != null && output[_vATPS][_i] != null) {
        contents[_VATPe] = de_VerifiedAccessTrustProviderCondensedList(__getArrayIfSingleItem(output[_vATPS][_i]), context);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectString(output[_cTre]);
    }
    if (output[_lUTa] != null) {
        contents[_LUTa] = __expectString(output[_lUTa]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_fE] != null) {
        contents[_FE] = __parseBoolean(output[_fE]);
    }
    if (output[_cECSD] != null) {
        contents[_CECSD] = de_VerifiedAccessInstanceCustomSubDomain(output[_cECSD], context);
    }
    return contents;
};
const de_VerifiedAccessInstanceCustomSubDomain = (output, context) => {
    const contents = {};
    if (output[_sDu] != null) {
        contents[_SDu] = __expectString(output[_sDu]);
    }
    if (output.nameserverSet === "") {
        contents[_Na] = [];
    }
    else if (output[_nSa] != null && output[_nSa][_i] != null) {
        contents[_Na] = de_ValueStringList(__getArrayIfSingleItem(output[_nSa][_i]), context);
    }
    return contents;
};
const de_VerifiedAccessInstanceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VerifiedAccessInstance(entry, context);
    });
};
const de_VerifiedAccessInstanceLoggingConfiguration = (output, context) => {
    const contents = {};
    if (output[_vAII] != null) {
        contents[_VAII] = __expectString(output[_vAII]);
    }
    if (output[_aLc] != null) {
        contents[_AL] = de_VerifiedAccessLogs(output[_aLc], context);
    }
    return contents;
};
const de_VerifiedAccessInstanceLoggingConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VerifiedAccessInstanceLoggingConfiguration(entry, context);
    });
};
const de_VerifiedAccessInstanceOpenVpnClientConfiguration = (output, context) => {
    const contents = {};
    if (output[_confi] != null) {
        contents[_Confi] = __expectString(output[_confi]);
    }
    if (output.routeSet === "") {
        contents[_Rout] = [];
    }
    else if (output[_rSou] != null && output[_rSou][_i] != null) {
        contents[_Rout] = de_VerifiedAccessInstanceOpenVpnClientConfigurationRouteList(__getArrayIfSingleItem(output[_rSou][_i]), context);
    }
    return contents;
};
const de_VerifiedAccessInstanceOpenVpnClientConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VerifiedAccessInstanceOpenVpnClientConfiguration(entry, context);
    });
};
const de_VerifiedAccessInstanceOpenVpnClientConfigurationRoute = (output, context) => {
    const contents = {};
    if (output[_ci] != null) {
        contents[_C] = __expectString(output[_ci]);
    }
    return contents;
};
const de_VerifiedAccessInstanceOpenVpnClientConfigurationRouteList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VerifiedAccessInstanceOpenVpnClientConfigurationRoute(entry, context);
    });
};
const de_VerifiedAccessInstanceUserTrustProviderClientConfiguration = (output, context) => {
    const contents = {};
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_scop] != null) {
        contents[_Scop] = __expectString(output[_scop]);
    }
    if (output[_is] != null) {
        contents[_I] = __expectString(output[_is]);
    }
    if (output[_aE] != null) {
        contents[_AE] = __expectString(output[_aE]);
    }
    if (output[_pSKE] != null) {
        contents[_PSKE] = __expectString(output[_pSKE]);
    }
    if (output[_tEo] != null) {
        contents[_TEo] = __expectString(output[_tEo]);
    }
    if (output[_uIE] != null) {
        contents[_UIE] = __expectString(output[_uIE]);
    }
    if (output[_cIli] != null) {
        contents[_CIl] = __expectString(output[_cIli]);
    }
    if (output[_cSl] != null) {
        contents[_CSl] = __expectString(output[_cSl]);
    }
    if (output[_pEk] != null) {
        contents[_PEk] = __parseBoolean(output[_pEk]);
    }
    return contents;
};
const de_VerifiedAccessLogCloudWatchLogsDestination = (output, context) => {
    const contents = {};
    if (output[_en] != null) {
        contents[_En] = __parseBoolean(output[_en]);
    }
    if (output[_dSel] != null) {
        contents[_DSeli] = de_VerifiedAccessLogDeliveryStatus(output[_dSel], context);
    }
    if (output[_lGo] != null) {
        contents[_LGo] = __expectString(output[_lGo]);
    }
    return contents;
};
const de_VerifiedAccessLogDeliveryStatus = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_VerifiedAccessLogKinesisDataFirehoseDestination = (output, context) => {
    const contents = {};
    if (output[_en] != null) {
        contents[_En] = __parseBoolean(output[_en]);
    }
    if (output[_dSel] != null) {
        contents[_DSeli] = de_VerifiedAccessLogDeliveryStatus(output[_dSel], context);
    }
    if (output[_dSeli] != null) {
        contents[_DSel] = __expectString(output[_dSeli]);
    }
    return contents;
};
const de_VerifiedAccessLogs = (output, context) => {
    const contents = {};
    if (output[_s_] != null) {
        contents[_S_] = de_VerifiedAccessLogS3Destination(output[_s_], context);
    }
    if (output[_cWL] != null) {
        contents[_CWL] = de_VerifiedAccessLogCloudWatchLogsDestination(output[_cWL], context);
    }
    if (output[_kDF] != null) {
        contents[_KDF] = de_VerifiedAccessLogKinesisDataFirehoseDestination(output[_kDF], context);
    }
    if (output[_lV] != null) {
        contents[_LV] = __expectString(output[_lV]);
    }
    if (output[_iTCn] != null) {
        contents[_ITCn] = __parseBoolean(output[_iTCn]);
    }
    return contents;
};
const de_VerifiedAccessLogS3Destination = (output, context) => {
    const contents = {};
    if (output[_en] != null) {
        contents[_En] = __parseBoolean(output[_en]);
    }
    if (output[_dSel] != null) {
        contents[_DSeli] = de_VerifiedAccessLogDeliveryStatus(output[_dSel], context);
    }
    if (output[_bN] != null) {
        contents[_BN] = __expectString(output[_bN]);
    }
    if (output[_pre] != null) {
        contents[_Pr] = __expectString(output[_pre]);
    }
    if (output[_bOu] != null) {
        contents[_BOu] = __expectString(output[_bOu]);
    }
    return contents;
};
const de_VerifiedAccessSseSpecificationResponse = (output, context) => {
    const contents = {};
    if (output[_cMKE] != null) {
        contents[_CMKE] = __parseBoolean(output[_cMKE]);
    }
    if (output[_kKA] != null) {
        contents[_KKA] = __expectString(output[_kKA]);
    }
    return contents;
};
const de_VerifiedAccessTrustProvider = (output, context) => {
    const contents = {};
    if (output[_vATPI] != null) {
        contents[_VATPI] = __expectString(output[_vATPI]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_tPT] != null) {
        contents[_TPT] = __expectString(output[_tPT]);
    }
    if (output[_uTPT] != null) {
        contents[_UTPT] = __expectString(output[_uTPT]);
    }
    if (output[_dTPT] != null) {
        contents[_DTPT] = __expectString(output[_dTPT]);
    }
    if (output[_oO] != null) {
        contents[_OO] = de_OidcOptions(output[_oO], context);
    }
    if (output[_dOev] != null) {
        contents[_DOe] = de_DeviceOptions(output[_dOev], context);
    }
    if (output[_pRNo] != null) {
        contents[_PRN] = __expectString(output[_pRNo]);
    }
    if (output[_cTre] != null) {
        contents[_CTre] = __expectString(output[_cTre]);
    }
    if (output[_lUTa] != null) {
        contents[_LUTa] = __expectString(output[_lUTa]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_sSs] != null) {
        contents[_SS] = de_VerifiedAccessSseSpecificationResponse(output[_sSs], context);
    }
    if (output[_nAOO] != null) {
        contents[_NAOO] = de_NativeApplicationOidcOptions(output[_nAOO], context);
    }
    return contents;
};
const de_VerifiedAccessTrustProviderCondensed = (output, context) => {
    const contents = {};
    if (output[_vATPI] != null) {
        contents[_VATPI] = __expectString(output[_vATPI]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_tPT] != null) {
        contents[_TPT] = __expectString(output[_tPT]);
    }
    if (output[_uTPT] != null) {
        contents[_UTPT] = __expectString(output[_uTPT]);
    }
    if (output[_dTPT] != null) {
        contents[_DTPT] = __expectString(output[_dTPT]);
    }
    return contents;
};
const de_VerifiedAccessTrustProviderCondensedList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VerifiedAccessTrustProviderCondensed(entry, context);
    });
};
const de_VerifiedAccessTrustProviderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VerifiedAccessTrustProvider(entry, context);
    });
};
const de_VgwTelemetry = (output, context) => {
    const contents = {};
    if (output[_aRC] != null) {
        contents[_ARC] = __strictParseInt32(output[_aRC]);
    }
    if (output[_lSC] != null) {
        contents[_LSC] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lSC]));
    }
    if (output[_oIA] != null) {
        contents[_OIA] = __expectString(output[_oIA]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_cAe] != null) {
        contents[_CA] = __expectString(output[_cAe]);
    }
    return contents;
};
const de_VgwTelemetryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VgwTelemetry(entry, context);
    });
};
const de_VirtualizationTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Volume = (output, context) => {
    const contents = {};
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output[_io] != null) {
        contents[_Io] = __strictParseInt32(output[_io]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vT] != null) {
        contents[_VT] = __expectString(output[_vT]);
    }
    if (output[_fRa] != null) {
        contents[_FRa] = __parseBoolean(output[_fRa]);
    }
    if (output[_mAE] != null) {
        contents[_MAE] = __parseBoolean(output[_mAE]);
    }
    if (output[_th] != null) {
        contents[_Th] = __strictParseInt32(output[_th]);
    }
    if (output[_sTs] != null) {
        contents[_STs] = __expectString(output[_sTs]);
    }
    if (output[_op] != null) {
        contents[_O] = de_OperatorResponse(output[_op], context);
    }
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    if (output[_si] != null) {
        contents[_Siz] = __strictParseInt32(output[_si]);
    }
    if (output[_sIn] != null) {
        contents[_SIn] = __expectString(output[_sIn]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_sta] != null) {
        contents[_Stat] = __expectString(output[_sta]);
    }
    if (output[_cTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTr]));
    }
    if (output.attachmentSet === "") {
        contents[_Atta] = [];
    }
    else if (output[_aSt] != null && output[_aSt][_i] != null) {
        contents[_Atta] = de_VolumeAttachmentList(__getArrayIfSingleItem(output[_aSt][_i]), context);
    }
    if (output[_enc] != null) {
        contents[_Enc] = __parseBoolean(output[_enc]);
    }
    if (output[_kKI] != null) {
        contents[_KKI] = __expectString(output[_kKI]);
    }
    return contents;
};
const de_VolumeAttachment = (output, context) => {
    const contents = {};
    if (output[_dOT] != null) {
        contents[_DOT] = __parseBoolean(output[_dOT]);
    }
    if (output[_aRs] != null) {
        contents[_ARs] = __expectString(output[_aRs]);
    }
    if (output[_iOS] != null) {
        contents[_IOS] = __expectString(output[_iOS]);
    }
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    if (output[_dev] != null) {
        contents[_Dev] = __expectString(output[_dev]);
    }
    if (output[_sta] != null) {
        contents[_Stat] = __expectString(output[_sta]);
    }
    if (output[_aTt] != null) {
        contents[_ATtt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_aTt]));
    }
    return contents;
};
const de_VolumeAttachmentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VolumeAttachment(entry, context);
    });
};
const de_VolumeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Volume(entry, context);
    });
};
const de_VolumeModification = (output, context) => {
    const contents = {};
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    if (output[_mSod] != null) {
        contents[_MSod] = __expectString(output[_mSod]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    if (output[_tSar] != null) {
        contents[_TSar] = __strictParseInt32(output[_tSar]);
    }
    if (output[_tIa] != null) {
        contents[_TIar] = __strictParseInt32(output[_tIa]);
    }
    if (output[_tVT] != null) {
        contents[_TVT] = __expectString(output[_tVT]);
    }
    if (output[_tTa] != null) {
        contents[_TTa] = __strictParseInt32(output[_tTa]);
    }
    if (output[_tMAE] != null) {
        contents[_TMAE] = __parseBoolean(output[_tMAE]);
    }
    if (output[_oSr] != null) {
        contents[_OSr] = __strictParseInt32(output[_oSr]);
    }
    if (output[_oIr] != null) {
        contents[_OIr] = __strictParseInt32(output[_oIr]);
    }
    if (output[_oVT] != null) {
        contents[_OVT] = __expectString(output[_oVT]);
    }
    if (output[_oTr] != null) {
        contents[_OTr] = __strictParseInt32(output[_oTr]);
    }
    if (output[_oMAE] != null) {
        contents[_OMAE] = __parseBoolean(output[_oMAE]);
    }
    if (output[_pro] != null) {
        contents[_Prog] = __strictParseLong(output[_pro]);
    }
    if (output[_sT] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_sT]));
    }
    if (output[_eTn] != null) {
        contents[_ETn] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eTn]));
    }
    return contents;
};
const de_VolumeModificationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VolumeModification(entry, context);
    });
};
const de_VolumeStatusAction = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_eIve] != null) {
        contents[_EIve] = __expectString(output[_eIve]);
    }
    if (output[_eTv] != null) {
        contents[_ETv] = __expectString(output[_eTv]);
    }
    return contents;
};
const de_VolumeStatusActionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VolumeStatusAction(entry, context);
    });
};
const de_VolumeStatusAttachmentStatus = (output, context) => {
    const contents = {};
    if (output[_iPo] != null) {
        contents[_IPo] = __expectString(output[_iPo]);
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    return contents;
};
const de_VolumeStatusAttachmentStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VolumeStatusAttachmentStatus(entry, context);
    });
};
const de_VolumeStatusDetails = (output, context) => {
    const contents = {};
    if (output[_n] != null) {
        contents[_N] = __expectString(output[_n]);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_VolumeStatusDetailsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VolumeStatusDetails(entry, context);
    });
};
const de_VolumeStatusEvent = (output, context) => {
    const contents = {};
    if (output[_de] != null) {
        contents[_De] = __expectString(output[_de]);
    }
    if (output[_eIve] != null) {
        contents[_EIve] = __expectString(output[_eIve]);
    }
    if (output[_eTv] != null) {
        contents[_ETv] = __expectString(output[_eTv]);
    }
    if (output[_nAo] != null) {
        contents[_NAo] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nAo]));
    }
    if (output[_nB] != null) {
        contents[_NB] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_nB]));
    }
    if (output[_iI] != null) {
        contents[_IIn] = __expectString(output[_iI]);
    }
    return contents;
};
const de_VolumeStatusEventsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VolumeStatusEvent(entry, context);
    });
};
const de_VolumeStatusInfo = (output, context) => {
    const contents = {};
    if (output.details === "") {
        contents[_Det] = [];
    }
    else if (output[_det] != null && output[_det][_i] != null) {
        contents[_Det] = de_VolumeStatusDetailsList(__getArrayIfSingleItem(output[_det][_i]), context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = __expectString(output[_sta]);
    }
    return contents;
};
const de_VolumeStatusItem = (output, context) => {
    const contents = {};
    if (output.actionsSet === "") {
        contents[_Acti] = [];
    }
    else if (output[_aSct] != null && output[_aSct][_i] != null) {
        contents[_Acti] = de_VolumeStatusActionsList(__getArrayIfSingleItem(output[_aSct][_i]), context);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output[_oA] != null) {
        contents[_OA] = __expectString(output[_oA]);
    }
    if (output.eventsSet === "") {
        contents[_Ev] = [];
    }
    else if (output[_eSv] != null && output[_eSv][_i] != null) {
        contents[_Ev] = de_VolumeStatusEventsList(__getArrayIfSingleItem(output[_eSv][_i]), context);
    }
    if (output[_vIo] != null) {
        contents[_VIo] = __expectString(output[_vIo]);
    }
    if (output[_vSol] != null) {
        contents[_VSol] = de_VolumeStatusInfo(output[_vSol], context);
    }
    if (output.attachmentStatuses === "") {
        contents[_AStt] = [];
    }
    else if (output[_aStt] != null && output[_aStt][_i] != null) {
        contents[_AStt] = de_VolumeStatusAttachmentStatusList(__getArrayIfSingleItem(output[_aStt][_i]), context);
    }
    return contents;
};
const de_VolumeStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VolumeStatusItem(entry, context);
    });
};
const de_Vpc = (output, context) => {
    const contents = {};
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_iTns] != null) {
        contents[_ITns] = __expectString(output[_iTns]);
    }
    if (output.ipv6CidrBlockAssociationSet === "") {
        contents[_ICBAS] = [];
    }
    else if (output[_iCBAS] != null && output[_iCBAS][_i] != null) {
        contents[_ICBAS] = de_VpcIpv6CidrBlockAssociationSet(__getArrayIfSingleItem(output[_iCBAS][_i]), context);
    }
    if (output.cidrBlockAssociationSet === "") {
        contents[_CBAS] = [];
    }
    else if (output[_cBAS] != null && output[_cBAS][_i] != null) {
        contents[_CBAS] = de_VpcCidrBlockAssociationSet(__getArrayIfSingleItem(output[_cBAS][_i]), context);
    }
    if (output[_iDs] != null) {
        contents[_IDs] = __parseBoolean(output[_iDs]);
    }
    if (output[_eCn] != null) {
        contents[_ECn] = de_VpcEncryptionControl(output[_eCn], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_bPAS] != null) {
        contents[_BPAS] = de_BlockPublicAccessStates(output[_bPAS], context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_cB] != null) {
        contents[_CB] = __expectString(output[_cB]);
    }
    if (output[_dOI] != null) {
        contents[_DOI] = __expectString(output[_dOI]);
    }
    return contents;
};
const de_VpcAttachment = (output, context) => {
    const contents = {};
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_VpcAttachmentList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcAttachment(entry, context);
    });
};
const de_VpcBlockPublicAccessExclusion = (output, context) => {
    const contents = {};
    if (output[_eIx] != null) {
        contents[_EIxc] = __expectString(output[_eIx]);
    }
    if (output[_iGEM] != null) {
        contents[_IGEM] = __expectString(output[_iGEM]);
    }
    if (output[_rAe] != null) {
        contents[_RAes] = __expectString(output[_rAe]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_rea] != null) {
        contents[_Rea] = __expectString(output[_rea]);
    }
    if (output[_cTrea] != null) {
        contents[_CTrea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTrea]));
    }
    if (output[_lUTas] != null) {
        contents[_LUTas] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lUTas]));
    }
    if (output[_dTele] != null) {
        contents[_DTelet] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_dTele]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_VpcBlockPublicAccessExclusionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcBlockPublicAccessExclusion(entry, context);
    });
};
const de_VpcBlockPublicAccessOptions = (output, context) => {
    const contents = {};
    if (output[_aAI] != null) {
        contents[_AAI] = __expectString(output[_aAI]);
    }
    if (output[_aRw] != null) {
        contents[_ARw] = __expectString(output[_aRw]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_iGBM] != null) {
        contents[_IGBM] = __expectString(output[_iGBM]);
    }
    if (output[_rea] != null) {
        contents[_Rea] = __expectString(output[_rea]);
    }
    if (output[_lUTas] != null) {
        contents[_LUTas] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_lUTas]));
    }
    if (output[_mB] != null) {
        contents[_MB] = __expectString(output[_mB]);
    }
    if (output[_eAx] != null) {
        contents[_EAx] = __expectString(output[_eAx]);
    }
    return contents;
};
const de_VpcCidrBlockAssociation = (output, context) => {
    const contents = {};
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_cB] != null) {
        contents[_CB] = __expectString(output[_cB]);
    }
    if (output[_cBS] != null) {
        contents[_CBS] = de_VpcCidrBlockState(output[_cBS], context);
    }
    return contents;
};
const de_VpcCidrBlockAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcCidrBlockAssociation(entry, context);
    });
};
const de_VpcCidrBlockState = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMt] != null) {
        contents[_SMt] = __expectString(output[_sMt]);
    }
    return contents;
};
const de_VpcClassicLink = (output, context) => {
    const contents = {};
    if (output[_cLE] != null) {
        contents[_CLE] = __parseBoolean(output[_cLE]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    return contents;
};
const de_VpcClassicLinkList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcClassicLink(entry, context);
    });
};
const de_VpcEncryptionControl = (output, context) => {
    const contents = {};
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_vECI] != null) {
        contents[_VECI] = __expectString(output[_vECI]);
    }
    if (output[_mod] != null) {
        contents[_Mo] = __expectString(output[_mod]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMta] != null) {
        contents[_SMta] = __expectString(output[_sMta]);
    }
    if (output[_rEes] != null) {
        contents[_REeso] = de_VpcEncryptionControlExclusions(output[_rEes], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_VpcEncryptionControlExclusion = (output, context) => {
    const contents = {};
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_sMta] != null) {
        contents[_SMta] = __expectString(output[_sMta]);
    }
    return contents;
};
const de_VpcEncryptionControlExclusions = (output, context) => {
    const contents = {};
    if (output[_iG] != null) {
        contents[_IGn] = de_VpcEncryptionControlExclusion(output[_iG], context);
    }
    if (output[_eOIG] != null) {
        contents[_EOIG] = de_VpcEncryptionControlExclusion(output[_eOIG], context);
    }
    if (output[_nG] != null) {
        contents[_NG] = de_VpcEncryptionControlExclusion(output[_nG], context);
    }
    if (output[_vPG] != null) {
        contents[_VPG] = de_VpcEncryptionControlExclusion(output[_vPG], context);
    }
    if (output[_vPpc] != null) {
        contents[_VPpc] = de_VpcEncryptionControlExclusion(output[_vPpc], context);
    }
    return contents;
};
const de_VpcEndpoint = (output, context) => {
    const contents = {};
    if (output[_vEI] != null) {
        contents[_VEIp] = __expectString(output[_vEI]);
    }
    if (output[_vET] != null) {
        contents[_VET] = __expectString(output[_vET]);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_sN] != null) {
        contents[_SNe] = __expectString(output[_sN]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_pDo] != null) {
        contents[_PD] = __expectString(output[_pDo]);
    }
    if (output.routeTableIdSet === "") {
        contents[_RTIo] = [];
    }
    else if (output[_rTIS] != null && output[_rTIS][_i] != null) {
        contents[_RTIo] = de_ValueStringList(__getArrayIfSingleItem(output[_rTIS][_i]), context);
    }
    if (output.subnetIdSet === "") {
        contents[_SIu] = [];
    }
    else if (output[_sISu] != null && output[_sISu][_i] != null) {
        contents[_SIu] = de_ValueStringList(__getArrayIfSingleItem(output[_sISu][_i]), context);
    }
    if (output.groupSet === "") {
        contents[_G] = [];
    }
    else if (output[_gS] != null && output[_gS][_i] != null) {
        contents[_G] = de_GroupIdentifierSet(__getArrayIfSingleItem(output[_gS][_i]), context);
    }
    if (output[_iAT] != null) {
        contents[_IAT] = __expectString(output[_iAT]);
    }
    if (output[_dOn] != null) {
        contents[_DOn] = de_DnsOptions(output[_dOn], context);
    }
    if (output[_pDE] != null) {
        contents[_PDE] = __parseBoolean(output[_pDE]);
    }
    if (output[_rM] != null) {
        contents[_RMe] = __parseBoolean(output[_rM]);
    }
    if (output.networkInterfaceIdSet === "") {
        contents[_NIIe] = [];
    }
    else if (output[_nIIS] != null && output[_nIIS][_i] != null) {
        contents[_NIIe] = de_ValueStringList(__getArrayIfSingleItem(output[_nIIS][_i]), context);
    }
    if (output.dnsEntrySet === "") {
        contents[_DE] = [];
    }
    else if (output[_dES] != null && output[_dES][_i] != null) {
        contents[_DE] = de_DnsEntrySet(__getArrayIfSingleItem(output[_dES][_i]), context);
    }
    if (output[_cTrea] != null) {
        contents[_CTrea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTrea]));
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_lEa] != null) {
        contents[_LEa] = de_LastError(output[_lEa], context);
    }
    if (output.ipv4PrefixSet === "") {
        contents[_IPp] = [];
    }
    else if (output[_iPSpv] != null && output[_iPSpv][_i] != null) {
        contents[_IPp] = de_SubnetIpPrefixesList(__getArrayIfSingleItem(output[_iPSpv][_i]), context);
    }
    if (output.ipv6PrefixSet === "") {
        contents[_IP] = [];
    }
    else if (output[_iPSpvr] != null && output[_iPSpvr][_i] != null) {
        contents[_IP] = de_SubnetIpPrefixesList(__getArrayIfSingleItem(output[_iPSpvr][_i]), context);
    }
    if (output[_fR] != null) {
        contents[_FR] = __expectString(output[_fR]);
    }
    if (output[_sNA] != null) {
        contents[_SNA] = __expectString(output[_sNA]);
    }
    if (output[_rCA] != null) {
        contents[_RCA] = __expectString(output[_rCA]);
    }
    if (output[_sR] != null) {
        contents[_SRe] = __expectString(output[_sR]);
    }
    return contents;
};
const de_VpcEndpointAssociation = (output, context) => {
    const contents = {};
    if (output[_id] != null) {
        contents[_Id] = __expectString(output[_id]);
    }
    if (output[_vEI] != null) {
        contents[_VEIp] = __expectString(output[_vEI]);
    }
    if (output[_sNA] != null) {
        contents[_SNA] = __expectString(output[_sNA]);
    }
    if (output[_sNN] != null) {
        contents[_SNN] = __expectString(output[_sNN]);
    }
    if (output[_aRAs] != null) {
        contents[_ARAs] = __expectString(output[_aRAs]);
    }
    if (output[_fR] != null) {
        contents[_FR] = __expectString(output[_fR]);
    }
    if (output[_fCa] != null) {
        contents[_FCa] = __expectString(output[_fCa]);
    }
    if (output[_dE] != null) {
        contents[_DEn] = de_DnsEntry(output[_dE], context);
    }
    if (output[_pDEr] != null) {
        contents[_PDEr] = de_DnsEntry(output[_pDEr], context);
    }
    if (output[_aRAss] != null) {
        contents[_ARAss] = __expectString(output[_aRAss]);
    }
    if (output[_rCGA] != null) {
        contents[_RCGA] = __expectString(output[_rCGA]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    return contents;
};
const de_VpcEndpointAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcEndpointAssociation(entry, context);
    });
};
const de_VpcEndpointConnection = (output, context) => {
    const contents = {};
    if (output[_sI] != null) {
        contents[_SIe] = __expectString(output[_sI]);
    }
    if (output[_vEI] != null) {
        contents[_VEIp] = __expectString(output[_vEI]);
    }
    if (output[_vEO] != null) {
        contents[_VEO] = __expectString(output[_vEO]);
    }
    if (output[_vESpc] != null) {
        contents[_VESpc] = __expectString(output[_vESpc]);
    }
    if (output[_cTrea] != null) {
        contents[_CTrea] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_cTrea]));
    }
    if (output.dnsEntrySet === "") {
        contents[_DE] = [];
    }
    else if (output[_dES] != null && output[_dES][_i] != null) {
        contents[_DE] = de_DnsEntrySet(__getArrayIfSingleItem(output[_dES][_i]), context);
    }
    if (output.networkLoadBalancerArnSet === "") {
        contents[_NLBAe] = [];
    }
    else if (output[_nLBAS] != null && output[_nLBAS][_i] != null) {
        contents[_NLBAe] = de_ValueStringList(__getArrayIfSingleItem(output[_nLBAS][_i]), context);
    }
    if (output.gatewayLoadBalancerArnSet === "") {
        contents[_GLBA] = [];
    }
    else if (output[_gLBAS] != null && output[_gLBAS][_i] != null) {
        contents[_GLBA] = de_ValueStringList(__getArrayIfSingleItem(output[_gLBAS][_i]), context);
    }
    if (output[_iAT] != null) {
        contents[_IAT] = __expectString(output[_iAT]);
    }
    if (output[_vECIp] != null) {
        contents[_VECIp] = __expectString(output[_vECIp]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vER] != null) {
        contents[_VER] = __expectString(output[_vER]);
    }
    return contents;
};
const de_VpcEndpointConnectionSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcEndpointConnection(entry, context);
    });
};
const de_VpcEndpointSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcEndpoint(entry, context);
    });
};
const de_VpcIpv6CidrBlockAssociation = (output, context) => {
    const contents = {};
    if (output[_aIs] != null) {
        contents[_AIss] = __expectString(output[_aIs]);
    }
    if (output[_iCB] != null) {
        contents[_ICB] = __expectString(output[_iCB]);
    }
    if (output[_iCBS] != null) {
        contents[_ICBS] = de_VpcCidrBlockState(output[_iCBS], context);
    }
    if (output[_nBG] != null) {
        contents[_NBG] = __expectString(output[_nBG]);
    }
    if (output[_iPpvo] != null) {
        contents[_IPpv] = __expectString(output[_iPpvo]);
    }
    if (output[_iAA] != null) {
        contents[_IAA] = __expectString(output[_iAA]);
    }
    if (output[_iSpo] != null) {
        contents[_ISpo] = __expectString(output[_iSpo]);
    }
    return contents;
};
const de_VpcIpv6CidrBlockAssociationSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcIpv6CidrBlockAssociation(entry, context);
    });
};
const de_VpcList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Vpc(entry, context);
    });
};
const de_VpcPeeringConnection = (output, context) => {
    const contents = {};
    if (output[_aVI] != null) {
        contents[_AVI] = de_VpcPeeringConnectionVpcInfo(output[_aVI], context);
    }
    if (output[_eT] != null) {
        contents[_ETx] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_eT]));
    }
    if (output[_rVIe] != null) {
        contents[_RVIe] = de_VpcPeeringConnectionVpcInfo(output[_rVIe], context);
    }
    if (output[_sta] != null) {
        contents[_Statu] = de_VpcPeeringConnectionStateReason(output[_sta], context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vPCI] != null) {
        contents[_VPCI] = __expectString(output[_vPCI]);
    }
    return contents;
};
const de_VpcPeeringConnectionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcPeeringConnection(entry, context);
    });
};
const de_VpcPeeringConnectionOptionsDescription = (output, context) => {
    const contents = {};
    if (output[_aDRFRV] != null) {
        contents[_ADRFRV] = __parseBoolean(output[_aDRFRV]);
    }
    if (output[_aEFLCLTRV] != null) {
        contents[_AEFLCLTRV] = __parseBoolean(output[_aEFLCLTRV]);
    }
    if (output[_aEFLVTRCL] != null) {
        contents[_AEFLVTRCL] = __parseBoolean(output[_aEFLVTRCL]);
    }
    return contents;
};
const de_VpcPeeringConnectionStateReason = (output, context) => {
    const contents = {};
    if (output[_co] != null) {
        contents[_Cod] = __expectString(output[_co]);
    }
    if (output[_me] != null) {
        contents[_Me] = __expectString(output[_me]);
    }
    return contents;
};
const de_VpcPeeringConnectionVpcInfo = (output, context) => {
    const contents = {};
    if (output[_cB] != null) {
        contents[_CB] = __expectString(output[_cB]);
    }
    if (output.ipv6CidrBlockSet === "") {
        contents[_ICBSp] = [];
    }
    else if (output[_iCBSp] != null && output[_iCBSp][_i] != null) {
        contents[_ICBSp] = de_Ipv6CidrBlockSet(__getArrayIfSingleItem(output[_iCBSp][_i]), context);
    }
    if (output.cidrBlockSet === "") {
        contents[_CBSi] = [];
    }
    else if (output[_cBSi] != null && output[_cBSi][_i] != null) {
        contents[_CBSi] = de_CidrBlockSet(__getArrayIfSingleItem(output[_cBSi][_i]), context);
    }
    if (output[_oI] != null) {
        contents[_OIwn] = __expectString(output[_oI]);
    }
    if (output[_pOe] != null) {
        contents[_POe] = de_VpcPeeringConnectionOptionsDescription(output[_pOe], context);
    }
    if (output[_vI] != null) {
        contents[_VI] = __expectString(output[_vI]);
    }
    if (output[_re] != null) {
        contents[_Regi] = __expectString(output[_re]);
    }
    return contents;
};
const de_VpnConnection = (output, context) => {
    const contents = {};
    if (output[_ca] != null) {
        contents[_Cat] = __expectString(output[_ca]);
    }
    if (output[_tGI] != null) {
        contents[_TGI] = __expectString(output[_tGI]);
    }
    if (output[_cNA] != null) {
        contents[_CNAo] = __expectString(output[_cNA]);
    }
    if (output[_cNAA] != null) {
        contents[_CNAA] = __expectString(output[_cNAA]);
    }
    if (output[_gAS] != null) {
        contents[_GAS] = __expectString(output[_gAS]);
    }
    if (output[_opt] != null) {
        contents[_Op] = de_VpnConnectionOptions(output[_opt], context);
    }
    if (output.routes === "") {
        contents[_Rout] = [];
    }
    else if (output[_rou] != null && output[_rou][_i] != null) {
        contents[_Rout] = de_VpnStaticRouteList(__getArrayIfSingleItem(output[_rou][_i]), context);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output.vgwTelemetry === "") {
        contents[_VTg] = [];
    }
    else if (output[_vTg] != null && output[_vTg][_i] != null) {
        contents[_VTg] = de_VgwTelemetryList(__getArrayIfSingleItem(output[_vTg][_i]), context);
    }
    if (output[_vCI] != null) {
        contents[_VCI] = __expectString(output[_vCI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_cGC] != null) {
        contents[_CGC] = __expectString(output[_cGC]);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_cGIu] != null) {
        contents[_CGIu] = __expectString(output[_cGIu]);
    }
    if (output[_vGI] != null) {
        contents[_VGI] = __expectString(output[_vGI]);
    }
    return contents;
};
const de_VpnConnectionDeviceType = (output, context) => {
    const contents = {};
    if (output[_vCDTI] != null) {
        contents[_VCDTI] = __expectString(output[_vCDTI]);
    }
    if (output[_ven] != null) {
        contents[_Ven] = __expectString(output[_ven]);
    }
    if (output[_pl] != null) {
        contents[_Pla] = __expectString(output[_pl]);
    }
    if (output[_sof] != null) {
        contents[_Sof] = __expectString(output[_sof]);
    }
    return contents;
};
const de_VpnConnectionDeviceTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpnConnectionDeviceType(entry, context);
    });
};
const de_VpnConnectionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpnConnection(entry, context);
    });
};
const de_VpnConnectionOptions = (output, context) => {
    const contents = {};
    if (output[_eAn] != null) {
        contents[_EA] = __parseBoolean(output[_eAn]);
    }
    if (output[_sRO] != null) {
        contents[_SRO] = __parseBoolean(output[_sRO]);
    }
    if (output[_lINC] != null) {
        contents[_LINC] = __expectString(output[_lINC]);
    }
    if (output[_rINC] != null) {
        contents[_RINC] = __expectString(output[_rINC]);
    }
    if (output[_lINCo] != null) {
        contents[_LINCo] = __expectString(output[_lINCo]);
    }
    if (output[_rINCe] != null) {
        contents[_RINCe] = __expectString(output[_rINCe]);
    }
    if (output[_oIAT] != null) {
        contents[_OIAT] = __expectString(output[_oIAT]);
    }
    if (output[_tTGAI] != null) {
        contents[_TTGAI] = __expectString(output[_tTGAI]);
    }
    if (output[_tIIV] != null) {
        contents[_TIIV] = __expectString(output[_tIIV]);
    }
    if (output.tunnelOptionSet === "") {
        contents[_TO] = [];
    }
    else if (output[_tOS] != null && output[_tOS][_i] != null) {
        contents[_TO] = de_TunnelOptionsList(__getArrayIfSingleItem(output[_tOS][_i]), context);
    }
    return contents;
};
const de_VpnGateway = (output, context) => {
    const contents = {};
    if (output[_aSA] != null) {
        contents[_ASA] = __strictParseLong(output[_aSA]);
    }
    if (output.tagSet === "") {
        contents[_Ta] = [];
    }
    else if (output[_tS] != null && output[_tS][_i] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_tS][_i]), context);
    }
    if (output[_vGI] != null) {
        contents[_VGI] = __expectString(output[_vGI]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    if (output[_ty] != null) {
        contents[_T] = __expectString(output[_ty]);
    }
    if (output[_aZ] != null) {
        contents[_AZ] = __expectString(output[_aZ]);
    }
    if (output.attachments === "") {
        contents[_VAp] = [];
    }
    else if (output[_att] != null && output[_att][_i] != null) {
        contents[_VAp] = de_VpcAttachmentList(__getArrayIfSingleItem(output[_att][_i]), context);
    }
    return contents;
};
const de_VpnGatewayList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpnGateway(entry, context);
    });
};
const de_VpnStaticRoute = (output, context) => {
    const contents = {};
    if (output[_dCB] != null) {
        contents[_DCB] = __expectString(output[_dCB]);
    }
    if (output[_s] != null) {
        contents[_S] = __expectString(output[_s]);
    }
    if (output[_st] != null) {
        contents[_Stat] = __expectString(output[_st]);
    }
    return contents;
};
const de_VpnStaticRouteList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpnStaticRoute(entry, context);
    });
};
const de_VpnTunnelLogOptions = (output, context) => {
    const contents = {};
    if (output[_cWLO] != null) {
        contents[_CWLO] = de_CloudWatchLogOptions(output[_cWLO], context);
    }
    return contents;
};
const de_WithdrawByoipCidrResult = (output, context) => {
    const contents = {};
    if (output[_bC] != null) {
        contents[_BC] = de_ByoipCidr(output[_bC], context);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2016-11-15";
const _A = "Action";
const _AA = "AllocateAddress";
const _AAC = "AsnAuthorizationContext";
const _AACv = "AvailableAddressCount";
const _AAG = "AuthorizeAllGroups";
const _AAI = "AwsAccountId";
const _AAId = "AddressAllocationId";
const _AAP = "AddAllowedPrincipals";
const _AART = "AddAllocationResourceTags";
const _AASA = "AutoAcceptSharedAssociations";
const _AASAu = "AutoAcceptSharedAttachments";
const _AAT = "AcceptAddressTransfer";
const _AAZ = "AllAvailabilityZones";
const _AAc = "AccessAll";
const _AAcc = "AccountAttributes";
const _AAd = "AdditionalAccounts";
const _AAs = "AssociateAddress";
const _AAsn = "AsnAssociation";
const _AAsns = "AsnAssociations";
const _ABC = "AdvertiseByoipCidr";
const _ABHP = "ActualBlockHourlyPrice";
const _AC = "AllowedCidrs";
const _ACIA = "AssociateCarrierIpAddress";
const _ACLV = "AttachClassicLinkVpc";
const _ACRBO = "AcceptCapacityReservationBillingOwnership";
const _ACRBOs = "AssociateCapacityReservationBillingOwner";
const _ACT = "ArchivalCompleteTime";
const _ACVI = "AuthorizeClientVpnIngress";
const _ACVTN = "AssociateClientVpnTargetNetwork";
const _ACc = "AcceleratorCount";
const _ACd = "AddressCount";
const _ACv = "AvailableCapacity";
const _AD = "ActiveDirectory";
const _ADNL = "AllocationDefaultNetmaskLength";
const _ADO = "AssociateDhcpOptions";
const _ADRFRV = "AllowDnsResolutionFromRemoteVpc";
const _ADRTI = "AssociationDefaultRouteTableId";
const _ADT = "AdditionalDetailType";
const _ADd = "AdditionalDetails";
const _ADn = "AnnouncementDirection";
const _ADp = "ApplicationDomain";
const _AE = "AuthorizationEndpoint";
const _AEC = "AnalyzedEniCount";
const _AECIR = "AssociateEnclaveCertificateIamRole";
const _AEFLCLTRV = "AllowEgressFromLocalClassicLinkToRemoteVpc";
const _AEFLVTRCL = "AllowEgressFromLocalVpcToRemoteClassicLink";
const _AEIO = "AutoEnableIO";
const _AES = "AttachedEbsStatus";
const _AET = "AnalysisEndTime";
const _AEd = "AddEntries";
const _AF = "AddressFamily";
const _AFn = "AnalysisFindings";
const _AGI = "AccessGroupId";
const _AGLBA = "AddGatewayLoadBalancerArns";
const _AH = "AllocateHosts";
const _AI = "AssetIds";
const _AIA = "AssignIpv6Addresses";
const _AIAC = "AvailableIpAddressCount";
const _AIAOC = "AssignIpv6AddressOnCreation";
const _AIAs = "AssignedIpv6Addresses";
const _AIB = "AssociateIpamByoasn";
const _AIC = "AvailableInstanceCapacity";
const _AICv = "AvailableInstanceCount";
const _AIEW = "AssociateInstanceEventWindow";
const _AIG = "AttachInternetGateway";
const _AIIP = "AssociateIamInstanceProfile";
const _AIP = "AssignedIpv6Prefixes";
const _AIPC = "AllocateIpamPoolCidr";
const _AIPs = "AssignedIpv4Prefixes";
const _AIRD = "AssociateIpamResourceDiscovery";
const _AISS = "AllowedImagesSettingsState";
const _AIT = "AllowedInstanceTypes";
const _AIc = "ActiveInstances";
const _AIcc = "AccountId";
const _AId = "AdditionalInfo";
const _AIl = "AllocationId";
const _AIll = "AllocationIds";
const _AIm = "AmiId";
const _AIs = "AssociationIds";
const _AIss = "AssociationId";
const _AIsse = "AssetId";
const _AIt = "AttachmentId";
const _AIth = "AthenaIntegrations";
const _AIu = "AutoImport";
const _AL = "AccessLogs";
const _ALI = "AmiLaunchIndex";
const _ALc = "AccountLevel";
const _AM = "AcceleratorManufacturers";
const _AMIT = "AllowsMultipleInstanceTypes";
const _AMNL = "AllocationMinNetmaskLength";
const _AMNLl = "AllocationMaxNetmaskLength";
const _AMS = "ApplianceModeSupport";
const _AN = "AttributeNames";
const _ANGA = "AssociateNatGatewayAddress";
const _ANI = "AttachNetworkInterface";
const _ANLBA = "AddNetworkLoadBalancerArns";
const _ANS = "AddNetworkServices";
const _ANc = "AcceleratorNames";
const _ANt = "AttributeName";
const _AO = "AuthenticationOptions";
const _AOI = "AddressOwnerId";
const _AOR = "AddOperatingRegions";
const _AOUE = "AddOrganizationalUnitExclusions";
const _AP = "AutoPlacement";
const _APCO = "AccepterPeeringConnectionOptions";
const _APH = "AlternatePathHints";
const _APIA = "AssignPrivateIpAddresses";
const _APIAs = "AssociatePublicIpAddress";
const _APIAss = "AssignedPrivateIpAddresses";
const _APICB = "AmazonProvidedIpv6CidrBlock";
const _APM = "ApplyPendingMaintenance";
const _APNGA = "AssignPrivateNatGatewayAddress";
const _APd = "AddedPrincipals";
const _APl = "AllowedPrincipals";
const _APs = "AsPaths";
const _AR = "AllowReassignment";
const _ARA = "AssociatedRoleArn";
const _ARAd = "AdditionalRoutesAvailable";
const _ARAs = "AssociatedResourceAccessibility";
const _ARAss = "AssociatedResourceArn";
const _ARC = "AcceptedRouteCount";
const _ARIEQ = "AcceptReservedInstancesExchangeQuote";
const _ARP = "AreRoutesPersisted";
const _ARS = "AssociateRouteServer";
const _ARSu = "AutoRecoverySupported";
const _ART = "AssociateRouteTable";
const _ARTI = "AddRouteTableIds";
const _ARTl = "AllocationResourceTags";
const _ARc = "AcceptanceRequired";
const _ARcl = "AclRule";
const _ARd = "AddressRegion";
const _ARl = "AllowReassociation";
const _ARll = "AllRegions";
const _ARs = "AssociatedResource";
const _ARss = "AssociatedRoles";
const _ARu = "AutoRecovery";
const _ARut = "AuthorizationRules";
const _ARw = "AwsRegion";
const _AS = "AllocationStrategy";
const _ASA = "AmazonSideAsn";
const _ASCB = "AssociateSubnetCidrBlock";
const _ASGE = "AuthorizeSecurityGroupEgress";
const _ASGI = "AuthorizeSecurityGroupIngress";
const _ASGId = "AddSecurityGroupIds";
const _ASGTCVTN = "ApplySecurityGroupsToClientVpnTargetNetwork";
const _ASGV = "AssociateSecurityGroupVpc";
const _ASI = "AddSubnetIds";
const _ASIAT = "AddSupportedIpAddressTypes";
const _ASR = "AddSupportedRegions";
const _ASS = "AmdSevSnp";
const _AST = "AnalysisStartTime";
const _ASTB = "AnalysisStartTimeBegin";
const _ASTE = "AnalysisStartTimeEnd";
const _ASc = "ActivityStatus";
const _ASn = "AnalysisStatus";
const _ASs = "AssociationState";
const _ASss = "AssociationStatus";
const _ASt = "AttributeSummaries";
const _AStt = "AttachmentStatuses";
const _ASw = "AwsService";
const _AT = "AssociationTarget";
const _ATGAI = "AccepterTransitGatewayAttachmentId";
const _ATGCB = "AddTransitGatewayCidrBlocks";
const _ATGMD = "AssociateTransitGatewayMulticastDomain";
const _ATGMDA = "AcceptTransitGatewayMulticastDomainAssociations";
const _ATGPA = "AcceptTransitGatewayPeeringAttachment";
const _ATGPT = "AssociateTransitGatewayPolicyTable";
const _ATGRT = "AssociateTransitGatewayRouteTable";
const _ATGVA = "AcceptTransitGatewayVpcAttachment";
const _ATI = "AssociateTrunkInterface";
const _ATIc = "AccepterTgwInfo";
const _ATMMB = "AcceleratorTotalMemoryMiB";
const _ATN = "AssociatedTargetNetworks";
const _ATS = "AddressTransferStatus";
const _ATc = "AcceleratorTypes";
const _ATd = "AddressingType";
const _ATdd = "AddressTransfer";
const _ATddr = "AddressTransfers";
const _ATddre = "AddressType";
const _ATl = "AllocationType";
const _ATll = "AllocationTime";
const _ATr = "ArchitectureTypes";
const _ATt = "AttachmentType";
const _ATtt = "AttachTime";
const _ATtta = "AttachedTo";
const _AV = "AttachVolume";
const _AVATP = "AttachVerifiedAccessTrustProvider";
const _AVC = "AvailableVCpus";
const _AVCB = "AssociateVpcCidrBlock";
const _AVEC = "AcceptVpcEndpointConnections";
const _AVG = "AttachVpnGateway";
const _AVI = "AccepterVpcInfo";
const _AVPC = "AcceptVpcPeeringConnection";
const _AVt = "AttributeValues";
const _AVtt = "AttributeValue";
const _AWSAKI = "AWSAccessKeyId";
const _AZ = "AvailabilityZone";
const _AZG = "AvailabilityZoneGroup";
const _AZI = "AvailabilityZoneId";
const _AZv = "AvailabilityZones";
const _Ac = "Accept";
const _Acc = "Accelerators";
const _Acl = "Acl";
const _Act = "Active";
const _Acti = "Actions";
const _Ad = "Address";
const _Add = "Add";
const _Addr = "Addresses";
const _Af = "Affinity";
const _Am = "Amount";
const _Ar = "Arn";
const _Arc = "Architecture";
const _As = "Asn";
const _Ass = "Associations";
const _Asso = "Association";
const _At = "Attribute";
const _Att = "Attachment";
const _Atta = "Attachments";
const _B = "Bucket";
const _BA = "BgpAsn";
const _BAE = "BgpAsnExtended";
const _BBIG = "BaselineBandwidthInGbps";
const _BBIM = "BaselineBandwidthInMbps";
const _BC = "ByoipCidr";
const _BCg = "BgpConfigurations";
const _BCy = "ByoipCidrs";
const _BCyt = "BytesConverted";
const _BDM = "BlockDeviceMappings";
const _BDMl = "BlockDurationMinutes";
const _BEBM = "BaselineEbsBandwidthMbps";
const _BEDN = "BaseEndpointDnsNames";
const _BI = "BundleInstance";
const _BII = "BranchInterfaceId";
const _BIa = "BaselineIops";
const _BIu = "BundleId";
const _BIun = "BundleIds";
const _BM = "BootMode";
const _BMa = "BareMetal";
const _BN = "BucketName";
const _BO = "BgpOptions";
const _BOu = "BucketOwner";
const _BP = "BurstablePerformance";
const _BPAS = "BlockPublicAccessStates";
const _BPF = "BaselinePerformanceFactors";
const _BPS = "BurstablePerformanceSupported";
const _BPi = "BillingProducts";
const _BS = "BgpStatus";
const _BSf = "BfdStatus";
const _BT = "BannerText";
const _BTE = "BundleTaskError";
const _BTIMB = "BaselineThroughputInMBps";
const _BTu = "BundleTask";
const _BTun = "BundleTasks";
const _BW = "BandwidthWeighting";
const _BWa = "BandwidthWeightings";
const _Bl = "Blackhole";
const _By = "Bytes";
const _Byo = "Byoasn";
const _Byoa = "Byoasns";
const _C = "Cidr";
const _CA = "CertificateArn";
const _CAC = "CidrAuthorizationContext";
const _CADNL = "ClearAllocationDefaultNetmaskLength";
const _CAU = "CoipAddressUsages";
const _CAa = "CapacityAllocations";
const _CAo = "ComponentArn";
const _CAom = "ComponentAccount";
const _CAr = "CreatedAt";
const _CB = "CidrBlock";
const _CBA = "CidrBlockAssociation";
const _CBAS = "CidrBlockAssociationSet";
const _CBDH = "CapacityBlockDurationHours";
const _CBDM = "CapacityBlockDurationMinutes";
const _CBE = "CapacityBlockExtensions";
const _CBEDH = "CapacityBlockExtensionDurationHours";
const _CBEED = "CapacityBlockExtensionEndDate";
const _CBEO = "CapacityBlockExtensionOfferings";
const _CBEOI = "CapacityBlockExtensionOfferingId";
const _CBEPD = "CapacityBlockExtensionPurchaseDate";
const _CBES = "CapacityBlockExtensionStatus";
const _CBESD = "CapacityBlockExtensionStartDate";
const _CBO = "CapacityBlockOfferings";
const _CBOI = "CapacityBlockOfferingId";
const _CBS = "CidrBlockState";
const _CBSi = "CidrBlockSet";
const _CBT = "CancelBundleTask";
const _CBr = "CreatedBy";
const _CC = "CoreCount";
const _CCB = "ClientCidrBlock";
const _CCC = "CreateCoipCidr";
const _CCG = "CreateCarrierGateway";
const _CCGr = "CreateCustomerGateway";
const _CCO = "ClientConnectOptions";
const _CCP = "CreateCoipPool";
const _CCR = "CancelCapacityReservation";
const _CCRBS = "CreateCapacityReservationBySplitting";
const _CCRF = "CancelCapacityReservationFleets";
const _CCRFE = "CancelCapacityReservationFleetError";
const _CCRFr = "CreateCapacityReservationFleet";
const _CCRr = "CreateCapacityReservation";
const _CCT = "CancelConversionTask";
const _CCVE = "CreateClientVpnEndpoint";
const _CCVR = "CreateClientVpnRoute";
const _CCl = "ClientConfiguration";
const _CCo = "CoipCidr";
const _CCp = "CpuCredits";
const _CCu = "CurrencyCode";
const _CD = "CommitmentDuration";
const _CDH = "CapacityDurationHours";
const _CDM = "CompletionDurationMinutes";
const _CDO = "CreateDhcpOptions";
const _CDPR = "CancelDeclarativePoliciesReport";
const _CDS = "CreateDefaultSubnet";
const _CDSDA = "ConfigDeliveryS3DestinationArn";
const _CDSu = "CustomDnsServers";
const _CDV = "CreateDefaultVpc";
const _CDl = "ClientData";
const _CDr = "CreateDate";
const _CDre = "CreationDate";
const _CDrea = "CreatedDate";
const _CE = "CronExpression";
const _CECSD = "CidrEndpointsCustomSubDomain";
const _CED = "CommitmentEndDate";
const _CEOIG = "CreateEgressOnlyInternetGateway";
const _CET = "CancelExportTask";
const _CETo = "ConnectionEstablishedTime";
const _CETon = "ConnectionEndTime";
const _CEo = "ConnectionEvents";
const _CF = "CreateFleet";
const _CFI = "CopyFpgaImage";
const _CFIr = "CreateFpgaImage";
const _CFL = "CreateFlowLogs";
const _CFS = "CurrentFleetState";
const _CFo = "ContainerFormat";
const _CG = "CarrierGateway";
const _CGC = "CustomerGatewayConfiguration";
const _CGI = "CarrierGatewayId";
const _CGIa = "CarrierGatewayIds";
const _CGIu = "CustomerGatewayId";
const _CGIus = "CustomerGatewayIds";
const _CGa = "CarrierGateways";
const _CGu = "CustomerGateway";
const _CGur = "CurrentGeneration";
const _CGus = "CustomerGateways";
const _CI = "CopyImage";
const _CIBM = "CurrentInstanceBootMode";
const _CIC = "CommittedInstanceCount";
const _CICE = "CreateInstanceConnectEndpoint";
const _CIERVT = "CreateIpamExternalResourceVerificationToken";
const _CIET = "CreateInstanceExportTask";
const _CIEW = "CreateInstanceEventWindow";
const _CIG = "CreateInternetGateway";
const _CILP = "CancelImageLaunchPermission";
const _CIP = "CreateIpamPool";
const _CIRD = "CreateIpamResourceDiscovery";
const _CIS = "CreateIpamScope";
const _CISI = "CurrentIpamScopeId";
const _CIT = "CancelImportTask";
const _CITo = "CopyImageTags";
const _CIa = "CarrierIp";
const _CIi = "CidrIp";
const _CIid = "CidrIpv6";
const _CIidr = "CidrIpv4";
const _CIl = "ClientId";
const _CIli = "ClientIp";
const _CIo = "ConnectionId";
const _CIom = "ComponentId";
const _CIomm = "CommitmentInfo";
const _CIop = "CoIp";
const _CIor = "CoreInfo";
const _CIr = "CreateImage";
const _CIre = "CreateIpam";
const _CKP = "CreateKeyPair";
const _CLB = "ClassicLoadBalancers";
const _CLBC = "ClassicLoadBalancersConfig";
const _CLBL = "ClassicLoadBalancerListener";
const _CLBO = "ClientLoginBannerOptions";
const _CLDS = "ClassicLinkDnsSupported";
const _CLE = "ClassicLinkEnabled";
const _CLG = "CloudwatchLogGroup";
const _CLGR = "CreateLocalGatewayRoute";
const _CLGRT = "CreateLocalGatewayRouteTable";
const _CLGRTVA = "CreateLocalGatewayRouteTableVpcAssociation";
const _CLGRTVIGA = "CreateLocalGatewayRouteTableVirtualInterfaceGroupAssociation";
const _CLO = "ConnectionLogOptions";
const _CLS = "CloudwatchLogStream";
const _CLT = "CreateLaunchTemplate";
const _CLTV = "CreateLaunchTemplateVersion";
const _CM = "CpuManufacturers";
const _CMKE = "CustomerManagedKeyEnabled";
const _CMPL = "CreateManagedPrefixList";
const _CN = "CommonName";
const _CNA = "CreateNetworkAcl";
const _CNAA = "CoreNetworkAttachmentArn";
const _CNAE = "CreateNetworkAclEntry";
const _CNAo = "CoreNetworkArn";
const _CNAon = "ConnectionNotificationArn";
const _CNG = "CreateNatGateway";
const _CNI = "CreateNetworkInterface";
const _CNIAS = "CreateNetworkInsightsAccessScope";
const _CNIP = "CreateNetworkInsightsPath";
const _CNIPr = "CreateNetworkInterfacePermission";
const _CNIo = "ConnectionNotificationIds";
const _CNIon = "ConnectionNotificationId";
const _CNIor = "CoreNetworkId";
const _CNS = "ConnectionNotificationState";
const _CNSo = "ConnectionNotificationSet";
const _CNT = "ConnectionNotificationType";
const _CNo = "ConnectionNotification";
const _CO = "CidrOptions";
const _COI = "CustomerOwnedIp";
const _COIP = "CustomerOwnedIpv4Pool";
const _COP = "CoolOffPeriod";
const _COPEO = "CoolOffPeriodExpiresOn";
const _COp = "CpuOptions";
const _CP = "CoipPool";
const _CPC = "ConnectPeerConfiguration";
const _CPG = "CreatePlacementGroup";
const _CPI = "ConfirmProductInstance";
const _CPIP = "CreatePublicIpv4Pool";
const _CPIo = "CoipPoolId";
const _CPo = "CoipPools";
const _CR = "CreateRoute";
const _CRA = "CapacityReservationArn";
const _CRBR = "CapacityReservationBillingRequests";
const _CRCC = "ClientRootCertificateChain";
const _CRCCA = "ClientRootCertificateChainArn";
const _CRF = "CapacityReservationFleets";
const _CRFA = "CapacityReservationFleetArn";
const _CRFI = "CapacityReservationFleetIds";
const _CRFIa = "CapacityReservationFleetId";
const _CRG = "CapacityReservationGroups";
const _CRI = "CapacityReservationId";
const _CRIL = "CancelReservedInstancesListing";
const _CRILr = "CreateReservedInstancesListing";
const _CRIT = "CreateRestoreImageTask";
const _CRIa = "CapacityReservationIds";
const _CRIap = "CapacityReservationInfo";
const _CRL = "CertificateRevocationList";
const _CRO = "CapacityReservationOptions";
const _CRP = "CapacityReservationPreference";
const _CRRGA = "CapacityReservationResourceGroupArn";
const _CRRVT = "CreateReplaceRootVolumeTask";
const _CRS = "CreateRouteServer";
const _CRSE = "CreateRouteServerEndpoint";
const _CRSP = "CreateRouteServerPeer";
const _CRSa = "CapacityReservationSpecification";
const _CRT = "CreateRouteTable";
const _CRTa = "CapacityReservationTarget";
const _CRa = "CancelReason";
const _CRap = "CapacityRebalance";
const _CRapa = "CapacityReservation";
const _CRapac = "CapacityReservations";
const _CRo = "ComponentRegion";
const _CS = "CopySnapshot";
const _CSBN = "CertificateS3BucketName";
const _CSCR = "CreateSubnetCidrReservation";
const _CSDS = "CreateSpotDatafeedSubscription";
const _CSFR = "CancelSpotFleetRequests";
const _CSFRS = "CurrentSpotFleetRequestState";
const _CSG = "CreateSecurityGroup";
const _CSIR = "CancelSpotInstanceRequests";
const _CSIRa = "CancelledSpotInstanceRequests";
const _CSIT = "CreateStoreImageTask";
const _CSOK = "CertificateS3ObjectKey";
const _CSl = "ClientSecret";
const _CSo = "ComplianceStatus";
const _CSon = "ConnectionStatuses";
const _CSr = "CreateSnapshot";
const _CSre = "CreateSnapshots";
const _CSrea = "CreateSubnet";
const _CSred = "CreditSpecification";
const _CSu = "CurrentState";
const _CSur = "CurrentStatus";
const _CT = "CreateTags";
const _CTC = "ConnectionTrackingConfiguration";
const _CTFS = "CopyTagsFromSource";
const _CTG = "CreateTransitGateway";
const _CTGC = "CreateTransitGatewayConnect";
const _CTGCP = "CreateTransitGatewayConnectPeer";
const _CTGMD = "CreateTransitGatewayMulticastDomain";
const _CTGPA = "CreateTransitGatewayPeeringAttachment";
const _CTGPLR = "CreateTransitGatewayPrefixListReference";
const _CTGPT = "CreateTransitGatewayPolicyTable";
const _CTGR = "CreateTransitGatewayRoute";
const _CTGRT = "CreateTransitGatewayRouteTable";
const _CTGRTA = "CreateTransitGatewayRouteTableAnnouncement";
const _CTGVA = "CreateTransitGatewayVpcAttachment";
const _CTI = "ConversionTaskId";
const _CTIo = "ConversionTaskIds";
const _CTMF = "CreateTrafficMirrorFilter";
const _CTMFR = "CreateTrafficMirrorFilterRule";
const _CTMS = "CreateTrafficMirrorSession";
const _CTMT = "CreateTrafficMirrorTarget";
const _CTS = "ConnectionTrackingSpecification";
const _CTl = "ClientToken";
const _CTo = "ConnectivityType";
const _CTom = "CompleteTime";
const _CTomp = "CompletionTime";
const _CTon = "ConversionTasks";
const _CTonv = "ConversionTask";
const _CTr = "CreateTime";
const _CTre = "CreationTime";
const _CTrea = "CreationTimestamp";
const _CV = "CreateVolume";
const _CVAE = "CreateVerifiedAccessEndpoint";
const _CVAG = "CreateVerifiedAccessGroup";
const _CVAI = "CreateVerifiedAccessInstance";
const _CVATP = "CreateVerifiedAccessTrustProvider";
const _CVBPAE = "CreateVpcBlockPublicAccessExclusion";
const _CVC = "CreateVpnConnection";
const _CVCR = "CreateVpnConnectionRoute";
const _CVE = "CreateVpcEndpoint";
const _CVECN = "CreateVpcEndpointConnectionNotification";
const _CVEI = "ClientVpnEndpointId";
const _CVEIl = "ClientVpnEndpointIds";
const _CVESC = "CreateVpcEndpointServiceConfiguration";
const _CVEl = "ClientVpnEndpoints";
const _CVG = "CreateVpnGateway";
const _CVP = "CreateVolumePermission";
const _CVPC = "CreateVpcPeeringConnection";
const _CVPr = "CreateVolumePermissions";
const _CVTN = "ClientVpnTargetNetworks";
const _CVr = "CreateVpc";
const _CVu = "CurrentVersion";
const _CWL = "CloudWatchLogs";
const _CWLO = "CloudWatchLogOptions";
const _Ca = "Cascade";
const _Cat = "Category";
const _Ch = "Checksum";
const _Ci = "Cidrs";
const _Co = "Comment";
const _Cod = "Code";
const _Com = "Component";
const _Con = "Context";
const _Conf = "Configured";
const _Confi = "Config";
const _Conn = "Connections";
const _Cor = "Cores";
const _Cou = "Count";
const _Cp = "Cpu";
const _D = "Destination";
const _DA = "DescribeAddresses";
const _DAA = "DescribeAccountAttributes";
const _DAAI = "DelegatedAdminAccountId";
const _DAAe = "DescribeAddressesAttribute";
const _DAIF = "DescribeAggregateIdFormat";
const _DAIS = "DisableAllowedImagesSettings";
const _DAIT = "DenyAllIgwTraffic";
const _DANPMS = "DescribeAwsNetworkPerformanceMetricSubscriptions";
const _DANPMSi = "DisableAwsNetworkPerformanceMetricSubscription";
const _DART = "DefaultAssociationRouteTable";
const _DAS = "DisableApiStop";
const _DAT = "DescribeAddressTransfers";
const _DATi = "DisableAddressTransfer";
const _DATis = "DisableApiTermination";
const _DAZ = "DescribeAvailabilityZones";
const _DAe = "DeprecateAt";
const _DAep = "DeprovisionedAddresses";
const _DAes = "DestinationAddresses";
const _DAest = "DestinationAddress";
const _DAesti = "DestinationArn";
const _DAi = "DisassociateAddress";
const _DBC = "DeprovisionByoipCidr";
const _DBCe = "DescribeByoipCidrs";
const _DBT = "DescribeBundleTasks";
const _DC = "DisallowedCidrs";
const _DCA = "DomainCertificateArn";
const _DCAR = "DeliverCrossAccountRole";
const _DCB = "DestinationCidrBlock";
const _DCBEH = "DescribeCapacityBlockExtensionHistory";
const _DCBEO = "DescribeCapacityBlockExtensionOfferings";
const _DCBO = "DescribeCapacityBlockOfferings";
const _DCC = "DeleteCoipCidr";
const _DCG = "DeleteCarrierGateway";
const _DCGe = "DeleteCustomerGateway";
const _DCGes = "DescribeCarrierGateways";
const _DCGesc = "DescribeCustomerGateways";
const _DCLI = "DescribeClassicLinkInstances";
const _DCLV = "DetachClassicLinkVpc";
const _DCP = "DeleteCoipPool";
const _DCPe = "DescribeCoipPools";
const _DCR = "DescribeCapacityReservations";
const _DCRBO = "DisassociateCapacityReservationBillingOwner";
const _DCRBR = "DescribeCapacityReservationBillingRequests";
const _DCRF = "DescribeCapacityReservationFleets";
const _DCRI = "DestinationCapacityReservationId";
const _DCRe = "DestinationCapacityReservation";
const _DCT = "DescribeConversionTasks";
const _DCVAR = "DescribeClientVpnAuthorizationRules";
const _DCVC = "DescribeClientVpnConnections";
const _DCVE = "DeleteClientVpnEndpoint";
const _DCVEe = "DescribeClientVpnEndpoints";
const _DCVR = "DeleteClientVpnRoute";
const _DCVRe = "DescribeClientVpnRoutes";
const _DCVTN = "DescribeClientVpnTargetNetworks";
const _DCVTNi = "DisassociateClientVpnTargetNetwork";
const _DCe = "DestinationCidr";
const _DCef = "DefaultCores";
const _DCh = "DhcpConfigurations";
const _DCi = "DiskContainers";
const _DCis = "DiskContainer";
const _DDO = "DeleteDhcpOptions";
const _DDOe = "DescribeDhcpOptions";
const _DDPR = "DescribeDeclarativePoliciesReports";
const _DE = "DnsEntries";
const _DECIR = "DisassociateEnclaveCertificateIamRole";
const _DEEBD = "DisableEbsEncryptionByDefault";
const _DEG = "DescribeElasticGpus";
const _DEIT = "DescribeExportImageTasks";
const _DEKI = "DataEncryptionKeyId";
const _DEOIG = "DeleteEgressOnlyInternetGateway";
const _DEOIGe = "DescribeEgressOnlyInternetGateways";
const _DET = "DescribeExportTasks";
const _DEn = "DnsEntry";
const _DF = "DeleteFleets";
const _DFA = "DefaultForAz";
const _DFH = "DescribeFleetHistory";
const _DFI = "DeleteFpgaImage";
const _DFIA = "DescribeFpgaImageAttribute";
const _DFIe = "DescribeFleetInstances";
const _DFIes = "DescribeFpgaImages";
const _DFL = "DeleteFlowLogs";
const _DFLI = "DescribeFastLaunchImages";
const _DFLe = "DescribeFlowLogs";
const _DFLi = "DisableFastLaunch";
const _DFSR = "DescribeFastSnapshotRestores";
const _DFSRi = "DisableFastSnapshotRestores";
const _DFe = "DescribeFleets";
const _DH = "DescribeHosts";
const _DHI = "DedicatedHostIds";
const _DHR = "DescribeHostReservations";
const _DHRO = "DescribeHostReservationOfferings";
const _DHS = "DedicatedHostsSupported";
const _DI = "DeleteIpam";
const _DIA = "DescribeImageAttribute";
const _DIAe = "DescribeInstanceAttribute";
const _DIB = "DeprovisionIpamByoasn";
const _DIBPA = "DisableImageBlockPublicAccess";
const _DIBe = "DescribeIpamByoasn";
const _DIBi = "DisassociateIpamByoasn";
const _DICB = "DestinationIpv6CidrBlock";
const _DICE = "DeleteInstanceConnectEndpoint";
const _DICEe = "DescribeInstanceConnectEndpoints";
const _DICS = "DescribeInstanceCreditSpecifications";
const _DID = "DisableImageDeprecation";
const _DIDP = "DisableImageDeregistrationProtection";
const _DIENA = "DeregisterInstanceEventNotificationAttributes";
const _DIENAe = "DescribeInstanceEventNotificationAttributes";
const _DIERVT = "DeleteIpamExternalResourceVerificationToken";
const _DIERVTe = "DescribeIpamExternalResourceVerificationTokens";
const _DIEW = "DeleteInstanceEventWindow";
const _DIEWe = "DescribeInstanceEventWindows";
const _DIEWi = "DisassociateInstanceEventWindow";
const _DIF = "DescribeIdFormat";
const _DIFi = "DiskImageFormat";
const _DIG = "DeleteInternetGateway";
const _DIGe = "DescribeInternetGateways";
const _DIGet = "DetachInternetGateway";
const _DIIF = "DescribeIdentityIdFormat";
const _DIIM = "DescribeInstanceImageMetadata";
const _DIIP = "DisassociateIamInstanceProfile";
const _DIIPA = "DescribeIamInstanceProfileAssociations";
const _DIIT = "DescribeImportImageTasks";
const _DIOAA = "DisableIpamOrganizationAdminAccount";
const _DIP = "DeleteIpamPool";
const _DIPC = "DeprovisionIpamPoolCidr";
const _DIPe = "DescribeIpamPools";
const _DIPes = "DescribeIpv6Pools";
const _DIRD = "DeleteIpamResourceDiscovery";
const _DIRDA = "DescribeIpamResourceDiscoveryAssociations";
const _DIRDe = "DescribeIpamResourceDiscoveries";
const _DIRDi = "DisassociateIpamResourceDiscovery";
const _DIS = "DeleteIpamScope";
const _DISI = "DestinationIpamScopeId";
const _DIST = "DescribeImportSnapshotTasks";
const _DISe = "DescribeInstanceStatus";
const _DISes = "DescribeIpamScopes";
const _DISi = "DiskImageSize";
const _DIT = "DescribeInstanceTopology";
const _DITO = "DescribeInstanceTypeOfferings";
const _DITe = "DescribeInstanceTypes";
const _DIe = "DeregisterImage";
const _DIes = "DescribeImages";
const _DIesc = "DescribeInstances";
const _DIescr = "DescribeIpams";
const _DIest = "DestinationIp";
const _DIev = "DeviceIndex";
const _DIevi = "DeviceId";
const _DIi = "DisableImage";
const _DIir = "DirectoryId";
const _DIis = "DiskImages";
const _DKP = "DeleteKeyPair";
const _DKPe = "DescribeKeyPairs";
const _DLADI = "DisableLniAtDeviceIndex";
const _DLEM = "DeliverLogsErrorMessage";
const _DLG = "DescribeLocalGateways";
const _DLGR = "DeleteLocalGatewayRoute";
const _DLGRT = "DeleteLocalGatewayRouteTable";
const _DLGRTVA = "DeleteLocalGatewayRouteTableVpcAssociation";
const _DLGRTVAe = "DescribeLocalGatewayRouteTableVpcAssociations";
const _DLGRTVIGA = "DeleteLocalGatewayRouteTableVirtualInterfaceGroupAssociation";
const _DLGRTVIGAe = "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations";
const _DLGRTe = "DescribeLocalGatewayRouteTables";
const _DLGVI = "DescribeLocalGatewayVirtualInterfaces";
const _DLGVIG = "DescribeLocalGatewayVirtualInterfaceGroups";
const _DLPA = "DeliverLogsPermissionArn";
const _DLS = "DescribeLockedSnapshots";
const _DLSe = "DeliverLogsStatus";
const _DLT = "DeleteLaunchTemplate";
const _DLTV = "DeleteLaunchTemplateVersions";
const _DLTVe = "DescribeLaunchTemplateVersions";
const _DLTe = "DescribeLaunchTemplates";
const _DMA = "DescribeMovingAddresses";
const _DMGM = "DeregisteredMulticastGroupMembers";
const _DMGS = "DeregisteredMulticastGroupSources";
const _DMH = "DescribeMacHosts";
const _DMPL = "DeleteManagedPrefixList";
const _DMPLe = "DescribeManagedPrefixLists";
const _DN = "DeviceName";
const _DNA = "DeleteNetworkAcl";
const _DNAE = "DeleteNetworkAclEntry";
const _DNAe = "DescribeNetworkAcls";
const _DNCI = "DefaultNetworkCardIndex";
const _DNG = "DeleteNatGateway";
const _DNGA = "DisassociateNatGatewayAddress";
const _DNGe = "DescribeNatGateways";
const _DNI = "DeleteNetworkInterface";
const _DNIA = "DeleteNetworkInsightsAnalysis";
const _DNIAS = "DeleteNetworkInsightsAccessScope";
const _DNIASA = "DeleteNetworkInsightsAccessScopeAnalysis";
const _DNIASAe = "DescribeNetworkInsightsAccessScopeAnalyses";
const _DNIASe = "DescribeNetworkInsightsAccessScopes";
const _DNIAe = "DescribeNetworkInsightsAnalyses";
const _DNIAes = "DescribeNetworkInterfaceAttribute";
const _DNII = "DeregisteredNetworkInterfaceIds";
const _DNIP = "DeleteNetworkInsightsPath";
const _DNIPe = "DeleteNetworkInterfacePermission";
const _DNIPes = "DescribeNetworkInsightsPaths";
const _DNIPesc = "DescribeNetworkInterfacePermissions";
const _DNIe = "DescribeNetworkInterfaces";
const _DNIet = "DetachNetworkInterface";
const _DNn = "DnsName";
const _DNo = "DomainName";
const _DO = "DestinationOptions";
const _DOA = "DestinationOutpostArn";
const _DOI = "DhcpOptionsId";
const _DOIh = "DhcpOptionsIds";
const _DOST = "DisconnectOnSessionTimeout";
const _DOT = "DeleteOnTermination";
const _DOe = "DeviceOptions";
const _DOh = "DhcpOptions";
const _DOn = "DnsOptions";
const _DP = "DeliveryPreference";
const _DPDTA = "DPDTimeoutAction";
const _DPDTS = "DPDTimeoutSeconds";
const _DPG = "DeletePlacementGroup";
const _DPGe = "DescribePlacementGroups";
const _DPIF = "DescribePrincipalIdFormat";
const _DPIP = "DeletePublicIpv4Pool";
const _DPIPC = "DeprovisionPublicIpv4PoolCidr";
const _DPIPe = "DescribePublicIpv4Pools";
const _DPL = "DescribePrefixLists";
const _DPLI = "DestinationPrefixListId";
const _DPLe = "DestinationPrefixLists";
const _DPR = "DestinationPortRange";
const _DPRT = "DefaultPropagationRouteTable";
const _DPRe = "DestinationPortRanges";
const _DPe = "DestinationPort";
const _DPer = "DeregistrationProtection";
const _DPes = "DestinationPorts";
const _DQ = "DataQueries";
const _DQRI = "DeleteQueuedReservedInstances";
const _DR = "DeleteRoute";
const _DRDAI = "DefaultResourceDiscoveryAssociationId";
const _DRDI = "DefaultResourceDiscoveryId";
const _DRI = "DescribeReservedInstances";
const _DRIL = "DescribeReservedInstancesListings";
const _DRIM = "DescribeReservedInstancesModifications";
const _DRIO = "DescribeReservedInstancesOfferings";
const _DRIT = "DnsRecordIpType";
const _DRRV = "DeleteReplacedRootVolume";
const _DRRVT = "DescribeReplaceRootVolumeTasks";
const _DRS = "DeleteRouteServer";
const _DRSE = "DeleteRouteServerEndpoint";
const _DRSEe = "DescribeRouteServerEndpoints";
const _DRSP = "DeleteRouteServerPeer";
const _DRSPe = "DescribeRouteServerPeers";
const _DRSPi = "DisableRouteServerPropagation";
const _DRSa = "DataRetentionSupport";
const _DRSe = "DescribeRouteServers";
const _DRSi = "DisassociateRouteServer";
const _DRT = "DeleteRouteTable";
const _DRTA = "DefaultRouteTableAssociation";
const _DRTP = "DefaultRouteTablePropagation";
const _DRTe = "DescribeRouteTables";
const _DRTi = "DisassociateRouteTable";
const _DRa = "DataResponses";
const _DRe = "DescribeRegions";
const _DRes = "DestinationRegion";
const _DRi = "DiscoveryRegion";
const _DRr = "DryRun";
const _DRy = "DynamicRouting";
const _DS = "DeleteSnapshot";
const _DSA = "DescribeSnapshotAttribute";
const _DSBPA = "DisableSnapshotBlockPublicAccess";
const _DSCA = "DisableSerialConsoleAccess";
const _DSCB = "DisassociateSubnetCidrBlock";
const _DSCR = "DeleteSubnetCidrReservation";
const _DSCRe = "DeletedSubnetCidrReservation";
const _DSDS = "DeleteSpotDatafeedSubscription";
const _DSDSe = "DescribeSpotDatafeedSubscription";
const _DSFI = "DescribeSpotFleetInstances";
const _DSFR = "DescribeSpotFleetRequests";
const _DSFRH = "DescribeSpotFleetRequestHistory";
const _DSG = "DeleteSecurityGroup";
const _DSGR = "DescribeSecurityGroupReferences";
const _DSGRe = "DescribeSecurityGroupRules";
const _DSGV = "DisassociateSecurityGroupVpc";
const _DSGVA = "DescribeSecurityGroupVpcAssociations";
const _DSGe = "DescribeSecurityGroups";
const _DSI = "DescribeScheduledInstances";
const _DSIA = "DescribeScheduledInstanceAvailability";
const _DSIR = "DescribeSpotInstanceRequests";
const _DSIT = "DescribeStoreImageTasks";
const _DSPH = "DescribeSpotPriceHistory";
const _DSSG = "DescribeStaleSecurityGroups";
const _DSTS = "DescribeSnapshotTierStatus";
const _DSe = "DeleteSubnet";
const _DSel = "DeliveryStream";
const _DSeli = "DeliveryStatus";
const _DSes = "DescribeSnapshots";
const _DSesc = "DescribeSubnets";
const _DSn = "DnsServers";
const _DSns = "DnsSupport";
const _DT = "DeleteTags";
const _DTA = "DpdTimeoutAction";
const _DTCT = "DefaultTargetCapacityType";
const _DTG = "DeleteTransitGateway";
const _DTGA = "DescribeTransitGatewayAttachments";
const _DTGC = "DeleteTransitGatewayConnect";
const _DTGCP = "DeleteTransitGatewayConnectPeer";
const _DTGCPe = "DescribeTransitGatewayConnectPeers";
const _DTGCe = "DescribeTransitGatewayConnects";
const _DTGMD = "DeleteTransitGatewayMulticastDomain";
const _DTGMDe = "DescribeTransitGatewayMulticastDomains";
const _DTGMDi = "DisassociateTransitGatewayMulticastDomain";
const _DTGMGM = "DeregisterTransitGatewayMulticastGroupMembers";
const _DTGMGS = "DeregisterTransitGatewayMulticastGroupSources";
const _DTGPA = "DeleteTransitGatewayPeeringAttachment";
const _DTGPAe = "DescribeTransitGatewayPeeringAttachments";
const _DTGPLR = "DeleteTransitGatewayPrefixListReference";
const _DTGPT = "DeleteTransitGatewayPolicyTable";
const _DTGPTe = "DescribeTransitGatewayPolicyTables";
const _DTGPTi = "DisassociateTransitGatewayPolicyTable";
const _DTGR = "DeleteTransitGatewayRoute";
const _DTGRT = "DeleteTransitGatewayRouteTable";
const _DTGRTA = "DeleteTransitGatewayRouteTableAnnouncement";
const _DTGRTAe = "DescribeTransitGatewayRouteTableAnnouncements";
const _DTGRTP = "DisableTransitGatewayRouteTablePropagation";
const _DTGRTe = "DescribeTransitGatewayRouteTables";
const _DTGRTi = "DisassociateTransitGatewayRouteTable";
const _DTGVA = "DeleteTransitGatewayVpcAttachment";
const _DTGVAe = "DescribeTransitGatewayVpcAttachments";
const _DTGe = "DescribeTransitGateways";
const _DTI = "DisassociateTrunkInterface";
const _DTIA = "DescribeTrunkInterfaceAssociations";
const _DTMF = "DeleteTrafficMirrorFilter";
const _DTMFR = "DeleteTrafficMirrorFilterRule";
const _DTMFRe = "DescribeTrafficMirrorFilterRules";
const _DTMFe = "DescribeTrafficMirrorFilters";
const _DTMS = "DeleteTrafficMirrorSession";
const _DTMSe = "DescribeTrafficMirrorSessions";
const _DTMT = "DeleteTrafficMirrorTarget";
const _DTMTe = "DescribeTrafficMirrorTargets";
const _DTP = "DeviceTrustProviders";
const _DTPC = "DefaultThreadsPerCore";
const _DTPT = "DeviceTrustProviderType";
const _DTS = "DpdTimeoutSeconds";
const _DTe = "DescribeTags";
const _DTel = "DeletionTime";
const _DTele = "DeleteTime";
const _DTelet = "DeletionTimestamp";
const _DTep = "DeprecationTime";
const _DTi = "DisablingTime";
const _DTis = "DisabledTime";
const _DV = "DeleteVolume";
const _DVA = "DescribeVolumeAttribute";
const _DVAE = "DeleteVerifiedAccessEndpoint";
const _DVAEe = "DescribeVerifiedAccessEndpoints";
const _DVAG = "DeleteVerifiedAccessGroup";
const _DVAGe = "DescribeVerifiedAccessGroups";
const _DVAI = "DeleteVerifiedAccessInstance";
const _DVAILC = "DescribeVerifiedAccessInstanceLoggingConfigurations";
const _DVAIe = "DescribeVerifiedAccessInstances";
const _DVATP = "DeleteVerifiedAccessTrustProvider";
const _DVATPe = "DescribeVerifiedAccessTrustProviders";
const _DVATPet = "DetachVerifiedAccessTrustProvider";
const _DVAe = "DescribeVpcAttribute";
const _DVBPAE = "DeleteVpcBlockPublicAccessExclusion";
const _DVBPAEe = "DescribeVpcBlockPublicAccessExclusions";
const _DVBPAO = "DescribeVpcBlockPublicAccessOptions";
const _DVC = "DeleteVpnConnection";
const _DVCB = "DisassociateVpcCidrBlock";
const _DVCL = "DescribeVpcClassicLink";
const _DVCLDS = "DescribeVpcClassicLinkDnsSupport";
const _DVCLDSi = "DisableVpcClassicLinkDnsSupport";
const _DVCLi = "DisableVpcClassicLink";
const _DVCR = "DeleteVpnConnectionRoute";
const _DVCe = "DescribeVpnConnections";
const _DVCef = "DefaultVCpus";
const _DVD = "DeviceValidationDomain";
const _DVE = "DeleteVpcEndpoints";
const _DVEA = "DescribeVpcEndpointAssociations";
const _DVEC = "DescribeVpcEndpointConnections";
const _DVECN = "DeleteVpcEndpointConnectionNotifications";
const _DVECNe = "DescribeVpcEndpointConnectionNotifications";
const _DVES = "DescribeVpcEndpointServices";
const _DVESC = "DeleteVpcEndpointServiceConfigurations";
const _DVESCe = "DescribeVpcEndpointServiceConfigurations";
const _DVESP = "DescribeVpcEndpointServicePermissions";
const _DVEe = "DescribeVpcEndpoints";
const _DVG = "DeleteVpnGateway";
const _DVGe = "DescribeVpnGateways";
const _DVGet = "DetachVpnGateway";
const _DVM = "DescribeVolumesModifications";
const _DVN = "DefaultVersionNumber";
const _DVPC = "DeleteVpcPeeringConnection";
const _DVPCe = "DescribeVpcPeeringConnections";
const _DVRP = "DisableVgwRoutePropagation";
const _DVS = "DescribeVolumeStatus";
const _DVe = "DeleteVpc";
const _DVef = "DefaultVersion";
const _DVes = "DescribeVolumes";
const _DVesc = "DescribeVpcs";
const _DVest = "DestinationVpc";
const _DVet = "DetachVolume";
const _Da = "Data";
const _De = "Description";
const _Dea = "Deadline";
const _Des = "Destinations";
const _Det = "Details";
const _Dev = "Device";
const _Di = "Direction";
const _Dis = "Disks";
const _Do = "Domain";
const _Du = "Duration";
const _E = "Ebs";
const _EA = "EnableAcceleration";
const _EAIS = "EnableAllowedImagesSettings";
const _EANPMS = "EnableAwsNetworkPerformanceMetricSubscription";
const _EAT = "EnableAddressTransfer";
const _EAn = "EniAddress";
const _EAx = "ExclusionsAllowed";
const _EB = "EgressBytes";
const _EBV = "ExcludeBootVolume";
const _EC = "ErrorCode";
const _ECTP = "ExcessCapacityTerminationPolicy";
const _ECVCC = "ExportClientVpnClientConfiguration";
const _ECVCCRL = "ExportClientVpnClientCertificateRevocationList";
const _ECn = "EncryptionControl";
const _ECx = "ExplanationCode";
const _ED = "EndDate";
const _EDH = "EnableDnsHostnames";
const _EDP = "EndpointDomainPrefix";
const _EDR = "EndDateRange";
const _EDS = "EnableDnsSupport";
const _EDT = "EndDateType";
const _EDVI = "ExcludeDataVolumeIds";
const _EDf = "EffectiveDate";
const _EDn = "EnableDns64";
const _EDnd = "EndpointDomain";
const _EDv = "EventDescription";
const _EDx = "ExpirationDate";
const _EEA = "EndpointEniAddress";
const _EEBD = "EbsEncryptionByDefault";
const _EEEBD = "EnableEbsEncryptionByDefault";
const _EEI = "EndpointEniId";
const _EFL = "EnableFastLaunch";
const _EFR = "EgressFilterRules";
const _EFSR = "EnableFastSnapshotRestores";
const _EGA = "ElasticGpuAssociations";
const _EGAI = "ElasticGpuAssociationId";
const _EGAS = "ElasticGpuAssociationState";
const _EGAT = "ElasticGpuAssociationTime";
const _EGH = "ElasticGpuHealth";
const _EGI = "ElasticGpuIds";
const _EGIl = "ElasticGpuId";
const _EGS = "ElasticGpuSpecifications";
const _EGSl = "ElasticGpuSpecification";
const _EGSla = "ElasticGpuSet";
const _EGSlas = "ElasticGpuState";
const _EGT = "ElasticGpuType";
const _EH = "EndHour";
const _EI = "EnableImage";
const _EIA = "ElasticInferenceAccelerators";
const _EIAA = "ElasticInferenceAcceleratorArn";
const _EIAAI = "ElasticInferenceAcceleratorAssociationId";
const _EIAAS = "ElasticInferenceAcceleratorAssociationState";
const _EIAAT = "ElasticInferenceAcceleratorAssociationTime";
const _EIAAl = "ElasticInferenceAcceleratorAssociations";
const _EIBPA = "EnableImageBlockPublicAccess";
const _EID = "EnableImageDeprecation";
const _EIDP = "EnableImageDeregistrationProtection";
const _EIOAA = "EnableIpamOrganizationAdminAccount";
const _EIT = "ExcludedInstanceTypes";
const _EITI = "ExportImageTaskIds";
const _EITIx = "ExportImageTaskId";
const _EITS = "EncryptionInTransitSupported";
const _EITx = "ExportImageTasks";
const _EIb = "EbsInfo";
const _EIf = "EfaInfo";
const _EIn = "EniId";
const _EIv = "EventInformation";
const _EIve = "EventId";
const _EIx = "ExportImage";
const _EIxc = "ExclusionId";
const _EIxch = "ExchangeId";
const _EIxcl = "ExclusionIds";
const _EKKI = "EncryptionKmsKeyId";
const _ELADI = "EnableLniAtDeviceIndex";
const _ELBL = "ElasticLoadBalancerListener";
const _EM = "ErrorMessage";
const _ENAUM = "EnableNetworkAddressUsageMetrics";
const _EO = "EbsOptimized";
const _EOI = "EbsOptimizedInfo";
const _EOIG = "EgressOnlyInternetGateway";
const _EOIGI = "EgressOnlyInternetGatewayId";
const _EOIGIg = "EgressOnlyInternetGatewayIds";
const _EOIGg = "EgressOnlyInternetGateways";
const _EOS = "EbsOptimizedSupport";
const _EOn = "EnclaveOptions";
const _EP = "ExcludePaths";
const _EPG = "EnablePrivateGua";
const _EPI = "EnablePrimaryIpv6";
const _EPg = "EgressPackets";
const _ERAOS = "EnableReachabilityAnalyzerOrganizationSharing";
const _ERNDAAAAR = "EnableResourceNameDnsAAAARecord";
const _ERNDAAAAROL = "EnableResourceNameDnsAAAARecordOnLaunch";
const _ERNDAR = "EnableResourceNameDnsARecord";
const _ERNDAROL = "EnableResourceNameDnsARecordOnLaunch";
const _ERSP = "EnableRouteServerPropagation";
const _ES = "EphemeralStorage";
const _ESBPA = "EnableSnapshotBlockPublicAccess";
const _ESCA = "EnableSerialConsoleAccess";
const _ESE = "EnaSrdEnabled";
const _ESS = "EnaSrdSpecification";
const _ESSn = "EnaSrdSupported";
const _EST = "EventSubType";
const _ESUE = "EnaSrdUdpEnabled";
const _ESUS = "EnaSrdUdpSpecification";
const _ESf = "EfaSupported";
const _ESn = "EnaSupport";
const _ESnc = "EncryptionSupport";
const _ET = "EndpointType";
const _ETGR = "ExportTransitGatewayRoutes";
const _ETGRTP = "EnableTransitGatewayRouteTablePropagation";
const _ETI = "ExportTaskId";
const _ETIx = "ExportTaskIds";
const _ETLC = "EnableTunnelLifecycleControl";
const _ETST = "ExportToS3Task";
const _ETa = "EarliestTime";
const _ETi = "EipTags";
const _ETn = "EndTime";
const _ETna = "EnablingTime";
const _ETnab = "EnabledTime";
const _ETv = "EventType";
const _ETx = "ExpirationTime";
const _ETxp = "ExportTask";
const _ETxpo = "ExportTasks";
const _EU = "ExecutableUsers";
const _EVAICC = "ExportVerifiedAccessInstanceClientConfiguration";
const _EVCL = "EnableVpcClassicLink";
const _EVCLDS = "EnableVpcClassicLinkDnsSupport";
const _EVIO = "EnableVolumeIO";
const _EVRP = "EnableVgwRoutePropagation";
const _EWD = "EndWeekDay";
const _Eg = "Egress";
const _En = "Enabled";
const _Enc = "Encrypted";
const _End = "End";
const _Endp = "Endpoint";
const _Ent = "Entries";
const _Er = "Error";
const _Err = "Errors";
const _Ev = "Events";
const _Eve = "Event";
const _Ex = "Explanations";
const _F = "Force";
const _FA = "FederatedAuthentication";
const _FAD = "FilterAtDestination";
const _FAS = "FilterAtSource";
const _FAi = "FirstAddress";
const _FC = "FulfilledCapacity";
const _FCR = "FleetCapacityReservations";
const _FCa = "FailureCode";
const _FCi = "FindingComponents";
const _FD = "ForceDelete";
const _FDN = "FipsDnsName";
const _FE = "FipsEnabled";
const _FF = "FileFormat";
const _FFC = "FailedFleetCancellations";
const _FFi = "FindingsFound";
const _FI = "FleetIds";
const _FIA = "FilterInArns";
const _FIAp = "FpgaImageAttribute";
const _FIGI = "FpgaImageGlobalId";
const _FII = "FpgaImageId";
const _FIIp = "FpgaImageIds";
const _FIPSE = "FIPSEnabled";
const _FIi = "FindingId";
const _FIl = "FleetId";
const _FIp = "FpgaImages";
const _FIpg = "FpgaInfo";
const _FL = "FlowLogs";
const _FLI = "FlowLogIds";
const _FLIa = "FastLaunchImages";
const _FLIl = "FlowLogId";
const _FLS = "FlowLogStatus";
const _FM = "FailureMessage";
const _FODC = "FulfilledOnDemandCapacity";
const _FP = "FromPort";
const _FPC = "ForwardPathComponents";
const _FPi = "FixedPrice";
const _FQPD = "FailedQueuedPurchaseDeletions";
const _FR = "FailureReason";
const _FRa = "FastRestored";
const _FS = "FleetState";
const _FSR = "FastSnapshotRestores";
const _FSRSE = "FastSnapshotRestoreStateErrors";
const _FSRi = "FirewallStatelessRule";
const _FSRir = "FirewallStatefulRule";
const _FSSIB = "FullSnapshotSizeInBytes";
const _FSST = "FirstSlotStartTime";
const _FSSTR = "FirstSlotStartTimeRange";
const _FTE = "FreeTierEligible";
const _Fa = "Fault";
const _Fi = "Filters";
const _Fil = "Filter";
const _Fl = "Fleets";
const _Fo = "Format";
const _Fp = "Fpgas";
const _Fr = "From";
const _Fre = "Frequency";
const _G = "Groups";
const _GA = "GroupArn";
const _GAECIR = "GetAssociatedEnclaveCertificateIamRoles";
const _GAIPC = "GetAssociatedIpv6PoolCidrs";
const _GAIS = "GetAllowedImagesSettings";
const _GANPD = "GetAwsNetworkPerformanceData";
const _GAS = "GatewayAssociationState";
const _GCO = "GetConsoleOutput";
const _GCPU = "GetCoipPoolUsage";
const _GCRU = "GetCapacityReservationUsage";
const _GCS = "GetConsoleScreenshot";
const _GD = "GroupDescription";
const _GDCS = "GetDefaultCreditSpecification";
const _GDPRS = "GetDeclarativePoliciesReportSummary";
const _GEDKKI = "GetEbsDefaultKmsKeyId";
const _GEEBD = "GetEbsEncryptionByDefault";
const _GFLIT = "GetFlowLogsIntegrationTemplate";
const _GGFCR = "GetGroupsForCapacityReservation";
const _GHRPP = "GetHostReservationPurchasePreview";
const _GI = "GatewayId";
const _GIA = "GroupIpAddress";
const _GIAH = "GetIpamAddressHistory";
const _GIBPAS = "GetImageBlockPublicAccessState";
const _GIDA = "GetIpamDiscoveredAccounts";
const _GIDPA = "GetIpamDiscoveredPublicAddresses";
const _GIDRC = "GetIpamDiscoveredResourceCidrs";
const _GIMD = "GetInstanceMetadataDefaults";
const _GIPA = "GetIpamPoolAllocations";
const _GIPC = "GetIpamPoolCidrs";
const _GIRC = "GetIpamResourceCidrs";
const _GITEP = "GetInstanceTpmEkPub";
const _GITFIR = "GetInstanceTypesFromInstanceRequirements";
const _GIUD = "GetInstanceUefiData";
const _GIp = "GpuInfo";
const _GIr = "GroupId";
const _GIro = "GroupIds";
const _GK = "GreKey";
const _GLBA = "GatewayLoadBalancerArns";
const _GLBEI = "GatewayLoadBalancerEndpointId";
const _GLN = "GroupLongName";
const _GLTD = "GetLaunchTemplateData";
const _GM = "GroupMember";
const _GMPLA = "GetManagedPrefixListAssociations";
const _GMPLE = "GetManagedPrefixListEntries";
const _GN = "GroupName";
const _GNIASAF = "GetNetworkInsightsAccessScopeAnalysisFindings";
const _GNIASC = "GetNetworkInsightsAccessScopeContent";
const _GNr = "GroupNames";
const _GOI = "GroupOwnerId";
const _GPD = "GetPasswordData";
const _GRIEQ = "GetReservedInstancesExchangeQuote";
const _GRSA = "GetRouteServerAssociations";
const _GRSP = "GetRouteServerPropagations";
const _GRSRD = "GetRouteServerRoutingDatabase";
const _GS = "GroupSource";
const _GSBPAS = "GetSnapshotBlockPublicAccessState";
const _GSCAS = "GetSerialConsoleAccessStatus";
const _GSCR = "GetSubnetCidrReservations";
const _GSGFV = "GetSecurityGroupsForVpc";
const _GSPS = "GetSpotPlacementScores";
const _GTGAP = "GetTransitGatewayAttachmentPropagations";
const _GTGMDA = "GetTransitGatewayMulticastDomainAssociations";
const _GTGPLR = "GetTransitGatewayPrefixListReferences";
const _GTGPTA = "GetTransitGatewayPolicyTableAssociations";
const _GTGPTE = "GetTransitGatewayPolicyTableEntries";
const _GTGRTA = "GetTransitGatewayRouteTableAssociations";
const _GTGRTP = "GetTransitGatewayRouteTablePropagations";
const _GVAEP = "GetVerifiedAccessEndpointPolicy";
const _GVAET = "GetVerifiedAccessEndpointTargets";
const _GVAGP = "GetVerifiedAccessGroupPolicy";
const _GVCDSC = "GetVpnConnectionDeviceSampleConfiguration";
const _GVCDT = "GetVpnConnectionDeviceTypes";
const _GVTRS = "GetVpnTunnelReplacementStatus";
const _Gp = "Gpus";
const _Gr = "Group";
const _H = "Hypervisor";
const _HCP = "HiveCompatiblePartitions";
const _HE = "HttpEndpoint";
const _HI = "HostIds";
const _HIS = "HostIdSet";
const _HIo = "HostId";
const _HM = "HostMaintenance";
const _HO = "HibernationOptions";
const _HP = "HostProperties";
const _HPI = "HttpProtocolIpv6";
const _HPRHL = "HttpPutResponseHopLimit";
const _HPo = "HourlyPrice";
const _HR = "HostRecovery";
const _HRGA = "HostResourceGroupArn";
const _HRI = "HostReservationId";
const _HRIS = "HostReservationIdSet";
const _HRS = "HostReservationSet";
const _HRi = "HistoryRecords";
const _HS = "HibernationSupported";
const _HT = "HttpTokens";
const _HTo = "HostnameType";
const _HZI = "HostedZoneId";
const _Hi = "Hibernate";
const _Ho = "Hosts";
const _I = "Issuer";
const _IA = "Ipv6Addresses";
const _IAA = "Ipv6AddressAttribute";
const _IAC = "Ipv6AddressCount";
const _IAI = "IncludeAllInstances";
const _IAIn = "InferenceAcceleratorInfo";
const _IAPI = "Ipv4AddressesPerInterface";
const _IAPIp = "Ipv6AddressesPerInterface";
const _IAT = "IpAddressType";
const _IATOI = "IncludeAllTagsOfInstance";
const _IAm = "ImageAllowed";
const _IAn = "InterfaceAssociation";
const _IAnt = "InterfaceAssociations";
const _IAp = "IpAddress";
const _IApa = "IpamArn";
const _IApv = "Ipv6Address";
const _IB = "IngressBytes";
const _IBPAS = "ImageBlockPublicAccessState";
const _IC = "InstanceCount";
const _ICA = "Ipv6CidrAssociations";
const _ICB = "Ipv6CidrBlock";
const _ICBA = "Ipv6CidrBlockAssociation";
const _ICBAS = "Ipv6CidrBlockAssociationSet";
const _ICBNBG = "Ipv6CidrBlockNetworkBorderGroup";
const _ICBS = "Ipv6CidrBlockState";
const _ICBSp = "Ipv6CidrBlockSet";
const _ICBn = "InsideCidrBlocks";
const _ICE = "InstanceConnectEndpoint";
const _ICEA = "InstanceConnectEndpointArn";
const _ICEI = "InstanceConnectEndpointId";
const _ICEIn = "InstanceConnectEndpointIds";
const _ICEn = "InstanceConnectEndpoints";
const _ICS = "InstanceCreditSpecifications";
const _ICVCCRL = "ImportClientVpnClientCertificateRevocationList";
const _ICm = "ImageCriteria";
const _ICn = "InstanceCounts";
const _ICp = "Ipv6Cidr";
const _ID = "IncludeDeprecated";
const _IDA = "IpamDiscoveredAccounts";
const _IDPA = "IpamDiscoveredPublicAddresses";
const _IDRC = "IpamDiscoveredResourceCidrs";
const _IDm = "ImageData";
const _IDn = "IncludeDisabled";
const _IDs = "IsDefault";
const _IE = "IsEgress";
const _IED = "InstanceExportDetails";
const _IEI = "InstanceEventId";
const _IERVT = "IpamExternalResourceVerificationToken";
const _IERVTA = "IpamExternalResourceVerificationTokenArn";
const _IERVTI = "IpamExternalResourceVerificationTokenId";
const _IERVTIp = "IpamExternalResourceVerificationTokenIds";
const _IERVTp = "IpamExternalResourceVerificationTokens";
const _IEW = "InstanceEventWindow";
const _IEWI = "InstanceEventWindowId";
const _IEWIn = "InstanceEventWindowIds";
const _IEWS = "InstanceEventWindowState";
const _IEWn = "InstanceEventWindows";
const _IF = "InstanceFamily";
const _IFCS = "InstanceFamilyCreditSpecification";
const _IFR = "IamFleetRole";
const _IFRn = "IngressFilterRules";
const _IG = "InstanceGenerations";
const _IGBM = "InternetGatewayBlockMode";
const _IGEM = "InternetGatewayExclusionMode";
const _IGI = "InternetGatewayId";
const _IGIn = "InternetGatewayIds";
const _IGn = "InternetGateway";
const _IGnt = "InternetGateways";
const _IH = "InstanceHealth";
const _IHn = "InboundHeader";
const _II = "ImportImage";
const _IIB = "InstanceInterruptionBehavior";
const _IIM = "InstanceImageMetadata";
const _IIP = "IamInstanceProfile";
const _IIPA = "IamInstanceProfileAssociation";
const _IIPAa = "IamInstanceProfileAssociations";
const _IIPI = "Ipv6IpamPoolId";
const _IIPIp = "Ipv4IpamPoolId";
const _IIS = "InstanceIdSet";
const _IISB = "InstanceInitiatedShutdownBehavior";
const _IIT = "ImportImageTasks";
const _IIm = "ImportInstance";
const _IIma = "ImageId";
const _IImag = "ImageIds";
const _IIn = "InstanceId";
const _IIns = "InstanceIds";
const _IIp = "IpamId";
const _IIpa = "IpamIds";
const _IKEV = "InternetKeyExchangeVersion";
const _IKEVe = "IKEVersions";
const _IKP = "ImportKeyPair";
const _IL = "ImageLocation";
const _ILn = "InstanceLifecycle";
const _IM = "IncludeMarketplace";
const _IMC = "InstanceMatchCriteria";
const _IMO = "InstanceMarketOptions";
const _IMOn = "InstanceMetadataOptions";
const _IMT = "InstanceMetadataTags";
const _IMU = "ImportManifestUrl";
const _IMm = "ImageMetadata";
const _IMn = "InstanceMonitorings";
const _IN = "Ipv6Native";
const _INL = "Ipv6NetmaskLength";
const _INLp = "Ipv4NetmaskLength";
const _IOA = "ImageOwnerAlias";
const _IOI = "IpOwnerId";
const _IOIn = "InstanceOwnerId";
const _IOS = "InstanceOwningService";
const _IP = "Ipv6Prefixes";
const _IPA = "IpamPoolAllocation";
const _IPAI = "IpamPoolAllocationId";
const _IPAp = "IpamPoolAllocations";
const _IPApa = "IpamPoolArn";
const _IPC = "Ipv6PrefixCount";
const _IPCI = "IpamPoolCidrId";
const _IPCp = "Ipv4PrefixCount";
const _IPCpa = "IpamPoolCidr";
const _IPCpam = "IpamPoolCidrs";
const _IPE = "IpPermissionsEgress";
const _IPI = "IpamPoolId";
const _IPIp = "IpamPoolIds";
const _IPIs = "IsPrimaryIpv6";
const _IPK = "IncludePublicKey";
const _IPO = "IpamPoolOwner";
const _IPR = "IsPermanentRestore";
const _IPTUC = "InstancePoolsToUseCount";
const _IPm = "ImageProviders";
const _IPn = "InstancePlatform";
const _IPng = "IngressPackets";
const _IPns = "InstancePort";
const _IPnt = "InterfacePermission";
const _IPnte = "InterfaceProtocol";
const _IPo = "IoPerformance";
const _IPp = "Ipv4Prefixes";
const _IPpa = "IpamPool";
const _IPpam = "IpamPools";
const _IPpe = "IpPermissions";
const _IPpr = "IpProtocol";
const _IPpre = "IpPrefixes";
const _IPpv = "Ipv6Pool";
const _IPpvo = "Ipv6Pools";
const _IPpvr = "Ipv4Prefix";
const _IPpvre = "Ipv6Prefix";
const _IPs = "IsPublic";
const _IPsr = "IsPrimary";
const _IR = "InstanceRequirements";
const _IRC = "IpamResourceCidrs";
const _IRCp = "IpamResourceCidr";
const _IRD = "IpamResourceDiscovery";
const _IRDA = "IpamResourceDiscoveryAssociation";
const _IRDAA = "IpamResourceDiscoveryAssociationArn";
const _IRDAI = "IpamResourceDiscoveryAssociationIds";
const _IRDAIp = "IpamResourceDiscoveryAssociationId";
const _IRDAp = "IpamResourceDiscoveryAssociations";
const _IRDApa = "IpamResourceDiscoveryArn";
const _IRDI = "IpamResourceDiscoveryId";
const _IRDIp = "IpamResourceDiscoveryIds";
const _IRDR = "IpamResourceDiscoveryRegion";
const _IRDp = "IpamResourceDiscoveries";
const _IRSDA = "IntegrationResultS3DestinationArn";
const _IRT = "IngressRouteTable";
const _IRWM = "InstanceRequirementsWithMetadata";
const _IRp = "IpRanges";
const _IRpa = "IpamRegion";
const _IRpv = "Ipv6Ranges";
const _IS = "ImportSnapshot";
const _ISA = "IpamScopeArn";
const _ISI = "IpamScopeId";
const _ISIn = "InstanceStorageInfo";
const _ISIp = "IpamScopeIds";
const _ISL = "InputStorageLocation";
const _ISS = "InstanceStorageSupported";
const _IST = "ImportSnapshotTasks";
const _ISTp = "IpamScopeType";
const _ISg = "Igmpv2Support";
const _ISm = "ImdsSupport";
const _ISmp = "ImpairedSince";
const _ISn = "InstanceSpecification";
const _ISns = "InstanceStatuses";
const _ISnst = "InstanceState";
const _ISnsta = "InstanceStatus";
const _ISnt = "IntegrateServices";
const _ISp = "Ipv6Support";
const _ISpa = "IpamScope";
const _ISpam = "IpamScopes";
const _ISpo = "IpSource";
const _ISpv = "Ipv6Supported";
const _IT = "InstanceType";
const _ITA = "InstanceTagAttribute";
const _ITC = "IcmpTypeCode";
const _ITCn = "IncludeTrustContext";
const _ITI = "ImportTaskId";
const _ITIm = "ImportTaskIds";
const _ITK = "InstanceTagKeys";
const _ITO = "InstanceTypeOfferings";
const _ITS = "InstanceTypeSpecifications";
const _ITm = "ImageType";
const _ITn = "InterfaceType";
const _ITns = "InstanceTenancy";
const _ITnst = "InstanceTypes";
const _ITnsta = "InstanceTags";
const _IU = "InstanceUsages";
const _IUp = "IpUsage";
const _IV = "ImportVolume";
const _IVE = "IsValidExchange";
const _IVk = "IkeVersions";
const _Id = "Id";
const _Im = "Image";
const _Ima = "Images";
const _In = "Instances";
const _Ins = "Instance";
const _Int = "Interval";
const _Io = "Iops";
const _Ip = "Ipv4";
const _Ipa = "Ipam";
const _Ipam = "Ipams";
const _Ipv = "Ipv6";
const _K = "Kernel";
const _KDF = "KinesisDataFirehose";
const _KF = "KeyFormat";
const _KFe = "KeyFingerprint";
const _KI = "KernelId";
const _KKA = "KmsKeyArn";
const _KKI = "KmsKeyId";
const _KM = "KeyMaterial";
const _KN = "KeyName";
const _KNe = "KeyNames";
const _KP = "KeyPairs";
const _KPI = "KeyPairId";
const _KPIe = "KeyPairIds";
const _KT = "KeyType";
const _KV = "KeyValue";
const _Ke = "Key";
const _Key = "Keyword";
const _L = "Locale";
const _LA = "LocalAddress";
const _LADT = "LastAttemptedDiscoveryTime";
const _LAZ = "LaunchedAvailabilityZone";
const _LAa = "LastAddress";
const _LB = "LoadBalancers";
const _LBA = "LoadBalancerArn";
const _LBAo = "LocalBgpAsn";
const _LBC = "LoadBalancersConfig";
const _LBLP = "LoadBalancerListenerPort";
const _LBO = "LoadBalancerOptions";
const _LBP = "LoadBalancerPort";
const _LBT = "LoadBalancerTarget";
const _LBTG = "LoadBalancerTargetGroup";
const _LBTGo = "LoadBalancerTargetGroups";
const _LBTP = "LoadBalancerTargetPort";
const _LC = "LoggingConfigurations";
const _LCA = "LicenseConfigurationArn";
const _LCO = "LockCreatedOn";
const _LCo = "LoggingConfiguration";
const _LD = "LogDestination";
const _LDST = "LockDurationStartTime";
const _LDT = "LogDestinationType";
const _LDo = "LockDuration";
const _LE = "LogEnabled";
const _LEO = "LockExpiresOn";
const _LET = "LastEvaluatedTime";
const _LEa = "LastError";
const _LF = "LogFormat";
const _LFA = "LambdaFunctionArn";
const _LG = "LaunchGroup";
const _LGA = "LogGroupArn";
const _LGI = "LocalGatewayId";
const _LGIo = "LocalGatewayIds";
const _LGN = "LogGroupName";
const _LGRT = "LocalGatewayRouteTable";
const _LGRTA = "LocalGatewayRouteTableArn";
const _LGRTI = "LocalGatewayRouteTableId";
const _LGRTIo = "LocalGatewayRouteTableIds";
const _LGRTVA = "LocalGatewayRouteTableVpcAssociation";
const _LGRTVAI = "LocalGatewayRouteTableVpcAssociationId";
const _LGRTVAIo = "LocalGatewayRouteTableVpcAssociationIds";
const _LGRTVAo = "LocalGatewayRouteTableVpcAssociations";
const _LGRTVIGA = "LocalGatewayRouteTableVirtualInterfaceGroupAssociation";
const _LGRTVIGAI = "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId";
const _LGRTVIGAIo = "LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds";
const _LGRTVIGAo = "LocalGatewayRouteTableVirtualInterfaceGroupAssociations";
const _LGRTo = "LocalGatewayRouteTables";
const _LGVI = "LocalGatewayVirtualInterfaces";
const _LGVIG = "LocalGatewayVirtualInterfaceGroups";
const _LGVIGI = "LocalGatewayVirtualInterfaceGroupId";
const _LGVIGIo = "LocalGatewayVirtualInterfaceGroupIds";
const _LGVII = "LocalGatewayVirtualInterfaceIds";
const _LGVIIo = "LocalGatewayVirtualInterfaceId";
const _LGo = "LogGroup";
const _LGoc = "LocalGateways";
const _LIIRB = "ListImagesInRecycleBin";
const _LINC = "LocalIpv4NetworkCidr";
const _LINCo = "LocalIpv6NetworkCidr";
const _LLT = "LastLaunchedTime";
const _LM = "LockMode";
const _LMA = "LastMaintenanceApplied";
const _LO = "LogOptions";
const _LOF = "LogOutputFormat";
const _LP = "LoadPermission";
const _LPa = "LaunchPermission";
const _LPau = "LaunchPermissions";
const _LPi = "LimitPrice";
const _LPo = "LoadPermissions";
const _LS = "LockSnapshot";
const _LSC = "LastStatusChange";
const _LSDT = "LastSuccessfulDiscoveryTime";
const _LSIRB = "ListSnapshotsInRecycleBin";
const _LSL = "LogsStorageLocation";
const _LST = "LocalStorageTypes";
const _LSa = "LaunchSpecification";
const _LSau = "LaunchSpecifications";
const _LSi = "LicenseSpecifications";
const _LSo = "LocalStorage";
const _LSoc = "LockState";
const _LT = "LocationType";
const _LTAO = "LaunchTemplateAndOverrides";
const _LTC = "LaunchTemplateConfigs";
const _LTD = "LaunchTemplateData";
const _LTI = "LaunchTemplateId";
const _LTIa = "LaunchTemplateIds";
const _LTN = "LaunchTemplateName";
const _LTNa = "LaunchTemplateNames";
const _LTOS = "LastTieringOperationStatus";
const _LTOSD = "LastTieringOperationStatusDetail";
const _LTP = "LastTieringProgress";
const _LTS = "LaunchTemplateSpecification";
const _LTST = "LastTieringStartTime";
const _LTV = "LaunchTemplateVersion";
const _LTVa = "LaunchTemplateVersions";
const _LTa = "LaunchTemplate";
const _LTat = "LatestTime";
const _LTau = "LaunchTemplates";
const _LTaun = "LaunchTime";
const _LTi = "LicenseType";
const _LTo = "LocalTarget";
const _LUT = "LastUpdateTime";
const _LUTa = "LastUpdatedTime";
const _LUTas = "LastUpdateTimestamp";
const _LV = "LogVersion";
const _LVN = "LatestVersionNumber";
const _La = "Latest";
const _Li = "Lifecycle";
const _Lic = "Licenses";
const _Lo = "Location";
const _M = "Min";
const _MA = "MutualAuthentication";
const _MAA = "ModifyAddressAttribute";
const _MAAA = "MaintenanceAutoAppliedAfter";
const _MAE = "MultiAttachEnabled";
const _MAI = "MaxAggregationInterval";
const _MAIe = "MediaAcceleratorInfo";
const _MAS = "MovingAddressStatuses";
const _MATV = "MoveAddressToVpc";
const _MAZG = "ModifyAvailabilityZoneGroup";
const _MAa = "MacAddress";
const _MB = "ManagedBy";
const _MBCTI = "MoveByoipCidrToIpam";
const _MBIM = "MaximumBandwidthInMbps";
const _MC = "MaxCount";
const _MCOIOL = "MapCustomerOwnedIpOnLaunch";
const _MCR = "ModifyCapacityReservation";
const _MCRF = "ModifyCapacityReservationFleet";
const _MCRI = "MoveCapacityReservationInstances";
const _MCVE = "ModifyClientVpnEndpoint";
const _MCi = "MinCount";
const _MCis = "MissingComponent";
const _MD = "MaxDuration";
const _MDA = "MulticastDomainAssociations";
const _MDCS = "ModifyDefaultCreditSpecification";
const _MDDS = "MaxDrainDurationSeconds";
const _MDK = "MetaDataKey";
const _MDV = "MetaDataValue";
const _MDa = "MaintenanceDetails";
const _MDe = "MetaData";
const _MDi = "MinDuration";
const _ME = "MaxEntries";
const _MEDKKI = "ModifyEbsDefaultKmsKeyId";
const _MEI = "MaximumEfaInterfaces";
const _MEM = "ManagedExceptionMessage";
const _MF = "ModifyFleet";
const _MFIA = "ModifyFpgaImageAttribute";
const _MFV = "MostFrequentValue";
const _MG = "MulticastGroups";
const _MGBPVC = "MemoryGiBPerVCpu";
const _MH = "ModifyHosts";
const _MHa = "MacHosts";
const _MI = "ModifyIpam";
const _MIA = "ModifyImageAttribute";
const _MIAo = "ModifyInstanceAttribute";
const _MIC = "MaxInstanceCount";
const _MICO = "ModifyInstanceCpuOptions";
const _MICRA = "ModifyInstanceCapacityReservationAttributes";
const _MICS = "ModifyInstanceCreditSpecification";
const _MIEST = "ModifyInstanceEventStartTime";
const _MIEW = "ModifyInstanceEventWindow";
const _MIF = "ModifyIdFormat";
const _MIIF = "ModifyIdentityIdFormat";
const _MIMD = "ModifyInstanceMetadataDefaults";
const _MIMO = "ModifyInstanceMaintenanceOptions";
const _MIMOo = "ModifyInstanceMetadataOptions";
const _MINPO = "ModifyInstanceNetworkPerformanceOptions";
const _MIP = "ModifyInstancePlacement";
const _MIPo = "ModifyIpamPool";
const _MIRC = "ModifyIpamResourceCidr";
const _MIRD = "ModifyIpamResourceDiscovery";
const _MIS = "ModifyIpamScope";
const _MIa = "MaximumIops";
const _MIe = "MemoryInfo";
const _MIo = "MonitorInstances";
const _MLGR = "ModifyLocalGatewayRoute";
const _MLT = "ModifyLaunchTemplate";
const _MMB = "MemoryMiB";
const _MMPL = "ModifyManagedPrefixList";
const _MNC = "MaximumNetworkCards";
const _MNI = "MaximumNetworkInterfaces";
const _MNIA = "ModifyNetworkInterfaceAttribute";
const _MO = "MetadataOptions";
const _MOSLRG = "MemberOfServiceLinkedResourceGroup";
const _MOSLSV = "MacOSLatestSupportedVersions";
const _MOa = "MaintenanceOptions";
const _MP = "MatchPaths";
const _MPDNO = "ModifyPrivateDnsNameOptions";
const _MPIOL = "MapPublicIpOnLaunch";
const _MPL = "MaxParallelLaunches";
const _MPa = "MaxPrice";
const _MPe = "MetricPoints";
const _MR = "MaxResults";
const _MRI = "ModifyReservedInstances";
const _MRS = "ModifyRouteServer";
const _MRo = "ModificationResults";
const _MRu = "MultiRegion";
const _MS = "MaintenanceStrategies";
const _MSA = "ModifySnapshotAttribute";
const _MSAo = "ModifySubnetAttribute";
const _MSDIH = "MaxSlotDurationInHours";
const _MSDIHi = "MinSlotDurationInHours";
const _MSFR = "ModifySpotFleetRequest";
const _MSGR = "ModifySecurityGroupRules";
const _MSPAPOOODP = "MaxSpotPriceAsPercentageOfOptimalOnDemandPrice";
const _MST = "ModifySnapshotTier";
const _MSa = "ManagementState";
const _MSo = "MoveStatus";
const _MSod = "ModificationState";
const _MSu = "MulticastSupport";
const _MT = "MarketType";
const _MTC = "MinTargetCapacity";
const _MTDID = "MaxTermDurationInDays";
const _MTDIDi = "MinTermDurationInDays";
const _MTG = "ModifyTransitGateway";
const _MTGPLR = "ModifyTransitGatewayPrefixListReference";
const _MTGVA = "ModifyTransitGatewayVpcAttachment";
const _MTIMB = "MaximumThroughputInMBps";
const _MTMFNS = "ModifyTrafficMirrorFilterNetworkServices";
const _MTMFR = "ModifyTrafficMirrorFilterRule";
const _MTMS = "ModifyTrafficMirrorSession";
const _MTP = "MaxTotalPrice";
const _MTe = "MemberType";
const _MV = "ModifyVolume";
const _MVA = "ModifyVolumeAttribute";
const _MVAE = "ModifyVerifiedAccessEndpoint";
const _MVAEP = "ModifyVerifiedAccessEndpointPolicy";
const _MVAG = "ModifyVerifiedAccessGroup";
const _MVAGP = "ModifyVerifiedAccessGroupPolicy";
const _MVAI = "ModifyVerifiedAccessInstance";
const _MVAILC = "ModifyVerifiedAccessInstanceLoggingConfiguration";
const _MVATP = "ModifyVerifiedAccessTrustProvider";
const _MVAo = "ModifyVpcAttribute";
const _MVBPAE = "ModifyVpcBlockPublicAccessExclusion";
const _MVBPAO = "ModifyVpcBlockPublicAccessOptions";
const _MVC = "ModifyVpnConnection";
const _MVCO = "ModifyVpnConnectionOptions";
const _MVE = "ModifyVpcEndpoint";
const _MVECN = "ModifyVpcEndpointConnectionNotification";
const _MVESC = "ModifyVpcEndpointServiceConfiguration";
const _MVESP = "ModifyVpcEndpointServicePermissions";
const _MVESPR = "ModifyVpcEndpointServicePayerResponsibility";
const _MVEa = "ManagesVpcEndpoints";
const _MVPCO = "ModifyVpcPeeringConnectionOptions";
const _MVT = "ModifyVpcTenancy";
const _MVTC = "ModifyVpnTunnelCertificate";
const _MVTO = "ModifyVpnTunnelOptions";
const _MVa = "MaxVersion";
const _MVi = "MinVersion";
const _Ma = "Max";
const _Mai = "Main";
const _Man = "Manufacturer";
const _Mana = "Managed";
const _Mar = "Marketplace";
const _Me = "Message";
const _Med = "Med";
const _Mes = "Messages";
const _Met = "Metric";
const _Mo = "Mode";
const _Mon = "Monitoring";
const _Moni = "Monitored";
const _N = "Name";
const _NA = "NetworkAcl";
const _NAAI = "NetworkAclAssociationId";
const _NAI = "NetworkAclId";
const _NAIe = "NetworkAclIds";
const _NAIew = "NewAssociationId";
const _NAOO = "NativeApplicationOidcOptions";
const _NAe = "NetworkAcls";
const _NAo = "NotAfter";
const _NB = "NotBefore";
const _NBD = "NotBeforeDeadline";
const _NBG = "NetworkBorderGroup";
const _NBGe = "NetworkBandwidthGbps";
const _NC = "NetworkCards";
const _NCI = "NetworkCardIndex";
const _ND = "NoDevice";
const _NDe = "NeuronDevices";
const _NES = "NitroEnclavesSupport";
const _NG = "NatGateway";
const _NGA = "NatGatewayAddresses";
const _NGI = "NatGatewayId";
const _NGIa = "NatGatewayIds";
const _NGa = "NatGateways";
const _NHI = "NextHopIp";
const _NI = "NetworkInterfaces";
const _NIA = "NetworkInsightsAnalyses";
const _NIAA = "NetworkInsightsAnalysisArn";
const _NIAI = "NetworkInsightsAnalysisId";
const _NIAIe = "NetworkInsightsAnalysisIds";
const _NIAS = "NetworkInsightsAccessScope";
const _NIASA = "NetworkInsightsAccessScopeAnalyses";
const _NIASAA = "NetworkInsightsAccessScopeAnalysisArn";
const _NIASAI = "NetworkInsightsAccessScopeAnalysisId";
const _NIASAIe = "NetworkInsightsAccessScopeAnalysisIds";
const _NIASAe = "NetworkInsightsAccessScopeArn";
const _NIASAet = "NetworkInsightsAccessScopeAnalysis";
const _NIASC = "NetworkInsightsAccessScopeContent";
const _NIASI = "NetworkInsightsAccessScopeId";
const _NIASIe = "NetworkInsightsAccessScopeIds";
const _NIASe = "NetworkInsightsAccessScopes";
const _NIASet = "NetworkInterfaceAttachmentStatus";
const _NIAe = "NetworkInsightsAnalysis";
const _NIC = "NetworkInterfaceCount";
const _NID = "NetworkInterfaceDescription";
const _NII = "NetworkInterfaceId";
const _NIIe = "NetworkInterfaceIds";
const _NIO = "NetworkInterfaceOptions";
const _NIOI = "NetworkInterfaceOwnerId";
const _NIP = "NetworkInsightsPath";
const _NIPA = "NetworkInsightsPathArn";
const _NIPI = "NetworkInsightsPathId";
const _NIPIe = "NetworkInterfacePermissionId";
const _NIPIet = "NetworkInsightsPathIds";
const _NIPIetw = "NetworkInterfacePermissionIds";
const _NIPe = "NetworkInsightsPaths";
const _NIPet = "NetworkInterfacePermissions";
const _NIe = "NetworkId";
const _NIet = "NetworkInterface";
const _NIetw = "NetworkInfo";
const _NIeu = "NeuronInfo";
const _NL = "NetmaskLength";
const _NLBA = "NetworkLoadBalancerArn";
const _NLBAe = "NetworkLoadBalancerArns";
const _NN = "NetworkNodes";
const _NOA = "NumberOfAccounts";
const _NOFA = "NumberOfFailedAccounts";
const _NOMA = "NumberOfMatchedAccounts";
const _NOUA = "NumberOfUnmatchedAccounts";
const _NP = "NetworkPerformance";
const _NPF = "NetworkPathFound";
const _NPO = "NetworkPerformanceOptions";
const _NPe = "NetworkPlatform";
const _NR = "NoReboot";
const _NS = "NvmeSupport";
const _NSST = "NextSlotStartTime";
const _NSe = "NetworkServices";
const _NT = "NextToken";
const _NTI = "NitroTpmInfo";
const _NTS = "NitroTpmSupport";
const _NTe = "NetworkType";
const _Na = "Nameservers";
const _O = "Operator";
const _OA = "OutpostArn";
const _OAr = "OrganizationArn";
const _OArg = "OrganizationArns";
const _OAw = "OwnerAlias";
const _OC = "OfferingClass";
const _OD = "OccurrenceDays";
const _ODAS = "OnDemandAllocationStrategy";
const _ODFC = "OnDemandFulfilledCapacity";
const _ODMPPOLP = "OnDemandMaxPricePercentageOverLowestPrice";
const _ODMTP = "OnDemandMaxTotalPrice";
const _ODO = "OnDemandOptions";
const _ODS = "OccurrenceDaySet";
const _ODTC = "OnDemandTargetCapacity";
const _OEP = "OrganizationsEntityPath";
const _OH = "OutboundHeader";
const _OI = "OfferingId";
const _OIA = "OutsideIpAddress";
const _OIAT = "OutsideIpAddressType";
const _OIS = "OptInStatus";
const _OIr = "OriginalIops";
const _OIw = "OwnerIds";
const _OIwn = "OwnerId";
const _OK = "ObjectKey";
const _OMAE = "OriginalMultiAttachEnabled";
const _OO = "OidcOptions";
const _OR = "OperatingRegions";
const _ORIWEA = "OutputReservedInstancesWillExpireAt";
const _ORTE = "OccurrenceRelativeToEnd";
const _OS = "OfferingSet";
const _OST = "OldestSampleTime";
const _OSr = "OriginalSize";
const _OSv = "OverlapStatus";
const _OT = "OfferingType";
const _OTp = "OperationType";
const _OTpt = "OptimizingTime";
const _OTr = "OriginalThroughput";
const _OU = "OccurrenceUnit";
const _OUA = "OrganizationalUnitArn";
const _OUAr = "OrganizationalUnitArns";
const _OUE = "OrganizationalUnitExclusions";
const _OUI = "OrganizationalUnitId";
const _OVC = "OpenVpnConfigurations";
const _OVT = "OriginalVolumeType";
const _Op = "Options";
const _Or = "Origin";
const _Ou = "Output";
const _Ov = "Overrides";
const _Ow = "Owners";
const _Own = "Owner";
const _P = "Protocol";
const _PA = "PubliclyAdvertisable";
const _PAI = "PeerAccountId";
const _PAIe = "PeeringAttachmentId";
const _PAR = "PoolAddressRange";
const _PARo = "PoolAddressRanges";
const _PAe = "PeerAddress";
const _PAee = "PeerAsn";
const _PAo = "PoolArn";
const _PAr = "PrincipalArn";
const _PB = "ProvisionedBandwidth";
const _PBA = "PeerBgpAsn";
const _PBC = "ProvisionByoipCidr";
const _PBIG = "PeakBandwidthInGbps";
const _PC = "ProductCode";
const _PCB = "PurchaseCapacityBlock";
const _PCBE = "PurchaseCapacityBlockExtension";
const _PCBo = "PoolCidrBlocks";
const _PCI = "PreserveClientIp";
const _PCIr = "ProductCodeId";
const _PCNI = "PeerCoreNetworkId";
const _PCS = "PostureComplianceStatuses";
const _PCT = "ProductCodeType";
const _PCa = "PartitionCount";
const _PCo = "PoolCidrs";
const _PCoo = "PoolCount";
const _PCr = "ProductCodes";
const _PD = "PolicyDocument";
const _PDE = "PrivateDnsEnabled";
const _PDEr = "PrivateDnsEntry";
const _PDHGN = "Phase1DHGroupNumbers";
const _PDHGNh = "Phase2DHGroupNumbers";
const _PDHT = "PrivateDnsHostnameType";
const _PDHTOL = "PrivateDnsHostnameTypeOnLaunch";
const _PDN = "PrivateDnsName";
const _PDNC = "PrivateDnsNameConfiguration";
const _PDNO = "PrivateDnsNameOptions";
const _PDNOOL = "PrivateDnsNameOptionsOnLaunch";
const _PDNVS = "PrivateDnsNameVerificationState";
const _PDNr = "PrivateDnsNames";
const _PDNu = "PublicDnsName";
const _PDOFIRE = "PrivateDnsOnlyForInboundResolverEndpoint";
const _PDRTI = "PropagationDefaultRouteTableId";
const _PDSI = "PublicDefaultScopeId";
const _PDSIr = "PrivateDefaultScopeId";
const _PDa = "PasswordData";
const _PDay = "PaymentDue";
const _PDl = "PlatformDetails";
const _PDo = "PoolDepth";
const _PDr = "ProductDescription";
const _PDri = "PricingDetails";
const _PDro = "ProductDescriptions";
const _PE = "PolicyEnabled";
const _PEA = "Phase1EncryptionAlgorithms";
const _PEAh = "Phase2EncryptionAlgorithms";
const _PED = "PartitionEndDate";
const _PEk = "PkceEnabled";
const _PF = "PacketField";
const _PFS = "PreviousFleetState";
const _PG = "PlacementGroup";
const _PGA = "PlacementGroupArn";
const _PGI = "PlacementGroupInfo";
const _PGl = "PlacementGroups";
const _PHP = "PerHourPartition";
const _PHR = "PurchaseHostReservation";
const _PHS = "PacketHeaderStatement";
const _PI = "PublicIp";
const _PIA = "PrivateIpAddresses";
const _PIAC = "PrivateIpAddressCount";
const _PIACr = "PrivateIpAddressConfigs";
const _PIAh = "Phase1IntegrityAlgorithms";
const _PIAha = "Phase2IntegrityAlgorithms";
const _PIAr = "PrivateIpAddress";
const _PIAu = "PublicIpAddress";
const _PIB = "ProvisionIpamByoasn";
const _PIP = "PublicIpv4Pool";
const _PIPC = "ProvisionIpamPoolCidr";
const _PIPI = "PublicIpv4PoolId";
const _PIPu = "PublicIpv4Pools";
const _PIS = "PublicIpSource";
const _PIc = "PciId";
const _PIo = "PoolId";
const _PIoo = "PoolIds";
const _PIr = "PrimaryIpv6";
const _PIri = "PrivateIp";
const _PIro = "ProcessorInfo";
const _PIu = "PublicIps";
const _PK = "PublicKey";
const _PKM = "PublicKeyMaterial";
const _PL = "PacketLength";
const _PLA = "PrefixListAssociations";
const _PLAr = "PrefixListArn";
const _PLD = "PeerLivenessDetection";
const _PLF = "PartitionLoadFrequency";
const _PLI = "PrefixListId";
const _PLIr = "PrefixListIds";
const _PLN = "PrefixListName";
const _PLOI = "PrefixListOwnerId";
const _PLS = "Phase1LifetimeSeconds";
const _PLSh = "Phase2LifetimeSeconds";
const _PLr = "PrefixList";
const _PLre = "PrefixLists";
const _PM = "PendingMaintenance";
const _PN = "PartitionNumber";
const _PNC = "PreviewNextCidr";
const _PO = "PaymentOption";
const _POI = "PeerOwnerId";
const _POe = "PeeringOptions";
const _PP = "ProgressPercentage";
const _PPIPC = "ProvisionPublicIpv4PoolCidr";
const _PR = "PortRange";
const _PRD = "PersistRoutesDuration";
const _PRIO = "PurchaseReservedInstancesOffering";
const _PRN = "PolicyReferenceName";
const _PRNo = "PolicyRuleNumber";
const _PRS = "PersistRoutesState";
const _PRU = "PtrRecordUpdate";
const _PRa = "PayerResponsibility";
const _PRe = "PersistRoutes";
const _PRee = "PeerRegion";
const _PRer = "PermanentRestore";
const _PRo = "PortRanges";
const _PRol = "PolicyRule";
const _PRt = "PtrRecord";
const _PRu = "PurchaseRequests";
const _PS = "PriceSchedules";
const _PSD = "PartitionStartDate";
const _PSET = "PreviousSlotEndTime";
const _PSFRS = "PreviousSpotFleetRequestState";
const _PSI = "PurchaseScheduledInstances";
const _PSK = "PreSharedKey";
const _PSKE = "PublicSigningKeyEndpoint";
const _PSKU = "PublicSigningKeyUrl";
const _PSe = "PeeringStatus";
const _PSer = "PermissionState";
const _PSh = "PhcSupport";
const _PSr = "PreviousState";
const _PSre = "PreviousStatus";
const _PT = "PurchaseToken";
const _PTGI = "PeerTransitGatewayId";
const _PTS = "PoolTagSpecifications";
const _PTr = "PrincipalType";
const _PTro = "ProvisionTime";
const _PTu = "PurchaseTime";
const _PU = "PresignedUrl";
const _PV = "PreviousVersion";
const _PVI = "PeerVpcId";
const _PVIr = "PrimaryVpcId";
const _PVr = "PropagatingVgws";
const _PZI = "ParentZoneId";
const _PZN = "ParentZoneName";
const _Pe = "Permission";
const _Per = "Period";
const _Pl = "Placement";
const _Pla = "Platform";
const _Po = "Port";
const _Pr = "Prefix";
const _Pri = "Priority";
const _Pric = "Price";
const _Prim = "Primary";
const _Prin = "Principal";
const _Princ = "Principals";
const _Pro = "Protocols";
const _Prog = "Progress";
const _Prop = "Propagation";
const _Prov = "Provisioned";
const _Pu = "Public";
const _Pur = "Purchase";
const _Q = "Quantity";
const _R = "References";
const _RA = "ReleaseAddress";
const _RAA = "ResetAddressAttribute";
const _RAE = "RemoteAccessEnabled";
const _RAG = "RevokeAllGroups";
const _RAP = "RemoveAllowedPrincipals";
const _RART = "RemoveAllocationResourceTags";
const _RATC = "RestoreAddressToClassic";
const _RAe = "ResolveAlias";
const _RAes = "ResourceArn";
const _RAo = "RoleArn";
const _RAu = "RuleAction";
const _RB = "RequestedBy";
const _RBET = "RecycleBinEnterTime";
const _RBETe = "RecycleBinExitTime";
const _RBUI = "RestorableByUserIds";
const _RC = "ResourceCidr";
const _RCA = "ResourceConfigurationArn";
const _RCGA = "ResourceConfigurationGroupArn";
const _RCRBO = "RejectCapacityReservationBillingOwnership";
const _RCS = "ResourceComplianceStatus";
const _RCVI = "RevokeClientVpnIngress";
const _RCe = "ReasonCodes";
const _RCec = "RecurringCharges";
const _RCet = "ReturnCode";
const _RD = "RestoreDuration";
const _RDAC = "ResourceDiscoveryAssociationCount";
const _RDCA = "RdsDbClusterArn";
const _RDI = "RamDiskId";
const _RDIA = "RdsDbInstanceArn";
const _RDN = "RootDeviceName";
const _RDPA = "RdsDbProxyArn";
const _RDS = "ResourceDiscoveryStatus";
const _RDT = "RootDeviceType";
const _RE = "RdsEndpoint";
const _RED = "RemoveEndDate";
const _REDKKI = "ResetEbsDefaultKmsKeyId";
const _RET = "RestoreExpiryTime";
const _REe = "RemoveEntries";
const _REes = "ResponseError";
const _REeso = "ResourceExclusions";
const _RF = "RemoveFields";
const _RFIA = "ResetFpgaImageAttribute";
const _RFP = "RekeyFuzzPercentage";
const _RGA = "RuleGroupArn";
const _RGI = "ReferencedGroupId";
const _RGIe = "ReferencedGroupInfo";
const _RGLBA = "RemoveGatewayLoadBalancerArns";
const _RGROP = "RuleGroupRuleOptionsPairs";
const _RGT = "RuleGroupType";
const _RGTP = "RuleGroupTypePairs";
const _RH = "ReleaseHosts";
const _RHS = "RequireHibernateSupport";
const _RI = "RebootInstances";
const _RIA = "ResetImageAttribute";
const _RIAe = "ResetInstanceAttribute";
const _RICIAIS = "ReplaceImageCriteriaInAllowedImagesSettings";
const _RID = "RouteInstallationDetails";
const _RIENA = "RegisterInstanceEventNotificationAttributes";
const _RIFRB = "RestoreImageFromRecycleBin";
const _RII = "ReservedInstanceIds";
const _RIIPA = "ReplaceIamInstanceProfileAssociation";
const _RIIe = "ReservedInstancesId";
const _RIIes = "ReservedInstancesIds";
const _RIIese = "ReservedInstanceId";
const _RIL = "ReservedInstancesListings";
const _RILI = "ReservedInstancesListingId";
const _RIM = "ReservedInstancesModifications";
const _RIMI = "ReservedInstancesModificationIds";
const _RIMIe = "ReservedInstancesModificationId";
const _RINC = "RemoteIpv4NetworkCidr";
const _RINCe = "RemoteIpv6NetworkCidr";
const _RIO = "ReservedInstancesOfferings";
const _RIOI = "ReservedInstancesOfferingIds";
const _RIOIe = "ReservedInstancesOfferingId";
const _RIPA = "ReleaseIpamPoolAllocation";
const _RIS = "ReportInstanceStatus";
const _RISR = "RouteInstallationStatusReason";
const _RISo = "RouteInstallationStatus";
const _RIVR = "ReservedInstanceValueRollup";
const _RIVS = "ReservedInstanceValueSet";
const _RIa = "RamdiskId";
const _RIe = "RegisterImage";
const _RIep = "ReportId";
const _RIepo = "ReportIds";
const _RIeq = "RequesterId";
const _RIes = "ResourceIds";
const _RIese = "ReservedInstances";
const _RIeser = "ReservationId";
const _RIeso = "ResourceId";
const _RIu = "RunInstances";
const _RM = "ReasonMessage";
const _RMGM = "RegisteredMulticastGroupMembers";
const _RMGS = "RegisteredMulticastGroupSources";
const _RMPLV = "RestoreManagedPrefixListVersion";
const _RMTS = "RekeyMarginTimeSeconds";
const _RMe = "RequesterManaged";
const _RN = "RegionName";
const _RNAA = "ReplaceNetworkAclAssociation";
const _RNAE = "ReplaceNetworkAclEntry";
const _RNIA = "ResetNetworkInterfaceAttribute";
const _RNII = "RegisteredNetworkInterfaceIds";
const _RNLBA = "RemoveNetworkLoadBalancerArns";
const _RNS = "RemoveNetworkServices";
const _RNe = "RegionNames";
const _RNes = "ResourceName";
const _RNo = "RoleName";
const _RNu = "RuleNumber";
const _RO = "RdsOptions";
const _ROI = "ResourceOwnerId";
const _ROR = "RemoveOperatingRegions";
const _ROS = "ResourceOverlapStatus";
const _ROUE = "RemoveOrganizationalUnitExclusions";
const _ROe = "ResourceOwner";
const _ROo = "RouteOrigin";
const _ROu = "RuleOptions";
const _RP = "ResetPolicy";
const _RPC = "ReturnPathComponents";
const _RPCO = "RequesterPeeringConnectionOptions";
const _RPDN = "RemovePrivateDnsName";
const _RR = "ReplaceRoute";
const _RRTA = "ReplaceRouteTableAssociation";
const _RRTI = "RemoveRouteTableIds";
const _RRVT = "ReplaceRootVolumeTask";
const _RRVTI = "ReplaceRootVolumeTaskIds";
const _RRVTIe = "ReplaceRootVolumeTaskId";
const _RRVTe = "ReplaceRootVolumeTasks";
const _RRe = "ResourceRegion";
const _RS = "ReplacementStrategy";
const _RSA = "ResetSnapshotAttribute";
const _RSAo = "RouteServerAssociation";
const _RSAou = "RouteServerAssociations";
const _RSE = "RouteServerEndpoint";
const _RSEI = "RouteServerEndpointId";
const _RSEIo = "RouteServerEndpointIds";
const _RSEo = "RouteServerEndpoints";
const _RSF = "RequestSpotFleet";
const _RSFRB = "RestoreSnapshotFromRecycleBin";
const _RSGE = "RevokeSecurityGroupEgress";
const _RSGI = "RevokeSecurityGroupIngress";
const _RSGIe = "RemoveSecurityGroupIds";
const _RSGR = "RevokedSecurityGroupRules";
const _RSI = "RequestSpotInstances";
const _RSIAT = "RemoveSupportedIpAddressTypes";
const _RSIe = "RemoveSubnetIds";
const _RSIo = "RouteServerId";
const _RSIou = "RouteServerIds";
const _RSIu = "RunScheduledInstances";
const _RSP = "RouteServerPeer";
const _RSPI = "RouteServerPeerId";
const _RSPIo = "RouteServerPeerIds";
const _RSPo = "RouteServerPeers";
const _RSPou = "RouteServerPropagation";
const _RSPout = "RouteServerPropagations";
const _RSR = "RemoveSupportedRegions";
const _RST = "RestoreSnapshotTier";
const _RSTe = "RestoreStartTime";
const _RSe = "ResourceStatement";
const _RSeg = "RegionalSummaries";
const _RSo = "RouteServer";
const _RSou = "RouteServers";
const _RSout = "RouteStatus";
const _RT = "ResourceType";
const _RTAI = "RouteTableAssociationId";
const _RTGCB = "RemoveTransitGatewayCidrBlocks";
const _RTGMDA = "RejectTransitGatewayMulticastDomainAssociations";
const _RTGMGM = "RegisterTransitGatewayMulticastGroupMembers";
const _RTGMGS = "RegisterTransitGatewayMulticastGroupSources";
const _RTGPA = "RejectTransitGatewayPeeringAttachment";
const _RTGR = "ReplaceTransitGatewayRoute";
const _RTGVA = "RejectTransitGatewayVpcAttachment";
const _RTI = "RouteTableId";
const _RTIe = "RequesterTgwInfo";
const _RTIo = "RouteTableIds";
const _RTR = "RouteTableRoute";
const _RTV = "RemainingTotalValue";
const _RTe = "ReservationType";
const _RTel = "ReleaseTime";
const _RTeq = "RequestTime";
const _RTes = "ResourceTag";
const _RTeso = "ResourceTypes";
const _RTesou = "ResourceTags";
const _RTo = "RouteTable";
const _RTou = "RouteTables";
const _RUI = "ReplaceUnhealthyInstances";
const _RUV = "RemainingUpfrontValue";
const _RV = "ReturnValue";
const _RVEC = "RejectVpcEndpointConnections";
const _RVI = "ReferencingVpcId";
const _RVIe = "RequesterVpcInfo";
const _RVPC = "RejectVpcPeeringConnection";
const _RVT = "ReplaceVpnTunnel";
const _RVe = "ReservationValue";
const _RWS = "ReplayWindowSize";
const _Ra = "Ramdisk";
const _Re = "Resources";
const _Rea = "Reason";
const _Rec = "Recurrence";
const _Reg = "Regions";
const _Regi = "Region";
const _Rem = "Remove";
const _Rep = "Reports";
const _Req = "Requested";
const _Res = "Resource";
const _Rese = "Reservations";
const _Resu = "Result";
const _Ret = "Return";
const _Ro = "Role";
const _Rou = "Route";
const _Rout = "Routes";
const _S = "Source";
const _SA = "StartupAction";
const _SAI = "SecondaryAllocationIds";
const _SAMLPA = "SAMLProviderArn";
const _SAZ = "SingleAvailabilityZone";
const _SAo = "SourceAddresses";
const _SAou = "SourceAddress";
const _SAour = "SourceArn";
const _SAu = "SuggestedAccounts";
const _SAub = "SubnetArn";
const _SAup = "SupportedArchitectures";
const _SB = "S3Bucket";
const _SBM = "SupportedBootModes";
const _SC = "SubnetConfigurations";
const _SCA = "ServerCertificateArn";
const _SCAE = "SerialConsoleAccessEnabled";
const _SCB = "SourceCidrBlock";
const _SCCDM = "SnapshotCopyCompletionDurationMinutes";
const _SCR = "SourceCapacityReservation";
const _SCRI = "SourceCapacityReservationId";
const _SCRIu = "SubnetCidrReservationId";
const _SCRu = "SubnetCidrReservation";
const _SCSIG = "SustainedClockSpeedInGhz";
const _SCc = "ScopeCount";
const _SCe = "ServiceConfiguration";
const _SCer = "ServiceConfigurations";
const _SCn = "SnapshotConfiguration";
const _SD = "StartDate";
const _SDC = "SourceDestCheck";
const _SDI = "SendDiagnosticInterrupt";
const _SDIH = "SlotDurationInHours";
const _SDLTV = "SuccessfullyDeletedLaunchTemplateVersions";
const _SDPR = "StartDeclarativePoliciesReport";
const _SDR = "StartDateRange";
const _SDS = "SpotDatafeedSubscription";
const _SDV = "SetDefaultVersion";
const _SDe = "ServiceDetails";
const _SDn = "SnapshotDetails";
const _SDp = "SpreadDomain";
const _SDu = "SubDomain";
const _SEL = "S3ExportLocation";
const _SET = "SampledEndTime";
const _SF = "SupportedFeatures";
const _SFC = "SuccessfulFleetCancellations";
const _SFD = "SuccessfulFleetDeletions";
const _SFII = "SourceFpgaImageId";
const _SFR = "SuccessfulFleetRequests";
const _SFRC = "SpotFleetRequestConfig";
const _SFRCp = "SpotFleetRequestConfigs";
const _SFRI = "SpotFleetRequestIds";
const _SFRIp = "SpotFleetRequestId";
const _SFRS = "SpotFleetRequestState";
const _SG = "SecurityGroups";
const _SGA = "SecurityGroupArn";
const _SGFV = "SecurityGroupForVpcs";
const _SGI = "SecurityGroupIds";
const _SGIe = "SecurityGroupId";
const _SGR = "SecurityGroupRules";
const _SGRA = "SecurityGroupRuleArn";
const _SGRD = "SecurityGroupRuleDescriptions";
const _SGRI = "SecurityGroupRuleIds";
const _SGRIe = "SecurityGroupRuleId";
const _SGRS = "SecurityGroupReferencingSupport";
const _SGRSe = "SecurityGroupReferenceSet";
const _SGRe = "SecurityGroupRule";
const _SGVA = "SecurityGroupVpcAssociations";
const _SGe = "SecurityGroup";
const _SH = "StartHour";
const _SI = "StartInstances";
const _SIAS = "ScheduledInstanceAvailabilitySet";
const _SIAT = "SupportedIpAddressTypes";
const _SICR = "SubnetIpv4CidrReservations";
const _SICRu = "SubnetIpv6CidrReservations";
const _SICS = "SuccessfulInstanceCreditSpecifications";
const _SIGB = "SizeInGB";
const _SII = "SourceImageId";
const _SIIc = "ScheduledInstanceIds";
const _SIIch = "ScheduledInstanceId";
const _SIIo = "SourceInstanceId";
const _SIMB = "SizeInMiB";
const _SIP = "StaleIpPermissions";
const _SIPE = "StaleIpPermissionsEgress";
const _SIPI = "SourceIpamPoolId";
const _SIR = "SpotInstanceRequests";
const _SIRI = "SpotInstanceRequestIds";
const _SIRIp = "SpotInstanceRequestId";
const _SIRo = "SourceImageRegion";
const _SIS = "ScheduledInstanceSet";
const _SIT = "SpotInstanceType";
const _SITR = "StoreImageTaskResults";
const _SITi = "SingleInstanceType";
const _SIe = "ServiceId";
const _SIer = "ServiceIds";
const _SIn = "SnapshotId";
const _SIna = "SnapshotIds";
const _SIo = "SourceIp";
const _SIt = "StopInstances";
const _SIta = "StartingInstances";
const _SIto = "StoppingInstances";
const _SIu = "SubnetIds";
const _SIub = "SubnetId";
const _SIubs = "SubsystemId";
const _SK = "S3Key";
const _SKo = "S3objectKey";
const _SL = "SpreadLevel";
const _SLGR = "SearchLocalGatewayRoutes";
const _SLo = "S3Location";
const _SM = "ServiceManaged";
const _SMPPOLP = "SpotMaxPricePercentageOverLowestPrice";
const _SMS = "SpotMaintenanceStrategies";
const _SMTP = "SpotMaxTotalPrice";
const _SMt = "StatusMessage";
const _SMta = "StateMessage";
const _SN = "SessionNumber";
const _SNA = "ServiceNetworkArn";
const _SNE = "SnsNotificationsEnabled";
const _SNIA = "StartNetworkInsightsAnalysis";
const _SNIASA = "StartNetworkInsightsAccessScopeAnalysis";
const _SNN = "ServiceNetworkName";
const _SNS = "SriovNetSupport";
const _SNe = "ServiceName";
const _SNeq = "SequenceNumber";
const _SNer = "ServiceNames";
const _SO = "SpotOptions";
const _SOT = "S3ObjectTags";
const _SP = "S3Prefix";
const _SPA = "SamlProviderArn";
const _SPH = "SpotPriceHistory";
const _SPI = "ServicePermissionId";
const _SPIA = "SecondaryPrivateIpAddresses";
const _SPIAC = "SecondaryPrivateIpAddressCount";
const _SPL = "SourcePrefixLists";
const _SPR = "SourcePortRange";
const _SPRo = "SourcePortRanges";
const _SPS = "SpotPlacementScores";
const _SPo = "SourcePorts";
const _SPp = "SpotPrice";
const _SQPD = "SuccessfulQueuedPurchaseDeletions";
const _SR = "SourceRegion";
const _SRDT = "SupportedRootDeviceTypes";
const _SRO = "StaticRoutesOnly";
const _SRT = "SubnetRouteTable";
const _SRe = "ServiceRegion";
const _SRer = "ServiceRegions";
const _SRerv = "ServiceResource";
const _SRo = "SourceResource";
const _SRt = "StateReason";
const _SRu = "SupportedRegions";
const _SS = "SseSpecification";
const _SSGN = "SourceSecurityGroupName";
const _SSGOI = "SourceSecurityGroupOwnerId";
const _SSGS = "StaleSecurityGroupSet";
const _SSI = "SourceSnapshotId";
const _SSIo = "SourceSnapshotIds";
const _SSP = "SelfServicePortal";
const _SSPU = "SelfServicePortalUrl";
const _SSS = "StaticSourcesSupport";
const _SSSAMLPA = "SelfServiceSAMLProviderArn";
const _SSSPA = "SelfServiceSamlProviderArn";
const _SST = "SampledStartTime";
const _SSTR = "SlotStartTimeRange";
const _SSe = "ServiceState";
const _SSu = "SupportedStrategies";
const _SSy = "SystemStatus";
const _ST = "SplitTunnel";
const _STA = "SnsTopicArn";
const _STC = "SpotTargetCapacity";
const _STD = "SnapshotTaskDetail";
const _STFR = "StoreTaskFailureReason";
const _STGMG = "SearchTransitGatewayMulticastGroups";
const _STGR = "SearchTransitGatewayRoutes";
const _STH = "SessionTimeoutHours";
const _STR = "SkipTunnelReplacement";
const _STRt = "StateTransitionReason";
const _STS = "SnapshotTierStatuses";
const _STSt = "StoreTaskState";
const _STT = "StateTransitionTime";
const _STa = "SampleTime";
const _STe = "ServiceType";
const _STo = "SourceType";
const _STs = "SseType";
const _STt = "StartTime";
const _STto = "StorageTier";
const _SUC = "SupportedUsageClasses";
const _SV = "SourceVersion";
const _SVESPDV = "StartVpcEndpointServicePrivateDnsVerification";
const _SVI = "SubsystemVendorId";
const _SVT = "SupportedVirtualizationTypes";
const _SVh = "ShellVersion";
const _SVo = "SourceVpc";
const _SVu = "SupportedVersions";
const _SWD = "StartWeekDay";
const _S_ = "S3";
const _Sc = "Scope";
const _Sco = "Score";
const _Scop = "Scopes";
const _Se = "Service";
const _Set = "Settings";
const _Si = "Signature";
const _Siz = "Size";
const _Sn = "Snapshots";
const _So = "Sources";
const _Soc = "Sockets";
const _Sof = "Software";
const _St = "Storage";
const _Sta = "Statistic";
const _Star = "Start";
const _Stat = "State";
const _Statu = "Status";
const _Status = "Statuses";
const _Str = "Strategy";
const _Su = "Subnet";
const _Sub = "Subscriptions";
const _Subn = "Subnets";
const _Suc = "Successful";
const _Succ = "Success";
const _T = "Type";
const _TAAC = "TotalAvailableAddressCount";
const _TAC = "TotalAddressCount";
const _TAI = "TransferAccountId";
const _TC = "TargetConfigurations";
const _TCS = "TargetCapacitySpecification";
const _TCUT = "TargetCapacityUnitType";
const _TCVC = "TerminateClientVpnConnections";
const _TCVR = "TargetConfigurationValueRollup";
const _TCVS = "TargetConfigurationValueSet";
const _TCa = "TargetCapacity";
const _TCar = "TargetConfiguration";
const _TCo = "TotalCapacity";
const _TD = "TrafficDirection";
const _TDe = "TerminationDelay";
const _TE = "TargetEnvironment";
const _TED = "TermEndDate";
const _TET = "TcpEstablishedTimeout";
const _TEo = "TokenEndpoint";
const _TFC = "TotalFulfilledCapacity";
const _TFMIMB = "TotalFpgaMemoryInMiB";
const _TG = "TargetGroups";
const _TGA = "TransitGatewayAddress";
const _TGAI = "TransitGatewayAttachmentId";
const _TGAIr = "TransitGatewayAttachmentIds";
const _TGAP = "TransitGatewayAttachmentPropagations";
const _TGAr = "TransitGatewayAttachments";
const _TGAra = "TransitGatewayAttachment";
const _TGAran = "TransitGatewayArn";
const _TGArans = "TransitGatewayAsn";
const _TGC = "TargetGroupsConfig";
const _TGCB = "TransitGatewayCidrBlocks";
const _TGCP = "TransitGatewayConnectPeer";
const _TGCPI = "TransitGatewayConnectPeerId";
const _TGCPIr = "TransitGatewayConnectPeerIds";
const _TGCPr = "TransitGatewayConnectPeers";
const _TGCr = "TransitGatewayConnect";
const _TGCra = "TransitGatewayConnects";
const _TGI = "TransitGatewayId";
const _TGIr = "TransitGatewayIds";
const _TGMD = "TransitGatewayMulticastDomain";
const _TGMDA = "TransitGatewayMulticastDomainArn";
const _TGMDI = "TransitGatewayMulticastDomainId";
const _TGMDIr = "TransitGatewayMulticastDomainIds";
const _TGMDr = "TransitGatewayMulticastDomains";
const _TGMIMB = "TotalGpuMemoryInMiB";
const _TGOI = "TransitGatewayOwnerId";
const _TGPA = "TransitGatewayPeeringAttachment";
const _TGPAr = "TransitGatewayPeeringAttachments";
const _TGPLR = "TransitGatewayPrefixListReference";
const _TGPLRr = "TransitGatewayPrefixListReferences";
const _TGPT = "TransitGatewayPolicyTable";
const _TGPTE = "TransitGatewayPolicyTableEntries";
const _TGPTI = "TransitGatewayPolicyTableId";
const _TGPTIr = "TransitGatewayPolicyTableIds";
const _TGPTr = "TransitGatewayPolicyTables";
const _TGRT = "TransitGatewayRouteTable";
const _TGRTA = "TransitGatewayRouteTableAnnouncement";
const _TGRTAI = "TransitGatewayRouteTableAnnouncementId";
const _TGRTAIr = "TransitGatewayRouteTableAnnouncementIds";
const _TGRTAr = "TransitGatewayRouteTableAnnouncements";
const _TGRTI = "TransitGatewayRouteTableId";
const _TGRTIr = "TransitGatewayRouteTableIds";
const _TGRTP = "TransitGatewayRouteTablePropagations";
const _TGRTR = "TransitGatewayRouteTableRoute";
const _TGRTr = "TransitGatewayRouteTables";
const _TGVA = "TransitGatewayVpcAttachment";
const _TGVAr = "TransitGatewayVpcAttachments";
const _TGr = "TransitGateway";
const _TGra = "TransitGateways";
const _THP = "TotalHourlyPrice";
const _TI = "TerminateInstances";
const _TIC = "TunnelInsideCidr";
const _TICo = "TotalInstanceCount";
const _TII = "TrunkInterfaceId";
const _TIIC = "TunnelInsideIpv6Cidr";
const _TIIV = "TunnelInsideIpVersion";
const _TIMIMB = "TotalInferenceMemoryInMiB";
const _TIWE = "TerminateInstancesWithExpiration";
const _TIa = "TargetId";
const _TIar = "TargetIops";
const _TIe = "TenantId";
const _TIer = "TerminatingInstances";
const _TLSGB = "TotalLocalStorageGB";
const _TMAE = "TargetMultiAttachEnabled";
const _TMF = "TrafficMirrorFilter";
const _TMFI = "TrafficMirrorFilterId";
const _TMFIr = "TrafficMirrorFilterIds";
const _TMFR = "TrafficMirrorFilterRule";
const _TMFRI = "TrafficMirrorFilterRuleId";
const _TMFRIr = "TrafficMirrorFilterRuleIds";
const _TMFRr = "TrafficMirrorFilterRules";
const _TMFr = "TrafficMirrorFilters";
const _TMMIMB = "TotalMediaMemoryInMiB";
const _TMS = "TrafficMirrorSession";
const _TMSI = "TrafficMirrorSessionId";
const _TMSIr = "TrafficMirrorSessionIds";
const _TMSr = "TrafficMirrorSessions";
const _TMT = "TrafficMirrorTarget";
const _TMTI = "TrafficMirrorTargetId";
const _TMTIr = "TrafficMirrorTargetIds";
const _TMTr = "TrafficMirrorTargets";
const _TN = "TokenName";
const _TNC = "TargetNetworkCidr";
const _TNDMIMB = "TotalNeuronDeviceMemoryInMiB";
const _TNI = "TargetNetworkId";
const _TO = "TunnelOptions";
const _TOAT = "TransferOfferAcceptedTimestamp";
const _TOET = "TransferOfferExpirationTimestamp";
const _TP = "ToPort";
const _TPC = "ThreadsPerCore";
const _TPT = "TrustProviderType";
const _TPr = "TransportProtocol";
const _TR = "ThroughResources";
const _TRC = "TargetResourceCount";
const _TRD = "TemporaryRestoreDays";
const _TRTI = "TargetRouteTableId";
const _TRi = "TimeRanges";
const _TS = "TagSpecifications";
const _TSD = "TermStartDate";
const _TSIGB = "TotalSizeInGB";
const _TSIH = "TotalScheduledInstanceHours";
const _TST = "TieringStartTime";
const _TSTa = "TaskStartTime";
const _TSa = "TargetSubnet";
const _TSag = "TagSet";
const _TSagp = "TagSpecification";
const _TSar = "TargetSize";
const _TSas = "TaskState";
const _TSp = "TpmSupport";
const _TT = "TrafficType";
const _TTC = "TotalTargetCapacity";
const _TTGAI = "TransportTransitGatewayAttachmentId";
const _TTa = "TargetThroughput";
const _TTr = "TransferType";
const _TUP = "TotalUpfrontPrice";
const _TV = "TargetVersion";
const _TVC = "TotalVCpus";
const _TVSI = "TargetVpcSubnetId";
const _TVT = "TargetVolumeType";
const _TVo = "TokenValue";
const _Ta = "Tags";
const _Tag = "Tag";
const _Te = "Tenancy";
const _Ter = "Term";
const _Th = "Throughput";
const _Ti = "Tier";
const _Tim = "Timestamp";
const _To = "To";
const _U = "Url";
const _UB = "UserBucket";
const _UD = "UserData";
const _UDLTV = "UnsuccessfullyDeletedLaunchTemplateVersions";
const _UDe = "UefiData";
const _UDp = "UpdatedDate";
const _UDpd = "UpdateDate";
const _UE = "UploadEnd";
const _UF = "UpfrontFee";
const _UFD = "UnsuccessfulFleetDeletions";
const _UFR = "UnsuccessfulFleetRequests";
const _UG = "UserGroups";
const _UI = "UnmonitorInstances";
const _UIA = "UnassignIpv6Addresses";
const _UIAn = "UnassignedIpv6Addresses";
const _UIC = "UsedInstanceCount";
const _UICS = "UnsuccessfulInstanceCreditSpecifications";
const _UIE = "UserInfoEndpoint";
const _UIGP = "UserIdGroupPairs";
const _UIP = "UnknownIpPermissions";
const _UIPn = "UnassignedIpv6Prefixes";
const _UIs = "UserId";
const _UIse = "UserIds";
const _ULI = "UseLongIds";
const _ULIA = "UseLongIdsAggregated";
const _UO = "UsageOperation";
const _UOUT = "UsageOperationUpdateTime";
const _UP = "UploadPolicy";
const _UPIA = "UnassignPrivateIpAddresses";
const _UPNGA = "UnassignPrivateNatGatewayAddress";
const _UPS = "UploadPolicySignature";
const _UPp = "UpfrontPrice";
const _UPs = "UsagePrice";
const _URBOI = "UnusedReservationBillingOwnerId";
const _US = "UnlockSnapshot";
const _USGRDE = "UpdateSecurityGroupRuleDescriptionsEgress";
const _USGRDI = "UpdateSecurityGroupRuleDescriptionsIngress";
const _UST = "UdpStreamTimeout";
const _USp = "UploadSize";
const _USpl = "UploadStart";
const _USs = "UsageStrategy";
const _UT = "UdpTimeout";
const _UTP = "UserTrustProvider";
const _UTPT = "UserTrustProviderType";
const _UTp = "UpdateTime";
const _Un = "Unsuccessful";
const _Us = "Username";
const _V = "Version";
const _VA = "VpcAttachment";
const _VAE = "VerifiedAccessEndpoint";
const _VAEI = "VerifiedAccessEndpointId";
const _VAEIe = "VerifiedAccessEndpointIds";
const _VAET = "VerifiedAccessEndpointTargets";
const _VAETD = "VerifiedAccessEndpointTargetDns";
const _VAETIA = "VerifiedAccessEndpointTargetIpAddress";
const _VAEe = "VerifiedAccessEndpoints";
const _VAG = "VerifiedAccessGroup";
const _VAGA = "VerifiedAccessGroupArn";
const _VAGI = "VerifiedAccessGroupId";
const _VAGIe = "VerifiedAccessGroupIds";
const _VAGe = "VerifiedAccessGroups";
const _VAI = "VerifiedAccessInstance";
const _VAII = "VerifiedAccessInstanceId";
const _VAIIe = "VerifiedAccessInstanceIds";
const _VAIe = "VerifiedAccessInstances";
const _VATP = "VerifiedAccessTrustProvider";
const _VATPI = "VerifiedAccessTrustProviderId";
const _VATPIe = "VerifiedAccessTrustProviderIds";
const _VATPe = "VerifiedAccessTrustProviders";
const _VAp = "VpcAttachments";
const _VBPAE = "VpcBlockPublicAccessExclusion";
const _VBPAEp = "VpcBlockPublicAccessExclusions";
const _VBPAO = "VpcBlockPublicAccessOptions";
const _VC = "VpnConnection";
const _VCC = "VCpuCount";
const _VCDSC = "VpnConnectionDeviceSampleConfiguration";
const _VCDT = "VpnConnectionDeviceTypes";
const _VCDTI = "VpnConnectionDeviceTypeId";
const _VCI = "VpnConnectionId";
const _VCIp = "VpnConnectionIds";
const _VCIpu = "VCpuInfo";
const _VCa = "ValidCores";
const _VCp = "VpnConnections";
const _VD = "VersionDescription";
const _VE = "VpcEndpoint";
const _VEA = "VpcEndpointAssociations";
const _VEC = "VpcEndpointConnections";
const _VECI = "VpcEncryptionControlId";
const _VECIp = "VpcEndpointConnectionId";
const _VEI = "VpcEndpointIds";
const _VEIp = "VpcEndpointId";
const _VEO = "VpcEndpointOwner";
const _VEPS = "VpcEndpointPolicySupported";
const _VER = "VpcEndpointRegion";
const _VES = "VpnEcmpSupport";
const _VESp = "VpcEndpointService";
const _VESpc = "VpcEndpointState";
const _VET = "VpcEndpointType";
const _VEp = "VpcEndpoints";
const _VF = "ValidFrom";
const _VFR = "ValidationFailureReason";
const _VG = "VpnGateway";
const _VGI = "VpnGatewayId";
const _VGIp = "VpnGatewayIds";
const _VGp = "VpnGateways";
const _VI = "VpcId";
const _VIe = "VendorId";
const _VIl = "VlanId";
const _VIo = "VolumeId";
const _VIol = "VolumeIds";
const _VIp = "VpcIds";
const _VM = "VerificationMethod";
const _VMo = "VolumesModifications";
const _VMol = "VolumeModification";
const _VN = "VirtualName";
const _VNI = "VirtualNetworkId";
const _VNe = "VersionNumber";
const _VOI = "VolumeOwnerId";
const _VOIp = "VpcOwnerId";
const _VP = "VpnPort";
const _VPC = "VpcPeeringConnection";
const _VPCI = "VpcPeeringConnectionId";
const _VPCIp = "VpcPeeringConnectionIds";
const _VPCp = "VpcPeeringConnections";
const _VPG = "VirtualPrivateGateway";
const _VPp = "VpnProtocol";
const _VPpc = "VpcPeering";
const _VS = "VolumeSize";
const _VSo = "VolumeStatuses";
const _VSol = "VolumeStatus";
const _VT = "VolumeType";
const _VTOIA = "VpnTunnelOutsideIpAddress";
const _VTPC = "ValidThreadsPerCore";
const _VTg = "VgwTelemetry";
const _VTi = "VirtualizationTypes";
const _VTir = "VirtualizationType";
const _VU = "ValidUntil";
const _Va = "Value";
const _Val = "Values";
const _Ve = "Versions";
const _Ven = "Vendor";
const _Vl = "Vlan";
const _Vo = "Volume";
const _Vol = "Volumes";
const _Vp = "Vpc";
const _Vpc = "Vpcs";
const _W = "Weight";
const _WBC = "WithdrawByoipCidr";
const _WC = "WithCooldown";
const _WCe = "WeightedCapacity";
const _WM = "WarningMessage";
const _WU = "WakeUp";
const _Wa = "Warning";
const _ZI = "ZoneIds";
const _ZIo = "ZoneId";
const _ZN = "ZoneNames";
const _ZNo = "ZoneName";
const _ZT = "ZoneType";
const _a = "associations";
const _aA = "asnAssociation";
const _aAC = "availableAddressCount";
const _aAI = "awsAccountId";
const _aAId = "addressAllocationId";
const _aAS = "asnAssociationSet";
const _aASA = "autoAcceptSharedAssociations";
const _aASAu = "autoAcceptSharedAttachments";
const _aASc = "accountAttributeSet";
const _aASd = "additionalAccountSet";
const _aAc = "accessAll";
const _aBHP = "actualBlockHourlyPrice";
const _aC = "availableCapacity";
const _aCIA = "associateCarrierIpAddress";
const _aCT = "archivalCompleteTime";
const _aCc = "acceleratorCount";
const _aCd = "addressCount";
const _aD = "activeDirectory";
const _aDNL = "allocationDefaultNetmaskLength";
const _aDRFRV = "allowDnsResolutionFromRemoteVpc";
const _aDRTI = "associationDefaultRouteTableId";
const _aDS = "additionalDetailSet";
const _aDT = "additionalDetailType";
const _aDn = "announcementDirection";
const _aDp = "applicationDomain";
const _aE = "authorizationEndpoint";
const _aEC = "analyzedEniCount";
const _aEFLCLTRV = "allowEgressFromLocalClassicLinkToRemoteVpc";
const _aEFLVTRCL = "allowEgressFromLocalVpcToRemoteClassicLink";
const _aEIO = "autoEnableIO";
const _aES = "attachedEbsStatus";
const _aF = "addressFamily";
const _aFS = "analysisFindingSet";
const _aI = "allocationId";
const _aIA = "assignedIpv6Addresses";
const _aIAC = "availableIpAddressCount";
const _aIAOC = "assignIpv6AddressOnCreation";
const _aIC = "availableInstanceCapacity";
const _aICv = "availableInstanceCount";
const _aIPS = "assignedIpv6PrefixSet";
const _aIPSs = "assignedIpv4PrefixSet";
const _aIS = "activeInstanceSet";
const _aISS = "allowedImagesSettingsState";
const _aITS = "allowedInstanceTypeSet";
const _aIc = "accountId";
const _aIm = "amiId";
const _aIs = "associationId";
const _aIss = "assetId";
const _aIt = "attachmentId";
const _aIu = "autoImport";
const _aL = "accountLevel";
const _aLI = "amiLaunchIndex";
const _aLc = "accessLogs";
const _aMIT = "allowsMultipleInstanceTypes";
const _aMNL = "allocationMinNetmaskLength";
const _aMNLl = "allocationMaxNetmaskLength";
const _aMS = "acceleratorManufacturerSet";
const _aMSp = "applianceModeSupport";
const _aN = "attributeName";
const _aNS = "acceleratorNameSet";
const _aO = "authenticationOptions";
const _aOI = "addressOwnerId";
const _aP = "allowedPrincipals";
const _aPCO = "accepterPeeringConnectionOptions";
const _aPHS = "alternatePathHintSet";
const _aPIA = "associatePublicIpAddress";
const _aPIAS = "assignedPrivateIpAddressesSet";
const _aPS = "addedPrincipalSet";
const _aPSs = "asPathSet";
const _aPu = "autoPlacement";
const _aR = "authorizationRule";
const _aRA = "associatedRoleArn";
const _aRAd = "additionalRoutesAvailable";
const _aRAs = "associatedResourceAccessibility";
const _aRAss = "associatedResourceArn";
const _aRC = "acceptedRouteCount";
const _aRP = "areRoutesPersisted";
const _aRS = "associatedRoleSet";
const _aRSu = "autoRecoverySupported";
const _aRTS = "allocationResourceTagSet";
const _aRc = "aclRule";
const _aRcc = "acceptanceRequired";
const _aRd = "addressRegion";
const _aRs = "associatedResource";
const _aRu = "autoRecovery";
const _aRw = "awsRegion";
const _aS = "associationState";
const _aSA = "amazonSideAsn";
const _aSS = "amdSevSnp";
const _aSSt = "attributeSummarySet";
const _aSc = "activityStatus";
const _aSct = "actionsSet";
const _aSd = "addressSet";
const _aSdd = "addressesSet";
const _aSl = "allocationStrategy";
const _aSn = "analysisStatus";
const _aSs = "associationStatus";
const _aSss = "associationSet";
const _aSt = "attachmentSet";
const _aStt = "attachmentStatuses";
const _aSw = "awsService";
const _aT = "addressTransfer";
const _aTGAI = "accepterTransitGatewayAttachmentId";
const _aTI = "accepterTgwInfo";
const _aTMMB = "acceleratorTotalMemoryMiB";
const _aTN = "associatedTargetNetwork";
const _aTS = "addressTransferStatus";
const _aTSc = "acceleratorTypeSet";
const _aTSd = "addressTransferSet";
const _aTd = "addressType";
const _aTdd = "addressingType";
const _aTl = "allocationType";
const _aTll = "allocationTime";
const _aTs = "associationTarget";
const _aTt = "attachTime";
const _aTtt = "attachedTo";
const _aTtta = "attachmentType";
const _aV = "attributeValue";
const _aVC = "availableVCpus";
const _aVI = "accepterVpcInfo";
const _aVS = "attributeValueSet";
const _aZ = "availabilityZone";
const _aZG = "availabilityZoneGroup";
const _aZI = "availabilityZoneId";
const _aZIv = "availabilityZoneInfo";
const _aZS = "availabilityZoneSet";
const _ac = "acl";
const _acc = "accelerators";
const _act = "active";
const _ad = "address";
const _af = "affinity";
const _am = "amount";
const _ar = "arn";
const _arc = "architecture";
const _as = "asn";
const _ass = "association";
const _at = "attachment";
const _att = "attachments";
const _b = "byoasn";
const _bA = "bgpAsn";
const _bAE = "bgpAsnExtended";
const _bBIG = "baselineBandwidthInGbps";
const _bBIM = "baselineBandwidthInMbps";
const _bC = "byoipCidr";
const _bCS = "byoipCidrSet";
const _bCg = "bgpConfigurations";
const _bCy = "bytesConverted";
const _bDM = "blockDeviceMapping";
const _bDMS = "blockDeviceMappingSet";
const _bDMl = "blockDurationMinutes";
const _bEBM = "baselineEbsBandwidthMbps";
const _bEDNS = "baseEndpointDnsNameSet";
const _bI = "bundleId";
const _bII = "branchInterfaceId";
const _bIT = "bundleInstanceTask";
const _bITS = "bundleInstanceTasksSet";
const _bIa = "baselineIops";
const _bM = "bootMode";
const _bMa = "bareMetal";
const _bN = "bucketName";
const _bO = "bgpOptions";
const _bOu = "bucketOwner";
const _bP = "burstablePerformance";
const _bPAS = "blockPublicAccessStates";
const _bPF = "baselinePerformanceFactors";
const _bPS = "burstablePerformanceSupported";
const _bS = "byoasnSet";
const _bSf = "bfdStatus";
const _bSg = "bgpStatus";
const _bT = "bannerText";
const _bTIMB = "baselineThroughputInMBps";
const _bW = "bandwidthWeighting";
const _bWa = "bandwidthWeightings";
const _bl = "blackhole";
const _bu = "bucket";
const _c = "component";
const _cA = "componentArn";
const _cAS = "capacityAllocationSet";
const _cAUS = "coipAddressUsageSet";
const _cAe = "certificateArn";
const _cAo = "componentAccount";
const _cAr = "createdAt";
const _cB = "cidrBlock";
const _cBA = "cidrBlockAssociation";
const _cBAS = "cidrBlockAssociationSet";
const _cBDH = "capacityBlockDurationHours";
const _cBDM = "capacityBlockDurationMinutes";
const _cBEDH = "capacityBlockExtensionDurationHours";
const _cBEED = "capacityBlockExtensionEndDate";
const _cBEOI = "capacityBlockExtensionOfferingId";
const _cBEOS = "capacityBlockExtensionOfferingSet";
const _cBEPD = "capacityBlockExtensionPurchaseDate";
const _cBES = "capacityBlockExtensionStatus";
const _cBESD = "capacityBlockExtensionStartDate";
const _cBESa = "capacityBlockExtensionSet";
const _cBOI = "capacityBlockOfferingId";
const _cBOS = "capacityBlockOfferingSet";
const _cBS = "cidrBlockState";
const _cBSi = "cidrBlockSet";
const _cBr = "createdBy";
const _cC = "currencyCode";
const _cCB = "clientCidrBlock";
const _cCO = "clientConnectOptions";
const _cCRFE = "cancelCapacityReservationFleetError";
const _cCl = "clientConfiguration";
const _cCo = "coreCount";
const _cCoi = "coipCidr";
const _cCp = "cpuCredits";
const _cD = "createDate";
const _cDM = "completionDurationMinutes";
const _cDr = "creationDate";
const _cDre = "createdDate";
const _cE = "connectionEvents";
const _cECSD = "cidrEndpointsCustomSubDomain";
const _cED = "commitmentEndDate";
const _cET = "connectionEstablishedTime";
const _cETo = "connectionEndTime";
const _cEr = "cronExpression";
const _cF = "containerFormat";
const _cFS = "currentFleetState";
const _cG = "carrierGateway";
const _cGC = "customerGatewayConfiguration";
const _cGI = "carrierGatewayId";
const _cGIu = "customerGatewayId";
const _cGS = "carrierGatewaySet";
const _cGSu = "customerGatewaySet";
const _cGu = "customerGateway";
const _cGur = "currentGeneration";
const _cI = "carrierIp";
const _cIBM = "currentInstanceBootMode";
const _cIC = "committedInstanceCount";
const _cIi = "cidrIp";
const _cIid = "cidrIpv6";
const _cIidr = "cidrIpv4";
const _cIl = "clientIp";
const _cIli = "clientId";
const _cIo = "componentId";
const _cIom = "commitmentInfo";
const _cIon = "connectionId";
const _cIop = "coIp";
const _cIor = "coreInfo";
const _cLB = "classicLoadBalancers";
const _cLBC = "classicLoadBalancersConfig";
const _cLBL = "classicLoadBalancerListener";
const _cLBO = "clientLoginBannerOptions";
const _cLDS = "classicLinkDnsSupported";
const _cLE = "classicLinkEnabled";
const _cLO = "connectionLogOptions";
const _cMKE = "customerManagedKeyEnabled";
const _cMS = "cpuManufacturerSet";
const _cN = "commonName";
const _cNA = "coreNetworkArn";
const _cNAA = "coreNetworkAttachmentArn";
const _cNAo = "connectionNotificationArn";
const _cNI = "connectionNotificationId";
const _cNIo = "coreNetworkId";
const _cNS = "connectionNotificationState";
const _cNSo = "connectionNotificationSet";
const _cNT = "connectionNotificationType";
const _cNo = "connectionNotification";
const _cO = "cpuOptions";
const _cOI = "customerOwnedIp";
const _cOIP = "customerOwnedIpv4Pool";
const _cOP = "coolOffPeriod";
const _cOPEO = "coolOffPeriodExpiresOn";
const _cOi = "cidrOptions";
const _cP = "coipPool";
const _cPC = "connectPeerConfiguration";
const _cPI = "coipPoolId";
const _cPS = "coipPoolSet";
const _cR = "capacityReservation";
const _cRA = "capacityReservationArn";
const _cRBRS = "capacityReservationBillingRequestSet";
const _cRCC = "clientRootCertificateChain";
const _cRFA = "capacityReservationFleetArn";
const _cRFI = "capacityReservationFleetId";
const _cRFS = "capacityReservationFleetSet";
const _cRGS = "capacityReservationGroupSet";
const _cRI = "capacityReservationId";
const _cRIa = "capacityReservationInfo";
const _cRL = "certificateRevocationList";
const _cRO = "capacityReservationOptions";
const _cRP = "capacityReservationPreference";
const _cRRGA = "capacityReservationResourceGroupArn";
const _cRS = "capacityReservationSet";
const _cRSa = "capacityReservationSpecification";
const _cRT = "capacityReservationTarget";
const _cRa = "capacityRebalance";
const _cRo = "componentRegion";
const _cS = "cidrSet";
const _cSBN = "certificateS3BucketName";
const _cSFRS = "currentSpotFleetRequestState";
const _cSOK = "certificateS3ObjectKey";
const _cSl = "clientSecret";
const _cSo = "complianceStatus";
const _cSon = "connectionStatuses";
const _cSr = "creditSpecification";
const _cSu = "currentState";
const _cSur = "currentStatus";
const _cT = "clientToken";
const _cTC = "connectionTrackingConfiguration";
const _cTI = "conversionTaskId";
const _cTS = "connectionTrackingSpecification";
const _cTo = "conversionTasks";
const _cTom = "completeTime";
const _cTomp = "completionTime";
const _cTon = "conversionTask";
const _cTonn = "connectivityType";
const _cTr = "createTime";
const _cTre = "creationTime";
const _cTrea = "creationTimestamp";
const _cVE = "clientVpnEndpoint";
const _cVEI = "clientVpnEndpointId";
const _cVP = "createVolumePermission";
const _cVTN = "clientVpnTargetNetworks";
const _cWL = "cloudWatchLogs";
const _cWLO = "cloudWatchLogOptions";
const _ca = "category";
const _ch = "checksum";
const _ci = "cidr";
const _co = "code";
const _con = "connections";
const _conf = "configured";
const _confi = "config";
const _cont = "context";
const _cor = "cores";
const _cou = "count";
const _cp = "cpu";
const _d = "destination";
const _dA = "destinationArn";
const _dAIT = "denyAllIgwTraffic";
const _dART = "defaultAssociationRouteTable";
const _dAS = "destinationAddressSet";
const _dASe = "deprovisionedAddressSet";
const _dASi = "disableApiStop";
const _dAT = "disableApiTermination";
const _dAe = "destinationAddress";
const _dC = "destinationCidr";
const _dCA = "domainCertificateArn";
const _dCAR = "deliverCrossAccountRole";
const _dCB = "destinationCidrBlock";
const _dCR = "destinationCapacityReservation";
const _dCS = "dhcpConfigurationSet";
const _dCe = "defaultCores";
const _dE = "dnsEntry";
const _dEKI = "dataEncryptionKeyId";
const _dES = "dnsEntrySet";
const _dFA = "defaultForAz";
const _dHIS = "dedicatedHostIdSet";
const _dHS = "dedicatedHostsSupported";
const _dI = "directoryId";
const _dICB = "destinationIpv6CidrBlock";
const _dIF = "diskImageFormat";
const _dIS = "diskImageSize";
const _dIe = "deviceIndex";
const _dIes = "destinationIp";
const _dLEM = "deliverLogsErrorMessage";
const _dLPA = "deliverLogsPermissionArn";
const _dLS = "deliverLogsStatus";
const _dMGM = "deregisteredMulticastGroupMembers";
const _dMGS = "deregisteredMulticastGroupSources";
const _dN = "deviceName";
const _dNCI = "defaultNetworkCardIndex";
const _dNII = "deregisteredNetworkInterfaceIds";
const _dNn = "dnsName";
const _dO = "dhcpOptions";
const _dOI = "dhcpOptionsId";
const _dOS = "dhcpOptionsSet";
const _dOST = "disconnectOnSessionTimeout";
const _dOT = "deleteOnTermination";
const _dOe = "destinationOptions";
const _dOev = "deviceOptions";
const _dOn = "dnsOptions";
const _dP = "deliveryPreference";
const _dPLI = "destinationPrefixListId";
const _dPLS = "destinationPrefixListSet";
const _dPR = "destinationPortRange";
const _dPRS = "destinationPortRangeSet";
const _dPRT = "defaultPropagationRouteTable";
const _dPS = "destinationPortSet";
const _dPe = "deregistrationProtection";
const _dPes = "destinationPort";
const _dR = "discoveryRegion";
const _dRDAI = "defaultResourceDiscoveryAssociationId";
const _dRDI = "defaultResourceDiscoveryId";
const _dRIT = "dnsRecordIpType";
const _dRRV = "deleteReplacedRootVolume";
const _dRS = "dataRetentionSupport";
const _dRSa = "dataResponseSet";
const _dRTA = "defaultRouteTableAssociation";
const _dRTP = "defaultRouteTablePropagation";
const _dRy = "dynamicRouting";
const _dS = "dnsServer";
const _dSCR = "deletedSubnetCidrReservation";
const _dSe = "destinationSet";
const _dSel = "deliveryStatus";
const _dSeli = "deliveryStream";
const _dSn = "dnsSupport";
const _dT = "deletionTime";
const _dTA = "dpdTimeoutAction";
const _dTCT = "defaultTargetCapacityType";
const _dTPC = "defaultThreadsPerCore";
const _dTPS = "deviceTrustProviderSet";
const _dTPT = "deviceTrustProviderType";
const _dTS = "dpdTimeoutSeconds";
const _dTe = "deprecationTime";
const _dTel = "deleteTime";
const _dTele = "deletionTimestamp";
const _dTi = "disablingTime";
const _dTis = "disabledTime";
const _dV = "destinationVpc";
const _dVC = "defaultVCpus";
const _dVD = "deviceValidationDomain";
const _dVN = "defaultVersionNumber";
const _dVe = "defaultVersion";
const _de = "description";
const _dea = "deadline";
const _def = "default";
const _det = "details";
const _dev = "device";
const _di = "direction";
const _dis = "disks";
const _do = "domain";
const _du = "duration";
const _e = "egress";
const _eA = "eniAddress";
const _eAn = "enableAcceleration";
const _eAx = "exclusionsAllowed";
const _eB = "egressBytes";
const _eC = "errorCode";
const _eCTP = "excessCapacityTerminationPolicy";
const _eCn = "encryptionControl";
const _eCx = "explanationCode";
const _eD = "endDate";
const _eDH = "enableDnsHostnames";
const _eDS = "enableDnsSupport";
const _eDT = "endDateType";
const _eDf = "effectiveDate";
const _eDn = "enableDns64";
const _eDnd = "endpointDomain";
const _eDv = "eventDescription";
const _eEA = "endpointEniAddress";
const _eEBD = "ebsEncryptionByDefault";
const _eEI = "endpointEniId";
const _eFRS = "egressFilterRuleSet";
const _eGAI = "elasticGpuAssociationId";
const _eGAS = "elasticGpuAssociationState";
const _eGASl = "elasticGpuAssociationSet";
const _eGAT = "elasticGpuAssociationTime";
const _eGH = "elasticGpuHealth";
const _eGI = "elasticGpuId";
const _eGS = "elasticGpuSet";
const _eGSS = "elasticGpuSpecificationSet";
const _eGSl = "elasticGpuState";
const _eGT = "elasticGpuType";
const _eH = "endHour";
const _eI = "exchangeId";
const _eIAA = "elasticInferenceAcceleratorArn";
const _eIAAI = "elasticInferenceAcceleratorAssociationId";
const _eIAAS = "elasticInferenceAcceleratorAssociationState";
const _eIAASl = "elasticInferenceAcceleratorAssociationSet";
const _eIAAT = "elasticInferenceAcceleratorAssociationTime";
const _eIAS = "elasticInferenceAcceleratorSet";
const _eITI = "exportImageTaskId";
const _eITS = "exportImageTaskSet";
const _eITSn = "encryptionInTransitSupported";
const _eITSx = "excludedInstanceTypeSet";
const _eIb = "ebsInfo";
const _eIf = "efaInfo";
const _eIn = "eniId";
const _eIv = "eventInformation";
const _eIve = "eventId";
const _eIx = "exclusionId";
const _eKKI = "encryptionKmsKeyId";
const _eLADI = "enableLniAtDeviceIndex";
const _eLBL = "elasticLoadBalancerListener";
const _eM = "errorMessage";
const _eNAUM = "enableNetworkAddressUsageMetrics";
const _eO = "ebsOptimized";
const _eOI = "ebsOptimizedInfo";
const _eOIG = "egressOnlyInternetGateway";
const _eOIGI = "egressOnlyInternetGatewayId";
const _eOIGS = "egressOnlyInternetGatewaySet";
const _eOS = "ebsOptimizedSupport";
const _eOn = "enclaveOptions";
const _eP = "egressPackets";
const _ePG = "enablePrivateGua";
const _ePS = "excludePathSet";
const _eRNDAAAAR = "enableResourceNameDnsAAAARecord";
const _eRNDAR = "enableResourceNameDnsARecord";
const _eS = "ephemeralStorage";
const _eSE = "enaSrdEnabled";
const _eSS = "enaSrdSpecification";
const _eSSn = "enaSrdSupported";
const _eST = "eventSubType";
const _eSUE = "enaSrdUdpEnabled";
const _eSUS = "enaSrdUdpSpecification";
const _eSf = "efaSupported";
const _eSn = "encryptionSupport";
const _eSna = "enaSupport";
const _eSnt = "entrySet";
const _eSr = "errorSet";
const _eSv = "eventsSet";
const _eSx = "explanationSet";
const _eT = "expirationTime";
const _eTI = "exportTaskId";
const _eTLC = "enableTunnelLifecycleControl";
const _eTS = "exportTaskSet";
const _eTSi = "eipTagSet";
const _eTSx = "exportToS3";
const _eTn = "endTime";
const _eTna = "enablingTime";
const _eTnab = "enabledTime";
const _eTnd = "endpointType";
const _eTv = "eventType";
const _eTx = "exportTask";
const _eWD = "endWeekDay";
const _eb = "ebs";
const _en = "enabled";
const _enc = "encrypted";
const _end = "end";
const _er = "error";
const _ev = "event";
const _f = "format";
const _fA = "federatedAuthentication";
const _fAD = "filterAtDestination";
const _fAS = "filterAtSource";
const _fAi = "firstAddress";
const _fC = "fulfilledCapacity";
const _fCRS = "fleetCapacityReservationSet";
const _fCS = "findingComponentSet";
const _fCa = "failureCode";
const _fDN = "fipsDnsName";
const _fE = "fipsEnabled";
const _fF = "fileFormat";
const _fFCS = "failedFleetCancellationSet";
const _fFi = "findingsFound";
const _fI = "findingId";
const _fIA = "fpgaImageAttribute";
const _fIAS = "filterInArnSet";
const _fIGI = "fpgaImageGlobalId";
const _fII = "fpgaImageId";
const _fIS = "fleetInstanceSet";
const _fISp = "fpgaImageSet";
const _fIl = "fleetId";
const _fIp = "fpgaInfo";
const _fLI = "flowLogId";
const _fLIS = "flowLogIdSet";
const _fLISa = "fastLaunchImageSet";
const _fLS = "flowLogSet";
const _fLSl = "flowLogStatus";
const _fM = "failureMessage";
const _fODC = "fulfilledOnDemandCapacity";
const _fP = "fromPort";
const _fPCS = "forwardPathComponentSet";
const _fPi = "fixedPrice";
const _fQPDS = "failedQueuedPurchaseDeletionSet";
const _fR = "failureReason";
const _fRa = "fastRestored";
const _fS = "fleetSet";
const _fSR = "firewallStatelessRule";
const _fSRS = "fastSnapshotRestoreSet";
const _fSRSES = "fastSnapshotRestoreStateErrorSet";
const _fSRi = "firewallStatefulRule";
const _fSSIB = "fullSnapshotSizeInBytes";
const _fSST = "firstSlotStartTime";
const _fSl = "fleetState";
const _fTE = "freeTierEligible";
const _fa = "fault";
const _fp = "fpgas";
const _fr = "from";
const _fre = "frequency";
const _g = "group";
const _gA = "groupArn";
const _gAS = "gatewayAssociationState";
const _gD = "groupDescription";
const _gI = "gatewayId";
const _gIA = "groupIpAddress";
const _gIp = "gpuInfo";
const _gIr = "groupId";
const _gK = "greKey";
const _gLBAS = "gatewayLoadBalancerArnSet";
const _gLBEI = "gatewayLoadBalancerEndpointId";
const _gLN = "groupLongName";
const _gM = "groupMember";
const _gN = "groupName";
const _gOI = "groupOwnerId";
const _gS = "groupSet";
const _gSr = "groupSource";
const _gp = "gpus";
const _gr = "groups";
const _h = "hypervisor";
const _hCP = "hiveCompatiblePartitions";
const _hE = "httpEndpoint";
const _hI = "hostId";
const _hIS = "hostIdSet";
const _hM = "hostMaintenance";
const _hO = "hibernationOptions";
const _hP = "hostProperties";
const _hPI = "httpProtocolIpv6";
const _hPRHL = "httpPutResponseHopLimit";
const _hPo = "hourlyPrice";
const _hR = "hostRecovery";
const _hRGA = "hostResourceGroupArn";
const _hRI = "hostReservationId";
const _hRS = "historyRecordSet";
const _hRSo = "hostReservationSet";
const _hS = "hostSet";
const _hSi = "hibernationSupported";
const _hT = "httpTokens";
const _hTo = "hostnameType";
const _hZI = "hostedZoneId";
const _i = "item";
const _iA = "interfaceAssociation";
const _iAA = "ipv6AddressAttribute";
const _iAC = "ipv6AddressCount";
const _iAI = "inferenceAcceleratorInfo";
const _iAPI = "ipv4AddressesPerInterface";
const _iAPIp = "ipv6AddressesPerInterface";
const _iAS = "interfaceAssociationSet";
const _iASp = "ipv6AddressesSet";
const _iAT = "ipAddressType";
const _iATOI = "includeAllTagsOfInstance";
const _iAm = "imageAllowed";
const _iAp = "ipAddress";
const _iApa = "ipamArn";
const _iApv = "ipv6Address";
const _iB = "ingressBytes";
const _iBPAS = "imageBlockPublicAccessState";
const _iC = "instanceCount";
const _iCAS = "ipv6CidrAssociationSet";
const _iCB = "ipv6CidrBlock";
const _iCBA = "ipv6CidrBlockAssociation";
const _iCBAS = "ipv6CidrBlockAssociationSet";
const _iCBS = "ipv6CidrBlockState";
const _iCBSp = "ipv6CidrBlockSet";
const _iCBn = "insideCidrBlocks";
const _iCE = "instanceConnectEndpoint";
const _iCEA = "instanceConnectEndpointArn";
const _iCEI = "instanceConnectEndpointId";
const _iCES = "instanceConnectEndpointSet";
const _iCS = "imageCriterionSet";
const _iCSS = "instanceCreditSpecificationSet";
const _iCn = "instanceCounts";
const _iCp = "ipv6Cidr";
const _iD = "imageData";
const _iDAS = "ipamDiscoveredAccountSet";
const _iDPAS = "ipamDiscoveredPublicAddressSet";
const _iDRCS = "ipamDiscoveredResourceCidrSet";
const _iDs = "isDefault";
const _iE = "instanceExport";
const _iEI = "instanceEventId";
const _iERVT = "ipamExternalResourceVerificationToken";
const _iERVTA = "ipamExternalResourceVerificationTokenArn";
const _iERVTI = "ipamExternalResourceVerificationTokenId";
const _iERVTS = "ipamExternalResourceVerificationTokenSet";
const _iEW = "instanceEventWindow";
const _iEWI = "instanceEventWindowId";
const _iEWS = "instanceEventWindowState";
const _iEWSn = "instanceEventWindowSet";
const _iEs = "isEgress";
const _iF = "instanceFamily";
const _iFCS = "instanceFamilyCreditSpecification";
const _iFR = "iamFleetRole";
const _iFRS = "ingressFilterRuleSet";
const _iG = "internetGateway";
const _iGBM = "internetGatewayBlockMode";
const _iGEM = "internetGatewayExclusionMode";
const _iGI = "internetGatewayId";
const _iGS = "internetGatewaySet";
const _iGSn = "instanceGenerationSet";
const _iH = "instanceHealth";
const _iHn = "inboundHeader";
const _iI = "instanceId";
const _iIB = "instanceInterruptionBehavior";
const _iIMS = "instanceImageMetadataSet";
const _iIP = "iamInstanceProfile";
const _iIPA = "iamInstanceProfileAssociation";
const _iIPAS = "iamInstanceProfileAssociationSet";
const _iIS = "instanceIdSet";
const _iISB = "instanceInitiatedShutdownBehavior";
const _iITS = "importImageTaskSet";
const _iIm = "importInstance";
const _iIma = "imageId";
const _iIn = "instanceIds";
const _iIp = "ipamId";
const _iL = "imageLocation";
const _iLn = "instanceLifecycle";
const _iM = "imageMetadata";
const _iMC = "instanceMatchCriteria";
const _iMO = "instanceMetadataOptions";
const _iMOn = "instanceMarketOptions";
const _iMT = "instanceMetadataTags";
const _iMU = "importManifestUrl";
const _iN = "ipv6Native";
const _iOA = "imageOwnerAlias";
const _iOI = "imageOwnerId";
const _iOIn = "instanceOwnerId";
const _iOIp = "ipOwnerId";
const _iOS = "instanceOwningService";
const _iP = "instancePort";
const _iPA = "ipamPoolAllocation";
const _iPAI = "ipamPoolAllocationId";
const _iPAS = "ipamPoolAllocationSet";
const _iPAp = "ipamPoolArn";
const _iPC = "ipamPoolCidr";
const _iPCI = "ipamPoolCidrId";
const _iPCS = "ipamPoolCidrSet";
const _iPCp = "ipv4PrefixCount";
const _iPCpv = "ipv6PrefixCount";
const _iPE = "ipPermissionsEgress";
const _iPI = "isPrimaryIpv6";
const _iPIp = "ipamPoolId";
const _iPR = "isPermanentRestore";
const _iPS = "ipamPoolSet";
const _iPSm = "imageProviderSet";
const _iPSp = "ipv6PoolSet";
const _iPSpr = "ipPrefixSet";
const _iPSpv = "ipv4PrefixSet";
const _iPSpvr = "ipv6PrefixSet";
const _iPTUC = "instancePoolsToUseCount";
const _iPn = "instancePlatform";
const _iPng = "ingressPackets";
const _iPnt = "interfacePermission";
const _iPnte = "interfaceProtocol";
const _iPo = "ioPerformance";
const _iPp = "ipamPool";
const _iPpe = "ipPermissions";
const _iPpr = "ipProtocol";
const _iPpv = "ipv4Prefix";
const _iPpvo = "ipv6Pool";
const _iPpvr = "ipv6Prefix";
const _iPs = "isPublic";
const _iPsr = "isPrimary";
const _iR = "instanceRequirements";
const _iRC = "ipamResourceCidr";
const _iRCS = "ipamResourceCidrSet";
const _iRD = "ipamResourceDiscovery";
const _iRDA = "ipamResourceDiscoveryAssociation";
const _iRDAA = "ipamResourceDiscoveryAssociationArn";
const _iRDAI = "ipamResourceDiscoveryAssociationId";
const _iRDAS = "ipamResourceDiscoveryAssociationSet";
const _iRDAp = "ipamResourceDiscoveryArn";
const _iRDI = "ipamResourceDiscoveryId";
const _iRDR = "ipamResourceDiscoveryRegion";
const _iRDS = "ipamResourceDiscoverySet";
const _iRT = "ingressRouteTable";
const _iRp = "ipamRegion";
const _iRpa = "ipRanges";
const _iRpv = "ipv6Ranges";
const _iS = "ipamScope";
const _iSA = "ipamScopeArn";
const _iSI = "instanceStorageInfo";
const _iSIp = "ipamScopeId";
const _iSS = "instanceStatusSet";
const _iSSn = "instanceStorageSupported";
const _iSSp = "ipamScopeSet";
const _iST = "ipamScopeType";
const _iSTS = "importSnapshotTaskSet";
const _iSg = "igmpv2Support";
const _iSm = "imagesSet";
const _iSma = "imageState";
const _iSmag = "imageSet";
const _iSmd = "imdsSupport";
const _iSmp = "impairedSince";
const _iSn = "instancesSet";
const _iSns = "instanceSet";
const _iSnst = "instanceState";
const _iSnsta = "instanceStatus";
const _iSp = "ipamSet";
const _iSpo = "ipSource";
const _iSpv = "ipv6Supported";
const _iSpvu = "ipv6Support";
const _iT = "instanceType";
const _iTA = "instanceTagAttribute";
const _iTC = "icmpTypeCode";
const _iTCn = "includeTrustContext";
const _iTI = "importTaskId";
const _iTKS = "instanceTagKeySet";
const _iTOS = "instanceTypeOfferingSet";
const _iTS = "instanceTypeSet";
const _iTSS = "instanceTypeSpecificationSet";
const _iTm = "imageType";
const _iTn = "instanceTypes";
const _iTns = "instanceTenancy";
const _iTnt = "interfaceType";
const _iU = "ipUsage";
const _iUS = "instanceUsageSet";
const _iV = "importVolume";
const _iVE = "isValidExchange";
const _iVS = "ikeVersionSet";
const _id = "id";
const _im = "image";
const _in = "instance";
const _ins = "instances";
const _int = "interval";
const _io = "iops";
const _ip = "ipam";
const _is = "issuer";
const _k = "key";
const _kDF = "kinesisDataFirehose";
const _kF = "keyFormat";
const _kFe = "keyFingerprint";
const _kI = "kernelId";
const _kKA = "kmsKeyArn";
const _kKI = "kmsKeyId";
const _kM = "keyMaterial";
const _kN = "keyName";
const _kPI = "keyPairId";
const _kS = "keySet";
const _kT = "keyType";
const _kV = "keyValue";
const _ke = "kernel";
const _key = "keyword";
const _l = "lifecycle";
const _lA = "localAddress";
const _lADT = "lastAttemptedDiscoveryTime";
const _lAZ = "launchedAvailabilityZone";
const _lAa = "lastAddress";
const _lBA = "loadBalancerArn";
const _lBAo = "localBgpAsn";
const _lBC = "loadBalancersConfig";
const _lBLP = "loadBalancerListenerPort";
const _lBO = "loadBalancerOptions";
const _lBP = "loadBalancerPort";
const _lBS = "loadBalancerSet";
const _lBT = "loadBalancerTarget";
const _lBTG = "loadBalancerTargetGroup";
const _lBTGS = "loadBalancerTargetGroupSet";
const _lBTP = "loadBalancerTargetPort";
const _lC = "loggingConfiguration";
const _lCA = "licenseConfigurationArn";
const _lCO = "lockCreatedOn";
const _lCS = "loggingConfigurationSet";
const _lD = "logDestination";
const _lDST = "lockDurationStartTime";
const _lDT = "logDestinationType";
const _lDo = "lockDuration";
const _lE = "logEnabled";
const _lEO = "lockExpiresOn";
const _lET = "lastEvaluatedTime";
const _lEa = "lastError";
const _lF = "logFormat";
const _lFA = "lambdaFunctionArn";
const _lG = "launchGroup";
const _lGA = "logGroupArn";
const _lGI = "localGatewayId";
const _lGN = "logGroupName";
const _lGRT = "localGatewayRouteTable";
const _lGRTA = "localGatewayRouteTableArn";
const _lGRTI = "localGatewayRouteTableId";
const _lGRTS = "localGatewayRouteTableSet";
const _lGRTVA = "localGatewayRouteTableVpcAssociation";
const _lGRTVAI = "localGatewayRouteTableVpcAssociationId";
const _lGRTVAS = "localGatewayRouteTableVpcAssociationSet";
const _lGRTVIGA = "localGatewayRouteTableVirtualInterfaceGroupAssociation";
const _lGRTVIGAI = "localGatewayRouteTableVirtualInterfaceGroupAssociationId";
const _lGRTVIGAS = "localGatewayRouteTableVirtualInterfaceGroupAssociationSet";
const _lGS = "localGatewaySet";
const _lGVIGI = "localGatewayVirtualInterfaceGroupId";
const _lGVIGS = "localGatewayVirtualInterfaceGroupSet";
const _lGVII = "localGatewayVirtualInterfaceId";
const _lGVIIS = "localGatewayVirtualInterfaceIdSet";
const _lGVIS = "localGatewayVirtualInterfaceSet";
const _lGo = "logGroup";
const _lINC = "localIpv4NetworkCidr";
const _lINCo = "localIpv6NetworkCidr";
const _lLT = "lastLaunchedTime";
const _lMA = "lastMaintenanceApplied";
const _lO = "logOptions";
const _lOF = "logOutputFormat";
const _lP = "loadPermissions";
const _lPa = "launchPermission";
const _lS = "licenseSpecifications";
const _lSC = "lastStatusChange";
const _lSDT = "lastSuccessfulDiscoveryTime";
const _lSTS = "localStorageTypeSet";
const _lSa = "launchSpecifications";
const _lSau = "launchSpecification";
const _lSi = "licenseSet";
const _lSo = "localStorage";
const _lSoc = "lockState";
const _lT = "launchTemplate";
const _lTAO = "launchTemplateAndOverrides";
const _lTC = "launchTemplateConfigs";
const _lTD = "launchTemplateData";
const _lTI = "launchTemplateId";
const _lTN = "launchTemplateName";
const _lTOS = "lastTieringOperationStatus";
const _lTOSD = "lastTieringOperationStatusDetail";
const _lTP = "lastTieringProgress";
const _lTS = "launchTemplateSpecification";
const _lTST = "lastTieringStartTime";
const _lTV = "launchTemplateVersion";
const _lTVS = "launchTemplateVersionSet";
const _lTa = "launchTemplates";
const _lTau = "launchTime";
const _lTi = "licenseType";
const _lTo = "locationType";
const _lUT = "lastUpdateTime";
const _lUTa = "lastUpdatedTime";
const _lUTas = "lastUpdateTimestamp";
const _lV = "logVersion";
const _lVN = "latestVersionNumber";
const _lo = "location";
const _loc = "locale";
const _m = "min";
const _mA = "mutualAuthentication";
const _mAAA = "maintenanceAutoAppliedAfter";
const _mAE = "multiAttachEnabled";
const _mAI = "maxAggregationInterval";
const _mAIe = "mediaAcceleratorInfo";
const _mASS = "movingAddressStatusSet";
const _mAa = "macAddress";
const _mB = "managedBy";
const _mBIM = "maximumBandwidthInMbps";
const _mC = "missingComponent";
const _mCOIOL = "mapCustomerOwnedIpOnLaunch";
const _mD = "maintenanceDetails";
const _mDA = "multicastDomainAssociations";
const _mDK = "metaDataKey";
const _mDV = "metaDataValue";
const _mDe = "metaData";
const _mE = "maxEntries";
const _mEI = "maximumEfaInterfaces";
const _mEM = "managedExceptionMessage";
const _mFV = "mostFrequentValue";
const _mG = "multicastGroups";
const _mGBPVC = "memoryGiBPerVCpu";
const _mHS = "macHostSet";
const _mI = "maximumIops";
const _mIe = "memoryInfo";
const _mMB = "memoryMiB";
const _mNC = "maximumNetworkCards";
const _mNI = "maximumNetworkInterfaces";
const _mO = "metadataOptions";
const _mOSLRG = "memberOfServiceLinkedResourceGroup";
const _mOSLSVS = "macOSLatestSupportedVersionSet";
const _mOa = "maintenanceOptions";
const _mP = "maxPrice";
const _mPIOL = "mapPublicIpOnLaunch";
const _mPL = "maxParallelLaunches";
const _mPS = "metricPointSet";
const _mPSa = "matchPathSet";
const _mR = "maxResults";
const _mRS = "modificationResultSet";
const _mS = "messageSet";
const _mSPAPOOODP = "maxSpotPriceAsPercentageOfOptimalOnDemandPrice";
const _mSa = "managementState";
const _mSai = "maintenanceStrategies";
const _mSo = "moveStatus";
const _mSod = "modificationState";
const _mSu = "multicastSupport";
const _mT = "marketType";
const _mTC = "minTargetCapacity";
const _mTDID = "maxTermDurationInDays";
const _mTDIDi = "minTermDurationInDays";
const _mTIMB = "maximumThroughputInMBps";
const _mTP = "maxTotalPrice";
const _mTe = "memberType";
const _mVE = "managesVpcEndpoints";
const _ma = "max";
const _mai = "main";
const _man = "manufacturer";
const _mana = "managed";
const _mar = "marketplace";
const _me = "message";
const _med = "med";
const _mem = "member";
const _met = "metric";
const _mo = "monitoring";
const _mod = "mode";
const _n = "name";
const _nA = "networkAcl";
const _nAAI = "networkAclAssociationId";
const _nAI = "networkAclId";
const _nAIe = "newAssociationId";
const _nAOO = "nativeApplicationOidcOptions";
const _nAS = "networkAclSet";
const _nAo = "notAfter";
const _nB = "notBefore";
const _nBD = "notBeforeDeadline";
const _nBG = "networkBorderGroup";
const _nBGe = "networkBandwidthGbps";
const _nC = "networkCards";
const _nCI = "networkCardIndex";
const _nD = "noDevice";
const _nDe = "neuronDevices";
const _nES = "nitroEnclavesSupport";
const _nG = "natGateway";
const _nGAS = "natGatewayAddressSet";
const _nGI = "natGatewayId";
const _nGS = "natGatewaySet";
const _nHI = "nextHopIp";
const _nI = "networkId";
const _nIA = "networkInsightsAnalysis";
const _nIAA = "networkInsightsAnalysisArn";
const _nIAI = "networkInsightsAnalysisId";
const _nIAS = "networkInsightsAccessScope";
const _nIASA = "networkInsightsAccessScopeArn";
const _nIASAA = "networkInsightsAccessScopeAnalysisArn";
const _nIASAI = "networkInsightsAccessScopeAnalysisId";
const _nIASAS = "networkInsightsAccessScopeAnalysisSet";
const _nIASAe = "networkInsightsAccessScopeAnalysis";
const _nIASC = "networkInsightsAccessScopeContent";
const _nIASI = "networkInsightsAccessScopeId";
const _nIASS = "networkInsightsAccessScopeSet";
const _nIASe = "networkInsightsAnalysisSet";
const _nIASet = "networkInterfaceAttachmentStatus";
const _nIC = "networkInterfaceCount";
const _nID = "networkInterfaceDescription";
const _nII = "networkInterfaceId";
const _nIIS = "networkInterfaceIdSet";
const _nIO = "networkInterfaceOptions";
const _nIOI = "networkInterfaceOwnerId";
const _nIP = "networkInsightsPath";
const _nIPA = "networkInsightsPathArn";
const _nIPI = "networkInsightsPathId";
const _nIPIe = "networkInterfacePermissionId";
const _nIPS = "networkInsightsPathSet";
const _nIPe = "networkInterfacePermissions";
const _nIS = "networkInterfaceSet";
const _nIe = "networkInterface";
const _nIet = "networkInfo";
const _nIeu = "neuronInfo";
const _nL = "netmaskLength";
const _nLBA = "networkLoadBalancerArn";
const _nLBAS = "networkLoadBalancerArnSet";
const _nNS = "networkNodeSet";
const _nOA = "numberOfAccounts";
const _nOFA = "numberOfFailedAccounts";
const _nOMA = "numberOfMatchedAccounts";
const _nOUA = "numberOfUnmatchedAccounts";
const _nP = "networkPerformance";
const _nPF = "networkPathFound";
const _nPO = "networkPerformanceOptions";
const _nPe = "networkPlatform";
const _nS = "nvmeSupport";
const _nSS = "networkServiceSet";
const _nSST = "nextSlotStartTime";
const _nSa = "nameserverSet";
const _nT = "networkType";
const _nTI = "nitroTpmInfo";
const _nTS = "nitroTpmSupport";
const _nTe = "nextToken";
const _o = "origin";
const _oA = "outpostArn";
const _oAr = "organizationArn";
const _oAw = "ownerAlias";
const _oC = "offeringClass";
const _oDAS = "onDemandAllocationStrategy";
const _oDFC = "onDemandFulfilledCapacity";
const _oDMPPOLP = "onDemandMaxPricePercentageOverLowestPrice";
const _oDMTP = "onDemandMaxTotalPrice";
const _oDO = "onDemandOptions";
const _oDS = "occurrenceDaySet";
const _oDTC = "onDemandTargetCapacity";
const _oEP = "organizationsEntityPath";
const _oH = "outboundHeader";
const _oI = "ownerId";
const _oIA = "outsideIpAddress";
const _oIAT = "outsideIpAddressType";
const _oIS = "optInStatus";
const _oIf = "offeringId";
const _oIr = "originalIops";
const _oK = "objectKey";
const _oMAE = "originalMultiAttachEnabled";
const _oO = "oidcOptions";
const _oRIWEA = "outputReservedInstancesWillExpireAt";
const _oRS = "operatingRegionSet";
const _oRTE = "occurrenceRelativeToEnd";
const _oS = "offeringSet";
const _oST = "oldestSampleTime";
const _oSr = "originalSize";
const _oSv = "overlapStatus";
const _oT = "optimizingTime";
const _oTf = "offeringType";
const _oTr = "originalThroughput";
const _oU = "occurrenceUnit";
const _oUA = "organizationalUnitArn";
const _oUES = "organizationalUnitExclusionSet";
const _oUI = "organizationalUnitId";
const _oVCS = "openVpnConfigurationSet";
const _oVT = "originalVolumeType";
const _op = "operator";
const _opt = "options";
const _ou = "output";
const _ov = "overrides";
const _ow = "owner";
const _p = "principal";
const _pA = "poolArn";
const _pAI = "peeringAttachmentId";
const _pAR = "poolAddressRange";
const _pARS = "poolAddressRangeSet";
const _pAe = "peerAddress";
const _pAee = "peerAsn";
const _pAu = "publiclyAdvertisable";
const _pB = "provisionedBandwidth";
const _pBA = "peerBgpAsn";
const _pBIG = "peakBandwidthInGbps";
const _pC = "productCodes";
const _pCB = "poolCidrBlock";
const _pCBS = "poolCidrBlockSet";
const _pCI = "preserveClientIp";
const _pCNI = "peerCoreNetworkId";
const _pCS = "poolCidrSet";
const _pCSS = "postureComplianceStatusSet";
const _pCa = "partitionCount";
const _pCo = "poolCount";
const _pCr = "productCode";
const _pD = "passwordData";
const _pDE = "privateDnsEnabled";
const _pDEr = "privateDnsEntry";
const _pDHGNS = "phase1DHGroupNumberSet";
const _pDHGNSh = "phase2DHGroupNumberSet";
const _pDN = "privateDnsName";
const _pDNC = "privateDnsNameConfiguration";
const _pDNO = "privateDnsNameOptions";
const _pDNOOL = "privateDnsNameOptionsOnLaunch";
const _pDNS = "privateDnsNameSet";
const _pDNVS = "privateDnsNameVerificationState";
const _pDNu = "publicDnsName";
const _pDOFIRE = "privateDnsOnlyForInboundResolverEndpoint";
const _pDRTI = "propagationDefaultRouteTableId";
const _pDS = "pricingDetailsSet";
const _pDSI = "publicDefaultScopeId";
const _pDSIr = "privateDefaultScopeId";
const _pDa = "paymentDue";
const _pDl = "platformDetails";
const _pDo = "policyDocument";
const _pDoo = "poolDepth";
const _pDr = "productDescription";
const _pE = "policyEnabled";
const _pEAS = "phase1EncryptionAlgorithmSet";
const _pEASh = "phase2EncryptionAlgorithmSet";
const _pEk = "pkceEnabled";
const _pF = "packetField";
const _pFS = "previousFleetState";
const _pG = "placementGroup";
const _pGA = "placementGroupArn";
const _pGI = "placementGroupInfo";
const _pGS = "placementGroupSet";
const _pHP = "perHourPartition";
const _pHS = "packetHeaderStatement";
const _pI = "publicIp";
const _pIA = "privateIpAddress";
const _pIAS = "privateIpAddressesSet";
const _pIASh = "phase1IntegrityAlgorithmSet";
const _pIASha = "phase2IntegrityAlgorithmSet";
const _pIP = "publicIpv4Pool";
const _pIPI = "publicIpv4PoolId";
const _pIPS = "publicIpv4PoolSet";
const _pIS = "publicIpSource";
const _pIc = "pciId";
const _pIo = "poolId";
const _pIr = "processorInfo";
const _pIri = "primaryIpv6";
const _pIriv = "privateIp";
const _pK = "publicKey";
const _pL = "prefixList";
const _pLA = "prefixListArn";
const _pLAS = "prefixListAssociationSet";
const _pLD = "peerLivenessDetection";
const _pLI = "prefixListId";
const _pLIr = "prefixListIds";
const _pLN = "prefixListName";
const _pLOI = "prefixListOwnerId";
const _pLS = "prefixListSet";
const _pLSh = "phase1LifetimeSeconds";
const _pLSha = "phase2LifetimeSeconds";
const _pLa = "packetLength";
const _pM = "pendingMaintenance";
const _pN = "partitionNumber";
const _pO = "paymentOption";
const _pOe = "peeringOptions";
const _pP = "progressPercentage";
const _pR = "ptrRecord";
const _pRD = "persistRoutesDuration";
const _pRN = "policyRuleNumber";
const _pRNo = "policyReferenceName";
const _pRS = "portRangeSet";
const _pRSe = "persistRoutesState";
const _pRU = "ptrRecordUpdate";
const _pRa = "payerResponsibility";
const _pRo = "portRange";
const _pRol = "policyRule";
const _pS = "previousState";
const _pSET = "previousSlotEndTime";
const _pSFRS = "previousSpotFleetRequestState";
const _pSK = "preSharedKey";
const _pSKE = "publicSigningKeyEndpoint";
const _pSKU = "publicSigningKeyUrl";
const _pSe = "permissionState";
const _pSee = "peeringStatus";
const _pSh = "phcSupport";
const _pSr = "principalSet";
const _pSre = "previousStatus";
const _pSri = "priceSchedules";
const _pSro = "protocolSet";
const _pT = "principalType";
const _pTGI = "peerTransitGatewayId";
const _pTr = "provisionTime";
const _pTu = "purchaseToken";
const _pVI = "primaryVpcId";
const _pVS = "propagatingVgwSet";
const _pZI = "parentZoneId";
const _pZN = "parentZoneName";
const _pe = "period";
const _per = "permission";
const _pl = "platform";
const _pla = "placement";
const _po = "port";
const _pr = "protocol";
const _pre = "prefix";
const _pri = "priority";
const _pric = "price";
const _prim = "primary";
const _pro = "progress";
const _prop = "propagation";
const _prov = "provisioned";
const _pu = "public";
const _pur = "purchase";
const _r = "return";
const _rA = "ruleAction";
const _rAE = "remoteAccessEnabled";
const _rAe = "resourceArn";
const _rB = "requestedBy";
const _rBET = "recycleBinEnterTime";
const _rBETe = "recycleBinExitTime";
const _rC = "returnCode";
const _rCA = "resourceConfigurationArn";
const _rCGA = "resourceConfigurationGroupArn";
const _rCS = "resourceComplianceStatus";
const _rCe = "resourceCidr";
const _rCec = "recurringCharges";
const _rD = "restoreDuration";
const _rDAC = "resourceDiscoveryAssociationCount";
const _rDCA = "rdsDbClusterArn";
const _rDI = "ramDiskId";
const _rDIA = "rdsDbInstanceArn";
const _rDN = "rootDeviceName";
const _rDPA = "rdsDbProxyArn";
const _rDS = "resourceDiscoveryStatus";
const _rDT = "rootDeviceType";
const _rE = "responseError";
const _rET = "restoreExpiryTime";
const _rEd = "rdsEndpoint";
const _rEe = "regionEndpoint";
const _rEes = "resourceExclusions";
const _rFP = "rekeyFuzzPercentage";
const _rGA = "ruleGroupArn";
const _rGI = "referencedGroupId";
const _rGIe = "referencedGroupInfo";
const _rGROPS = "ruleGroupRuleOptionsPairSet";
const _rGT = "ruleGroupType";
const _rGTPS = "ruleGroupTypePairSet";
const _rHS = "requireHibernateSupport";
const _rI = "reportId";
const _rIDS = "routeInstallationDetailSet";
const _rII = "reservedInstancesId";
const _rIIe = "reservedInstanceId";
const _rILI = "reservedInstancesListingId";
const _rILS = "reservedInstancesListingsSet";
const _rIMI = "reservedInstancesModificationId";
const _rIMS = "reservedInstancesModificationsSet";
const _rINC = "remoteIpv4NetworkCidr";
const _rINCe = "remoteIpv6NetworkCidr";
const _rIOI = "reservedInstancesOfferingId";
const _rIOS = "reservedInstancesOfferingsSet";
const _rIS = "reservedInstancesSet";
const _rISR = "routeInstallationStatusReason";
const _rISo = "routeInstallationStatus";
const _rIVR = "reservedInstanceValueRollup";
const _rIVS = "reservedInstanceValueSet";
const _rIa = "ramdiskId";
const _rIe = "regionInfo";
const _rIeq = "requesterId";
const _rIes = "resourceId";
const _rIese = "reservationId";
const _rM = "requesterManaged";
const _rMGM = "registeredMulticastGroupMembers";
const _rMGS = "registeredMulticastGroupSources";
const _rMTS = "rekeyMarginTimeSeconds";
const _rN = "ruleNumber";
const _rNII = "registeredNetworkInterfaceIds";
const _rNe = "regionName";
const _rNes = "resourceName";
const _rNo = "roleName";
const _rO = "resourceOwner";
const _rOI = "resourceOwnerId";
const _rOS = "ruleOptionSet";
const _rOSe = "resourceOverlapStatus";
const _rOd = "rdsOptions";
const _rOo = "routeOrigin";
const _rPCO = "requesterPeeringConnectionOptions";
const _rPCS = "returnPathComponentSet";
const _rR = "resourceRegion";
const _rRVT = "replaceRootVolumeTask";
const _rRVTI = "replaceRootVolumeTaskId";
const _rRVTS = "replaceRootVolumeTaskSet";
const _rS = "referenceSet";
const _rSA = "routeServerAssociation";
const _rSAS = "routeServerAssociationSet";
const _rSE = "routeServerEndpoint";
const _rSEI = "routeServerEndpointId";
const _rSES = "routeServerEndpointSet";
const _rSGRS = "revokedSecurityGroupRuleSet";
const _rSI = "routeServerId";
const _rSP = "routeServerPeer";
const _rSPI = "routeServerPeerId";
const _rSPS = "routeServerPeerSet";
const _rSPSo = "routeServerPropagationSet";
const _rSPo = "routeServerPropagation";
const _rSS = "regionalSummarySet";
const _rSSo = "routeServerSet";
const _rST = "restoreStartTime";
const _rSe = "reportSet";
const _rSep = "replacementStrategy";
const _rSes = "reservationSet";
const _rSeso = "resourceStatement";
const _rSesou = "resourceSet";
const _rSo = "routeServer";
const _rSou = "routeSet";
const _rSout = "routeStatus";
const _rT = "reservationType";
const _rTAI = "routeTableAssociationId";
const _rTI = "routeTableId";
const _rTIS = "routeTableIdSet";
const _rTIe = "requesterTgwInfo";
const _rTR = "routeTableRoute";
const _rTS = "routeTableSet";
const _rTSe = "resourceTagSet";
const _rTSes = "resourceTypeSet";
const _rTV = "remainingTotalValue";
const _rTe = "resourceType";
const _rTel = "releaseTime";
const _rTeq = "requestTime";
const _rTo = "routeTable";
const _rUI = "replaceUnhealthyInstances";
const _rUV = "remainingUpfrontValue";
const _rV = "returnValue";
const _rVI = "referencingVpcId";
const _rVIe = "requesterVpcInfo";
const _rVe = "reservationValue";
const _rWS = "replayWindowSize";
const _ra = "ramdisk";
const _re = "region";
const _rea = "reason";
const _rec = "recurrence";
const _req = "requested";
const _res = "result";
const _reso = "resource";
const _ro = "route";
const _rou = "routes";
const _s = "source";
const _sA = "sourceArn";
const _sAS = "sourceAddressSet";
const _sASu = "suggestedAccountSet";
const _sAZ = "singleAvailabilityZone";
const _sAo = "sourceAddress";
const _sAt = "startupAction";
const _sAu = "supportedArchitectures";
const _sAub = "subnetArn";
const _sB = "s3Bucket";
const _sBM = "supportedBootModes";
const _sC = "serviceConfiguration";
const _sCA = "serverCertificateArn";
const _sCAE = "serialConsoleAccessEnabled";
const _sCB = "sourceCidrBlock";
const _sCR = "sourceCapacityReservation";
const _sCRI = "subnetCidrReservationId";
const _sCRu = "subnetCidrReservation";
const _sCS = "serviceConfigurationSet";
const _sCSIG = "sustainedClockSpeedInGhz";
const _sCc = "scopeCount";
const _sCn = "snapshotConfiguration";
const _sD = "startDate";
const _sDC = "sourceDestCheck";
const _sDIH = "slotDurationInHours";
const _sDLTVS = "successfullyDeletedLaunchTemplateVersionSet";
const _sDS = "spotDatafeedSubscription";
const _sDSe = "serviceDetailSet";
const _sDSn = "snapshotDetailSet";
const _sDp = "spreadDomain";
const _sDu = "subDomain";
const _sEL = "s3ExportLocation";
const _sET = "sampledEndTime";
const _sF = "supportedFeatures";
const _sFCS = "successfulFleetCancellationSet";
const _sFDS = "successfulFleetDeletionSet";
const _sFRC = "spotFleetRequestConfig";
const _sFRCS = "spotFleetRequestConfigSet";
const _sFRI = "spotFleetRequestId";
const _sFRS = "successfulFleetRequestSet";
const _sFRSp = "spotFleetRequestState";
const _sG = "securityGroup";
const _sGA = "securityGroupArn";
const _sGFVS = "securityGroupForVpcSet";
const _sGI = "securityGroupId";
const _sGIS = "securityGroupIdSet";
const _sGIe = "securityGroupIds";
const _sGIec = "securityGroupInfo";
const _sGR = "securityGroupRule";
const _sGRA = "securityGroupRuleArn";
const _sGRI = "securityGroupRuleId";
const _sGRS = "securityGroupRuleSet";
const _sGRSe = "securityGroupReferenceSet";
const _sGRSec = "securityGroupReferencingSupport";
const _sGS = "securityGroupSet";
const _sGVAS = "securityGroupVpcAssociationSet";
const _sGe = "securityGroups";
const _sH = "startHour";
const _sI = "serviceId";
const _sIAS = "scheduledInstanceAvailabilitySet";
const _sIATS = "supportedIpAddressTypeSet";
const _sICRS = "subnetIpv4CidrReservationSet";
const _sICRSu = "subnetIpv6CidrReservationSet";
const _sICSS = "successfulInstanceCreditSpecificationSet";
const _sIGB = "sizeInGB";
const _sII = "sourceInstanceId";
const _sIIc = "scheduledInstanceId";
const _sIIo = "sourceImageId";
const _sIMB = "sizeInMiB";
const _sIP = "staleIpPermissions";
const _sIPE = "staleIpPermissionsEgress";
const _sIPI = "sourceIpamPoolId";
const _sIR = "sourceImageRegion";
const _sIRI = "spotInstanceRequestId";
const _sIRS = "spotInstanceRequestSet";
const _sIS = "scheduledInstanceSet";
const _sISu = "subnetIdSet";
const _sIT = "spotInstanceType";
const _sITRS = "storeImageTaskResultSet";
const _sITi = "singleInstanceType";
const _sIn = "snapshotId";
const _sIo = "sourceIp";
const _sIu = "subnetId";
const _sIub = "subnetIds";
const _sK = "s3Key";
const _sKo = "s3objectKey";
const _sL = "s3Location";
const _sLp = "spreadLevel";
const _sM = "serviceManaged";
const _sMPPOLP = "spotMaxPricePercentageOverLowestPrice";
const _sMS = "spotMaintenanceStrategies";
const _sMTP = "spotMaxTotalPrice";
const _sMt = "statusMessage";
const _sMta = "stateMessage";
const _sN = "serviceName";
const _sNA = "serviceNetworkArn";
const _sNE = "snsNotificationsEnabled";
const _sNN = "serviceNetworkName";
const _sNS = "serviceNameSet";
const _sNSr = "sriovNetSupport";
const _sNe = "sequenceNumber";
const _sNes = "sessionNumber";
const _sO = "spotOptions";
const _sP = "s3Prefix";
const _sPA = "samlProviderArn";
const _sPHS = "spotPriceHistorySet";
const _sPI = "servicePermissionId";
const _sPIAC = "secondaryPrivateIpAddressCount";
const _sPLS = "sourcePrefixListSet";
const _sPR = "sourcePortRange";
const _sPRS = "sourcePortRangeSet";
const _sPS = "sourcePortSet";
const _sPSS = "spotPlacementScoreSet";
const _sPp = "spotPrice";
const _sQPDS = "successfulQueuedPurchaseDeletionSet";
const _sR = "serviceRegion";
const _sRDT = "supportedRootDeviceTypes";
const _sRO = "staticRoutesOnly";
const _sRS = "supportedRegionSet";
const _sRT = "subnetRouteTable";
const _sRe = "serviceResource";
const _sRo = "sourceResource";
const _sRt = "stateReason";
const _sS = "snapshotSet";
const _sSGS = "staleSecurityGroupSet";
const _sSPU = "selfServicePortalUrl";
const _sSS = "staticSourcesSupport";
const _sSSPA = "selfServiceSamlProviderArn";
const _sST = "sampledStartTime";
const _sSe = "settingSet";
const _sSer = "serviceState";
const _sSo = "sourceSet";
const _sSs = "sseSpecification";
const _sSt = "statusSet";
const _sSu = "subscriptionSet";
const _sSub = "subnetSet";
const _sSup = "supportedStrategies";
const _sSy = "systemStatus";
const _sT = "startTime";
const _sTA = "snsTopicArn";
const _sTC = "spotTargetCapacity";
const _sTD = "snapshotTaskDetail";
const _sTFR = "storeTaskFailureReason";
const _sTH = "sessionTimeoutHours";
const _sTR = "stateTransitionReason";
const _sTS = "storeTaskState";
const _sTSS = "snapshotTierStatusSet";
const _sTT = "stateTransitionTime";
const _sTa = "sampleTime";
const _sTe = "serviceType";
const _sTo = "sourceType";
const _sTp = "splitTunnel";
const _sTs = "sseType";
const _sTt = "storageTier";
const _sUC = "supportedUsageClasses";
const _sV = "sourceVpc";
const _sVT = "supportedVirtualizationTypes";
const _sVh = "shellVersion";
const _sVu = "supportedVersions";
const _sWD = "startWeekDay";
const _s_ = "s3";
const _sc = "scope";
const _sco = "score";
const _scop = "scopes";
const _se = "service";
const _si = "size";
const _so = "sockets";
const _sof = "software";
const _st = "state";
const _sta = "status";
const _star = "start";
const _stat = "statistic";
const _sto = "storage";
const _str = "strategy";
const _su = "subnet";
const _sub = "subnets";
const _suc = "successful";
const _succ = "success";
const _t = "tenancy";
const _tAAC = "totalAvailableAddressCount";
const _tAC = "totalAddressCount";
const _tAI = "transferAccountId";
const _tC = "totalCapacity";
const _tCS = "targetCapacitySpecification";
const _tCUT = "targetCapacityUnitType";
const _tCVR = "targetConfigurationValueRollup";
const _tCVS = "targetConfigurationValueSet";
const _tCa = "targetConfiguration";
const _tCar = "targetCapacity";
const _tD = "terminationDelay";
const _tDr = "trafficDirection";
const _tE = "targetEnvironment";
const _tED = "termEndDate";
const _tET = "tcpEstablishedTimeout";
const _tEo = "tokenEndpoint";
const _tFC = "totalFulfilledCapacity";
const _tFMIMB = "totalFpgaMemoryInMiB";
const _tG = "transitGateway";
const _tGA = "transitGatewayAttachments";
const _tGAI = "transitGatewayAttachmentId";
const _tGAP = "transitGatewayAttachmentPropagations";
const _tGAr = "transitGatewayAttachment";
const _tGAra = "transitGatewayArn";
const _tGAran = "transitGatewayAsn";
const _tGArans = "transitGatewayAddress";
const _tGC = "transitGatewayConnect";
const _tGCB = "transitGatewayCidrBlocks";
const _tGCP = "transitGatewayConnectPeer";
const _tGCPI = "transitGatewayConnectPeerId";
const _tGCPS = "transitGatewayConnectPeerSet";
const _tGCS = "transitGatewayConnectSet";
const _tGCa = "targetGroupsConfig";
const _tGI = "transitGatewayId";
const _tGMD = "transitGatewayMulticastDomain";
const _tGMDA = "transitGatewayMulticastDomainArn";
const _tGMDI = "transitGatewayMulticastDomainId";
const _tGMDr = "transitGatewayMulticastDomains";
const _tGMIMB = "totalGpuMemoryInMiB";
const _tGOI = "transitGatewayOwnerId";
const _tGPA = "transitGatewayPeeringAttachment";
const _tGPAr = "transitGatewayPeeringAttachments";
const _tGPLR = "transitGatewayPrefixListReference";
const _tGPLRS = "transitGatewayPrefixListReferenceSet";
const _tGPT = "transitGatewayPolicyTable";
const _tGPTE = "transitGatewayPolicyTableEntries";
const _tGPTI = "transitGatewayPolicyTableId";
const _tGPTr = "transitGatewayPolicyTables";
const _tGRT = "transitGatewayRouteTable";
const _tGRTA = "transitGatewayRouteTableAnnouncement";
const _tGRTAI = "transitGatewayRouteTableAnnouncementId";
const _tGRTAr = "transitGatewayRouteTableAnnouncements";
const _tGRTI = "transitGatewayRouteTableId";
const _tGRTP = "transitGatewayRouteTablePropagations";
const _tGRTR = "transitGatewayRouteTableRoute";
const _tGRTr = "transitGatewayRouteTables";
const _tGS = "transitGatewaySet";
const _tGVA = "transitGatewayVpcAttachment";
const _tGVAr = "transitGatewayVpcAttachments";
const _tGa = "targetGroups";
const _tHP = "totalHourlyPrice";
const _tI = "targetId";
const _tIC = "totalInstanceCount";
const _tICu = "tunnelInsideCidr";
const _tII = "trunkInterfaceId";
const _tIIC = "tunnelInsideIpv6Cidr";
const _tIIV = "tunnelInsideIpVersion";
const _tIMIMB = "totalInferenceMemoryInMiB";
const _tIWE = "terminateInstancesWithExpiration";
const _tIa = "targetIops";
const _tIe = "tenantId";
const _tLSGB = "totalLocalStorageGB";
const _tMAE = "targetMultiAttachEnabled";
const _tMF = "trafficMirrorFilter";
const _tMFI = "trafficMirrorFilterId";
const _tMFR = "trafficMirrorFilterRule";
const _tMFRI = "trafficMirrorFilterRuleId";
const _tMFRS = "trafficMirrorFilterRuleSet";
const _tMFS = "trafficMirrorFilterSet";
const _tMMIMB = "totalMediaMemoryInMiB";
const _tMS = "trafficMirrorSession";
const _tMSI = "trafficMirrorSessionId";
const _tMSS = "trafficMirrorSessionSet";
const _tMT = "trafficMirrorTarget";
const _tMTI = "trafficMirrorTargetId";
const _tMTS = "trafficMirrorTargetSet";
const _tN = "tokenName";
const _tNDMIMB = "totalNeuronDeviceMemoryInMiB";
const _tNI = "targetNetworkId";
const _tOAT = "transferOfferAcceptedTimestamp";
const _tOET = "transferOfferExpirationTimestamp";
const _tOS = "tunnelOptionSet";
const _tP = "transportProtocol";
const _tPC = "threadsPerCore";
const _tPT = "trustProviderType";
const _tPo = "toPort";
const _tRC = "targetResourceCount";
const _tRS = "throughResourceSet";
const _tRSi = "timeRangeSet";
const _tRTI = "targetRouteTableId";
const _tS = "tagSet";
const _tSD = "termStartDate";
const _tSIGB = "totalSizeInGB";
const _tSIH = "totalScheduledInstanceHours";
const _tSS = "tagSpecificationSet";
const _tST = "tieringStartTime";
const _tSTa = "taskStartTime";
const _tSa = "targetSubnet";
const _tSar = "targetSize";
const _tSas = "taskState";
const _tSp = "tpmSupport";
const _tT = "trafficType";
const _tTC = "totalTargetCapacity";
const _tTGAI = "transportTransitGatewayAttachmentId";
const _tTa = "targetThroughput";
const _tTr = "transferType";
const _tUP = "totalUpfrontPrice";
const _tV = "tokenValue";
const _tVC = "totalVCpus";
const _tVT = "targetVolumeType";
const _ta = "tags";
const _tag = "tag";
const _te = "term";
const _th = "throughput";
const _ti = "timestamp";
const _tie = "tier";
const _to = "to";
const _ty = "type";
const _u = "unsuccessful";
const _uB = "userBucket";
const _uD = "uefiData";
const _uDLTVS = "unsuccessfullyDeletedLaunchTemplateVersionSet";
const _uDp = "updatedDate";
const _uDpd = "updateDate";
const _uDs = "userData";
const _uF = "upfrontFee";
const _uFDS = "unsuccessfulFleetDeletionSet";
const _uFRS = "unsuccessfulFleetRequestSet";
const _uI = "userId";
const _uIA = "unassignedIpv6Addresses";
const _uIC = "usedInstanceCount";
const _uICSS = "unsuccessfulInstanceCreditSpecificationSet";
const _uIE = "userInfoEndpoint";
const _uIPS = "unknownIpPermissionSet";
const _uIPSn = "unassignedIpv6PrefixSet";
const _uLI = "useLongIds";
const _uLIA = "useLongIdsAggregated";
const _uO = "usageOperation";
const _uOUT = "usageOperationUpdateTime";
const _uP = "upfrontPrice";
const _uPS = "uploadPolicySignature";
const _uPp = "uploadPolicy";
const _uPs = "usagePrice";
const _uRBOI = "unusedReservationBillingOwnerId";
const _uS = "usageStrategy";
const _uST = "udpStreamTimeout";
const _uT = "updateTime";
const _uTP = "userTrustProvider";
const _uTPT = "userTrustProviderType";
const _uTd = "udpTimeout";
const _ur = "url";
const _us = "username";
const _v = "value";
const _vAE = "verifiedAccessEndpoint";
const _vAEI = "verifiedAccessEndpointId";
const _vAES = "verifiedAccessEndpointSet";
const _vAETD = "verifiedAccessEndpointTargetDns";
const _vAETIA = "verifiedAccessEndpointTargetIpAddress";
const _vAETS = "verifiedAccessEndpointTargetSet";
const _vAG = "verifiedAccessGroup";
const _vAGA = "verifiedAccessGroupArn";
const _vAGI = "verifiedAccessGroupId";
const _vAGS = "verifiedAccessGroupSet";
const _vAI = "verifiedAccessInstance";
const _vAII = "verifiedAccessInstanceId";
const _vAIS = "verifiedAccessInstanceSet";
const _vATP = "verifiedAccessTrustProvider";
const _vATPI = "verifiedAccessTrustProviderId";
const _vATPS = "verifiedAccessTrustProviderSet";
const _vBPAE = "vpcBlockPublicAccessExclusion";
const _vBPAES = "vpcBlockPublicAccessExclusionSet";
const _vBPAO = "vpcBlockPublicAccessOptions";
const _vC = "vpnConnection";
const _vCC = "vCpuCount";
const _vCDSC = "vpnConnectionDeviceSampleConfiguration";
const _vCDTI = "vpnConnectionDeviceTypeId";
const _vCDTS = "vpnConnectionDeviceTypeSet";
const _vCI = "vpnConnectionId";
const _vCIp = "vCpuInfo";
const _vCS = "vpnConnectionSet";
const _vCa = "validCores";
const _vD = "versionDescription";
const _vE = "vpcEndpoint";
const _vEAS = "vpcEndpointAssociationSet";
const _vECI = "vpcEncryptionControlId";
const _vECIp = "vpcEndpointConnectionId";
const _vECS = "vpcEndpointConnectionSet";
const _vEI = "vpcEndpointId";
const _vEO = "vpcEndpointOwner";
const _vEPS = "vpcEndpointPolicySupported";
const _vER = "vpcEndpointRegion";
const _vES = "vpcEndpointService";
const _vESp = "vpcEndpointSet";
const _vESpc = "vpcEndpointState";
const _vESpn = "vpnEcmpSupport";
const _vET = "vpcEndpointType";
const _vF = "validFrom";
const _vFR = "validationFailureReason";
const _vG = "vpnGateway";
const _vGI = "vpnGatewayId";
const _vGS = "vpnGatewaySet";
const _vI = "vpcId";
const _vIl = "vlanId";
const _vIo = "volumeId";
const _vM = "volumeModification";
const _vMS = "volumeModificationSet";
const _vN = "virtualName";
const _vNI = "virtualNetworkId";
const _vNe = "versionNumber";
const _vOI = "volumeOwnerId";
const _vOIp = "vpcOwnerId";
const _vP = "vpnProtocol";
const _vPC = "vpcPeeringConnection";
const _vPCI = "vpcPeeringConnectionId";
const _vPCS = "vpcPeeringConnectionSet";
const _vPG = "virtualPrivateGateway";
const _vPp = "vpnPort";
const _vPpc = "vpcPeering";
const _vS = "volumeSet";
const _vSS = "volumeStatusSet";
const _vSa = "valueSet";
const _vSo = "volumeSize";
const _vSol = "volumeStatus";
const _vSp = "vpcSet";
const _vT = "volumeType";
const _vTOIA = "vpnTunnelOutsideIpAddress";
const _vTPC = "validThreadsPerCore";
const _vTg = "vgwTelemetry";
const _vTi = "virtualizationType";
const _vU = "validUntil";
const _ve = "version";
const _ven = "vendor";
const _vl = "vlan";
const _vo = "volumes";
const _vol = "volume";
const _vp = "vpc";
const _vpc = "vpcs";
const _w = "warning";
const _wC = "weightedCapacity";
const _wM = "warningMessage";
const _we = "weight";
const _zI = "zoneId";
const _zN = "zoneName";
const _zS = "zoneState";
const _zT = "zoneType";
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadEc2ErrorCode = (output, data) => {
    if (data.Errors.Error?.Code !== undefined) {
        return data.Errors.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
