{"version":3,"sources":["../src/parse.js"],"names":["body","normalize","prev","_cur","cur","charAt","trim","Array","isArray","concat","parseProperties","scheme","string","token","params","res","exec","str","TypeError","start","indexOf","substr"],"mappings":";;;;;;;AACA;;AAEA;AACA,IAAMA,IAAI,GAAG,oIAAb,C,CAAmJ;;AAEnJ,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAChBC,IADgB,EAEhBC,IAFgB,EAGW;AAC3B;AACA,MAAMC,GAAG,GAAGD,IAAI,CAACE,MAAL,CAAY,CAAZ,MAAmB,GAAnB,GAAyB,mBAAQF,IAAR,CAAzB,GAAyCA,IAAI,CAACG,IAAL,EAArD,CAF2B,CAI3B;;AACA,MAAIC,KAAK,CAACC,OAAN,CAAcN,IAAd,CAAJ,EAAyB;AACvB,WAAOA,IAAI,CAACO,MAAL,CAAYL,GAAZ,CAAP;AACD,GAFD,MAEO,IAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;AACnC,WAAO,CAACA,IAAD,EAAOE,GAAP,CAAP;AACD;;AACD,SAAOA,GAAP;AACD,CAdD;;AAsBA,IAAMM,eAAe,GAAG,SAAlBA,eAAkB,CAACC,MAAD,EAASC,MAAT,EAA4B;AAClD,MAAIC,KAAK,GAAG,IAAZ;AACA,MAAMC,MAAM,GAAG,EAAf,CAFkD,CAIlD;;AACA,SAAO,IAAP,EAAa;AACX,QAAMC,GAAG,GAAGf,IAAI,CAACgB,IAAL,CAAUJ,MAAV,CAAZ;;AACA,QAAIG,GAAG,KAAK,IAAZ,EAAkB;AAChB;AACD;;AACD,QAAIA,GAAG,CAAC,CAAD,CAAP,EAAY;AACVD,MAAAA,MAAM,CAACC,GAAG,CAAC,CAAD,CAAJ,CAAN,GAAiBd,SAAS,CAACa,MAAM,CAACC,GAAG,CAAC,CAAD,CAAJ,CAAP,EAAiBA,GAAG,CAAC,CAAD,CAApB,CAA1B;AACD,KAFD,MAEO;AACLF,MAAAA,KAAK,GAAGZ,SAAS,CAACY,KAAD,EAAQE,GAAG,CAAC,CAAD,CAAX,CAAjB;AACD;AACF;;AAED,SAAO;AAACJ,IAAAA,MAAD;AAASG,IAAAA,MAAT;AAAiBD,IAAAA;AAAjB,GAAP;AACD,CAlBD;;eAoBe,kBAACI,GAAD,EAAyB;AACtC,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,UAAM,IAAIC,SAAJ,CAAc,gCAAd,CAAN;AACD;;AAED,MAAMC,KAAK,GAAGF,GAAG,CAACG,OAAJ,CAAY,GAAZ,CAAd;AACA,MAAMT,MAAM,GAAGM,GAAG,CAACI,MAAJ,CAAW,CAAX,EAAcF,KAAd,CAAf;;AAEA,MAAI,CAAC,oBAASR,MAAT,CAAL,EAAuB;AACrB,UAAM,IAAIO,SAAJ,CAAe,kBAAiBP,MAAO,EAAvC,CAAN;AACD;;AAED,SAAOD,eAAe,CAACC,MAAD,EAASM,GAAG,CAACI,MAAJ,CAAWF,KAAX,CAAT,CAAtB;AACD,C","sourcesContent":["// @flow\nimport {isScheme, unquote} from './util';\n\n// lol dis\nconst body = /((?:[a-zA-Z0-9._~+\\/-]+=*(?:\\s+|$))|[^\\u0000-\\u001F\\u007F()<>@,;:\\\\\"/?={}\\[\\]\\u0020\\u0009]+)(?:=([^\\\\\"=\\s,]+|\"(?:[^\"\\\\]|\\\\.)*\"))?/g; // eslint-disable-line\n\nconst normalize = (\n  prev: ?(string | Array<string>),\n  _cur: string,\n): string | Array<string> => {\n  // Fixup quoted strings and tokens with spaces around them\n  const cur = _cur.charAt(0) === '\"' ? unquote(_cur) : _cur.trim();\n\n  // Marshal\n  if (Array.isArray(prev)) {\n    return prev.concat(cur);\n  } else if (typeof prev === 'string') {\n    return [prev, cur];\n  }\n  return cur;\n};\n\ntype Result = {\n  scheme: string,\n  params: {[string]: string},\n  token: ?(string | Array<string>),\n};\n\nconst parseProperties = (scheme, string): Result => {\n  let token = null;\n  const params = {};\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const res = body.exec(string);\n    if (res === null) {\n      break;\n    }\n    if (res[2]) {\n      params[res[1]] = normalize(params[res[1]], res[2]);\n    } else {\n      token = normalize(token, res[1]);\n    }\n  }\n\n  return {scheme, params, token};\n};\n\nexport default (str: string): Result => {\n  if (typeof str !== 'string') {\n    throw new TypeError('Header value must be a string.');\n  }\n\n  const start = str.indexOf(' ');\n  const scheme = str.substr(0, start);\n\n  if (!isScheme(scheme)) {\n    throw new TypeError(`Invalid scheme ${scheme}`);\n  }\n\n  return parseProperties(scheme, str.substr(start));\n};\n"],"file":"parse.js"}