"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOptions = exports.checkOptions = void 0;
const _2019_1 = require("ajv/dist/2019");
const glob = require("glob");
const boolOrNat = { type: ["boolean", "integer"], minimum: 0 };
const CODE = "code-";
const ajvOptions = {
    strict: boolOrString(["log"]),
    strictSchema: boolOrString(["log"]),
    strictNumbers: boolOrString(["log"]),
    strictTypes: boolOrString(["log"]),
    strictTuples: boolOrString(["log"]),
    strictRequired: boolOrString(["log"]),
    allowMatchingProperties: { type: "boolean" },
    allowUnionTypes: { type: "boolean" },
    validateFormats: { type: "boolean" },
    data: { type: "boolean" },
    allErrors: { type: "boolean" },
    verbose: { type: "boolean" },
    comment: { type: "boolean" },
    inlineRefs: boolOrNat,
    loopRequired: { type: "integer" },
    loopEnum: { type: "integer" },
    ownProperties: { type: "boolean" },
    multipleOfPrecision: boolOrNat,
    messages: { type: "boolean" },
    [`${CODE}es5`]: { type: "boolean" },
    [`${CODE}lines`]: { type: "boolean" },
    [`${CODE}optimize`]: boolOrNat,
    [`${CODE}formats`]: { type: "string" },
    // options to modify validated data:
    removeAdditional: boolOrString(["all", "failing"]),
    useDefaults: boolOrString(["empty"]),
    coerceTypes: boolOrString(["array"]),
};
const ajv = new _2019_1.default({
    allErrors: true,
    coerceTypes: "array",
    strictTypes: false,
    formats: { notGlob: (s) => !glob.hasMagic(s) },
    keywords: ["ajvOptions"],
});
function boolOrString(vs) {
    return { anyOf: [{ type: "boolean" }, { enum: vs }] };
}
const DEFS = {
    stringOrArray: { type: ["string", "array"], items: { type: "string" } },
};
function checkOptions(schema, argv) {
    var _a;
    var _b;
    schema.$defs = DEFS;
    if ("ajvOptions" in schema) {
        schema.properties = { ...schema.properties, ...ajvOptions, ...withDashCase(ajvOptions) };
    }
    (_b = schema.properties)._ || (_b._ = { maxItems: 1 });
    schema.additionalProperties = false;
    const valid = ajv.validate(schema, argv);
    if (valid)
        return null;
    let errors = "";
    (_a = ajv.errors) === null || _a === void 0 ? void 0 : _a.forEach((err) => {
        errors += "error: ";
        switch (err.keyword) {
            case "required":
                errors += "parameter " + parameter(err.params.missingProperty) + " is required";
                break;
            case "additionalProperties":
                errors += "parameter " + parameter(err.params.additionalProperty) + " is unknown";
                break;
            case "maxItems":
                errors += "invalid syntax (too many arguments)";
                break;
            case "format":
                if (err.params.format === "notGlob") {
                    errors += "only one file is allowed in parameter " + parameter(err.instancePath.slice(1));
                    break;
                }
                errors += `parameter ${parameter(err.instancePath.slice(1))} ${err.message}`;
                break;
            default:
                errors += `parameter ${parameter(err.instancePath.slice(1))} ${err.message}`;
        }
        errors += "\n";
    });
    return errors;
}
exports.checkOptions = checkOptions;
function parameter(str) {
    return (str.length === 1 ? "-" : "--") + str;
}
function getOptions(argv) {
    var _a;
    const options = { code: {} };
    for (const opt in ajvOptions) {
        const value = (_a = argv[toDashCase(opt)]) !== null && _a !== void 0 ? _a : argv[opt];
        if (value === undefined)
            continue;
        if (opt.startsWith(CODE)) {
            options.code[opt.slice(CODE.length)] = value;
        }
        else {
            options[opt === "data" ? "$data" : opt] = value;
        }
    }
    return options;
}
exports.getOptions = getOptions;
function toDashCase(str) {
    return str.replace(/[A-Z]/g, (s) => "-" + s.toLowerCase());
}
function withDashCase(sm) {
    const res = {};
    for (const p in sm) {
        res[toDashCase(p)] = sm[p];
    }
    return res;
}
//# sourceMappingURL=options.js.map