# Build the RunWhen Local image
name: Build and Tag Image
on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - "src/VERSION"
      - ".github/workflows/merge_to_main.yaml"

permissions:
  contents: "read"
  id-token: "write"
  security-events: "write"
  actions: "read"
  packages: write

env:
  PROJECT_ID: runwhen-nonprod-shared
  IMAGE: runwhen-local
  DEFAULT_BRANCH: "origin/${{ github.event.repository.default_branch }}"
  CONTAINER_NAME: "runwhen-local"
  SHARED_ARTIFACT_REPOSITORY_PATH: "us-docker.pkg.dev/runwhen-nonprod-shared/public-images"
  RW_LOCAL_MKDOCS_CONFIG: "src/cheat-sheet-docs/mkdocs.yml"
  SANDBOX_DEPLOYMENT_NAME: "runwhen-local"
  SANDBOX_DEPLOYMENT_NAMESPACE: "runwhen-local"
  APP_LABEL: "app=runwhen-local"
  GHCR_ORG: "runwhen-contrib"


jobs:
  scan-repo:
    runs-on: ubuntu-latest
    outputs:
      image_path: ${{ steps.publish-beta.outputs.image_path }}
    steps:
      - uses: actions/checkout@v4
        name: Checkout
      # - name: Run Trivy vulnerability scanner in repo mode
      #   uses: aquasecurity/trivy-action@0.20.0
      #   with:
      #     scan-type: 'fs'
      #     ignore-unfixed: true
      #     format: 'sarif'
      #     output: 'trivy-results-repo.sarif'
      #     severity: 'CRITICAL'

      # - name: Upload Trivy scan results to GitHub Security tab
      #   uses: github/codeql-action/upload-sarif@v3
      #   with:
      #     sarif_file: 'trivy-results-repo.sarif'
  # Build amd64 natively on x86_64
  build-amd64:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    env:
      IMAGE: runwhen-local
      SHARED_ARTIFACT_REPOSITORY_PATH: us-docker.pkg.dev/runwhen-nonprod-shared/public-images
      RW_LOCAL_MKDOCS_CONFIG: src/cheat-sheet-docs/mkdocs.yml
      GHCR_ORG: "runwhen-contrib"
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
      - id: version
        run: |
          echo "VERSION=$(cat src/VERSION | jq -r .version)" | tee -a $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      - run: |
          sed -i "s/date: today/date: $(date +'%Y-%m-%d %H:%M')/g" ${RW_LOCAL_MKDOCS_CONFIG}
          sed -i "s/version: 0\.1/version: ${VERSION}/g" ${RW_LOCAL_MKDOCS_CONFIG}
      - uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.RUNWHEN_NONPROD_SHARED_WI_PROVIDER }}
          service_account: ${{ secrets.RUNWHEN_NONPROD_SHARED_WI_SA }}
      - run: gcloud --quiet auth configure-docker us-docker.pkg.dev
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build & push linux/amd64
        run: |
          cd src
          docker buildx create --use --name mybuilder || docker buildx use mybuilder
          docker buildx inspect --bootstrap
          docker buildx build \
            --platform linux/amd64 \
            --push \
            --tag "${{ env.SHARED_ARTIFACT_REPOSITORY_PATH }}/${{ env.IMAGE }}:${VERSION}-amd64" \
            --tag "${{ env.SHARED_ARTIFACT_REPOSITORY_PATH }}/${{ env.IMAGE }}:latest-amd64" \
            --tag "ghcr.io/${{ env.GHCR_ORG }}/${{ env.IMAGE }}:${VERSION}-amd64" \
            --tag "ghcr.io/${{ env.GHCR_ORG }}/${{ env.IMAGE }}:latest-amd64" \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --build-arg GITHUB_SHA="$GITHUB_SHA" \
            --build-arg GITHUB_REF="$GITHUB_REF" \
            -f Dockerfile .

  # Build arm64 natively on GitHub-hosted ARM
  build-arm64:
    runs-on: ubuntu-24.04-arm
    permissions:
      contents: read
      packages: write
      id-token: write
    env:
      IMAGE: runwhen-local
      SHARED_ARTIFACT_REPOSITORY_PATH: us-docker.pkg.dev/runwhen-nonprod-shared/public-images
      RW_LOCAL_MKDOCS_CONFIG: src/cheat-sheet-docs/mkdocs.yml
      GHCR_ORG: "runwhen-contrib"
    steps:
      - uses: actions/checkout@v4
      - run: echo "VERSION=$(cat src/VERSION | jq -r .version)" | tee -a $GITHUB_ENV
      - run: |
          sed -i "s/date: today/date: $(date +'%Y-%m-%d %H:%M')/g" ${RW_LOCAL_MKDOCS_CONFIG}
          sed -i "s/version: 0\.1/version: ${VERSION}/g" ${RW_LOCAL_MKDOCS_CONFIG}
      - uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.RUNWHEN_NONPROD_SHARED_WI_PROVIDER }}
          service_account: ${{ secrets.RUNWHEN_NONPROD_SHARED_WI_SA }}
      - run: gcloud --quiet auth configure-docker us-docker.pkg.dev
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build & push linux/arm64
        run: |
          cd src
          docker buildx create --use --name mybuilder || docker buildx use mybuilder
          docker buildx inspect --bootstrap
          docker buildx build \
            --platform linux/arm64 \
            --push \
            --tag "${{ env.SHARED_ARTIFACT_REPOSITORY_PATH }}/${{ env.IMAGE }}:${VERSION}-arm64" \
            --tag "${{ env.SHARED_ARTIFACT_REPOSITORY_PATH }}/${{ env.IMAGE }}:latest-arm64" \
            --tag "ghcr.io/${{ env.GHCR_ORG }}/${{ env.IMAGE }}:${VERSION}-arm64" \
            --tag "ghcr.io/${{ env.GHCR_ORG }}/${{ env.IMAGE }}:latest-arm64" \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --build-arg GITHUB_SHA="$GITHUB_SHA" \
            --build-arg GITHUB_REF="$GITHUB_REF" \
            -f Dockerfile .

  # Stitch the multi-arch tag when both are pushed
  publish-manifest:
    runs-on: ubuntu-latest
    needs: [build-amd64, build-arm64]
    permissions:
      contents: read
      packages: write
      id-token: write
    env:
      IMAGE: runwhen-local
      SHARED_ARTIFACT_REPOSITORY_PATH: us-docker.pkg.dev/runwhen-nonprod-shared/public-images
      GHCR_ORG: "runwhen-contrib"
    steps:
      - uses: actions/checkout@v4
      - run: echo "VERSION=$(cat src/VERSION | jq -r .version)" | tee -a $GITHUB_ENV
      - uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.RUNWHEN_NONPROD_SHARED_WI_PROVIDER }}
          service_account: ${{ secrets.RUNWHEN_NONPROD_SHARED_WI_SA }}
      - run: gcloud --quiet auth configure-docker us-docker.pkg.dev
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Create & push GCP manifest
        run: |
          FULL="${{ env.SHARED_ARTIFACT_REPOSITORY_PATH }}/${{ env.IMAGE }}"
          docker buildx imagetools create \
            --tag "${FULL}:${VERSION}" \
            --tag "${FULL}:latest" \
            "${FULL}:${VERSION}-amd64" \
            "${FULL}:${VERSION}-arm64"
      - name: Create & push GHCR manifest
        run: |
          FULL="ghcr.io/${{ env.GHCR_ORG }}/${{ env.IMAGE }}"
          docker buildx imagetools create \
            --tag "${FULL}:${VERSION}" \
            --tag "${FULL}:latest" \
            "${FULL}:${VERSION}-amd64" \
            "${FULL}:${VERSION}-arm64"
      - name: Inspect GCP manifest
        run: |
          FULL="${{ env.SHARED_ARTIFACT_REPOSITORY_PATH }}/${{ env.IMAGE }}"
          docker buildx imagetools inspect "${FULL}:${VERSION}"
      - name: Inspect GHCR manifest
        run: |
          FULL="ghcr.io/${{ env.GHCR_ORG }}/${{ env.IMAGE }}"
          docker buildx imagetools inspect "${FULL}:${VERSION}"

      - name: Notify Slack of Container Build
        id: slack-publish-nonprod-shared-artifact-repo
        uses: slackapi/slack-github-action@v1.19.0
        with:
          channel-id: "#notifications" # Slack channel id or name to post message. https://api.slack.com/methods/chat.postMessage#channels
          slack-message: "Just Pushed to ${{env.SHARED_ARTIFACT_REPOSITORY_PATH }}/${{ env.IMAGE }}:${{ env.VERSION }}"
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

  # Deploy to sandbox after successful build
  deploy-to-sandbox:
    runs-on: ubuntu-latest
    needs: [publish-manifest]
    env:
      SANDBOX_DEPLOYMENT_NAME: runwhen-local
      SANDBOX_DEPLOYMENT_NAMESPACE: runwhen-local
    steps:
      - name: Rollout new image in sandbox
        id: rollout-new-sandbox-image
        env:
          KUBECONFIG_SECRET: ${{secrets.SANDBOX_KUBECONFIG}}
        run: |-
          echo "$KUBECONFIG_SECRET" > kubeconfig
          KUBECONFIG=kubeconfig kubectl rollout restart deployment runwhen-local -n ${{ env.SANDBOX_DEPLOYMENT_NAMESPACE }}

      - name: Notify Slack of RunWhen Local Deployment
        id: slack-deploy-nonprod-sandbox
        uses: slackapi/slack-github-action@v1.19.0
        with:
          channel-id: "#env-sandbox" # Slack channel id or name to post message. https://api.slack.com/methods/chat.postMessage#channels
          slack-message: "Just deployed latest version of RunWhen Local to sandbox at https://runwhen-local.sandbox.runwhen.com"
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

      - name: Notify Slack of RunWhen Local Deployment to GHCR
        id: slack-deploy-to-ghcr
        uses: slackapi/slack-github-action@v1.19.0
        with:
          channel-id: "#runwhen-local" # Slack channel id or name to post message. https://api.slack.com/methods/chat.postMessage#channels
          slack-message: "Just deployed latest version of RunWhen Local to https://github.com/orgs/runwhen-contrib/packages/container/package/runwhen-local"
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

  notify:
    runs-on: ubuntu-latest
    needs:
      - publish-manifest
      - deploy-to-sandbox
      - scan-repo
    if: always()  # Ensure this runs even if previous jobs fail

    steps:
      - name: Set Workflow Status
        id: status
        run: |
          if [[ "${{ needs.publish-manifest.result }}" == "failure" || "${{ needs.deploy-to-sandbox.result }}" == "failure" || "${{ needs.scan-repo.result }}" == "failure" ]]; then
            echo "status=❌ *Failure*" >> $GITHUB_ENV
          elif [[ "${{ needs.publish-manifest.result }}" == "cancelled" || "${{ needs.deploy-to-sandbox.result }}" == "cancelled" || "${{ needs.scan-repo.result }}" == "cancelled" ]]; then
            echo "status=⚠️ *Cancelled*" >> $GITHUB_ENV
          else
            echo "status=✅ *Success*" >> $GITHUB_ENV
          fi

      - name: Send Slack Notification
        uses: slackapi/slack-github-action@v1
        with:
          channel-id: "#runwhen-local"
          slack-message: "${{ env.status }} - Workflow *${{ github.workflow }}* in repo *${{ github.repository }}* on branch *${{ github.ref_name }}*.\nSee the run: <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>"
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        