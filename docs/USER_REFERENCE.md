# Introduction
This document is the reference manual for RunWhen Local. It covers the configuration and execution of the tool that
discovers cloud resources, matches those resources against applicable RunWhen code bundles to generate a RunWhen
workspace, and generates cheat sheet documentation for any code bundles that have associated CLI commands that can
be executed manually from a command shell.

It's assumed that you've already downloaded and deployed RunWhen Local. If you haven't done that already,
the installation instructions are at the RunWhen web site:
https://docs.runwhen.com/public/v/runwhen-local/.

If you followed those getting started instructions you will have created some initial configuration data and executed
the RunWhen Local run script. That script first invokes the **workspace builder** to generate a RunWhen local
**workspace**, which is a collection of SLX configurations to be run by the RunWhen platform. The workspace builder
first scans for resources across all configured cloud platforms and builds a database of the discovered resources.
Then it evaluates matching rules in the configured RunWhen code collections against the discovered resources to
identify relevant code bundles. If a match is found the workspace builder generates SLX data associated with the
matching code bundle.

After the workspace builder has executed cheat sheet documentation is generated by scanning the generated workspace
and extracting CLI commands from any SLXs that are based on a command line tool execution rather than pure code.
This generates a static website that is used to browse the cheat sheet documentation and to trigger subsequent
executions of the RunWhen Local run/build process.

The rest of this document covers the details of the configuration files that are used to control the
RunWhen Local execution.

# Configuration

Assuming you've followed the getting started instructions at the RunWhen Local page listed above, you have
a directory  that's shared between your local execution environment and the container running RunWhen Local.
All configuration files go into that shared directory. There are three different types of configuration files:
* workspace info file
* upload info file
* workspace builder customization files

## Level of Detail
The matching of code bundles and generation of SLX info in the generated workspace is controlled by a
**level of detail** (LOD) setting, which can be specified at the level of a platform-specific scoping construct.
For example, for Kubernetes the LOD scoping is the namespace and for Azure it's the resource group.
The LOD lets the user control how detailed the generated SLX information is for each scope.
Each match rule for a code bundle has an associated LOD setting. And each scope for a cloud platform
also has a LOD (or a default value is used if one isn't set explicitly for a scope). When a match
is found the match rule LOD value is compared against the resource scope LOD value. If the scope LOD value is
greater (i.e. more detailed) than the match rule LOD value, then the match rule is enabled and emits the
associated SLXs.

The values for the level of detail are:

| String Value | Integer Value | Description                               |
|--------------|---------------|-------------------------------------------|
| none         | 0             | No SLXs are generated                     |
| basic        | 1             | Only basic SLXs are generated             |
| detailed     | 2             | All matching/relevant SLXs are generated  |

Note: In earlier versions of RunWhen Local the LOD values were integer values rather than string values.
These integer values are still supported for backwards compatibility, but are deprecated. You may
still see them in some existing code bundles and/or configuration files, though, so they're included in the
above table for reference purposes.

## Workspace Info File
The primary configuration file is the workspace info file, typically named workspaceInfo.yaml.
It contains information about:
* basic information for creating the RunWhen workspace
* which cloud platforms to scan to discover resources and credentials for accessing them
* which RunWhen code collections to scan for matching code bundles
* custom information used by specific code bundles

The top-level structure of the workspace info file is:
```yaml
# Information about the RunWhen workspace
workspaceName: my-workspace
# More workspace config
# Information about cloud platforms to scan to discover resources
cloudConfig:
  kubernetes:
    # Kubernetes config
  azure:
    # Azure config
  # Other platform configs
  
# Information about which code collections to scan for code bundles
codeCollections:
- "https://github.com/runwhen-contrib/rw-public-codecollection.git"
- # Another code collections to scan


# Custom information about specific code bundles
custom:
  prometheus_provider: gmp
  # More custom configuration
```
### Basic Workspace Configuration Info
There are several settings that are used to configure information in the workspace that's generated to be uploaded to the RunWhen platform to. The available settings are:

| Label               | Description                                             |
|---------------------|---------------------------------------------------------|
| workspaceName       | The name of the workspace to generate                   |
| workspaceOwnerEmail | The email address of the owner of the workspace         |
| defaultLocation     | The location where the the workspace is hosted          |
| defaultLOD          | The default level of detail to user for cloud resources |


### Cloud Platform Configuration

Information about the cloud platforms to scan for resources is contained in the "cloudConfig" block/object
in the workspace info file. There's a separate block for each platform with platform-specific fields
containing credentials for accessing the cloud platform, resource scope level of detail configuration,
and possibly other configuration relevant to that platform.

The currently supported platforms are Kubernetes, Azure, and GCP.

#### Kubernetes
The supported fields for Kubernetes (block name = "kubernetes) are:

| Field Name     | Description                                                                 |
|----------------|-----------------------------------------------------------------------------|
| kubeconfigFile | The name of the kubeconfig file to use                                      |
| namespaceLODs  | Object/dictionary specifying level of detail values for specific namespaces |
| namespaces     | An explicit list of which namespaces to scan for resources                  |

For the "kubeconfig" field you need to copy that file into the shared directory and the field value is
just the name of that file.

The "namespaceLODs" field is a dictionary/object where the key/field is the name of the namespace
and the value is a level of detail value, either "none", "basic" or "detailed" as described above.

The "namespaces" field should only be needed in cases of limited privilege where the credentials
in the kubeconfig file don't have privileges to list all the available namespaces, but do
have privileges to access resources in certain namespaces, but you need to already know the
names of the namespaces. So this is a mechanism for specifying this explicit list of namespaces.

#### Azure
The supported fields for Azure (block name = "azure") are:

| Field Name                  | Description                                                                      |
|-----------------------------|----------------------------------------------------------------------------------|
| subscriptionId              | The subscription ID for the specified client/application ID                      |
| tenantId                    | The tenant ID for the specified client/application ID                            |
| clientId                    | The client/application ID to use to authenticate                                 |
| clientSecret                | The client/application secret to use to authenticate                             |
| resourceGroupLevelOfDetails | Object/dictionary specifying level of detail values for specific resource groups |

The first four fields are necessary for authenticating to Azure to index/discover resources. The workspace
builder uses CloudQuery under the covers to do the indexing for Azure. The documentation for the
Azure plugin to CloudQuery (https://hub.cloudquery.io/plugins/source/cloudquery/azure/v11.4.2/docs)
contains more information about those fields and how to generate them using the Azure CLI.

The resourceGroupLevelOfDetails fields is similar to the namespaceLODs field for the Kubernetes plugin.
The key/field name is the name of the resource group and the value is the level of detail value.

#### Google Cloud Platform (GCP)
The supported fields for GCP (block name = "gcp") are:

| Field Name                 | Description                                                               |
|----------------------------|---------------------------------------------------------------------------|
| applicationCredentialsFile | Name of the credentials file to use to authenticate                       |
| projects                   | List of names of the projects to index                                    |
| projectLevelOfDetails      | Object/dictionary specifying level of detail values for specific projects |

The "applicationCredentialsFile" is the name of the file in the shared directory to use to authenticate to GCP.
This file is created/downloaded using the GCP CLI or web GUI. Similar to Azure, the GCP support is based on
CloudQuery, so the documentation page for the CloudQuery GCP plugin
(https://hub.cloudquery.io/plugins/source/cloudquery/gcp/v11.5.1/docs) contains more details about
the credentials file.

The "projects" fields specifies the list of projects to index. In that case the application credentials
file must be configured so that it can access multiple projects. Consult the GCP documentation for how
to do that. The entries in this list are project ID values.

The "projectLevelOfDetails" is similar to the Kubernetes namespaceLODs field except that the key/field
name is the name of the project (more specifically, the project ID).

### Code Collection Configuration

By default, the workspace builder scans for code bundles from a built-in/preconfigured list
of standard RunWhen code collections. Currently, this list is:

| Code Collection | Branch |
|------|-------|
| https://github.com/runwhen-contrib/rw-public-codecollection.git | main |
| https://github.com/runwhen-contrib/rw-cli-codecollection.git | main |

You may want to override the built-in list for a number of reasons:
- supplementing the built-in code collections with other third-party code collections
- suppressing one or more of the built-in code collections
- overriding the branch used for one or more code collections
- specifying a subset of the code bundles to enable for a code collection

To support these use cases the code collection list can be customized in the workspace info file
with a "codeCollections" block. This is a list of the code collections to enable. A code
collection item in the list can be specified with either a simple string or a code
collection object/block with info about the target code collection.

For the string specification the string is just the URL of the git repo. The string can
also be the special "defaults" value, which enables all the built-in code collections.
This is useful if you want to enable most of the built-in code collections, but
suppress/blacklist some of them. If you prefix the git URL with a "!" character, then
that means to exclude that code collection rather than enable it. When using the string
format for a code collection entry the "main" branch is used. If you want to specify
a different branch you need to use the object/block format.

The object block format for a code collection entry is an object/dictionary with the following fields:

| Field Name  | Description                                                           |
|-------------|-----------------------------------------------------------------------|
| repoURL     | URL of the git repo for the code collection                           |
| branch      | branch to use in the repo                                             |
| tag         | tag to use in the repo                                                |
| ref         | git ref to use in the repo                                            |
| authUser    | user id to use when cloning the repo                                  |
| authToken   | auth token credential to use when cloning repo                        |
| action      | inclusion action, either "include" or "exclude", defaults to "include |
| codeBundles | List of code bundles to enable for the code collection                |

Only one of the branch, tag or ref fields should be specified.

The authUser and authToken fields are only necessary for non-public repos. All the RunWhen-provided
code collections are open source, so they don't require any credentials.

The "action" field lets you toggle between inclusion/whitelist and exclusion/blacklist. The most
common use case will just be an explicit whitelist of included code collections. Since the "action"
field defaults to "include" you can just omit it for that use case.

The "codeBundles" field is just a list of the names of the code bundles to enable. The code
bundle name is the directory name of the code bundle in the codebundles directory in the code
collection. This field is optional. If it's omitted, then all code bundles are enabled. The
code bundle value can be a file glob expression like you can use is the command line shell,
so you can have wildcard expressions that match multiple code bundles. TODO: would be nice
to have some examples here.

The custom code collection configuration is useful for code collection authors. For new
third-party code collections you can just add the new code collection to the list. If
you're developing/testing a single code bundle, you can limit the workspace builder to
just that code bundle:
```yaml
codeCollections:
- repoURL: https://github.com/author-account/my-custom-code-collection.git
  codeBundles:
  - my-code-bundle
```
If you're developing new code bundles for one of the standard RunWhen code collections, then
the easiest way to handle that is to fork the RunWhen repo and then stage your new code bundle
code in the fork. Remember that you need to commit any changes you make to your local clone
and push to the GitHub repo to make the new code accessible to the workspace builder.

### Custom Code Bundle Configuration
Individual code bundles may require additional information to generate the SLX files in the generated workspace.
These settings go in the "custom" block in the workspace info file. Consult the documentation for the code collection
for information about which custom settings are required for specific code bundles.

## Upload Info File

After RunWhen Local has executed and generate a workspace the workspace can be uploaded
to the RunWhen platform where it can be viewed in a web GUI and the configured SLXs can
be executed. To perform the upload RunWhen Local needs credentials
to authenticate to the RunWhen platform. To obtain the credentials you first need to create an account on the
RuwWhen platform and create a new, empty workspace in the GUI.

Once you've done that, navigate to the workspace settings page where there's a link to
create an upload info file associated with that workspace. Save the upload info file to the shared
directory used by RunWhen Local. It contains the information about the settings for the workspace and an upload
token value, which is used by RunWhen Local to authenticate to the RunWhen platform. It doesn't contain
any user-configured information, so you shouldn't edit the file and should just consider it as opaque data.
Now rerun the RunWhen Local script and add the --upload flag, which uses the upload info file to
authenticate to the platform and uploads and merges the newly generated workspace data.

When you create the upload info file the GUI prompts you for an expiration date for the embedded authentication
token. Unless you choose to have the token never expire you will need to periodically refresh/redownload the
upload info file from the RunWhen platform GUI after each expiration.

Note that the name of the workspace that was generated in the platform is included in the upload info file
and overrides the workspace name in the workspace info file, since the names must match between the workspace
in the platform and the workspace data that's created by RunWhen Local.

## Workspace Builder Customization Files

Workspace builder customization files support more fine-grained customization of the workspace builder operation.
Currently, two types of customizations are supported:
* groups of SLXs
* dependency relationships between groups

To add customization files, create a directory named "map-customization-rules" in the shared directory.
Then create one or more YAML files in this directory, named whoever you like, that contains the
customization content.

The top-level structure of a customization file is:
```yaml
apiVersion: runwhen.com/v1
kind: MapCustomizationRules
spec:
  groupRules:
  - match: # Boolean predicate that matches SLXs to assign to the specified group
    group: # Which group to assign the SLX to
  groupRelationshipRules:
  - subject: # Name of the subject group in the relationship
    verb: # Relationship/dependency direction, either "dependent-on" or "depended-on-by"
    matches: # Boolean predicate that matches other groups that are related to the subject group
```

### Match Predicates
Both types of customization rules make use of a YAML structured object representing a boolean match predicate
expression. All predicates have a common "type" field that indicates the type of the match predicate,
i.e. a polymorphic type indicator. The leaf predicates that do the actual matching use regular
expression to match against attributes of some target object, either an SLX instance (for SLX
groupings) or group name (for group dependency relationships). Those match predicates are
discussed in the following sections that discuss the different customizations.

Additionally, there are predicate that combine child predicates in the usual boolean logical
operations.

The boolean AND operation is supported with an "and" predicate type. The predicate evaluates
to true only if all the child match predicates evaluate to true. The format is:

| Field Name | Description                                |
|------------|--------------------------------------------|
| type       | Value is "and" for a boolean AND operation |
| matches    | List of child match predicates             |

The boolean OR operation is supported with an "or" predicate type. The predicate evaluates
to true if any of the child match predicates evaluates to true. The format is:

| Field Name | Description                              |
|------------|------------------------------------------|
| type       | Value is "or" for a boolean OR operation |
| matches    | List of child match predicates           |

The boolean NOT operation is supported with a "not" predicate type. The predicate
evaluates to true if the child predicate evaluates to false. The format is:

| Field Name | Description                                |
|------------|--------------------------------------------|
| type       | Value is "not" for a boolean NOT operation |
| predicate  | Child match predicate                      |

### SLX Groups

The RunWhen platform workspace/map GUI lets you group together related SLXs. These groupings may be
based on the cloud platform scope or some related functionality. The style of grouping is a
user preference and, in general, the workspace builder doesn't have the requisite  domain knowledge
about the target cloud application to know how to group things, so it must be configured by the user
in a "groupRules" block in a map customization file containing one or more group rules. The
workspace builder does have some simple standard group rules, but it is likely that users will
have a different grouping model of their application and will want to override the defaults.

Each group rule contains two fields:

| Field Name | Description                                                                    |
|------------|--------------------------------------------------------------------------------|
| match      | Boolean predicate that matches generated SLXs to assign to the specified group |
| group      | Name of the group to which to assign the matching SLXs                         |

The "match" field is a match predicate described above.

The predicate type that actually matches things is a "pattern" predicate. The fields of a pattern
predicate are:

| Field Name | Description                                                                               |
|------------|-------------------------------------------------------------------------------------------|
| type       | value is "pattern" for a pattern predicate                                                |
| matchType  | Which property of a candidate SLX to match on (should probably be named matchProperty?)   |
| pattern    | A regular expression pattern to match against the indicated matchType property of the SLX |
| matchMode  | Type of match operation, either "substring" or "exact"; defaults to "substring"           |

The supported values for the matchType are:

| Type/Property Name | Description                                                                 |
|--------------------|-----------------------------------------------------------------------------|
| name               | Shortened name of the SLX                                                   |
| qualified-name     | Qualified name of the SLX                                                   |
| full-name          | Full (unshortened) name of the SLX                                          |
| base-name          | Base name of the candidate SLX, i.e. minus any resource-specific qualifiers |
| <resource-path>    | A path in the full data of the discovered resource associated with the SLX  |

The "name" field is the name in the Kubernetes custom resource file. It is typically a shortened,
not super human-friendly name including the workspace name, so you will typically not want to match on this.

The "qualified name" is the same as the name field, minus the workspace name. Similary, it's not
super-friendly, so not typically what you want to match on.

The "full-name" is the full name of the SLX, not including the workspace name, and also not
doing any shortening/mangling of the qualifier values.

The "base-name" is the base name of the SLX, minus the resource-dependent qualifier values. This
is the most common field to match, since it typically contains some indication of the
component/purpose associated with the SLX.

If the matchType value doesn't match one of these built-in values, then it is interpreted as
a path expression into the raw resource data. The path expression is a slash-separated list
of path components in the resource data. If one of the components in the path is a list,
then the rest of the path is evaluated against each of the elements in the list and if
any of them matches, then it's considered a match.

The raw resource data is very platform and resource type dependent, so consult the documentation
for the specific platforms for information about the structure of the data.

The "pattern" field uses the Python regular expression syntax (https://docs.python.org/3/library/re.html)

The values for the "matchMode" field are:

| Value     | Description                                                            |
|-----------|------------------------------------------------------------------------|
| substring | Matches if any substring of the matchType property matches the pattern |
| exact     | Matches if the full name of the matchType property matches the pattern |

### Group Relationships
