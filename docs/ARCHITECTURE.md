# Architecture 

## High-Level Architecture 
The current design and packaging of RunWhen Local is such that it can be deployed as a single container into any container runtime or Kubernetes environment. This would support users who wish to run this locally on their laptop, or deployed in a self-managed cluster, whichever is easier for the user. All data that RunWhen Local collects is stored locally and does not interact with any other RunWhen Platform API **unless it intentionally uploaded for the purposes of onboarding to RunWhen Platform**. 

![](../assets/architecture-high-level.svg)

In the diagram above, we can see that the RunWhen Local container image has two main components: 
- **Workspace Builder**: Performs discovery of Kubernetes based resources and uses specific rules to generate RunWhen specific data
- **Cheat Sheet**: This component reads in all of RunWhen specifc configuration data generated by Workspace builder and creates tailored troubleshooting commands that are displayed by an MkDocs instance

The following high-level flow is shown: 
1. The user provides the necessary configuration data, which includes: 
    - a single kubeconfig with the necessary permissions and clusters to be scanned
    - a workspaceInfo.yaml file, which provides instruction on how to discover the resources, along with other details that are useful **if** uploading the contents to the RunWhen Platform (which is part of the onboarding experience for the commercial SaaS offering). 
2. The Workspace Builder performs a discovery task and stores all discovered resources into a neo4j database
3. Generation Rules and Customization Rules are then applied to the discovered resources, matching open source troubleshooting commands with the discovered resources. 
4. Configuration files are generated and stored in the output directory that are specific to RunWhen - these files contain links to the applicable open source troubleshooting code, along with the specific customizations needed to make the commands work for the specific user. 
5. The Cheat Sheet process then reads in the configuration files
6. With the configuration files read, it 
    - Downloads the open source troubleshooting code
    - Combines the configuration parameters with the open source troubleshooting code
    - Creates markdown documentation with each applicable troubleshooting command
6. Finally all markdown content is copied to a directory that MkDocs is actively watching, presenting this to the user.  

