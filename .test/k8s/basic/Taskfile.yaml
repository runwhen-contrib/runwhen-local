version: "3"

tasks:
  default:
    desc: "Generate workspaceInfo and rebuild/test"
    cmds:
      - task: generate-rwl-config-basic
      - task: build-rwl
      - task: run-rwl-discovery

  clean:
    desc: "Run cleanup tasks"
    cmds:
      - task: clean-rwl-discovery

  generate-rwl-config-detailed:
    desc: "Generate RunWhen Local configuration (workspaceInfo.yaml)"
    env:
      RW_WORKSPACE: '{{.RW_WORKSPACE | default "my-workspace"}}'
    cmds:
      - |
        # Generate workspaceInfo.yaml with fetched cluster details
        cat <<EOF > workspaceInfo.yaml
        workspaceName: "$RW_WORKSPACE"
        workspaceOwnerEmail: authors@runwhen.com
        defaultLocation: location-01
        defaultLOD: detailed
        cloudConfig:
          kubernetes:             
            kubeconfigFile: /shared/kubeconfig.secret
            contexts:
              sandbox-cluster-1: 
                defaultNamespaceLOD: detailed
        codeCollections: []
        # codeCollections: 
        #   - repoURL: "https://github.com/runwhen-contrib/rw-cli-codecollection"
        #     branch: "main"
        #     codeBundles: ["k8s-namespace-healthcheck", "k8s-deployment-healthcheck"]
        custom: 
          kubernetes_distribution_binary: kubectl
        EOF
    silent: true

  generate-rwl-config-basic:
    desc: "Generate RunWhen Local configuration (workspaceInfo.yaml)"
    env:
      RW_WORKSPACE: '{{.RW_WORKSPACE | default "my-workspace"}}'
    cmds:
      - |
        # Generate workspaceInfo.yaml with fetched cluster details
        cat <<EOF > workspaceInfo.yaml
        workspaceName: "$RW_WORKSPACE"
        workspaceOwnerEmail: authors@runwhen.com
        defaultLocation: location-01
        defaultLOD: detailed
        cloudConfig:
          kubernetes:             
            kubeconfigFile: /shared/kubeconfig.secret
            contexts:
              sandbox-cluster-1: 
                defaultNamespaceLOD: basic
        codeCollections: []
        # codeCollections: 
        #   - repoURL: "https://github.com/runwhen-contrib/rw-cli-codecollection"
        #     branch: "main"
        #     codeBundles: ["k8s-namespace-healthcheck", "k8s-deployment-healthcheck"]
        custom: 
          kubernetes_distribution_binary: kubectl
        EOF
    silent: true

  build-rwl:
    desc: "Build RWL test image"
    cmds:
      - |
        BUILD_DIR=../../../src/
        CONTAINER_NAME="RunWhenLocal"
        if docker ps -q --filter "name=$CONTAINER_NAME" | grep -q .; then
          echo "Stopping and removing existing container $CONTAINER_NAME..."
          docker stop $CONTAINER_NAME && docker rm $CONTAINER_NAME
        elif docker ps -a -q --filter "name=$CONTAINER_NAME" | grep -q .; then
          echo "Removing existing stopped container $CONTAINER_NAME..."
          docker rm $CONTAINER_NAME
        else
          echo "No existing container named $CONTAINER_NAME found."
        fi
        
        echo "Cleaning up output directory..."
        rm -rf output || { echo "Failed to remove output directory"; exit 1; }
        mkdir output && chmod 777 output || { echo "Failed to set permissions"; exit 1; }
        ## Building Container Image
        docker buildx build --builder mybuilder --platform linux/amd64  --build-arg INCLUDE_CODE_COLLECTION_CACHE=true -t runwhen-local:test -f $BUILD_DIR/Dockerfile $BUILD_DIR --load

        ## Use this if you need to test both arm64/amd64 builds
        # docker buildx build --builder mybuilder --platform linux/amd64,linux/arm64  -t runwhen-local:test -f $BUILD_DIR/Dockerfile $BUILD_DIR

    silent: true


  run-rwl-discovery-no-github:
    desc: "Run RunWhen Local Discovery on test infrastructure"
    cmds:
      - |
        rm slx_count.txt || true
        CONTAINER_NAME="RunWhenLocal"    
        if docker ps -q --filter "name=$CONTAINER_NAME" | grep -q .; then
          echo "Stopping and removing existing container $CONTAINER_NAME..."
          docker stop $CONTAINER_NAME && docker rm $CONTAINER_NAME
        elif docker ps -a -q --filter "name=$CONTAINER_NAME" | grep -q .; then
          echo "Removing existing stopped container $CONTAINER_NAME..."
          docker rm $CONTAINER_NAME
        else
          echo "No existing container named $CONTAINER_NAME found."
        fi
        
        echo "Cleaning up output directory..."
        rm -rf output || { echo "Failed to remove output directory"; exit 1; }
        mkdir output && chmod 777 output || { echo "Failed to set permissions"; exit 1; }

        echo "Starting new container $CONTAINER_NAME..."

        docker run -e DEBUG_LOGGING=false --add-host github.com:0.0.0.0 --name $CONTAINER_NAME -p 8081:8081 -v $(pwd):/shared -d runwhen-local:test || {
          echo "Failed to start container"; exit 1;
        }

        echo "Running workspace builder script in container..."
        docker exec -w /workspace-builder $CONTAINER_NAME ./run.sh $1 --verbose || {
          echo "Error executing script in container"; exit 1;
        }

        echo "Review generated config files under output/workspaces/"
        total_slxs=$(find $(find 'output/' -type d -name 'slxs') -mindepth 1 -type d | wc -l)
        echo "Total SLXs: $total_slxs"
        echo "$total_slxs" > slx_count.txt
    silent: true

  run-rwl-discovery:
    desc: "Run RunWhen Local Discovery on test infrastructure"
    cmds:
      - |
        rm slx_count.txt || true
        CONTAINER_NAME="RunWhenLocal"    
        if docker ps -q --filter "name=$CONTAINER_NAME" | grep -q .; then
          echo "Stopping and removing existing container $CONTAINER_NAME..."
          docker stop $CONTAINER_NAME && docker rm $CONTAINER_NAME
        elif docker ps -a -q --filter "name=$CONTAINER_NAME" | grep -q .; then
          echo "Removing existing stopped container $CONTAINER_NAME..."
          docker rm $CONTAINER_NAME
        else
          echo "No existing container named $CONTAINER_NAME found."
        fi
        
        echo "Cleaning up output directory..."
        rm -rf output || { echo "Failed to remove output directory"; exit 1; }
        mkdir output && chmod 777 output || { echo "Failed to set permissions"; exit 1; }

        echo "Starting new container $CONTAINER_NAME..."

        docker run -e DEBUG_LOGGING=false --name $CONTAINER_NAME -p 8081:8081 -p 8000:8000 -v $(pwd):/shared -d runwhen-local:test || {
          echo "Failed to start container"; exit 1;
        }

        echo "Running workspace builder script in container..."
        docker exec -w /workspace-builder $CONTAINER_NAME ./run.sh $1 --verbose || {
          echo "Error executing script in container"; exit 1;
        }

        echo "Review generated config files under output/workspaces/"
        total_slxs=$(find $(find 'output/' -type d -name 'slxs') -mindepth 1 -type d | wc -l)
        echo "Total SLXs: $total_slxs"
        echo "$total_slxs" > slx_count.txt
    silent: true

  ci-run-rwl-discovery:
    desc: "Run RunWhen Local Discovery on test infrastructure"
    cmds:
      - |
        rm slx_count.txt || true
        CONTAINER_NAME="RunWhenLocal"    
        if docker ps -q --filter "name=$CONTAINER_NAME" | grep -q .; then
          echo "Stopping and removing existing container $CONTAINER_NAME..."
          docker stop $CONTAINER_NAME && docker rm $CONTAINER_NAME
        elif docker ps -a -q --filter "name=$CONTAINER_NAME" | grep -q .; then
          echo "Removing existing stopped container $CONTAINER_NAME..."
          docker rm $CONTAINER_NAME
        else
          echo "No existing container named $CONTAINER_NAME found."
        fi
        
        echo "Cleaning up output directory..."
        rm -rf output || { echo "Failed to remove output directory"; exit 1; }
        mkdir output && chmod 777 output || { echo "Failed to set permissions"; exit 1; }
        chmod 777 . 
        echo "Starting new container $CONTAINER_NAME..."
        echo "User $(whoami)"
        # 1. Start container in the background
        docker run -d \
          -e WB_DEBUG_SUPPRESS_CHEAT_SHEET="true" \
          -e DEBUG_LOGS=true \
          --name "$CONTAINER_NAME" \
          -p 8081:8081 \
          -v "$(pwd):/shared" \
          runwhen-local:test

        # 2. Follow the main container logs in the background (if you care about them)
        docker logs -f "$CONTAINER_NAME" &

        # 3. Now exec the script. Its stdout goes to your pipeline.
        #    By default, docker exec prints to the current terminal/session.
        docker exec -w /workspace-builder "$CONTAINER_NAME" ./run.sh "$1" --verbose 2>&1 | tee run_sh_output.log

        # 3.5. Capture container logs before stopping (needed for git safe directory validation)
        echo "Capturing container logs..."
        docker logs "$CONTAINER_NAME" > container_logs.log 2>&1 || echo "Failed to capture container logs"

        # 4. (Optional) Stop container if you no longer need it running
        docker stop "$CONTAINER_NAME"
        docker rm "$CONTAINER_NAME"        

        echo "Review generated config files under output/workspaces/"
        total_slxs=$(find $(find 'output/' -type d -name 'slxs') -mindepth 1 -type d | wc -l)
        echo "Total SLXs: $total_slxs"
        echo "$total_slxs" > slx_count.txt
    silent: true


  ci-test-1:
      desc: "Run CI Discovery Test 1 - K8s only - basic LOD "
      env:
        RW_WORKSPACE: '{{.RW_WORKSPACE | default "my-workspace"}}'
      vars: 
        EXPECTED_SLXS: "5"
      cmds:
        - |
          # Generate workspaceInfo.yaml with fetched cluster details
          cat <<EOF > workspaceInfo.yaml
          workspaceName: "$RW_WORKSPACE"
          workspaceOwnerEmail: authors@runwhen.com
          defaultLocation: location-01
          defaultLOD: none
          cloudConfig:
            kubernetes:             
              kubeconfigFile: /shared/kubeconfig.secret
              contexts:
                sandbox-cluster-1: 
                  defaultNamespaceLOD: basic
              
              namespaces:
                - ci-verify-basic
          codeCollections: []
          custom: 
            kubernetes_distribution_binary: kubectl
          EOF

        - task: ci-run-rwl-discovery
        - task: verify-slx-count
          vars:
            EXPECTED_SLX_COUNT: "{{.EXPECTED_SLXS}}"
        - task: verify-rwl-output
        - task: validate-k8s-yaml
      silent: true


  ci-test-2:
      desc: "Run CI Discovery Test 2 - K8s only - detailed LOD "
      env:
        RW_WORKSPACE: '{{.RW_WORKSPACE | default "my-workspace"}}'
      vars: 
        EXPECTED_SLXS: "12"
      cmds:
        - |
          # Generate workspaceInfo.yaml with fetched cluster details
          cat <<EOF > workspaceInfo.yaml
          workspaceName: "$RW_WORKSPACE"
          workspaceOwnerEmail: authors@runwhen.com
          defaultLocation: location-01
          defaultLOD: none
          cloudConfig:
            kubernetes:             
              kubeconfigFile: /shared/kubeconfig.secret
              contexts:
                sandbox-cluster-1: 
                  defaultNamespaceLOD: detailed
              namespaces:
                - ci-verify-basic
          codeCollections: []
          custom: 
            kubernetes_distribution_binary: kubectl
          EOF

      
        - task: ci-run-rwl-discovery
        - task: verify-slx-count
          vars:
            EXPECTED_SLX_COUNT: "{{.EXPECTED_SLXS}}"
        - task: validate-k8s-yaml


      silent: true

  test-multi-kubeconfig:
      desc: "Test multi-context kubeconfig with overlapping namespaces"
      cmds:
        - |
          echo "Testing multi-context kubeconfig discovery..."
          echo "Expected: Both watcher-platform-cluster-01 and beta-platform-cluster-01"
          echo "should emit SLXs for backend-services namespace (LOD: detailed)"
          
          # Copy the multi-kubeconfig workspaceInfo
          cp multi-kubeconfig-workspaceInfo.yaml workspaceInfo.yaml

        - task: build-rwl
        - task: run-rwl-discovery
        
        - |
          echo ""
          echo "=== Multi-Context Test Results ==="
          total_slxs=$(find $(find 'output/' -type d -name 'slxs') -mindepth 1 -type d 2>/dev/null | wc -l)
          echo "Total SLXs generated: $total_slxs"
          echo ""
          echo "Review the generated SLXs in output/workspaces/"
          echo "Check the logs for namespace processing from both contexts"
      silent: false

  ci-test-local-git:
      desc: "Run CI Discovery Test - Local Git Functionality Validation"
      env:
        RW_WORKSPACE: '{{.RW_WORKSPACE | default "my-workspace-local-git"}}'
      vars: 
        EXPECTED_SLXS: "1"
      cmds:
        - |
          # Generate workspaceInfo.yaml with useLocalGit enabled and explicit code collections
          cat <<EOF > workspaceInfo.yaml
          workspaceName: "$RW_WORKSPACE"
          workspaceOwnerEmail: authors@runwhen.com
          defaultLocation: location-01
          defaultLOD: none
          cloudConfig:
            kubernetes:             
              kubeconfigFile: /shared/kubeconfig.secret
              contexts:
                sandbox-cluster-1: 
                  defaultNamespaceLOD: detailed
          codeCollections:
          - repoURL: https://github.com/runwhen-contrib/rw-public-codecollection.git
            tag: v0.0.20
          - repoURL: https://github.com/runwhen-contrib/rw-cli-codecollection.git
            tag: v0.0.26
            codeBundles: ["k8s-cluster-resource-health"]
          - repoURL: https://github.com/runwhen-contrib/rw-workspace-utils.git
            tag: 2025-11-03.1
          - repoURL: https://github.com/runwhen-contrib/azure-c7n-codecollection.git
            tag: v0.0.1
          useLocalGit: true
          custom: 
            kubernetes_distribution_binary: kubectl
          EOF

        - task: ci-run-rwl-discovery
        - task: verify-local-git-logs
        - task: verify-slx-count
          vars:
            EXPECTED_SLX_COUNT: "{{.EXPECTED_SLXS}}"
        - task: validate-k8s-yaml

      silent: true

  verify-local-git-logs:
    desc: "Verify that local git functionality worked correctly by checking logs"
    vars:
      # Expected code collections that must be served from local cache.
      # Must match repos in src/default-code-collections.yaml (those baked into the image).
      # rw-generic-codecollection is NOT in the default cache ‚Äî it will clone remotely.
      EXPECTED_CACHED_REPOS: "rw-public-codecollection rw-cli-codecollection rw-workspace-utils azure-c7n-codecollection"
    cmds:
      - |
        echo ""
        echo "========================================"
        echo "  Local Git Functionality Validation"
        echo "========================================"
        echo ""

        FAILURES=0
        WARNINGS=0

        # Helper: search both log files (container_logs.log has entrypoint + Django server output,
        # run_sh_output.log has the docker-exec run.sh output)
        search_logs() {
          local pattern="$1"
          grep -q "$pattern" run_sh_output.log 2>/dev/null && return 0
          [ -f container_logs.log ] && grep -q "$pattern" container_logs.log 2>/dev/null && return 0
          return 1
        }
        extract_logs() {
          local pattern="$1"
          { grep "$pattern" run_sh_output.log 2>/dev/null; [ -f container_logs.log ] && grep "$pattern" container_logs.log 2>/dev/null; } | sort -u
        }

        # ‚îÄ‚îÄ 1. USE_LOCAL_GIT resolved correctly ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        echo "--- [1/6] USE_LOCAL_GIT configuration ---"
        if search_logs "USE_LOCAL_GIT resolved to True"; then
          echo -e "\033[32m  ‚úî USE_LOCAL_GIT resolved to True\033[0m"
          extract_logs "USE_LOCAL_GIT resolved to" | sed 's/^/    /'
        elif search_logs "Using local git cache dir:"; then
          echo -e "\033[32m  ‚úî USE_LOCAL_GIT is active (inferred from cache usage)\033[0m"
          WARNINGS=$((WARNINGS + 1))
          echo -e "\033[33m    ‚ö† 'USE_LOCAL_GIT resolved to' log line not found ‚Äî upgrade code_collection.py\033[0m"
        else
          echo -e "\033[31m  ‚úò USE_LOCAL_GIT does not appear to be enabled\033[0m"
          echo "    Searched for 'USE_LOCAL_GIT resolved to True' and 'Using local git cache dir:'"
          echo "    in run_sh_output.log and container_logs.log"
          FAILURES=$((FAILURES + 1))
        fi
        echo ""

        # ‚îÄ‚îÄ 2. Git safe directories ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        echo "--- [2/6] Git safe directory configuration ---"
        SAFE_DIR_COUNT=$(extract_logs "Added safe directory:" | wc -l)
        if [ "$SAFE_DIR_COUNT" -gt 0 ]; then
          echo -e "\033[32m  ‚úî $SAFE_DIR_COUNT safe directories configured\033[0m"
          extract_logs "Added safe directory:" | sed 's/^/    /'
        else
          echo -e "\033[31m  ‚úò No 'Added safe directory:' messages found in logs\033[0m"
          FAILURES=$((FAILURES + 1))
        fi
        echo ""

        # ‚îÄ‚îÄ 3. All expected code collections served from local cache ‚îÄ
        echo "--- [3/6] Code collections served from local cache ---"
        CACHE_HIT_COUNT=0
        CACHE_MISS_REPOS=""
        for repo in {{.EXPECTED_CACHED_REPOS}}; do
          if search_logs "Using local git cache dir:.*${repo}"; then
            echo -e "\033[32m  ‚úî ${repo} ‚Äî served from local cache\033[0m"
            CACHE_HIT_COUNT=$((CACHE_HIT_COUNT + 1))
          else
            echo -e "\033[31m  ‚úò ${repo} ‚Äî NOT found in local cache logs\033[0m"
            CACHE_MISS_REPOS="${CACHE_MISS_REPOS} ${repo}"
            FAILURES=$((FAILURES + 1))
          fi
        done
        EXPECTED_COUNT=$(echo "{{.EXPECTED_CACHED_REPOS}}" | wc -w)
        echo "  ($CACHE_HIT_COUNT / $EXPECTED_COUNT code collections from cache)"
        echo ""

        # ‚îÄ‚îÄ 4. No remote clone operations ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        echo "--- [4/6] No remote git clone/fetch operations ---"
        if search_logs "Cloning from git source"; then
          echo -e "\033[31m  ‚úò Remote clone detected ‚Äî useLocalGit should prevent this\033[0m"
          extract_logs "Cloning from git source" | sed 's/^/    /'
          FAILURES=$((FAILURES + 1))
        else
          echo -e "\033[32m  ‚úî No remote clone operations detected\033[0m"
        fi
        echo ""

        # ‚îÄ‚îÄ 5. No dubious ownership / git errors ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        echo "--- [5/6] Git error checks ---"
        if search_logs "dubious ownership"; then
          echo -e "\033[31m  ‚úò Git dubious ownership error detected\033[0m"
          extract_logs "dubious ownership" | sed 's/^/    /'
          FAILURES=$((FAILURES + 1))
        else
          echo -e "\033[32m  ‚úî No dubious ownership errors\033[0m"
        fi
        if search_logs "SHA is empty"; then
          echo -e "\033[31m  ‚úò Git 'SHA is empty' error detected\033[0m"
          extract_logs "SHA is empty" | sed 's/^/    /'
          FAILURES=$((FAILURES + 1))
        else
          echo -e "\033[32m  ‚úî No 'SHA is empty' errors\033[0m"
        fi
        echo ""

        # ‚îÄ‚îÄ 6. Workspace builder completed without errors ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        echo "--- [6/6] Workspace builder completion ---"
        if search_logs "Error 500 from Workspace Builder"; then
          echo -e "\033[31m  ‚úò Workspace Builder returned error 500\033[0m"
          FAILURES=$((FAILURES + 1))
        elif search_logs "Workspace builder completed successfully"; then
          echo -e "\033[32m  ‚úî Workspace builder completed successfully\033[0m"
        else
          echo -e "\033[33m  ‚ö† Could not confirm workspace builder success message\033[0m"
          WARNINGS=$((WARNINGS + 1))
        fi
        echo ""

        # ‚îÄ‚îÄ Summary ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        echo "========================================"
        echo "  Results: $FAILURES failure(s), $WARNINGS warning(s)"
        echo "========================================"
        if [ "$FAILURES" -gt 0 ]; then
          echo -e "\033[31m  ‚úò Local Git Functionality Validation FAILED\033[0m"
          echo ""
          echo "--- Debug: last 30 lines of run_sh_output.log ---"
          tail -30 run_sh_output.log 2>/dev/null || echo "(file not found)"
          echo ""
          if [ -f container_logs.log ]; then
            echo "--- Debug: last 30 lines of container_logs.log ---"
            tail -30 container_logs.log 2>/dev/null
            echo ""
          fi
          exit 1
        else
          echo -e "\033[32m  ‚úî Local Git Functionality Validation PASSED\033[0m"
        fi
    silent: true

  verify-slx-count: 
    desc: "Validate SLX Count in CI test"
    vars:
      EXPECTED_SLX_COUNT: "{{.EXPECTED_SLX_COUNT | default `0`}}"
    cmds: 
      - |
          total_slxs=$(cat slx_count.txt)
          echo "---Validating SLX Count---"
          echo "Total SLXs: $total_slxs (Expected: {{.EXPECTED_SLX_COUNT}})"
          if [[ "$total_slxs" -lt "{{.EXPECTED_SLX_COUNT}}" ]]; then
            echo -e "\033[31m‚ùå Total SLX count failed\033[0m"
            exit 1
          else
            echo -e "\033[32m‚úîÔ∏è SLX Validation Passed\033[0m"
            exit 0
          fi
    silent: true

  verify-rwl-output: 
    desc: "Validate that rendered content is as intended"
    cmds: 
      - | 
        echo "Validate Runbook location configuration"
        RUNBOOK_FILE=$(find . -type f -name "runbook.yaml" | head -n 1)
        if [ -z "$RUNBOOK_FILE" ]; then
          echo "Error: No runbook.yaml file found in subdirectories." >&2
          exit 1
        fi
        LOCATION=$(yq e '.spec.location' "$RUNBOOK_FILE")
        if [ "$LOCATION" = "missing_workspaceInfo_custom_variable" ]; then
          echo "Error: runbook.yaml contains an invalid spec.location value." >&2
          exit 1
        fi
        echo "Validation successful: $RUNBOOK_FILE has a valid spec.location."

        echo "Validate SLI location configuration"
        SLI_FILE=$(find . -type f -name "sli.yaml" | head -n 1)
        if [ -z "$SLI_FILE" ]; then
          echo "Error: No sli.yaml file found in subdirectories." >&2
          exit 1
        fi
        LOCATION=$(yq e '.spec.location' "$SLI_FILE")
        if [ "$LOCATION" = "missing_workspaceInfo_custom_variable" ]; then
          echo "Error: runbook.yaml contains an invalid spec.location value." >&2
          exit 1
        fi
        echo "Validation successful: $SLI_FILE has a valid spec.location."
    silent: true

  clean-rwl-discovery:
    desc: "Check and clean up RunWhen Local discovery output"
    cmds:
      - |
        rm -rf output
        rm workspaceInfo.yaml
    silent: true

  validate-k8s-yaml:
    desc: "Validate generated YAML files for K8s compatibility issues"
    cmds:
      - |
        if [ ! -d "output" ]; then
          echo "‚ùå Output directory does not exist. Run discovery first."
          exit 1
        fi
        echo "üîç Validating K8s YAML compatibility..."
        python3 ../validate-yaml-compatibility.py output/workspaces/
    silent: false

  ci-test-with-validation:
    desc: "Run CI test with K8s YAML validation"
    cmds:
      - task: generate-rwl-config-basic
      - task: build-rwl
      - task: run-rwl-discovery
      - task: validate-k8s-yaml
      - echo "‚úÖ CI test with validation completed successfully!"

  validate-only:
    desc: "Run only YAML validation on existing output (for quick testing)"
    cmds:
      - task: validate-k8s-yaml
